{
  "$meta": {
    "package_metadata_source": "https://github.com/westonsteimel/package-metadata/tree/42075b3ee192d5eb4974ff9328bdb31a42593b88",
    "timestamp": 1636582142
  },
  "accesscontrol": [
    {
      "id": "pyup.io-accesscontrol:CVE-2021-32807",
      "advisory": "The module `AccessControl` defines security policies for Python code used in restricted code within Zope applications. Restricted code is any code that resides in Zope's object database, such as the contents of `Script (Python)` objects. The policies defined in `AccessControl` severely restrict access to Python modules and only exempt a few that are deemed safe, such as Python's `string` module. However, full access to the `string` module also allows access to the class `Formatter`, which can be overridden and extended within `Script (Python)` in a way that provides access to other unsafe Python libraries. Those unsafe Python libraries can be used for remote code execution. By default, you need to have the admin-level Zope \"Manager\" role to add or edit `Script (Python)` objects through the web. Only sites that allow untrusted users to add/edit these scripts through the web - which would be a very unusual configuration to begin with - are at risk. The problem has been fixed in AccessControl 4.3 and 5.2. Only AccessControl versions 4 and 5 are vulnerable, and only on Python 3, not Python 2.7. As a workaround, a site administrator can restrict adding/editing `Script (Python)` objects through the web using the standard Zope user/role permission mechanisms. Untrusted users should not be assigned the Zope Manager role and adding/editing these scripts through the web should be restricted to trusted users only. This is the default configuration in Zope.",
      "cve": "CVE-2021-32807",
      "specs": [
        ">=4.0,<4.3",
        ">=5.0,<5.2"
      ]
    },
    {
      "id": "pyup.io-accesscontrol:CVE-2021-32811",
      "advisory": "Zope is an open-source web application server. Zope versions prior to versions 4.6.3 and 5.3 have a remote code execution security issue. In order to be affected, one must use Python 3 for one's Zope deployment, run Zope 4 below version 4.6.3 or Zope 5 below version 5.3, and have the optional `Products.PythonScripts` add-on package installed. By default, one must have the admin-level Zope \"Manager\" role to add or edit Script (Python) objects through the web. Only sites that allow untrusted users to add/edit these scripts through the web are at risk. Zope releases 4.6.3 and 5.3 are not vulnerable. As a workaround, a site administrator can restrict adding/editing Script (Python) objects through the web using the standard Zope user/role permission mechanisms. Untrusted users should not be assigned the Zope Manager role and adding/editing these scripts through the web should be restricted to trusted users only. This is the default configuration in Zope.",
      "cve": "CVE-2021-32811",
      "specs": [
        ">=4.0,<4.3",
        ">=5.0,<5.2"
      ]
    }
  ],
  "aiohttp": [
    {
      "id": "pyup.io-aiohttp:CVE-2021-21330",
      "advisory": "aiohttp is an asynchronous HTTP client/server framework for asyncio and Python. In aiohttp before version 3.7.4 there is an open redirect vulnerability. A maliciously crafted link to an aiohttp-based web-server could redirect the browser to a different website. It is caused by a bug in the `aiohttp.web_middlewares.normalize_path_middleware` middleware. This security problem has been fixed in 3.7.4. Upgrade your dependency using pip as follows \"pip install aiohttp >= 3.7.4\". If upgrading is not an option for you, a workaround can be to avoid using `aiohttp.web_middlewares.normalize_path_middleware` in your applications.",
      "cve": "CVE-2021-21330",
      "specs": [
        "<3.7.4"
      ]
    }
  ],
  "aiohttp-session": [
    {
      "id": "pyup.io-aiohttp-session:CVE-2018-1000814",
      "advisory": "aio-libs aiohttp-session version 2.6.0 and earlier contains a Other/Unknown vulnerability in EncryptedCookieStorage and NaClCookieStorage that can result in Non-expiring sessions / Infinite lifespan. This attack appear to be exploitable via Recreation of a cookie post-expiry with the same value.",
      "cve": "CVE-2018-1000814",
      "specs": [
        "<=2.6.0"
      ]
    }
  ],
  "aioxmpp": [
    {
      "id": "pyup.io-aioxmpp:CVE-2019-1000007",
      "advisory": "aioxmpp version 0.10.2 and earlier contains a Improper Handling of Structural Elements vulnerability in Stanza Parser, rollback during error processing, aioxmpp.xso.model.guard function that can result in Denial of Service, Other. This attack appears to be exploitable via Remote. A crafted stanza can be sent to an application which uses the vulnerable components to either inject data in a different context or cause the application to reconnect (potentially losing data). This vulnerability appears to have been fixed in 0.10.3.",
      "cve": "CVE-2019-1000007",
      "specs": [
        "<=0.10.2"
      ]
    }
  ],
  "alerta": [
    {
      "id": "pyup.io-alerta:CVE-2020-26214",
      "advisory": "In Alerta before version 8.1.0, users may be able to bypass LDAP authentication if they provide an empty password when Alerta server is configure to use LDAP as the authorization provider. Only deployments where LDAP servers are configured to allow unauthenticated authentication mechanism for anonymous authorization are affected. A fix has been implemented in version 8.1.0 that returns HTTP 401 Unauthorized response for any authentication attempts where the password field is empty. As a workaround LDAP administrators can disallow unauthenticated bind requests by clients.",
      "cve": "CVE-2020-26214",
      "specs": [
        "<7.5.7",
        ">=8.0.0,<8.1.0"
      ]
    }
  ],
  "alerta-server": [
    {
      "id": "pyup.io-alerta-server:CVE-2020-26214",
      "advisory": "In Alerta before version 8.1.0, users may be able to bypass LDAP authentication if they provide an empty password when Alerta server is configure to use LDAP as the authorization provider. Only deployments where LDAP servers are configured to allow unauthenticated authentication mechanism for anonymous authorization are affected. A fix has been implemented in version 8.1.0 that returns HTTP 401 Unauthorized response for any authentication attempts where the password field is empty. As a workaround LDAP administrators can disallow unauthenticated bind requests by clients.",
      "cve": "CVE-2020-26214",
      "specs": [
        "<7.5.7",
        ">=8.0.0,<8.1.0"
      ]
    }
  ],
  "ampache": [
    {
      "id": "pyup.io-ampache:CVE-2006-5668",
      "advisory": "Unspecified vulnerability in Ampache 3.3.2 and earlier, when register_globals is enabled, allows remote attackers to bypass security restrictions and gain guest access.",
      "cve": "CVE-2006-5668",
      "specs": [
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.2.4",
        "==3.3",
        "==3.3.1",
        "==3.3.1.2",
        "==3.3.2"
      ]
    },
    {
      "id": "pyup.io-ampache:CVE-2007-4437",
      "advisory": "SQL injection vulnerability in albums.php in Ampache before 3.3.3.5 allows remote attackers to execute arbitrary SQL commands via the match parameter.  NOTE: some details are obtained from third party information.",
      "cve": "CVE-2007-4437",
      "specs": [
        "<=3.3.3.4"
      ]
    },
    {
      "id": "pyup.io-ampache:CVE-2007-4438",
      "advisory": "Session fixation vulnerability in Ampache before 3.3.3.5 allows remote attackers to hijack web sessions via unspecified vectors.",
      "cve": "CVE-2007-4438",
      "specs": [
        "<=3.3.3.4"
      ]
    },
    {
      "id": "pyup.io-ampache:CVE-2008-3929",
      "advisory": "gather-messages.sh in Ampache 3.4.1 allows local users to overwrite arbitrary files via a symlink attack on the /tmp/filelist temporary file.",
      "cve": "CVE-2008-3929",
      "specs": [
        "==3.4.1"
      ]
    },
    {
      "id": "pyup.io-ampache:CVE-2017-18375",
      "advisory": "Ampache 3.8.3 allows PHP Object Instantiation via democratic.ajax.php and democratic.class.php.",
      "cve": "CVE-2017-18375",
      "specs": [
        "==3.8.3"
      ]
    },
    {
      "id": "pyup.io-ampache:CVE-2019-12385",
      "advisory": "An issue was discovered in Ampache through 3.9.1. The search engine is affected by a SQL Injection, so any user able to perform lib/class/search.class.php searches (even guest users) can dump any data contained in the database (sessions, hashed passwords, etc.). This may lead to a full compromise of admin accounts, when combined with the weak password generator algorithm used in the lostpassword functionality.",
      "cve": "CVE-2019-12385",
      "specs": [
        "<=3.9.1"
      ]
    },
    {
      "id": "pyup.io-ampache:CVE-2019-12386",
      "advisory": "An issue was discovered in Ampache through 3.9.1. A stored XSS exists in the localplay.php LocalPlay \"add instance\" functionality. The injected code is reflected in the instances menu. This vulnerability can be abused to force an admin to create a new privileged user whose credentials are known by the attacker.",
      "cve": "CVE-2019-12386",
      "specs": [
        "<=3.9.1"
      ]
    },
    {
      "id": "pyup.io-ampache:CVE-2020-15153",
      "advisory": "Ampache before version 4.2.2 allows unauthenticated users to perform SQL injection. Refer to the referenced GitHub Security Advisory for details and a workaround. This is fixed in version 4.2.2 and the development branch.",
      "cve": "CVE-2020-15153",
      "specs": [
        "<4.2.2"
      ]
    },
    {
      "id": "pyup.io-ampache:CVE-2021-21399",
      "advisory": "Ampache is a web based audio/video streaming application and file manager. Versions prior to 4.4.1 allow unauthenticated access to Ampache using the subsonic API. To successfully make the attack you must use a username that is not part of the site to bypass the auth checks. For more details and workaround guidance see the referenced GitHub security advisory.",
      "cve": "CVE-2021-21399",
      "specs": [
        "<4.4.1"
      ]
    },
    {
      "id": "pyup.io-ampache:CVE-2021-32644",
      "advisory": "Ampache is an open source web based audio/video streaming application and file manager. Due to a lack of input filtering versions 4.x.y are vulnerable to code injection in random.php. The attack requires user authentication to access the random.php page unless the site is running in demo mode. This issue has been resolved in 4.4.3.",
      "cve": "CVE-2021-32644",
      "specs": [
        "==4.4.2"
      ]
    }
  ],
  "ansible": [
    {
      "id": "pyup.io-ansible:CVE-2013-2233",
      "advisory": "Ansible before 1.2.1 makes it easier for remote attackers to conduct man-in-the-middle attacks by leveraging failure to cache SSH host keys.",
      "cve": "CVE-2013-2233",
      "specs": [
        "<1.2.1"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2013-4259",
      "advisory": "runner/connection_plugins/ssh.py in Ansible before 1.2.3, when using ControlPersist, allows local users to redirect a ssh session via a symlink attack on a socket file with a predictable name in /tmp/.",
      "cve": "CVE-2013-4259",
      "specs": [
        "<=1.2.2"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2013-4260",
      "advisory": "lib/ansible/playbook/__init__.py in Ansible 1.2.x before 1.2.3, when playbook does not run due to an error, allows local users to overwrite arbitrary files via a symlink attack on a retry file with a predictable name in /var/tmp/ansible/.",
      "cve": "CVE-2013-4260",
      "specs": [
        "==1.2",
        "==1.2.1",
        "==1.2.2"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2014-2686",
      "advisory": "Ansible prior to 1.5.4 mishandles the evaluation of some strings.",
      "cve": "CVE-2014-2686",
      "specs": [
        "<1.5.4"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2014-3498",
      "advisory": "The user module in ansible before 1.6.6 allows remote authenticated users to execute arbitrary commands.",
      "cve": "CVE-2014-3498",
      "specs": [
        "<=1.6.5"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2014-4657",
      "advisory": "The safe_eval function in Ansible before 1.5.4 does not properly restrict the code subset, which allows remote attackers to execute arbitrary code via crafted instructions.",
      "cve": "CVE-2014-4657",
      "specs": [
        "<1.5.4"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2014-4658",
      "advisory": "The vault subsystem in Ansible before 1.5.5 does not set the umask before creation or modification of a vault file, which allows local users to obtain sensitive key information by reading a file.",
      "cve": "CVE-2014-4658",
      "specs": [
        "<1.5.5"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2014-4659",
      "advisory": "Ansible before 1.5.5 sets 0644 permissions for sources.list, which might allow local users to obtain sensitive credential information in opportunistic circumstances by reading a file that uses the \"deb http://user:pass@server:port/\" format.",
      "cve": "CVE-2014-4659",
      "specs": [
        "<1.5.5"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2014-4660",
      "advisory": "Ansible before 1.5.5 constructs filenames containing user and password fields on the basis of deb lines in sources.list, which might allow local users to obtain sensitive credential information in opportunistic circumstances by leveraging existence of a file that uses the \"deb http://user:pass@server:port/\" format.",
      "cve": "CVE-2014-4660",
      "specs": [
        "<1.5.5"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2014-4678",
      "advisory": "The safe_eval function in Ansible before 1.6.4 does not properly restrict the code subset, which allows remote attackers to execute arbitrary code via crafted instructions. NOTE: this vulnerability exists because of an incomplete fix for CVE-2014-4657.",
      "cve": "CVE-2014-4678",
      "specs": [
        "<1.6.4"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2014-4966",
      "advisory": "Ansible before 1.6.7 does not prevent inventory data with \"{{\" and \"lookup\" substrings, and does not prevent remote data with \"{{\" substrings, which allows remote attackers to execute arbitrary code via (1) crafted lookup('pipe') calls or (2) crafted Jinja2 data.",
      "cve": "CVE-2014-4966",
      "specs": [
        "<1.6.7"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2014-4967",
      "advisory": "Multiple argument injection vulnerabilities in Ansible before 1.6.7 allow remote attackers to execute arbitrary code by leveraging access to an Ansible managed host and providing a crafted fact, as demonstrated by a fact with (1) a trailing \" src=\" clause, (2) a trailing \" temp=\" clause, or (3) a trailing \" validate=\" clause accompanied by a shell command.",
      "cve": "CVE-2014-4967",
      "specs": [
        "<1.6.7"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2015-3908",
      "advisory": "Ansible before 1.9.2 does not verify that the server hostname matches a domain name in the subject's Common Name (CN) or subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
      "cve": "CVE-2015-3908",
      "specs": [
        "<=1.9.1"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2015-6240",
      "advisory": "The chroot, jail, and zone connection plugins in ansible before 1.9.2 allow local users to escape a restricted environment via a symlink attack.",
      "cve": "CVE-2015-6240",
      "specs": [
        "<=1.9.1"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2016-3096",
      "advisory": "The create_script function in the lxc_container module in Ansible before 1.9.6-1 and 2.x before 2.0.2.0 allows local users to write to arbitrary files or gain privileges via a symlink attack on (1) /opt/.lxc-attach-script, (2) the archived container in the archive_path directory, or the (3) lxc-attach-script.log or (4) lxc-attach-script.err files in the temporary directory.",
      "cve": "CVE-2016-3096",
      "specs": [
        "<=1.9.6",
        "==2.0",
        "==2.0.1"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2016-8614",
      "advisory": "A flaw was found in Ansible before version 2.2.0. The apt_key module does not properly verify key fingerprints, allowing remote adversary to create an OpenPGP key which matches the short key ID and inject this key instead of the correct key.",
      "cve": "CVE-2016-8614",
      "specs": [
        "<2.2.0"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2016-8628",
      "advisory": "Ansible before version 2.2.0 fails to properly sanitize fact variables sent from the Ansible controller. An attacker with the ability to create special variables on the controller could execute arbitrary commands on Ansible clients as the user Ansible runs as.",
      "cve": "CVE-2016-8628",
      "specs": [
        "<2.2.0"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2016-8647",
      "advisory": "An input validation vulnerability was found in Ansible's mysql_user module before 2.2.1.0, which may fail to correctly change a password in certain circumstances. Thus the previous password would still be active when it should have been changed.",
      "cve": "CVE-2016-8647",
      "specs": [
        "<2.2.1.0"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2016-9587",
      "advisory": "Ansible before versions 2.1.4, 2.2.1 is vulnerable to an improper input validation in Ansible's handling of data sent from client systems. An attacker with control over a client system being managed by Ansible and the ability to send facts back to the Ansible server could use this flaw to execute arbitrary code on the Ansible server using the Ansible server privileges.",
      "cve": "CVE-2016-9587",
      "specs": [
        "<2.1.4",
        "<2.2.1"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2017-7466",
      "advisory": "Ansible before version 2.3 has an input validation vulnerability in the handling of data sent from client systems. An attacker with control over a client system being managed by Ansible, and the ability to send facts back to the Ansible server, could use this flaw to execute arbitrary code on the Ansible server using the Ansible server privileges.",
      "cve": "CVE-2017-7466",
      "specs": [
        "<2.3"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2017-7481",
      "advisory": "Ansible before versions 2.3.1.0 and 2.4.0.0 fails to properly mark lookup-plugin results as unsafe. If an attacker could control the results of lookup() calls, they could inject Unicode strings to be parsed by the jinja2 templating system, resulting in code execution. By default, the jinja2 templating language is now marked as 'unsafe' and is not evaluated.",
      "cve": "CVE-2017-7481",
      "specs": [
        "<2.3.1.0",
        ">=2.3.2.0,<2.4.0.0"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2017-7550",
      "advisory": "A flaw was found in the way Ansible (2.3.x before 2.3.3, and 2.4.x before 2.4.1) passed certain parameters to the jenkins_plugin module. Remote attackers could use this flaw to expose sensitive information from a remote host's logs. This flaw was fixed by not allowing passwords to be specified in the \"params\" argument, and noting this in the module documentation.",
      "cve": "CVE-2017-7550",
      "specs": [
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.1"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2018-10855",
      "advisory": "Ansible 2.5 prior to 2.5.5, and 2.4 prior to 2.4.5, do not honor the no_log task flag for failed tasks. When the no_log flag has been used to protect sensitive data passed to a task from being logged, and that task does not run successfully, Ansible will expose sensitive data in log files and on the terminal of the user running Ansible.",
      "cve": "CVE-2018-10855",
      "specs": [
        "==2.0",
        ">2.5,<=2.5.5",
        ">=2.4,<2.4.5"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2018-10874",
      "advisory": "In ansible it was found that inventory variables are loaded from current working directory when running ad-hoc command which are under attacker's control, allowing to run arbitrary code as a result.",
      "cve": "CVE-2018-10874",
      "specs": [
        "==2.0",
        "==2.4",
        "==2.5",
        "==2.6"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2018-10875",
      "advisory": "A flaw was found in ansible. ansible.cfg is read from the current working directory which can be altered to make it point to a plugin or a module path under the control of an attacker, thus allowing the attacker to execute arbitrary code.",
      "cve": "CVE-2018-10875",
      "specs": [
        "==2.0",
        "==2.4",
        "==2.5",
        "==2.6"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2018-16837",
      "advisory": "Ansible \"User\" module leaks any data which is passed on as a parameter to ssh-keygen. This could lean in undesirable situations such as passphrases credentials passed as a parameter for the ssh-keygen executable. Showing those credentials in clear text form for every user which have access just to the process list.",
      "cve": "CVE-2018-16837",
      "specs": [
        "==2.0",
        "==2.5",
        "==2.6",
        "==2.7"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2018-16859",
      "advisory": "Execution of Ansible playbooks on Windows platforms with PowerShell ScriptBlock logging and Module logging enabled can allow for 'become' passwords to appear in EventLogs in plaintext. A local user with administrator privileges on the machine can view these logs and discover the plaintext password. Ansible Engine 2.8 and older are believed to be vulnerable.",
      "cve": "CVE-2018-16859",
      "specs": [
        "<2.5.13",
        ">=2.6.0,<2.6.10",
        ">=2.7.0,<2.7.4",
        ">=2.7.5,<=2.8"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2018-16876",
      "advisory": "ansible before versions 2.5.14, 2.6.11, 2.7.5 is vulnerable to a information disclosure flaw in vvv+ mode with no_log on that can lead to leakage of sensible data.",
      "cve": "CVE-2018-16876",
      "specs": [
        "==2.0",
        "==2.5",
        "==2.6",
        "==2.7",
        ">=2.5.0,<2.5.14",
        ">=2.6.0,<2.6.11",
        ">=2.7.0,<2.7.5"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2018-7750",
      "advisory": "transport.py in the SSH server implementation of Paramiko before 1.17.6, 1.18.x before 1.18.5, 2.0.x before 2.0.8, 2.1.x before 2.1.5, 2.2.x before 2.2.3, 2.3.x before 2.3.2, and 2.4.x before 2.4.1 does not properly check whether authentication is completed before processing other requests, as demonstrated by channel-open. A customized SSH client can simply skip the authentication step.",
      "cve": "CVE-2018-7750",
      "specs": [
        "==2.0",
        "==2.4"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2019-10156",
      "advisory": "A flaw was discovered in the way Ansible templating was implemented in versions before 2.6.18, 2.7.12 and 2.8.2, causing the possibility of information disclosure through unexpected variable substitution. By taking advantage of unintended variable substitution the content of any variable may be disclosed.",
      "cve": "CVE-2019-10156",
      "specs": [
        "<2.6.18",
        ">=2.7.0,<2.7.12",
        ">=2.8.0,<2.8.2"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2019-10206",
      "advisory": "ansible-playbook -k and ansible cli tools, all versions 2.8.x before 2.8.4, all 2.7.x before 2.7.13 and all 2.6.x before 2.6.19, prompt passwords by expanding them from templates as they could contain special characters. Passwords should be wrapped to prevent templates trigger and exposing them.",
      "cve": "CVE-2019-10206",
      "specs": [
        ">=2.6.0,<2.6.19",
        ">=2.7.0,<2.7.13",
        ">=2.8.0,<2.8.4"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2019-10217",
      "advisory": "A flaw was found in ansible 2.8.0 before 2.8.4. Fields managing sensitive data should be set as such by no_log feature. Some of these fields in GCP modules are not set properly. service_account_contents() which is common class for all gcp modules is not setting no_log to True. Any sensitive data managed by that function would be leak as an output when running ansible playbooks.",
      "cve": "CVE-2019-10217",
      "specs": [
        ">=2.8.0,<2.8.4"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2019-14846",
      "advisory": "In Ansible, all Ansible Engine versions up to ansible-engine 2.8.5, ansible-engine 2.7.13, ansible-engine 2.6.19, were logging at the DEBUG level which lead to a disclosure of credentials if a plugin used a library that logged credentials at the DEBUG level. This flaw does not affect Ansible modules, as those are executed in a separate process.",
      "cve": "CVE-2019-14846",
      "specs": [
        "<2.6.20",
        ">=2.7.0,<2.7.14",
        ">=2.8.0,<2.8.6"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2019-14856",
      "advisory": "ansible before versions 2.8.6, 2.7.14, 2.6.20 is vulnerable to a None",
      "cve": "CVE-2019-14856",
      "specs": [
        ">=2.6.0,<2.6.20",
        ">=2.7.0,<2.7.14",
        ">=2.8.0,<2.8.6"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2019-14858",
      "advisory": "A vulnerability was found in Ansible engine 2.x up to 2.8 and Ansible tower 3.x up to 3.5. When a module has an argument_spec with sub parameters marked as no_log, passing an invalid parameter name to the module will cause the task to fail before the no_log options in the sub parameters are processed. As a result, data in the sub parameter fields will not be masked and will be displayed if Ansible is run with increased verbosity and present in the module invocation arguments for the task.",
      "cve": "CVE-2019-14858",
      "specs": [
        ">=2.0,<=2.8.0"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2019-14864",
      "advisory": "Ansible, versions 2.9.x before 2.9.1, 2.8.x before 2.8.7 and Ansible versions 2.7.x before 2.7.15, is not respecting the flag no_log set it to True when Sumologic and Splunk callback plugins are used send tasks results events to collectors. This would discloses and collects any sensitive data.",
      "cve": "CVE-2019-14864",
      "specs": [
        ">=2.7.0,<2.7.15",
        ">=2.8.0,<2.8.7",
        ">=2.9.0,<2.9.1"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2019-14904",
      "advisory": "A flaw was found in the solaris_zone module from the Ansible Community modules. When setting the name for the zone on the Solaris host, the zone name is checked by listing the process with the 'ps' bare command on the remote machine. An attacker could take advantage of this flaw by crafting the name of the zone and executing arbitrary commands in the remote host. Ansible Engine 2.7.15, 2.8.7, and 2.9.2 as well as previous versions are affected.",
      "cve": "CVE-2019-14904",
      "specs": [
        "<2.7.15",
        ">=2.8.0,<2.8.7",
        ">=2.9.0,<2.9.2"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2019-14905",
      "advisory": "A vulnerability was found in Ansible Engine versions 2.9.x before 2.9.3, 2.8.x before 2.8.8, 2.7.x before 2.7.16 and earlier, where in Ansible's nxos_file_copy module can be used to copy files to a flash or bootflash on NXOS devices. Malicious code could craft the filename parameter to perform OS command injections. This could result in a loss of confidentiality of the system among other issues.",
      "cve": "CVE-2019-14905",
      "specs": [
        ">=2.7.0,<2.7.16",
        ">=2.8.0,<2.8.8",
        ">=2.9.0,<2.9.3"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2019-3828",
      "advisory": "Ansible fetch module before versions 2.5.15, 2.6.14, 2.7.8 has a path traversal vulnerability which allows copying and overwriting files outside of the specified destination in the local ansible controller host, by not restricting an absolute path.",
      "cve": "CVE-2019-3828",
      "specs": [
        ">=2.5.0,<2.5.15",
        ">=2.6.0,<2.6.14",
        ">=2.7.0,<2.7.8"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2020-10684",
      "advisory": "A flaw was found in Ansible Engine, all versions 2.7.x, 2.8.x and 2.9.x prior to 2.7.17, 2.8.9 and 2.9.6 respectively, when using ansible_facts as a subkey of itself and promoting it to a variable when inject is enabled, overwriting the ansible_facts after the clean. An attacker could take advantage of this by altering the ansible_facts, such as ansible_hosts, users and any other key data which would lead into privilege escalation or code injection.",
      "cve": "CVE-2020-10684",
      "specs": [
        ">=2.7.0,<2.7.17",
        ">=2.8.0,<2.8.9",
        ">=2.9.0,<2.9.6"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2020-10685",
      "advisory": "A flaw was found in Ansible Engine affecting Ansible Engine versions 2.7.x before 2.7.17 and 2.8.x before 2.8.11 and 2.9.x before 2.9.7 as well as Ansible Tower before and including versions 3.4.5 and 3.5.5 and 3.6.3 when using modules which decrypts vault files such as assemble, script, unarchive, win_copy, aws_s3 or copy modules. The temporary directory is created in /tmp leaves the s ts unencrypted. On Operating Systems which /tmp is not a tmpfs but part of the root partition, the directory is only cleared on boot and the decryp emains when the host is switched off. The system will be vulnerable when the system is not running. So decrypted data must be cleared as soon as possible and the data which normally is encrypted ble.",
      "cve": "CVE-2020-10685",
      "specs": [
        ">=2.7.0,<2.7.17",
        ">=2.8.0,<2.8.11",
        ">=2.9.0,<2.9.7"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2020-10691",
      "advisory": "An archive traversal flaw was found in all ansible-engine versions 2.9.x prior to 2.9.7, when running ansible-galaxy collection install. When extracting a collection .tar.gz file, the directory is created without sanitizing the filename. An attacker could take advantage to overwrite any file within the system.",
      "cve": "CVE-2020-10691",
      "specs": [
        ">=2.9.0,<2.9.7"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2020-10729",
      "advisory": "A flaw was found in the use of insufficiently random values in Ansible. Two random password lookups of the same length generate the equal value as the template caching action for the same file since no re-evaluation happens. The highest threat from this vulnerability would be that all passwords are exposed at once for the file. This flaw affects Ansible Engine versions before 2.9.6.",
      "cve": "CVE-2020-10729",
      "specs": [
        "<2.9.6"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2020-10744",
      "advisory": "An incomplete fix was found for the fix of the flaw CVE-2020-1733 ansible: insecure temporary directory when running become_user from become directive. The provided fix is insufficient to prevent the race condition on systems using ACLs and FUSE filesystems. Ansible Engine 2.7.18, 2.8.12, and 2.9.9 as well as previous versions are affected and Ansible Tower 3.4.5, 3.5.6 and 3.6.4 as well as previous versions are affected.",
      "cve": "CVE-2020-10744",
      "specs": [
        ">=2.7.0,<=2.7.18",
        ">=2.8.0,<=2.8.12",
        ">=2.9.0,<=2.9.9"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2020-14330",
      "advisory": "An Improper Output Neutralization for Logs flaw was found in Ansible when using the uri module, where sensitive data is exposed to content and json output. This flaw allows an attacker to access the logs or outputs of performed tasks to read keys used in playbooks from other users within the uri module. The highest threat from this vulnerability is to data confidentiality.",
      "cve": "CVE-2020-14330",
      "specs": [
        "<2.9.12"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2020-14332",
      "advisory": "A flaw was found in the Ansible Engine when using module_args. Tasks executed with check mode (--check-mode) do not properly neutralize sensitive data exposed in the event data. This flaw allows unauthorized users to read this data. The highest threat from this vulnerability is to confidentiality.",
      "cve": "CVE-2020-14332",
      "specs": [
        ">=2.8.0,<2.8.14",
        ">=2.9.0,<2.9.12"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2020-14365",
      "advisory": "A flaw was found in the Ansible Engine, in ansible-engine 2.8.x before 2.8.15 and ansible-engine 2.9.x before 2.9.13, when installing packages using the dnf module. GPG signatures are ignored during installation even when disable_gpg_check is set to False, which is the default behavior. This flaw leads to malicious packages being installed on the system and arbitrary code executed via package installation scripts. The highest threat from this vulnerability is to integrity and system availability.",
      "cve": "CVE-2020-14365",
      "specs": [
        ">=2.8.0,<=2.8.15",
        ">=2.9.0,<=2.9.13"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2020-1733",
      "advisory": "A race condition flaw was found in Ansible Engine 2.7.17 and prior, 2.8.9 and prior, 2.9.6 and prior when running a playbook with an unprivileged become user. When Ansible needs to run a module with become user, the temporary directory is created in /var/tmp. This directory is created with \"umask 77 && mkdir -p <dir>\"; this operation does not fail if the directory already exists and is owned by another user. An attacker could take advantage to gain control of the become user as the target directory can be retrieved by iterating '/proc/<pid>/cmdline'.",
      "cve": "CVE-2020-1733",
      "specs": [
        "<=2.7.16",
        ">=2.8.0,<2.8.8",
        ">=2.9.0,<=2.9.5"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2020-1734",
      "advisory": "A flaw was found in the pipe lookup plugin of ansible. Arbitrary commands can be run, when the pipe lookup plugin uses subprocess.Popen() with shell=True, by overwriting ansible facts and the variable is not escaped by quote plugin. An attacker could take advantage and run arbitrary commands by overwriting the ansible facts.",
      "cve": "CVE-2020-1734",
      "specs": [
        "<=2.7.16",
        "==2.8.8",
        "==2.9.5"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2020-1735",
      "advisory": "A flaw was found in the Ansible Engine when the fetch module is used. An attacker could intercept the module, inject a new path, and then choose a new destination path on the controller node. All versions in 2.7.x, 2.8.x and 2.9.x branches are believed to be vulnerable.",
      "cve": "CVE-2020-1735",
      "specs": [
        "<=2.7.16",
        ">=2.8.0,<=2.8.8",
        ">=2.9.0,<=2.9.5"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2020-1736",
      "advisory": "A flaw was found in Ansible Engine when a file is moved using atomic_move primitive as the file mode cannot be specified. This sets the destination files world-readable if the destination file does not exist and if the file exists, the file could be changed to have less restrictive permissions before the move. This could lead to the disclosure of sensitive data. All versions in 2.7.x, 2.8.x and 2.9.x branches are believed to be vulnerable.",
      "cve": "CVE-2020-1736",
      "specs": [
        "<=2.7.16",
        ">=2.8.0,<=2.8.8",
        ">=2.9.0,<=2.9.5"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2020-1737",
      "advisory": "A flaw was found in Ansible 2.7.17 and prior, 2.8.9 and prior, and 2.9.6 and prior when using the Extract-Zip function from the win_unzip module as the extracted file(s) are not checked if they belong to the destination folder. An attacker could take advantage of this flaw by crafting an archive anywhere in the file system, using a path traversal. This issue is fixed in 2.10.",
      "cve": "CVE-2020-1737",
      "specs": [
        "<2.7.17",
        ">=2.8.0,<2.8.9",
        ">=2.9.0,<2.9.6"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2020-1738",
      "advisory": "A flaw was found in Ansible Engine when the module package or service is used and the parameter 'use' is not specified. If a previous task is executed with a malicious user, the module sent can be selected by the attacker using the ansible facts file. All versions in 2.7.x, 2.8.x and 2.9.x branches are believed to be vulnerable.",
      "cve": "CVE-2020-1738",
      "specs": [
        "<=2.7.16",
        ">=2.8.0,<=2.8.8",
        ">=2.9.0,<=2.9.5"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2020-1739",
      "advisory": "A flaw was found in Ansible 2.7.16 and prior, 2.8.8 and prior, and 2.9.5 and prior when a password is set with the argument \"password\" of svn module, it is used on svn command line, disclosing to other users within the same node. An attacker could take advantage by reading the cmdline file from that particular PID on the procfs.",
      "cve": "CVE-2020-1739",
      "specs": [
        "<=2.7.16",
        ">=2.8.0,<=2.8.8",
        ">=2.9.0,<=2.9.5"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2020-1740",
      "advisory": "A flaw was found in Ansible Engine when using Ansible Vault for editing encrypted files. When a user executes \"ansible-vault edit\", another user on the same computer can read the old and new secret, as it is created in a temporary file with mkstemp and the returned file descriptor is closed and the method write_data is called to write the existing secret in the file. This method will delete the file before recreating it insecurely. All versions in 2.7.x, 2.8.x and 2.9.x branches are believed to be vulnerable.",
      "cve": "CVE-2020-1740",
      "specs": [
        "<=2.7.16",
        ">=2.8.0,<=2.8.8",
        ">=2.9.0,<=2.9.5"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2020-1746",
      "advisory": "A flaw was found in the Ansible Engine affecting Ansible Engine versions 2.7.x before 2.7.17 and 2.8.x before 2.8.11 and 2.9.x before 2.9.7 as well as Ansible Tower before and including versions 3.4.5 and 3.5.5 and 3.6.3 when the ldap_attr and ldap_entry community modules are used. The issue discloses the LDAP bind password to stdout or a log file if a playbook task is written using the bind_pw in the parameters field. The highest threat from this vulnerability is data confidentiality.",
      "cve": "CVE-2020-1746",
      "specs": [
        ">=2.7.0,<2.7.17",
        ">=2.8.0,<2.8.11",
        ">=2.9.0,<2.9.7"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2020-1753",
      "advisory": "A security flaw was found in Ansible Engine, all Ansible 2.7.x versions prior to 2.7.17, all Ansible 2.8.x versions prior to 2.8.11 and all Ansible 2.9.x versions prior to 2.9.7, when managing kubernetes using the k8s module. Sensitive parameters such as passwords and tokens are passed to kubectl from the command line, not using an environment variable or an input configuration file. This will disclose passwords and tokens from process list and no_log directive from debug module would not have any effect making these secrets being disclosed on stdout and log files.",
      "cve": "CVE-2020-1753",
      "specs": [
        "<=2.7.16",
        ">=2.8.0,<=2.8.8",
        ">=2.9.0,<=2.9.5"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2020-25635",
      "advisory": "A flaw was found in Ansible Base when using the aws_ssm connection plugin as garbage collector is not happening after playbook run is completed. Files would remain in the bucket exposing the data. This issue affects directly data confidentiality.",
      "cve": "CVE-2020-25635",
      "specs": [
        "==2.10.1-rc2"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2020-25636",
      "advisory": "A flaw was found in Ansible Base when using the aws_ssm connection plugin as there is no namespace separation for file transfers. Files are written directly to the root bucket, making possible to have collisions when running multiple ansible processes. This issue affects mainly the service availability.",
      "cve": "CVE-2020-25636",
      "specs": [
        "==2.10.1-rc2"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2021-20178",
      "advisory": "A flaw was found in ansible module where credentials are disclosed in the console log by default and not protected by the security feature when using the bitbucket_pipeline_variable module. This flaw allows an attacker to steal bitbucket_pipeline credentials. The highest threat from this vulnerability is to confidentiality.",
      "cve": "CVE-2021-20178",
      "specs": [
        "<2.9.18"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2021-20191",
      "advisory": "A flaw was found in ansible. Credentials, such as secrets, are being disclosed in console log by default and not protected by no_log feature when using those modules. An attacker can take advantage of this information to steal those credentials. The highest threat from this vulnerability is to data confidentiality. Versions before ansible 2.9.18 are affected.",
      "cve": "CVE-2021-20191",
      "specs": [
        "<2.8.19",
        ">=2.10.0,<2.10.7",
        ">=2.9.0,<2.9.18"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2021-20228",
      "advisory": "A flaw was found in the Ansible Engine 2.9.18, where sensitive info is not masked by default and is not protected by the no_log feature when using the sub-option feature of the basic.py module. This flaw allows an attacker to obtain sensitive information. The highest threat from this vulnerability is to confidentiality.",
      "cve": "CVE-2021-20228",
      "specs": [
        "==2.0",
        "==2.9",
        "==2.9.18"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2021-3447",
      "advisory": "A flaw was found in several ansible modules, where parameters containing credentials, such as secrets, were being logged in plain-text on managed nodes, as well as being made visible on the controller node when run in verbose mode. These parameters were not protected by the no_log feature. An attacker can take advantage of this information to steal those credentials, provided when they have access to the log files containing them. The highest threat from this vulnerability is to data confidentiality. This flaw affects Red Hat Ansible Automation Platform in versions before 1.2.2 and Ansible Tower in versions before 3.8.2.",
      "cve": "CVE-2021-3447",
      "specs": [
        "<1.2.2"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2021-3532",
      "advisory": "A flaw was found in Ansible where the secret information present in async_files are getting disclosed when the user changes the jobdir to a world readable directory. Any secret information in an async status file will be readable by a malicious user on that system. This flaw affects Ansible Tower 3.7 and Ansible Automation Platform 1.2.",
      "cve": "CVE-2021-3532",
      "specs": [
        "==2.0"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2021-3533",
      "advisory": "A flaw was found in Ansible if an ansible user sets ANSIBLE_ASYNC_DIR to a subdirectory of a world writable directory. When this occurs, there is a race condition on the managed machine. A malicious, non-privileged account on the remote machine can exploit the race condition to access the async result data. This flaw affects Ansible Tower 3.7 and Ansible Automation Platform 1.2.",
      "cve": "CVE-2021-3533",
      "specs": [
        "==2.0"
      ]
    },
    {
      "id": "pyup.io-ansible:CVE-2021-3583",
      "advisory": "A flaw was found in Ansible, where a user's controller is vulnerable to template injection. This issue can occur through facts used in the template if the user is trying to put templates in multi-line YAML strings and the facts being handled do not routinely include special template characters. This flaw allows attackers to perform command injection, which discloses sensitive information. The highest threat from this vulnerability is to confidentiality and integrity.",
      "cve": "CVE-2021-3583",
      "specs": [
        "<2.9.23"
      ]
    }
  ],
  "ansible-vault": [
    {
      "id": "pyup.io-ansible-vault:CVE-2017-2809",
      "advisory": "An exploitable vulnerability exists in the yaml loading functionality of ansible-vault before 1.0.5. A specially crafted vault can execute arbitrary python commands resulting in command execution. An attacker can insert python into the vault to trigger this vulnerability.",
      "cve": "CVE-2017-2809",
      "specs": [
        "<=1.0.4"
      ]
    }
  ],
  "apache-airflow": [
    {
      "id": "pyup.io-apache-airflow:CVE-2017-12614",
      "advisory": "It was noticed an XSS in certain 404 pages that could be exploited to perform an XSS attack. Chrome will detect this as a reflected XSS attempt and prevent the page from loading. Firefox and other browsers don't, and are vulnerable to this attack. Mitigation: The fix for this is to upgrade to Apache Airflow 1.9.0 or above.",
      "cve": "CVE-2017-12614",
      "specs": [
        "<1.9.0"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2017-15720",
      "advisory": "In Apache Airflow 1.8.2 and earlier, an authenticated user can execute code remotely on the Airflow webserver by creating a special object.",
      "cve": "CVE-2017-15720",
      "specs": [
        "<=1.8.2"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2017-17835",
      "advisory": "In Apache Airflow 1.8.2 and earlier, a CSRF vulnerability allowed for a remote command injection on a default install of Airflow.",
      "cve": "CVE-2017-17835",
      "specs": [
        "<=1.8.2"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2017-17836",
      "advisory": "In Apache Airflow 1.8.2 and earlier, an experimental Airflow feature displayed authenticated cookies, as well as passwords to databases used by Airflow. An attacker who has limited access to airflow, whether it be via XSS or by leaving a machine unlocked can exfiltrate all credentials from the system.",
      "cve": "CVE-2017-17836",
      "specs": [
        "<=1.8.2"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2018-20244",
      "advisory": "In Apache Airflow before 1.10.2, a malicious admin user could edit the state of objects in the Airflow metadata database to execute arbitrary javascript on certain page views.",
      "cve": "CVE-2018-20244",
      "specs": [
        "<1.10.2"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2018-20245",
      "advisory": "The LDAP auth backend (airflow.contrib.auth.backends.ldap_auth) prior to Apache Airflow 1.10.1 was misconfigured and contained improper checking of exceptions which disabled server certificate checking.",
      "cve": "CVE-2018-20245",
      "specs": [
        "<1.10.1"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2019-0216",
      "advisory": "A malicious admin user could edit the state of objects in the Airflow metadata database to execute arbitrary javascript on certain page views.",
      "cve": "CVE-2019-0216",
      "specs": [
        "<=1.10.2"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2019-0229",
      "advisory": "A number of HTTP endpoints in the Airflow webserver (both RBAC and classic) did not have adequate protection and were vulnerable to cross-site request forgery attacks.",
      "cve": "CVE-2019-0229",
      "specs": [
        "<=1.10.2"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2019-12398",
      "advisory": "In Apache Airflow before 1.10.5 when running with the \"classic\" UI, a malicious admin user could edit the state of objects in the Airflow metadata database to execute arbitrary javascript on certain page views. The new \"RBAC\" UI is unaffected.",
      "cve": "CVE-2019-12398",
      "specs": [
        "<1.10.5"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2019-12417",
      "advisory": "A malicious admin user could edit the state of objects in the Airflow metadata database to execute arbitrary javascript on certain page views. This also presented a Local File Disclosure vulnerability to any file readable by the webserver process.",
      "cve": "CVE-2019-12417",
      "specs": [
        "<=1.10.5"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2020-11978",
      "advisory": "An issue was found in Apache Airflow versions 1.10.10 and below. A remote code/command injection vulnerability was discovered in one of the example DAGs shipped with Airflow which would allow any authenticated user to run arbitrary commands as the user running airflow worker/scheduler (depending on the executor in use). If you already have examples disabled by setting load_examples=False in the config then you are not vulnerable.",
      "cve": "CVE-2020-11978",
      "specs": [
        "<=1.10.10"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2020-11981",
      "advisory": "An issue was found in Apache Airflow versions 1.10.10 and below. When using CeleryExecutor, if an attacker can connect to the broker (Redis, RabbitMQ) directly, it is possible to inject commands, resulting in the celery worker running arbitrary commands.",
      "cve": "CVE-2020-11981",
      "specs": [
        "<=1.10.10"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2020-11982",
      "advisory": "An issue was found in Apache Airflow versions 1.10.10 and below. When using CeleryExecutor, if an attack can connect to the broker (Redis, RabbitMQ) directly, it was possible to insert a malicious payload directly to the broker which could lead to a deserialization attack (and thus remote code execution) on the Worker.",
      "cve": "CVE-2020-11982",
      "specs": [
        "<=1.10.10"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2020-11983",
      "advisory": "An issue was found in Apache Airflow versions 1.10.10 and below. It was discovered that many of the admin management screens in the new/RBAC UI handled escaping incorrectly, allowing authenticated users with appropriate permissions to create stored XSS attacks.",
      "cve": "CVE-2020-11983",
      "specs": [
        "<=1.10.10"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2020-13927",
      "advisory": "The previous default setting for Airflow's Experimental API was to allow all API requests without authentication, but this poses security risks to users who miss this fact. From Airflow 1.10.11 the default has been changed to deny all requests by default and is documented at https://airflow.apache.org/docs/1.10.11/security.html#api-authentication. Note this change fixes it for new installs but existing users need to change their config to default `[api]auth_backend = airflow.api.auth.backend.deny_all` as mentioned in the Updating Guide: https://github.com/apache/airflow/blob/1.10.11/UPDATING.md#experimental-api-will-deny-all-request-by-default",
      "cve": "CVE-2020-13927",
      "specs": [
        "<1.10.11"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2020-13944",
      "advisory": "In Apache Airflow < 1.10.12, the \"origin\" parameter passed to some of the endpoints like '/trigger' was vulnerable to XSS exploit.",
      "cve": "CVE-2020-13944",
      "specs": [
        "<1.10.12"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2020-17511",
      "advisory": "In Airflow versions prior to 1.10.13, when creating a user using airflow CLI, the password gets logged in plain text in the Log table in Airflow Metadatase. Same happened when creating a Connection with a password field.",
      "cve": "CVE-2020-17511",
      "specs": [
        "<1.10.13"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2020-17513",
      "advisory": "In Apache Airflow versions prior to 1.10.13, the Charts and Query View of the old (Flask-admin based) UI were vulnerable for SSRF attack.",
      "cve": "CVE-2020-17513",
      "specs": [
        "<1.10.13"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2020-17515",
      "advisory": "The \"origin\" parameter passed to some of the endpoints like '/trigger' was vulnerable to XSS exploit. This issue affects Apache Airflow versions prior to 1.10.13. This is same as CVE-2020-13944 but the implemented fix in Airflow 1.10.13 did not fix the issue completely.",
      "cve": "CVE-2020-17515",
      "specs": [
        "<1.10.13"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2020-17526",
      "advisory": "Incorrect Session Validation in Apache Airflow Webserver versions prior to 1.10.14 with default config allows a malicious airflow user on site A where they log in normally, to access unauthorized Airflow Webserver on Site B through the session from Site A. This does not affect users who have changed the default value for `[webserver] secret_key` config.",
      "cve": "CVE-2020-17526",
      "specs": [
        "<1.10.14"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2020-9485",
      "advisory": "An issue was found in Apache Airflow versions 1.10.10 and below. A stored XSS vulnerability was discovered in the Chart pages of the the \"classic\" UI.",
      "cve": "CVE-2020-9485",
      "specs": [
        "<=1.10.10"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2021-26559",
      "advisory": "Improper Access Control on Configurations Endpoint for the Stable API of Apache Airflow allows users with Viewer or User role to get Airflow Configurations including sensitive information even when `[webserver] expose_config` is set to `False` in `airflow.cfg`. This allowed a privilege escalation attack. This issue affects Apache Airflow 2.0.0.",
      "cve": "CVE-2021-26559",
      "specs": [
        "==2.0.0"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2021-26697",
      "advisory": "The lineage endpoint of the deprecated Experimental API was not protected by authentication in Airflow 2.0.0. This allowed unauthenticated users to hit that endpoint. This is low-severity issue as the attacker needs to be aware of certain parameters to pass to that endpoint and even after can just get some metadata about a DAG and a Task. This issue affects Apache Airflow 2.0.0.",
      "cve": "CVE-2021-26697",
      "specs": [
        "==2.0.0"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2021-28359",
      "advisory": "The \"origin\" parameter passed to some of the endpoints like '/trigger' was vulnerable to XSS exploit. This issue affects Apache Airflow versions <1.10.15 in 1.x series and affects 2.0.0 and 2.0.1 and 2.x series. This is the same as CVE-2020-13944 & CVE-2020-17515 but the implemented fix did not fix the issue completely. Update to Airflow 1.10.15 or 2.0.2. Please also update your Python version to the latest available PATCH releases of the installed MINOR versions, example update to Python 3.6.13 if you are on Python 3.6. (Those contain the fix for CVE-2021-23336 https://nvd.nist.gov/vuln/detail/CVE-2021-23336).",
      "cve": "CVE-2021-28359",
      "specs": [
        ">=1.0.0,<1.10.15",
        ">=2.0.0,<2.0.2"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2021-29621",
      "advisory": "Flask-AppBuilder is a development framework, built on top of Flask. User enumeration in database authentication in Flask-AppBuilder <= 3.2.3. Allows for a non authenticated user to enumerate existing accounts by timing the response time from the server when you are logging in. Upgrade to version 3.3.0 or higher to resolve.",
      "cve": "CVE-2021-29621",
      "specs": [
        "==1.10.0"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2021-35936",
      "advisory": "If remote logging is not used, the worker (in the case of CeleryExecutor) or the scheduler (in the case of LocalExecutor) runs a Flask logging server and is listening on a specific port and also binds on 0.0.0.0 by default. This logging server had no authentication and allows reading log files of DAG jobs. This issue affects Apache Airflow < 2.1.2.",
      "cve": "CVE-2021-35936",
      "specs": [
        "<2.1.2"
      ]
    },
    {
      "id": "pyup.io-apache-airflow:CVE-2021-38540",
      "advisory": "The variable import endpoint was not protected by authentication in Airflow >=2.0.0, <2.1.3. This allowed unauthenticated users to hit that endpoint to add/modify Airflow variables used in DAGs, potentially resulting in a denial of service, information disclosure or remote code execution. This issue affects Apache Airflow >=2.0.0, <2.1.3.",
      "cve": "CVE-2021-38540",
      "specs": [
        ">=2.0.0,<2.1.3"
      ]
    }
  ],
  "apache-libcloud": [
    {
      "id": "pyup.io-apache-libcloud:CVE-2010-4340",
      "advisory": "libcloud before 0.4.1 does not verify SSL certificates for HTTPS connections, which allows remote attackers to spoof certificates and bypass intended access restrictions via a man-in-the-middle (MITM) attack.",
      "cve": "CVE-2010-4340",
      "specs": [
        "<=0.4.0",
        "==0.2.0",
        "==0.3.0",
        "==0.3.1"
      ]
    },
    {
      "id": "pyup.io-apache-libcloud:CVE-2012-3446",
      "advisory": "Apache Libcloud before 0.11.1 uses an incorrect regular expression during verification of whether the server hostname matches a domain name in the subject's Common Name (CN) or subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via a crafted certificate.",
      "cve": "CVE-2012-3446",
      "specs": [
        "<=0.11.0",
        "==0.10.1",
        "==0.2.0",
        "==0.3.0",
        "==0.3.1",
        "==0.4.0",
        "==0.4.2",
        "==0.5.0",
        "==0.5.2",
        "==0.6.0-beta1",
        "==0.6.1",
        "==0.6.2",
        "==0.7.0",
        "==0.7.1",
        "==0.8.0",
        "==0.9.1"
      ]
    },
    {
      "id": "pyup.io-apache-libcloud:CVE-2013-6480",
      "advisory": "Libcloud 0.12.3 through 0.13.2 does not set the scrub_data parameter for the destroy DigitalOcean API, which allows local users to obtain sensitive information by leveraging a new VM.",
      "cve": "CVE-2013-6480",
      "specs": [
        "==0.12.3",
        "==0.12.4",
        "==0.13.0",
        "==0.13.1",
        "==0.13.2"
      ]
    }
  ],
  "apache-superset": [
    {
      "id": "pyup.io-apache-superset:CVE-2018-8021",
      "advisory": "Versions of Superset prior to 0.23 used an unsafe load method from the pickle library to deserialize data leading to possible remote code execution. Note Superset 0.23 was released prior to any Superset release under the Apache Software Foundation.",
      "cve": "CVE-2018-8021",
      "specs": [
        "<0.23"
      ]
    },
    {
      "id": "pyup.io-apache-superset:CVE-2019-12413",
      "advisory": "In Apache Incubator Superset before 0.31 user could query database metadata information from a database he has no access to, by using a specially crafted complex query.",
      "cve": "CVE-2019-12413",
      "specs": [
        "<0.31"
      ]
    },
    {
      "id": "pyup.io-apache-superset:CVE-2019-12414",
      "advisory": "In Apache Incubator Superset before 0.32, a user can view database names that he has no access to on a dropdown list in SQLLab",
      "cve": "CVE-2019-12414",
      "specs": [
        "<0.32"
      ]
    },
    {
      "id": "pyup.io-apache-superset:CVE-2020-13948",
      "advisory": "While investigating a bug report on Apache Superset, it was determined that an authenticated user could craft requests via a number of templated text fields in the product that would allow arbitrary access to Python\u2019s `os` package in the web application process in versions < 0.37.1. It was thus possible for an authenticated user to list and access files, environment variables, and process information. Additionally it was possible to set environment variables for the current process, create and update files in folders writable by the web process, and execute arbitrary programs accessible by the web process. All other operations available to the `os` package in Python were also available, even if not explicitly enumerated in this CVE.",
      "cve": "CVE-2020-13948",
      "specs": [
        "<0.37.1"
      ]
    },
    {
      "id": "pyup.io-apache-superset:CVE-2020-13952",
      "advisory": "In the course of work on the open source project it was discovered that authenticated users running queries against Hive and Presto database engines could access information via a number of templated fields including the contents of query description metadata database, the hashed version of the authenticated users\u2019 password, and access to connection information including the plaintext password for the current connection. It would also be possible to run arbitrary methods on the database connection object for the Presto or Hive connection, allowing the user to bypass security controls internal to Superset. This vulnerability is present in every Apache Superset version < 0.37.2.",
      "cve": "CVE-2020-13952",
      "specs": [
        "<0.37.2"
      ]
    },
    {
      "id": "pyup.io-apache-superset:CVE-2020-1932",
      "advisory": "An information disclosure issue was found in Apache Superset 0.34.0, 0.34.1, 0.35.0, and 0.35.1. Authenticated Apache Superset users are able to retrieve other users' information, including hashed passwords, by accessing an unused and undocumented API endpoint on Apache Superset.",
      "cve": "CVE-2020-1932",
      "specs": [
        "==0.34.0",
        "==0.34.1",
        "==0.35.0",
        "==0.35.1"
      ]
    },
    {
      "id": "pyup.io-apache-superset:CVE-2021-27907",
      "advisory": "Apache Superset up to and including 0.38.0 allowed the creation of a Markdown component on a Dashboard page for describing chart's related information. Abusing this functionality, a malicious user could inject javascript code executing unwanted action in the context of the user's browser. The javascript code will be automatically executed (Stored XSS) when a legitimate user surfs on the dashboard page. The vulnerability is exploitable creating a \u201cdiv\u201d section and embedding in it a \u201csvg\u201d element with javascript code.",
      "cve": "CVE-2021-27907",
      "specs": [
        "<=0.38.0"
      ]
    },
    {
      "id": "pyup.io-apache-superset:CVE-2021-28125",
      "advisory": "Apache Superset up to and including 1.0.1 allowed for the creation of an external URL that could be malicious. By not checking user input for open redirects the URL shortener functionality would allow for a malicious user to create a short URL for a dashboard that could convince the user to click the link.",
      "cve": "CVE-2021-28125",
      "specs": [
        "<=1.0.1"
      ]
    },
    {
      "id": "pyup.io-apache-superset:CVE-2021-32609",
      "advisory": "Apache Superset up to and including 1.1 does not sanitize titles correctly on the Explore page. This allows an attacker with Explore access to save a chart with a malicious title, injecting html (including scripts) into the page.",
      "cve": "CVE-2021-32609",
      "specs": [
        "<=1.1"
      ]
    },
    {
      "id": "pyup.io-apache-superset:CVE-2021-41971",
      "advisory": "Apache Superset up to and including 1.3.0 when configured with ENABLE_TEMPLATE_PROCESSING on (disabled by default) allowed SQL injection when a malicious authenticated user sends an http request with a custom URL.",
      "cve": "CVE-2021-41971",
      "specs": [
        "<=1.3.0"
      ]
    }
  ],
  "apkleaks": [
    {
      "id": "pyup.io-apkleaks:CVE-2021-21386",
      "advisory": "APKLeaks is an open-source project for scanning APK file for URIs, endpoints & secrets. APKLeaks prior to v2.0.3 allows remote attackers to execute arbitrary OS commands via package name inside application manifest. An attacker could include arguments that allow unintended commands or code to be executed, allow sensitive data to be read or modified or could cause other unintended behavior through malicious package name. The problem is fixed in version v2.0.6-dev and above.",
      "cve": "CVE-2021-21386",
      "specs": [
        "<2.0.3"
      ]
    }
  ],
  "apprise": [
    {
      "id": "pyup.io-apprise:CVE-2021-39229",
      "advisory": "Apprise is an open source library which allows you to send a notification to almost all of the most popular notification services available. In affected versions users who use Apprise granting them access to the IFTTT plugin (which just comes out of the box) are subject to a denial of service attack on an inefficient regular expression. The vulnerable regular expression is [here](https://github.com/caronc/apprise/blob/0007eade20934ddef0aba38b8f1aad980cfff253/apprise/plugins/NotifyIFTTT.py#L356-L359). The problem has been patched in release version 0.9.5.1. Users who are unable to upgrade are advised to remove `apprise/plugins/NotifyIFTTT.py` to eliminate the service.",
      "cve": "CVE-2021-39229",
      "specs": [
        "<0.9.5.1"
      ]
    }
  ],
  "archmage": [
    {
      "id": "pyup.io-archmage:CVE-2015-1589",
      "advisory": "Directory traversal vulnerability in arCHMage 0.2.4 allows remote attackers to write to arbitrary files via a .. (dot dot) in a CHM file.",
      "cve": "CVE-2015-1589",
      "specs": [
        "==0.2.4"
      ]
    }
  ],
  "asyncpg": [
    {
      "id": "pyup.io-asyncpg:CVE-2020-17446",
      "advisory": "asyncpg before 0.21.0 allows a malicious PostgreSQL server to trigger a crash or execute arbitrary code (on a database client) via a crafted server response, because of access to an uninitialized pointer in the array data decoder.",
      "cve": "CVE-2020-17446",
      "specs": [
        "<0.21.0"
      ]
    }
  ],
  "aubio": [
    {
      "id": "pyup.io-aubio:CVE-2017-17054",
      "advisory": "In aubio 0.4.6, a divide-by-zero error exists in the function new_aubio_source_wavread() in source_wavread.c, which may lead to DoS when playing a crafted audio file.",
      "cve": "CVE-2017-17054",
      "specs": [
        "==0.4.6"
      ]
    },
    {
      "id": "pyup.io-aubio:CVE-2017-17554",
      "advisory": "A NULL pointer dereference (DoS) Vulnerability was found in the function aubio_source_avcodec_readframe in io/source_avcodec.c of aubio 0.4.6, which may lead to DoS when playing a crafted audio file.",
      "cve": "CVE-2017-17554",
      "specs": [
        "==0.4.6"
      ]
    },
    {
      "id": "pyup.io-aubio:CVE-2017-17555",
      "advisory": "The swri_audio_convert function in audioconvert.c in FFmpeg libswresample through 3.0.101, as used in FFmpeg 3.4.1, aubio 0.4.6, and other products, allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted audio file.",
      "cve": "CVE-2017-17555",
      "specs": [
        "==0.4.6"
      ]
    },
    {
      "id": "pyup.io-aubio:CVE-2018-14521",
      "advisory": "An issue was discovered in aubio 0.4.6. A SEGV signal can occur in aubio_source_avcodec_readframe in io/source_avcodec.c, as demonstrated by aubiomfcc.",
      "cve": "CVE-2018-14521",
      "specs": [
        "==0.4.6"
      ]
    },
    {
      "id": "pyup.io-aubio:CVE-2018-14522",
      "advisory": "An issue was discovered in aubio 0.4.6. A SEGV signal can occur in aubio_pitch_set_unit in pitch/pitch.c, as demonstrated by aubionotes.",
      "cve": "CVE-2018-14522",
      "specs": [
        "==0.4.6"
      ]
    },
    {
      "id": "pyup.io-aubio:CVE-2018-14523",
      "advisory": "An issue was discovered in aubio 0.4.6. A buffer over-read can occur in new_aubio_pitchyinfft in pitch/pitchyinfft.c, as demonstrated by aubionotes.",
      "cve": "CVE-2018-14523",
      "specs": [
        "==0.4.6"
      ]
    },
    {
      "id": "pyup.io-aubio:CVE-2018-19800",
      "advisory": "aubio v0.4.0 to v0.4.8 has a Buffer Overflow in new_aubio_tempo.",
      "cve": "CVE-2018-19800",
      "specs": [
        ">=0.4.0,<=0.4.8"
      ]
    },
    {
      "id": "pyup.io-aubio:CVE-2018-19801",
      "advisory": "aubio v0.4.0 to v0.4.8 has a NULL pointer dereference in new_aubio_filterbank via invalid n_filters.",
      "cve": "CVE-2018-19801",
      "specs": [
        ">=0.4.0,<=0.4.8"
      ]
    },
    {
      "id": "pyup.io-aubio:CVE-2018-19802",
      "advisory": "aubio v0.4.0 to v0.4.8 has a new_aubio_onset NULL pointer dereference.",
      "cve": "CVE-2018-19802",
      "specs": [
        ">=0.4.0,<=0.4.8"
      ]
    }
  ],
  "autobahn": [
    {
      "id": "pyup.io-autobahn:CVE-2020-35678",
      "advisory": "Autobahn|Python before 20.12.3 allows redirect header injection.",
      "cve": "CVE-2020-35678",
      "specs": [
        "<20.12.3"
      ]
    }
  ],
  "aws-encryption-sdk": [
    {
      "id": "pyup.io-aws-encryption-sdk:CVE-2020-8897",
      "advisory": "A weak robustness vulnerability exists in the AWS Encryption SDKs for Java, Python, C and Javalcript prior to versions 2.0.0. Due to the non-committing property of AES-GCM (and other AEAD ciphers such as AES-GCM-SIV or (X)ChaCha20Poly1305) used by the SDKs to encrypt messages, an attacker can craft a unique cyphertext which will decrypt to multiple different results, and becomes especially relevant in a multi-recipient setting. We recommend users update their SDK to 2.0.0 or later.",
      "cve": "CVE-2020-8897",
      "specs": [
        "<2.0.0"
      ]
    }
  ],
  "babel": [
    {
      "id": "pyup.io-babel:CVE-2021-42771",
      "advisory": "Babel.Locale in Babel before 2.9.1 allows attackers to load arbitrary locale .dat files (containing serialized Python objects) via directory traversal, leading to code execution.",
      "cve": "CVE-2021-42771",
      "specs": [
        "<2.9.1"
      ]
    }
  ],
  "beaker": [
    {
      "id": "pyup.io-beaker:CVE-2012-3458",
      "advisory": "Beaker before 1.6.4, when using PyCrypto to encrypt sessions, uses AES in ECB cipher mode, which might allow remote attackers to obtain portions of sensitive session data via unspecified vectors.",
      "cve": "CVE-2012-3458",
      "specs": [
        "<=1.6.4"
      ]
    },
    {
      "id": "pyup.io-beaker:CVE-2013-7489",
      "advisory": "The Beaker library through 1.11.0 for Python is affected by deserialization of untrusted data, which could lead to arbitrary code execution.",
      "cve": "CVE-2013-7489",
      "specs": [
        "<=1.11.0"
      ]
    }
  ],
  "bikeshed": [
    {
      "id": "pyup.io-bikeshed:CVE-2021-23422",
      "advisory": "This affects the package bikeshed before 3.0.0. This can occur when an untrusted source file containing Inline Tag Command metadata is processed. When an arbitrary OS command is executed, the command output would be included in the HTML output.",
      "cve": "CVE-2021-23422",
      "specs": [
        "<3.0.0"
      ]
    },
    {
      "id": "pyup.io-bikeshed:CVE-2021-23423",
      "advisory": "This affects the package bikeshed before 3.0.0. This can occur when an untrusted source file containing include, include-code or include-raw block is processed. The contents of arbitrary files could be disclosed in the HTML output.",
      "cve": "CVE-2021-23423",
      "specs": [
        "<3.0.0"
      ]
    }
  ],
  "binderhub": [
    {
      "id": "pyup.io-binderhub:CVE-2021-39159",
      "advisory": "BinderHub is a kubernetes-based cloud service that allows users to share reproducible interactive computing environments from code repositories. In affected versions a remote code execution vulnerability has been identified in BinderHub, where providing BinderHub with maliciously crafted input could execute code in the BinderHub context, with the potential to egress credentials of the BinderHub deployment, including JupyterHub API tokens, kubernetes service accounts, and docker registry credentials. This may provide the ability to manipulate images and other user created pods in the deployment, with the potential to escalate to the host depending on the underlying kubernetes configuration. Users are advised to update to version 0.2.0-n653. If users are unable to update they may disable the git repo provider by specifying the `BinderHub.repo_providers` as a workaround.",
      "cve": "CVE-2021-39159",
      "specs": [
        "<0.2.0-n653"
      ]
    }
  ],
  "blackduck": [
    {
      "id": "pyup.io-blackduck:CVE-2020-27589",
      "advisory": "Synopsys hub-rest-api-python (aka blackduck on PyPI) version 0.0.25 - 0.0.52 does not validate SSL certificates in certain cases.",
      "cve": "CVE-2020-27589",
      "specs": [
        ">=0.0.25,<=0.0.52"
      ]
    }
  ],
  "blazar-dashboard": [
    {
      "id": "pyup.io-blazar-dashboard:CVE-2020-26943",
      "advisory": "An issue was discovered in OpenStack blazar-dashboard before 1.3.1, 2.0.0, and 3.0.0. A user allowed to access the Blazar dashboard in Horizon may trigger code execution on the Horizon host as the user the Horizon service runs under (because the Python eval function is used). This may result in Horizon host unauthorized access and further compromise of the Horizon service. All setups using the Horizon dashboard with the blazar-dashboard plugin are affected.",
      "cve": "CVE-2020-26943",
      "specs": [
        "<1.3.1",
        "==2.0.0",
        "==3.0.0"
      ]
    }
  ],
  "bleach": [
    {
      "id": "pyup.io-bleach:CVE-2018-7753",
      "advisory": "An issue was discovered in Bleach 2.1.x before 2.1.3. Attributes that have URI values weren't properly sanitized if the values contained character entities. Using character entities, it was possible to construct a URI value with a scheme that was not allowed that would slide through unsanitized.",
      "cve": "CVE-2018-7753",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2"
      ]
    },
    {
      "id": "pyup.io-bleach:CVE-2020-6802",
      "advisory": "In Mozilla Bleach before 3.11, a mutation XSS affects users calling bleach.clean with noscript and a raw tag in the allowed/whitelisted tags option.",
      "cve": "CVE-2020-6802",
      "specs": [
        "<3.1.1"
      ]
    },
    {
      "id": "pyup.io-bleach:CVE-2020-6816",
      "advisory": "In Mozilla Bleach before 3.12, a mutation XSS in bleach.clean when RCDATA and either svg or math tags are whitelisted and the keyword argument strip=False.",
      "cve": "CVE-2020-6816",
      "specs": [
        "<3.1.2"
      ]
    }
  ],
  "bodhi": [
    {
      "id": "pyup.io-bodhi:CVE-2017-1002152",
      "advisory": "Bodhi 2.9.0 and lower is vulnerable to cross-site scripting resulting in code injection caused by incorrect validation of bug titles.",
      "cve": "CVE-2017-1002152",
      "specs": [
        "<=2.9.0"
      ]
    }
  ],
  "bottle": [
    {
      "id": "pyup.io-bottle:CVE-2014-3137",
      "advisory": "Bottle 0.10.x before 0.10.12, 0.11.x before 0.11.7, and 0.12.x before 0.12.6 does not properly limit content types, which allows remote attackers to bypass intended access restrictions via an accepted Content-Type followed by a ; (semi-colon) and a Content-Type that would not be accepted, as demonstrated in YouCompleteMe to execute arbitrary code.",
      "cve": "CVE-2014-3137",
      "specs": [
        "==0.10.0",
        "==0.10.1",
        "==0.10.10",
        "==0.10.11",
        "==0.10.2",
        "==0.10.3",
        "==0.10.4",
        "==0.10.5",
        "==0.10.6",
        "==0.10.7",
        "==0.10.8",
        "==0.10.9",
        "==0.11.0",
        "==0.11.1",
        "==0.11.2",
        "==0.11.3",
        "==0.11.4",
        "==0.11.5",
        "==0.11.6",
        "==0.11.7",
        "==0.12.0",
        "==0.12.1",
        "==0.12.2",
        "==0.12.3",
        "==0.12.4",
        "==0.12.5"
      ]
    },
    {
      "id": "pyup.io-bottle:CVE-2016-9964",
      "advisory": "redirect() in bottle.py in bottle 0.12.10 doesn't filter a \"\\r\\n\" sequence, which leads to a CRLF attack, as demonstrated by a redirect(\"233\\r\\nSet-Cookie: name=salt\") call.",
      "cve": "CVE-2016-9964",
      "specs": [
        "==0.12.10"
      ]
    },
    {
      "id": "pyup.io-bottle:CVE-2020-28473",
      "advisory": "The package bottle from 0 and before 0.12.19 are vulnerable to Web Cache Poisoning by using a vector called parameter cloaking. When the attacker can separate query parameters using a semicolon (;), they can cause a difference in the interpretation of the request between the proxy (running with default configuration) and the server. This can result in malicious requests being cached as completely safe ones, as the proxy would usually not see the semicolon as a separator, and therefore would not include it in a cache key of an unkeyed parameter.",
      "cve": "CVE-2020-28473",
      "specs": [
        "<0.12.19"
      ]
    }
  ],
  "bsdiff4": [
    {
      "id": "pyup.io-bsdiff4:CVE-2020-15904",
      "advisory": "A buffer overflow in the patching routine of bsdiff4 before 1.2.0 allows an attacker to write to heap memory (beyond allocated bounds) via a crafted patch file.",
      "cve": "CVE-2020-15904",
      "specs": [
        "<1.2.0"
      ]
    }
  ],
  "buildbot": [
    {
      "id": "pyup.io-buildbot:CVE-2009-2959",
      "advisory": "Cross-site scripting (XSS) vulnerability in the waterfall web status view (status/web/waterfall.py) in Buildbot 0.7.6 through 0.7.11p1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2009-2959",
      "specs": [
        "==0.7.10",
        "==0.7.10p1",
        "==0.7.11",
        "==0.7.11p1",
        "==0.7.6",
        "==0.7.7",
        "==0.7.8",
        "==0.7.9"
      ]
    },
    {
      "id": "pyup.io-buildbot:CVE-2009-2967",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in Buildbot 0.7.6 through 0.7.11p2 allow remote attackers to inject arbitrary web script or HTML via unspecified vectors, different vulnerabilities than CVE-2009-2959.",
      "cve": "CVE-2009-2967",
      "specs": [
        "==0.7.10",
        "==0.7.10p1",
        "==0.7.11",
        "==0.7.11p1",
        "==0.7.11p2",
        "==0.7.6",
        "==0.7.7",
        "==0.7.8",
        "==0.7.9"
      ]
    },
    {
      "id": "pyup.io-buildbot:CVE-2019-12300",
      "advisory": "Buildbot before 1.8.2 and 2.x before 2.3.1 accepts a user-submitted authorization token from OAuth and uses it to authenticate a user. If an attacker has a token allowing them to read the user details of a victim, they can login as the victim.",
      "cve": "CVE-2019-12300",
      "specs": [
        "<1.8.2",
        ">=2.0.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-buildbot:CVE-2019-7313",
      "advisory": "www/resource.py in Buildbot before 1.8.1 allows CRLF injection in the Location header of /auth/login and /auth/logout via the redirect parameter. This affects other web sites in the same domain.",
      "cve": "CVE-2019-7313",
      "specs": [
        ">=0.9.0,<=1.8.0"
      ]
    }
  ],
  "cabot": [
    {
      "id": "pyup.io-cabot:CVE-2020-25449",
      "advisory": "Cross Site Scripting (XSS) vulnerability in Arachnys Cabot 0.11.12 can be exploited via the Address column.",
      "cve": "CVE-2020-25449",
      "specs": [
        "==0.11.12"
      ]
    },
    {
      "id": "pyup.io-cabot:CVE-2020-7734",
      "advisory": "All versions of package cabot are vulnerable to Cross-site Scripting (XSS) via the Endpoint column.",
      "cve": "CVE-2020-7734",
      "specs": [
        "<=0.11.16"
      ]
    }
  ],
  "cairosvg": [
    {
      "id": "pyup.io-cairosvg:CVE-2021-21236",
      "advisory": "CairoSVG is a Python (pypi) package. CairoSVG is an SVG converter based on Cairo. In CairoSVG before version 2.5.1, there is a regular expression denial of service (REDoS) vulnerability. When processing SVG files, the python package CairoSVG uses two regular expressions which are vulnerable to Regular Expression Denial of Service (REDoS). If an attacker provides a malicious SVG, it can make cairosvg get stuck processing the file for a very long time. This is fixed in version 2.5.1. See Referenced GitHub advisory for more information.",
      "cve": "CVE-2021-21236",
      "specs": [
        "<2.5.1"
      ]
    }
  ],
  "celery": [
    {
      "id": "pyup.io-celery:CVE-2011-4356",
      "advisory": "Celery 2.1 and 2.2 before 2.2.8, 2.3 before 2.3.4, and 2.4 before 2.4.4 changes the effective id but not the real id during processing of the --uid and --gid arguments to celerybeat, celeryd_detach, celeryd-multi, and celeryev, which allows local users to gain privileges via vectors involving crafted code that is executed by the worker process.",
      "cve": "CVE-2011-4356",
      "specs": [
        "==2.1.0",
        "==2.2.0",
        "==2.2.1",
        "==2.2.2",
        "==2.2.3",
        "==2.2.4",
        "==2.2.5",
        "==2.2.6",
        "==2.2.7",
        "==2.3.0",
        "==2.3.1",
        "==2.3.2",
        "==2.3.3",
        "==2.4.0",
        "==2.4.1",
        "==2.4.2",
        "==2.4.3"
      ]
    }
  ],
  "cfscrape": [
    {
      "id": "pyup.io-cfscrape:CVE-2017-7235",
      "advisory": "An issue was discovered in cloudflare-scrape 1.6.6 through 1.7.1. A malicious website owner could craft a page that executes arbitrary Python code against any cfscrape user who scrapes that website. This is fixed in 1.8.0.",
      "cve": "CVE-2017-7235",
      "specs": [
        "==1.6.6",
        "==1.6.7",
        "==1.6.8",
        "==1.7.0",
        "==1.7.1"
      ]
    }
  ],
  "channels": [
    {
      "id": "pyup.io-channels:CVE-2020-35681",
      "advisory": "Django Channels 3.x before 3.0.3 allows remote attackers to obtain sensitive information from a different request scope. The legacy channels.http.AsgiHandler class, used for handling HTTP type requests in an ASGI environment prior to Django 3.0, did not correctly separate request scopes in Channels 3.0. In many cases this would result in a crash but, with correct timing, responses could be sent to the wrong client, resulting in potential leakage of session identifiers and other sensitive data. Note that this affects only the legacy Channels provided class, and not Django's similar ASGIHandler, available from Django 3.0.",
      "cve": "CVE-2020-35681",
      "specs": [
        ">=3.0.0,<3.0.3"
      ]
    }
  ],
  "cherrymusic": [
    {
      "id": "pyup.io-cherrymusic:CVE-2015-8309",
      "advisory": "Directory traversal vulnerability in Cherry Music before 0.36.0 allows remote authenticated users to read arbitrary files via the \"value\" parameter to \"download.\"",
      "cve": "CVE-2015-8309",
      "specs": [
        "<=0.35.2"
      ]
    },
    {
      "id": "pyup.io-cherrymusic:CVE-2015-8310",
      "advisory": "Cross-site scripting (XSS) vulnerability in Cherry Music before 0.36.0 allows remote authenticated users to inject arbitrary web script or HTML via the playlistname field when creating a new playlist.",
      "cve": "CVE-2015-8310",
      "specs": [
        "<=0.35.2"
      ]
    }
  ],
  "cinder": [
    {
      "id": "pyup.io-cinder:CVE-2013-4183",
      "advisory": "The clear_volume function in LVMVolumeDriver driver in OpenStack Cinder 2013.1.1 through 2013.1.2 does not properly clear data when deleting a snapshot, which allows local users to obtain sensitive information via unspecified vectors.",
      "cve": "CVE-2013-4183",
      "specs": [
        "==2013.1.1",
        "==2013.1.2"
      ]
    },
    {
      "id": "pyup.io-cinder:CVE-2013-4202",
      "advisory": "The (1) backup (api/contrib/backups.py) and (2) volume transfer (contrib/volume_transfer.py) APIs in OpenStack Cinder Grizzly 2013.1.3 and earlier allows remote attackers to cause a denial of service (resource consumption and crash) via an XML Entity Expansion (XEE) attack.  NOTE: this issue is due to an incomplete fix for CVE-2013-1664.",
      "cve": "CVE-2013-4202",
      "specs": [
        ">=2013.1,<=2013.1.3"
      ]
    },
    {
      "id": "pyup.io-cinder:CVE-2014-3641",
      "advisory": "The (1) GlusterFS and (2) Linux Smbfs drivers in OpenStack Cinder before 2014.1.3 allows remote authenticated users to obtain file data from the Cinder-volume host by cloning and attaching a volume with a crafted qcow2 header.",
      "cve": "CVE-2014-3641",
      "specs": [
        "<=2014.1.2",
        "==2014.1.1"
      ]
    },
    {
      "id": "pyup.io-cinder:CVE-2014-7230",
      "advisory": "The processutils.execute function in OpenStack oslo-incubator, Cinder, Nova, and Trove before 2013.2.4 and 2014.1 before 2014.1.3 allows local users to obtain passwords from commands that cause a ProcessExecutionError by reading the log.",
      "cve": "CVE-2014-7230",
      "specs": [
        ">=2013.2,<2013.2.4",
        ">=2014.1,<2014.1.3"
      ]
    },
    {
      "id": "pyup.io-cinder:CVE-2014-7231",
      "advisory": "The strutils.mask_password function in the OpenStack Oslo utility library, Cinder, Nova, and Trove before 2013.2.4 and 2014.1 before 2014.1.3 does not properly mask passwords when logging commands, which allows local users to obtain passwords by reading the log.",
      "cve": "CVE-2014-7231",
      "specs": [
        ">=2013.2,<2013.2.4",
        ">=2014.1,<2014.1.3"
      ]
    },
    {
      "id": "pyup.io-cinder:CVE-2015-5162",
      "advisory": "The image parser in OpenStack Cinder 7.0.2 and 8.0.0 through 8.1.1; Glance before 11.0.1 and 12.0.0; and Nova before 12.0.4 and 13.0.0 does not properly limit qemu-img calls, which might allow attackers to cause a denial of service (memory and disk consumption) via a crafted disk image.",
      "cve": "CVE-2015-5162",
      "specs": [
        "==7.0.2",
        "==8.0.0",
        "==8.1.0"
      ]
    },
    {
      "id": "pyup.io-cinder:CVE-2017-15139",
      "advisory": "A vulnerability was found in openstack-cinder releases up to and including Queens, allowing newly created volumes in certain storage volume configurations to contain previous data. It specifically affects ScaleIO volumes using thin volumes and zero padding. This could lead to leakage of sensitive information between tenants.",
      "cve": "CVE-2017-15139",
      "specs": [
        "<=12.0.4-7"
      ]
    },
    {
      "id": "pyup.io-cinder:CVE-2020-10755",
      "advisory": "An insecure-credentials flaw was found in all openstack-cinder versions before openstack-cinder 14.1.0, all openstack-cinder 15.x.x versions before openstack-cinder 15.2.0 and all openstack-cinder 16.x.x versions before openstack-cinder 16.1.0. When using openstack-cinder with the Dell EMC ScaleIO or VxFlex OS backend storage driver, credentials for the entire backend are exposed in the ``connection_info`` element in all Block Storage v3 Attachments API calls containing that element. This flaw enables an end-user to create a volume, make an API call to show the attachment detail information, and retrieve a username and password that may be used to connect to another user's volume. Additionally, these credentials are valid for the ScaleIO or VxFlex OS Management API, should an attacker discover the Management API endpoint. Source: OpenStack project",
      "cve": "CVE-2020-10755",
      "specs": [
        "<14.1.0",
        ">=15.0.0,<15.2.0",
        ">=16.0.0,<16.1.0"
      ]
    }
  ],
  "clearsilver": [
    {
      "id": "pyup.io-clearsilver:CVE-2011-4357",
      "advisory": "Format string vulnerability in the p_cgi_error function in python/neo_cgi.c in the Python CGI Kit (neo_cgi) module for Clearsilver 0.10.5 and earlier allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via format string specifiers that are not properly handled when creating CGI error messages using the cgi_error API function.",
      "cve": "CVE-2011-4357",
      "specs": [
        "<=0.10.5",
        "==0.1",
        "==0.10.1",
        "==0.10.2",
        "==0.10.3",
        "==0.10.4",
        "==0.2",
        "==0.2.1",
        "==0.3",
        "==0.4",
        "==0.5",
        "==0.6",
        "==0.7",
        "==0.7.1",
        "==0.7.2",
        "==0.8.0",
        "==0.8.1",
        "==0.9.0",
        "==0.9.1",
        "==0.9.14",
        "==0.9.2",
        "==0.9.3",
        "==0.9.6",
        "==0.9.7"
      ]
    }
  ],
  "clickhouse-driver": [
    {
      "id": "pyup.io-clickhouse-driver:CVE-2020-26759",
      "advisory": "clickhouse-driver before 0.1.5 allows a malicious clickhouse server to trigger a crash or execute arbitrary code (on a database client) via a crafted server response, due to a buffer overflow.",
      "cve": "CVE-2020-26759",
      "specs": [
        "<0.1.5"
      ]
    }
  ],
  "coapthon": [
    {
      "id": "pyup.io-coapthon:CVE-2018-12680",
      "advisory": "The Serialize.deserialize() method in CoAPthon 3.1, 4.0.0, 4.0.1, and 4.0.2 mishandles certain exceptions, leading to a denial of service in applications that use this library (e.g., the standard CoAP server, CoAP client, CoAP reverse proxy, example collect CoAP server and client) when they receive crafted CoAP messages.",
      "cve": "CVE-2018-12680",
      "specs": [
        "==3.1",
        "==4.0.0",
        "==4.0.1",
        "==4.0.2"
      ]
    }
  ],
  "coapthon3": [
    {
      "id": "pyup.io-coapthon3:CVE-2018-12679",
      "advisory": "The Serialize.deserialize() method in CoAPthon3 1.0 and 1.0.1 mishandles certain exceptions, leading to a denial of service in applications that use this library (e.g., the standard CoAP server, CoAP client, example collect CoAP server and client) when they receive crafted CoAP messages.",
      "cve": "CVE-2018-12679",
      "specs": [
        "==1.0",
        "==1.0.1"
      ]
    }
  ],
  "cobbler": [
    {
      "id": "pyup.io-cobbler:CVE-2011-4953",
      "advisory": "The set_mgmt_parameters function in item.py in cobbler before 2.2.2 allows context-dependent attackers to execute arbitrary code via vectors related to the use of the yaml.load function instead of the yaml.safe_load function, as demonstrated using Puppet.",
      "cve": "CVE-2011-4953",
      "specs": [
        "<=2.2.1"
      ]
    },
    {
      "id": "pyup.io-cobbler:CVE-2014-3225",
      "advisory": "Absolute path traversal vulnerability in the web interface in Cobbler 2.4.x through 2.6.x allows remote authenticated users to read arbitrary files via the Kickstart field in a profile.",
      "cve": "CVE-2014-3225",
      "specs": [
        "==2.4.0",
        "==2.4.0-1",
        "==2.4.1",
        "==2.4.2",
        "==2.4.3",
        "==2.4.4",
        "==2.6.0"
      ]
    },
    {
      "id": "pyup.io-cobbler:CVE-2016-9605",
      "advisory": "A flaw was found in cobbler software component version 2.6.11-1. It suffers from an invalid parameter validation vulnerability, leading the arbitrary file reading. The flaw is triggered by navigating to a vulnerable URL via cobbler-web on a default installation.",
      "cve": "CVE-2016-9605",
      "specs": [
        "==2.6.11-1"
      ]
    },
    {
      "id": "pyup.io-cobbler:CVE-2017-1000469",
      "advisory": "Cobbler version up to 2.8.2 is vulnerable to a command injection vulnerability in the \"add repo\" component resulting in arbitrary code execution as root user.",
      "cve": "CVE-2017-1000469",
      "specs": [
        "<=2.8.2"
      ]
    },
    {
      "id": "pyup.io-cobbler:CVE-2018-1000226",
      "advisory": "Cobbler version Verified as present in Cobbler versions 2.6.11+, but code inspection suggests at least 2.0.0+ or possibly even older versions may be vulnerable contains a Incorrect Access Control vulnerability in XMLRPC API (/cobbler_api) that can result in Privilege escalation, data manipulation or exfiltration, LDAP credential harvesting. This attack appear to be exploitable via \"network connectivity\". Taking advantage of improper validation of security tokens in API endpoints. Please note this is a different issue than CVE-2018-10931.",
      "cve": "CVE-2018-1000226",
      "specs": [
        ">=2.0.0"
      ]
    },
    {
      "id": "pyup.io-cobbler:CVE-2018-10931",
      "advisory": "It was found that cobbler 2.6.x exposed all functions from its CobblerXMLRPCInterface class over XMLRPC. A remote, unauthenticated attacker could use this flaw to gain high privileges within cobbler, upload files to arbitrary location in the context of the daemon.",
      "cve": "CVE-2018-10931",
      "specs": [
        ">=2.6.0,<=2.6.11"
      ]
    },
    {
      "id": "pyup.io-cobbler:CVE-2021-40323",
      "advisory": "Cobbler before 3.3.0 allows log poisoning, and resultant Remote Code Execution, via an XMLRPC method that logs to the logfile for template injection.",
      "cve": "CVE-2021-40323",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-cobbler:CVE-2021-40324",
      "advisory": "Cobbler before 3.3.0 allows arbitrary file write operations via upload_log_data.",
      "cve": "CVE-2021-40324",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-cobbler:CVE-2021-40325",
      "advisory": "Cobbler before 3.3.0 allows authorization bypass for modification of settings.",
      "cve": "CVE-2021-40325",
      "specs": [
        "<=3.3.0"
      ]
    }
  ],
  "colander": [
    {
      "id": "pyup.io-colander:CVE-2017-18361",
      "advisory": "In Pylons Colander through 1.6, the URL validator allows an attacker to potentially cause an infinite loop thereby causing a denial of service via an unclosed parenthesis.",
      "cve": "CVE-2017-18361",
      "specs": [
        "<=1.6"
      ]
    }
  ],
  "conference-scheduler-cli": [
    {
      "id": "pyup.io-conference-scheduler-cli:CVE-2018-14572",
      "advisory": "In conference-scheduler-cli, a pickle.load call on imported data allows remote attackers to execute arbitrary code via a crafted .pickle file, as demonstrated by Python code that contains an os.system call.",
      "cve": "CVE-2018-14572",
      "specs": [
        "<=0.10.1"
      ]
    }
  ],
  "confire": [
    {
      "id": "pyup.io-confire:CVE-2017-16763",
      "advisory": "An exploitable vulnerability exists in the YAML parsing functionality in config.py in Confire 0.2.0. Due to the user-specific configuration being loaded from \"~/.confire.yaml\" using the yaml.load function, a YAML parser can execute arbitrary Python commands resulting in command execution. An attacker can insert Python into loaded YAML to trigger this vulnerability.",
      "cve": "CVE-2017-16763",
      "specs": [
        "==0.2.0"
      ]
    }
  ],
  "cryptography": [
    {
      "id": "pyup.io-cryptography:CVE-2016-9243",
      "advisory": "HKDF in cryptography before 1.5.2 returns an empty byte-string if used with a length less than algorithm.digest_size.",
      "cve": "CVE-2016-9243",
      "specs": [
        "<=1.5.2"
      ]
    },
    {
      "id": "pyup.io-cryptography:CVE-2018-10903",
      "advisory": "A flaw was found in python-cryptography versions between >=1.9.0 and <2.3. The finalize_with_tag API did not enforce a minimum tag length. If a user did not validate the input length prior to passing it to finalize_with_tag an attacker could craft an invalid payload with a shortened tag (e.g. 1 byte) such that they would have a 1 in 256 chance of passing the MAC check. GCM tag forgeries can cause key leakage.",
      "cve": "CVE-2018-10903",
      "specs": [
        ">=1.9.0,<2.3"
      ]
    },
    {
      "id": "pyup.io-cryptography:CVE-2020-25659",
      "advisory": "python-cryptography 3.2 is vulnerable to Bleichenbacher timing attacks in the RSA decryption API, via timed processing of valid PKCS#1 v1.5 ciphertext.",
      "cve": "CVE-2020-25659",
      "specs": [
        "==3.2"
      ]
    },
    {
      "id": "pyup.io-cryptography:CVE-2020-36242",
      "advisory": "In the cryptography package before 3.3.2 for Python, certain sequences of update calls to symmetrically encrypt multi-GB values could result in an integer overflow and buffer overflow, as demonstrated by the Fernet class.",
      "cve": "CVE-2020-36242",
      "specs": [
        "<3.3.2"
      ]
    }
  ],
  "cumin": [
    {
      "id": "pyup.io-cumin:CVE-2012-1575",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in Cumin before r5238 allow remote attackers to inject arbitrary web script or HTML via vectors involving (1) widgets or (2) pages.",
      "cve": "CVE-2012-1575",
      "specs": [
        "<=r5237"
      ]
    },
    {
      "id": "pyup.io-cumin:CVE-2012-2680",
      "advisory": "Cumin before 0.1.5444, as used in Red Hat Enterprise Messaging, Realtime, and Grid (MRG) 2.0, does not properly restrict access to resources, which allows remote attackers to obtain sensitive information via unspecified vectors related to (1) \"web pages,\" (2) \"export functionality,\" and (3) \"image viewing.\"",
      "cve": "CVE-2012-2680",
      "specs": [
        "<=0.1.5192-4",
        "==0.1.3160-1",
        "==0.1.4369-1",
        "==0.1.4410-2",
        "==0.1.4494-1",
        "==0.1.4794-1",
        "==0.1.4916-1",
        "==0.1.5033-1",
        "==0.1.5037-1",
        "==0.1.5054-1",
        "==0.1.5068-1",
        "==0.1.5092-1",
        "==0.1.5098-2",
        "==0.1.5105-1",
        "==0.1.5137-1",
        "==0.1.5137-2",
        "==0.1.5137-3",
        "==0.1.5137-4",
        "==0.1.5137-5",
        "==0.1.5192-1"
      ]
    },
    {
      "id": "pyup.io-cumin:CVE-2012-2681",
      "advisory": "Cumin before 0.1.5444, as used in Red Hat Enterprise Messaging, Realtime, and Grid (MRG) 2.0, uses predictable random numbers to generate session keys, which makes it easier for remote attackers to guess the session key.",
      "cve": "CVE-2012-2681",
      "specs": [
        "<=0.1.5192-4",
        "==0.1.3160-1",
        "==0.1.4369-1",
        "==0.1.4410-2",
        "==0.1.4494-1",
        "==0.1.4794-1",
        "==0.1.4916-1",
        "==0.1.5098-2",
        "==0.1.5192-1"
      ]
    },
    {
      "id": "pyup.io-cumin:CVE-2012-2683",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in Cumin before 0.1.5444, as used in Red Hat Enterprise Messaging, Realtime, and Grid (MRG) 2.0, allow remote attackers to inject arbitrary web script or HTML via unspecified vectors related to (1) \"error message displays\" or (2) \"in source HTML on certain pages.\"",
      "cve": "CVE-2012-2683",
      "specs": [
        "<=0.1.5192-4",
        "==0.1.3160-1",
        "==0.1.4369-1",
        "==0.1.4410-2",
        "==0.1.4494-1",
        "==0.1.4794-1",
        "==0.1.4916-1",
        "==0.1.5033-1",
        "==0.1.5037-1",
        "==0.1.5054-1",
        "==0.1.5068-1",
        "==0.1.5092-1",
        "==0.1.5098-2",
        "==0.1.5105-1",
        "==0.1.5137-1",
        "==0.1.5137-2",
        "==0.1.5137-3",
        "==0.1.5137-4",
        "==0.1.5137-5",
        "==0.1.5192-1"
      ]
    },
    {
      "id": "pyup.io-cumin:CVE-2012-2684",
      "advisory": "Multiple SQL injection vulnerabilities in the get_sample_filters_by_signature function in Cumin before 0.1.5444, as used in Red Hat Enterprise Messaging, Realtime, and Grid (MRG) 2.0, allow remote attackers to execute arbitrary SQL commands via the (1) agent or (2) object id.",
      "cve": "CVE-2012-2684",
      "specs": [
        "<=0.1.5192-4",
        "==0.1.3160-1",
        "==0.1.4369-1",
        "==0.1.4410-2",
        "==0.1.4494-1",
        "==0.1.4794-1",
        "==0.1.4916-1",
        "==0.1.5033-1",
        "==0.1.5037-1",
        "==0.1.5054-1",
        "==0.1.5068-1",
        "==0.1.5092-1",
        "==0.1.5098-2",
        "==0.1.5105-1",
        "==0.1.5137-1",
        "==0.1.5137-2",
        "==0.1.5137-3",
        "==0.1.5137-4",
        "==0.1.5137-5",
        "==0.1.5192-1"
      ]
    },
    {
      "id": "pyup.io-cumin:CVE-2012-2685",
      "advisory": "Cumin before 0.1.5444, as used in Red Hat Enterprise Messaging, Realtime, and Grid (MRG) 2.0, allows remote authenticated users to cause a denial of service (memory consumption) via a large size in an image request.",
      "cve": "CVE-2012-2685",
      "specs": [
        "<=0.1.5192-4",
        "==0.1.3160-1",
        "==0.1.4369-1",
        "==0.1.4410-2",
        "==0.1.4494-1",
        "==0.1.4794-1",
        "==0.1.4916-1",
        "==0.1.5033-1",
        "==0.1.5037-1",
        "==0.1.5054-1",
        "==0.1.5068-1",
        "==0.1.5092-1",
        "==0.1.5098-2",
        "==0.1.5105-1",
        "==0.1.5137-1",
        "==0.1.5137-2",
        "==0.1.5137-3",
        "==0.1.5137-4",
        "==0.1.5137-5",
        "==0.1.5192-1"
      ]
    },
    {
      "id": "pyup.io-cumin:CVE-2012-2734",
      "advisory": "Multiple cross-site request forgery (CSRF) vulnerabilities in Cumin before 0.1.5444, as used in Red Hat Enterprise Messaging, Realtime, and Grid (MRG) 2.0, allow remote attackers to hijack the authentication of arbitrary users for requests that execute commands via unspecified vectors.",
      "cve": "CVE-2012-2734",
      "specs": [
        "<=0.1.5192-4",
        "==0.1.3160-1",
        "==0.1.4369-1",
        "==0.1.4410-2",
        "==0.1.4494-1",
        "==0.1.4794-1",
        "==0.1.4916-1",
        "==0.1.5033-1",
        "==0.1.5037-1",
        "==0.1.5054-1",
        "==0.1.5068-1",
        "==0.1.5092-1",
        "==0.1.5098-2",
        "==0.1.5105-1",
        "==0.1.5137-1",
        "==0.1.5137-2",
        "==0.1.5137-3",
        "==0.1.5137-4",
        "==0.1.5137-5",
        "==0.1.5192-1"
      ]
    },
    {
      "id": "pyup.io-cumin:CVE-2012-2735",
      "advisory": "Session fixation vulnerability in Cumin before 0.1.5444, as used in Red Hat Enterprise Messaging, Realtime, and Grid (MRG) 2.0, allows remote attackers to hijack web sessions via a crafted session cookie.",
      "cve": "CVE-2012-2735",
      "specs": [
        "<=0.1.5192-4",
        "==0.1.3160-1",
        "==0.1.4369-1",
        "==0.1.4410-2",
        "==0.1.4494-1",
        "==0.1.4794-1",
        "==0.1.4916-1",
        "==0.1.5033-1",
        "==0.1.5037-1",
        "==0.1.5054-1",
        "==0.1.5068-1",
        "==0.1.5092-1",
        "==0.1.5098-2",
        "==0.1.5105-1",
        "==0.1.5137-1",
        "==0.1.5137-2",
        "==0.1.5137-3",
        "==0.1.5137-4",
        "==0.1.5137-5",
        "==0.1.5192-1"
      ]
    },
    {
      "id": "pyup.io-cumin:CVE-2012-3459",
      "advisory": "Cumin before 0.1.5444, as used in Red Hat Enterprise Messaging, Realtime, and Grid (MRG) 2.0, allows remote authenticated users to modify Condor attributes and possibly gain privileges via crafted additional parameters in an HTTP POST request, which triggers a job attribute change request to Condor.",
      "cve": "CVE-2012-3459",
      "specs": [
        "<=0.1.5192-4",
        "==0.1.3160-1",
        "==0.1.4369-1",
        "==0.1.4410-2",
        "==0.1.4494-1",
        "==0.1.4794-1",
        "==0.1.4916-1",
        "==0.1.5033-1",
        "==0.1.5037-1",
        "==0.1.5054-1",
        "==0.1.5068-1",
        "==0.1.5092-1",
        "==0.1.5098-2",
        "==0.1.5105-1",
        "==0.1.5137-1",
        "==0.1.5137-2",
        "==0.1.5137-3",
        "==0.1.5137-4",
        "==0.1.5137-5",
        "==0.1.5192-1"
      ]
    }
  ],
  "dask": [
    {
      "id": "pyup.io-dask:CVE-2021-42343",
      "advisory": "An issue was discovered in Dask (aka python-dask) through 2021.09.1. Single machine Dask clusters started with dask.distributed.LocalCluster or dask.distributed.Client (which defaults to using LocalCluster) would mistakenly configure their respective Dask workers to listen on external interfaces (typically with a randomly selected high port) rather than only on localhost. A Dask cluster created using this method (when running on a machine that has an applicable port exposed) could be used by a sophisticated attacker to achieve remote code execution.",
      "cve": "CVE-2021-42343",
      "specs": [
        "<=2021.09.1"
      ]
    }
  ],
  "datasette": [
    {
      "id": "pyup.io-datasette:CVE-2021-32670",
      "advisory": "Datasette is an open source multi-tool for exploring and publishing data. The `?_trace=1` debugging feature in Datasette does not correctly escape generated HTML, resulting in a [reflected cross-site scripting](https://owasp.org/www-community/attacks/xss/#reflected-xss-attacks) vulnerability. This vulnerability is particularly relevant if your Datasette installation includes authenticated features using plugins such as [datasette-auth-passwords](https://datasette.io/plugins/datasette-auth-passwords) as an attacker could use the vulnerability to access protected data. Datasette 0.57 and 0.56.1 both include patches for this issue. If you run Datasette behind a proxy you can workaround this issue by rejecting any incoming requests with `?_trace=` or `&_trace=` in their query string parameters.",
      "cve": "CVE-2021-32670",
      "specs": [
        "<0.56.1"
      ]
    }
  ],
  "diffoscope": [
    {
      "id": "pyup.io-diffoscope:CVE-2017-0359",
      "advisory": "diffoscope before 77 writes to arbitrary locations on disk based on the contents of an untrusted archive.",
      "cve": "CVE-2017-0359",
      "specs": [
        "<77"
      ]
    }
  ],
  "django": [
    {
      "id": "pyup.io-django:CVE-2007-0404",
      "advisory": "bin/compile-messages.py in Django 0.95 does not quote argument strings before invoking the msgfmt program through the os.system function, which allows attackers to execute arbitrary commands via shell metacharacters in a (1) .po or (2) .mo file.",
      "cve": "CVE-2007-0404",
      "specs": [
        "==0.95"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2007-0405",
      "advisory": "The LazyUser class in the AuthenticationMiddleware for Django 0.95 does not properly cache the user name across requests, which allows remote authenticated users to gain the privileges of a different user.",
      "cve": "CVE-2007-0405",
      "specs": [
        "==0.95"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2007-5712",
      "advisory": "The internationalization (i18n) framework in Django 0.91, 0.95, 0.95.1, and 0.96, and as used in other products such as PyLucid, when the USE_I18N option and the i18n component are enabled, allows remote attackers to cause a denial of service (memory consumption) via many HTTP requests with large Accept-Language headers.",
      "cve": "CVE-2007-5712",
      "specs": [
        "==0.91",
        "==0.95",
        "==0.95.1",
        "==0.96"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2007-5828",
      "advisory": "** DISPUTED **  Cross-site request forgery (CSRF) vulnerability in the admin panel in Django 0.96 allows remote attackers to change passwords of arbitrary users via a request to admin/auth/user/1/password/.  NOTE: this issue has been disputed by Debian, since product documentation includes a recommendation for a CSRF protection module that is included with the product.  However, CVE considers this an issue because the default configuration does not use this module.",
      "cve": "CVE-2007-5828",
      "specs": [
        "==0.96"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2008-2302",
      "advisory": "Cross-site scripting (XSS) vulnerability in the login form in the administration application in Django 0.91 before 0.91.2, 0.95 before 0.95.3, and 0.96 before 0.96.2 allows remote attackers to inject arbitrary web script or HTML via the URI of a certain previous request.",
      "cve": "CVE-2008-2302",
      "specs": [
        "==0.91",
        "==0.95",
        "==0.96"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2008-3909",
      "advisory": "The administration application in Django 0.91, 0.95, and 0.96 stores unauthenticated HTTP POST requests and processes them after successful authentication occurs, which allows remote attackers to conduct cross-site request forgery (CSRF) attacks and delete or modify data via unspecified requests.",
      "cve": "CVE-2008-3909",
      "specs": [
        "==0.91",
        "==0.95",
        "==0.96"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2009-2659",
      "advisory": "The Admin media handler in core/servers/basehttp.py in Django 1.0 and 0.96 does not properly map URL requests to expected \"static media files,\" which allows remote attackers to conduct directory traversal attacks and read arbitrary files via a crafted URL.",
      "cve": "CVE-2009-2659",
      "specs": [
        "==0.96",
        "==1.0"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2009-3695",
      "advisory": "Algorithmic complexity vulnerability in the forms library in Django 1.0 before 1.0.4 and 1.1 before 1.1.1 allows remote attackers to cause a denial of service (CPU consumption) via a crafted (1) EmailField (email address) or (2) URLField (URL) that triggers a large amount of backtracking in a regular expression.",
      "cve": "CVE-2009-3695",
      "specs": [
        "==1.0",
        "==1.1"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2010-3082",
      "advisory": "Cross-site scripting (XSS) vulnerability in Django 1.2.x before 1.2.2 allows remote attackers to inject arbitrary web script or HTML via a csrfmiddlewaretoken (aka csrf_token) cookie.",
      "cve": "CVE-2010-3082",
      "specs": [
        "==1.2.1",
        "==1.2.1-2",
        "==1.2.2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2010-4534",
      "advisory": "The administrative interface in django.contrib.admin in Django before 1.1.3, 1.2.x before 1.2.4, and 1.3.x before 1.3 beta 1 does not properly restrict use of the query string to perform certain object filtering, which allows remote authenticated users to obtain sensitive information via a series of requests containing regular expressions, as demonstrated by a created_by__password__regex parameter.",
      "cve": "CVE-2010-4534",
      "specs": [
        "<=1.1.2",
        "==0.91",
        "==0.95",
        "==0.95.1",
        "==0.96",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.1",
        "==1.1.0",
        "==1.2",
        "==1.2.1",
        "==1.2.2",
        "==1.2.3",
        "==1.3-alpha1",
        "==1.3-alpha2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2010-4535",
      "advisory": "The password reset functionality in django.contrib.auth in Django before 1.1.3, 1.2.x before 1.2.4, and 1.3.x before 1.3 beta 1 does not validate the length of a string representing a base36 timestamp, which allows remote attackers to cause a denial of service (resource consumption) via a URL that specifies a large base36 integer.",
      "cve": "CVE-2010-4535",
      "specs": [
        "<=1.1.2",
        "==0.91",
        "==0.95",
        "==0.95.1",
        "==0.96",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.1",
        "==1.1.0",
        "==1.2",
        "==1.2.1",
        "==1.2.2",
        "==1.2.3",
        "==1.3-alpha1",
        "==1.3-alpha2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2011-0696",
      "advisory": "Django 1.1.x before 1.1.4 and 1.2.x before 1.2.5 does not properly validate HTTP requests that contain an X-Requested-With header, which makes it easier for remote attackers to conduct cross-site request forgery (CSRF) attacks via forged AJAX requests that leverage a \"combination of browser plugins and redirects,\" a related issue to CVE-2011-0447.",
      "cve": "CVE-2011-0696",
      "specs": [
        "==1.1",
        "==1.1.0",
        "==1.1.2",
        "==1.1.3",
        "==1.2",
        "==1.2.1",
        "==1.2.2",
        "==1.2.3",
        "==1.2.4"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2011-0697",
      "advisory": "Cross-site scripting (XSS) vulnerability in Django 1.1.x before 1.1.4 and 1.2.x before 1.2.5 might allow remote attackers to inject arbitrary web script or HTML via a filename associated with a file upload.",
      "cve": "CVE-2011-0697",
      "specs": [
        "==1.1",
        "==1.1.0",
        "==1.1.2",
        "==1.1.3",
        "==1.2",
        "==1.2.1",
        "==1.2.2",
        "==1.2.3",
        "==1.2.4"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2011-4136",
      "advisory": "django.contrib.sessions in Django before 1.2.7 and 1.3.x before 1.3.1, when session data is stored in the cache, uses the root namespace for both session identifiers and application-data keys, which allows remote attackers to modify a session by triggering use of a key that is equal to that session's identifier.",
      "cve": "CVE-2011-4136",
      "specs": [
        "<=1.2.6",
        "==0.91",
        "==0.95",
        "==0.95.1",
        "==0.96",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.1",
        "==1.1.0",
        "==1.1.2",
        "==1.1.3",
        "==1.2",
        "==1.2.1",
        "==1.2.1-2",
        "==1.2.2",
        "==1.2.3",
        "==1.2.4",
        "==1.2.5",
        "==1.3",
        "==1.3-alpha1",
        "==1.3-alpha2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2011-4137",
      "advisory": "The verify_exists functionality in the URLField implementation in Django before 1.2.7 and 1.3.x before 1.3.1 relies on Python libraries that attempt access to an arbitrary URL with no timeout, which allows remote attackers to cause a denial of service (resource consumption) via a URL associated with (1) a slow response, (2) a completed TCP connection with no application data sent, or (3) a large amount of application data, a related issue to CVE-2011-1521.",
      "cve": "CVE-2011-4137",
      "specs": [
        "<=1.2.6",
        "==0.91",
        "==0.95",
        "==0.95.1",
        "==0.96",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.1",
        "==1.1.0",
        "==1.1.2",
        "==1.1.3",
        "==1.2",
        "==1.2.1",
        "==1.2.1-2",
        "==1.2.2",
        "==1.2.3",
        "==1.2.4",
        "==1.2.5",
        "==1.3",
        "==1.3-alpha1",
        "==1.3-alpha2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2011-4138",
      "advisory": "The verify_exists functionality in the URLField implementation in Django before 1.2.7 and 1.3.x before 1.3.1 originally tests a URL's validity through a HEAD request, but then uses a GET request for the new target URL in the case of a redirect, which might allow remote attackers to trigger arbitrary GET requests with an unintended source IP address via a crafted Location header.",
      "cve": "CVE-2011-4138",
      "specs": [
        "<=1.2.6",
        "==0.91",
        "==0.95",
        "==0.95.1",
        "==0.96",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.1",
        "==1.1.0",
        "==1.1.2",
        "==1.1.3",
        "==1.2",
        "==1.2.1",
        "==1.2.1-2",
        "==1.2.2",
        "==1.2.3",
        "==1.2.4",
        "==1.2.5",
        "==1.3",
        "==1.3-alpha1",
        "==1.3-alpha2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2011-4139",
      "advisory": "Django before 1.2.7 and 1.3.x before 1.3.1 uses a request's HTTP Host header to construct a full URL in certain circumstances, which allows remote attackers to conduct cache poisoning attacks via a crafted request.",
      "cve": "CVE-2011-4139",
      "specs": [
        "<=1.2.6",
        "==0.91",
        "==0.95",
        "==0.95.1",
        "==0.96",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.1",
        "==1.1.0",
        "==1.1.2",
        "==1.1.3",
        "==1.2",
        "==1.2.1",
        "==1.2.1-2",
        "==1.2.2",
        "==1.2.3",
        "==1.2.4",
        "==1.2.5",
        "==1.3",
        "==1.3-alpha1",
        "==1.3-alpha2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2011-4140",
      "advisory": "The CSRF protection mechanism in Django through 1.2.7 and 1.3.x through 1.3.1 does not properly handle web-server configurations supporting arbitrary HTTP Host headers, which allows remote attackers to trigger unauthenticated forged requests via vectors involving a DNS CNAME record and a web page containing JavaScript code.",
      "cve": "CVE-2011-4140",
      "specs": [
        "<=1.2.6",
        "==0.91",
        "==0.95",
        "==0.95.1",
        "==0.96",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.1",
        "==1.1.0",
        "==1.1.2",
        "==1.1.3",
        "==1.2",
        "==1.2.1",
        "==1.2.1-2",
        "==1.2.2",
        "==1.2.3",
        "==1.2.4",
        "==1.2.5",
        "==1.3",
        "==1.3-alpha1",
        "==1.3-alpha2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2012-3442",
      "advisory": "The (1) django.http.HttpResponseRedirect and (2) django.http.HttpResponsePermanentRedirect classes in Django before 1.3.2 and 1.4.x before 1.4.1 do not validate the scheme of a redirect target, which might allow remote attackers to conduct cross-site scripting (XSS) attacks via a data: URL.",
      "cve": "CVE-2012-3442",
      "specs": [
        "<=1.3",
        "==0.95",
        "==0.96",
        "==1.0",
        "==1.0-alpha1",
        "==1.0-alpha2",
        "==1.0-beta",
        "==1.0-beta2",
        "==1.0.1",
        "==1.0.2",
        "==1.1",
        "==1.1-alpha1",
        "==1.1-beta1",
        "==1.1-rc1",
        "==1.1.2",
        "==1.1.3",
        "==1.1.4",
        "==1.2",
        "==1.2-alpha1",
        "==1.2-beta1",
        "==1.2-rc1",
        "==1.2.2",
        "==1.2.4",
        "==1.2.5",
        "==1.2.6",
        "==1.2.7",
        "==1.3-alpha1",
        "==1.3-beta1",
        "==1.4"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2012-3443",
      "advisory": "The django.forms.ImageField class in the form system in Django before 1.3.2 and 1.4.x before 1.4.1 completely decompresses image data during image validation, which allows remote attackers to cause a denial of service (memory consumption) by uploading an image file.",
      "cve": "CVE-2012-3443",
      "specs": [
        "<=1.3",
        "==0.95",
        "==0.96",
        "==1.0",
        "==1.0-alpha1",
        "==1.0-alpha2",
        "==1.0-beta",
        "==1.0-beta2",
        "==1.0.1",
        "==1.0.2",
        "==1.1",
        "==1.1-alpha1",
        "==1.1-beta1",
        "==1.1-rc1",
        "==1.1.2",
        "==1.1.3",
        "==1.1.4",
        "==1.2",
        "==1.2-alpha1",
        "==1.2-beta1",
        "==1.2-rc1",
        "==1.2.2",
        "==1.2.4",
        "==1.2.5",
        "==1.2.6",
        "==1.2.7",
        "==1.3-alpha1",
        "==1.3-beta1",
        "==1.4"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2012-3444",
      "advisory": "The get_image_dimensions function in the image-handling functionality in Django before 1.3.2 and 1.4.x before 1.4.1 uses a constant chunk size in all attempts to determine dimensions, which allows remote attackers to cause a denial of service (process or thread consumption) via a large TIFF image.",
      "cve": "CVE-2012-3444",
      "specs": [
        "<=1.3",
        "==0.95",
        "==0.96",
        "==1.0",
        "==1.0-alpha1",
        "==1.0-alpha2",
        "==1.0-beta",
        "==1.0-beta2",
        "==1.0.1",
        "==1.0.2",
        "==1.1",
        "==1.1-alpha1",
        "==1.1-beta1",
        "==1.1-rc1",
        "==1.1.2",
        "==1.1.3",
        "==1.1.4",
        "==1.2",
        "==1.2-alpha1",
        "==1.2-beta1",
        "==1.2-rc1",
        "==1.2.2",
        "==1.2.4",
        "==1.2.5",
        "==1.2.6",
        "==1.2.7",
        "==1.3-alpha1",
        "==1.3-beta1",
        "==1.4"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2012-4520",
      "advisory": "The django.http.HttpRequest.get_host function in Django 1.3.x before 1.3.4 and 1.4.x before 1.4.2 allows remote attackers to generate and display arbitrary URLs via crafted username and password Host header values.",
      "cve": "CVE-2012-4520",
      "specs": [
        "==1.3",
        "==1.3-alpha1",
        "==1.3-beta1",
        "==1.3.1",
        "==1.3.2",
        "==1.3.3",
        "==1.4",
        "==1.4.1"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2013-0305",
      "advisory": "The administrative interface for Django 1.3.x before 1.3.6, 1.4.x before 1.4.4, and 1.5 before release candidate 2 does not check permissions for the history view, which allows remote authenticated administrators to obtain sensitive object history information.",
      "cve": "CVE-2013-0305",
      "specs": [
        "==1.3",
        "==1.3-alpha1",
        "==1.3-beta1",
        "==1.3.1",
        "==1.3.2",
        "==1.3.3",
        "==1.4",
        "==1.4-alpha",
        "==1.4-beta",
        "==1.4.1",
        "==1.4.2",
        "==1.5-alpha",
        "==1.5-beta"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2013-0306",
      "advisory": "The form library in Django 1.3.x before 1.3.6, 1.4.x before 1.4.4, and 1.5 before release candidate 2 allows remote attackers to bypass intended resource limits for formsets and cause a denial of service (memory consumption) or trigger server errors via a modified max_num parameter.",
      "cve": "CVE-2013-0306",
      "specs": [
        "==1.3",
        "==1.3-alpha1",
        "==1.3-beta1",
        "==1.3.1",
        "==1.3.2",
        "==1.3.3",
        "==1.4",
        "==1.4-alpha",
        "==1.4-beta",
        "==1.4.1",
        "==1.4.2",
        "==1.5-alpha",
        "==1.5-beta"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2013-1443",
      "advisory": "The authentication framework (django.contrib.auth) in Django 1.4.x before 1.4.8, 1.5.x before 1.5.4, and 1.6.x before 1.6 beta 4 allows remote attackers to cause a denial of service (CPU consumption) via a long password which is then hashed.",
      "cve": "CVE-2013-1443",
      "specs": [
        "==1.4",
        "==1.4.1",
        "==1.4.2",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.4.7",
        "==1.5",
        "==1.5-alpha",
        "==1.5-beta",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.6-beta1",
        "==1.6-beta2",
        "==1.6-beta3"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2013-4249",
      "advisory": "Cross-site scripting (XSS) vulnerability in the AdminURLFieldWidget widget in contrib/admin/widgets.py in Django 1.5.x before 1.5.2 and 1.6.x before 1.6 beta 2 allows remote attackers to inject arbitrary web script or HTML via a URLField.",
      "cve": "CVE-2013-4249",
      "specs": [
        "==1.5",
        "==1.5-alpha",
        "==1.5-beta",
        "==1.5.1",
        "==1.6-beta1"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2013-4315",
      "advisory": "Directory traversal vulnerability in Django 1.4.x before 1.4.7, 1.5.x before 1.5.3, and 1.6.x before 1.6 beta 3 allows remote attackers to read arbitrary files via a file path in the ALLOWED_INCLUDE_ROOTS setting followed by a .. (dot dot) in a ssi template tag.",
      "cve": "CVE-2013-4315",
      "specs": [
        "==1.4",
        "==1.4.1",
        "==1.4.2",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.5",
        "==1.5-alpha",
        "==1.5-beta",
        "==1.5.1",
        "==1.6-beta1",
        "==1.6-beta2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2013-6044",
      "advisory": "The is_safe_url function in utils/http.py in Django 1.4.x before 1.4.6, 1.5.x before 1.5.2, and 1.6 before beta 2 treats a URL's scheme as safe even if it is not HTTP or HTTPS, which might introduce cross-site scripting (XSS) or other vulnerabilities into Django applications that use this function, as demonstrated by \"the login view in django.contrib.auth.views\" and the javascript: scheme.",
      "cve": "CVE-2013-6044",
      "specs": [
        "==1.4",
        "==1.4.1",
        "==1.4.2",
        "==1.4.4",
        "==1.4.5",
        "==1.5",
        "==1.5.1",
        "==1.6-beta1"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2014-0472",
      "advisory": "The django.core.urlresolvers.reverse function in Django before 1.4.11, 1.5.x before 1.5.6, 1.6.x before 1.6.3, and 1.7.x before 1.7 beta 2 allows remote attackers to import and execute arbitrary Python modules by leveraging a view that constructs URLs using user input and a \"dotted Python path.\"",
      "cve": "CVE-2014-0472",
      "specs": [
        "<=1.4.10",
        "==1.4",
        "==1.4.1",
        "==1.4.2",
        "==1.4.3",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8",
        "==1.4.9",
        "==1.5",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.4",
        "==1.5.5",
        "==1.6",
        "==1.6.1",
        "==1.6.2",
        "==1.7-alpha1",
        "==1.7-alpha2",
        "==1.7-beta1"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2014-0473",
      "advisory": "The caching framework in Django before 1.4.11, 1.5.x before 1.5.6, 1.6.x before 1.6.3, and 1.7.x before 1.7 beta 2 reuses a cached CSRF token for all anonymous users, which allows remote attackers to bypass CSRF protections by reading the CSRF cookie for anonymous users.",
      "cve": "CVE-2014-0473",
      "specs": [
        "<=1.4.10",
        "==1.4",
        "==1.4.1",
        "==1.4.2",
        "==1.4.3",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8",
        "==1.4.9",
        "==1.5",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.4",
        "==1.5.5",
        "==1.6",
        "==1.6.1",
        "==1.6.2",
        "==1.7-alpha1",
        "==1.7-alpha2",
        "==1.7-beta1"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2014-0474",
      "advisory": "The (1) FilePathField, (2) GenericIPAddressField, and (3) IPAddressField model field classes in Django before 1.4.11, 1.5.x before 1.5.6, 1.6.x before 1.6.3, and 1.7.x before 1.7 beta 2 do not properly perform type conversion, which allows remote attackers to have unspecified impact and vectors, related to \"MySQL typecasting.\"",
      "cve": "CVE-2014-0474",
      "specs": [
        "<=1.4.10",
        "==1.4",
        "==1.4.1",
        "==1.4.2",
        "==1.4.3",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8",
        "==1.4.9",
        "==1.5",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.4",
        "==1.5.5",
        "==1.6",
        "==1.6.1",
        "==1.6.2",
        "==1.7-alpha1",
        "==1.7-alpha2",
        "==1.7-beta1"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2014-0480",
      "advisory": "The core.urlresolvers.reverse function in Django before 1.4.14, 1.5.x before 1.5.9, 1.6.x before 1.6.6, and 1.7 before release candidate 3 does not properly validate URLs, which allows remote attackers to conduct phishing attacks via a // (slash slash) in a URL, which triggers a scheme-relative URL to be generated.",
      "cve": "CVE-2014-0480",
      "specs": [
        "<=1.4.13",
        "==1.4",
        "==1.4.1",
        "==1.4.10",
        "==1.4.11",
        "==1.4.12",
        "==1.4.2",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8",
        "==1.4.9",
        "==1.5",
        "==1.5-alpha",
        "==1.5-beta",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.4",
        "==1.5.5",
        "==1.5.6",
        "==1.5.7",
        "==1.5.8",
        "==1.6",
        "==1.6-beta1",
        "==1.6-beta2",
        "==1.6-beta3",
        "==1.6-beta4",
        "==1.6.1",
        "==1.6.2",
        "==1.6.3",
        "==1.6.4",
        "==1.6.5",
        "==1.7-beta1",
        "==1.7-beta2",
        "==1.7-beta3",
        "==1.7-beta4",
        "==1.7-rc1",
        "==1.7-rc2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2014-0481",
      "advisory": "The default configuration for the file upload handling system in Django before 1.4.14, 1.5.x before 1.5.9, 1.6.x before 1.6.6, and 1.7 before release candidate 3 uses a sequential file name generation process when a file with a conflicting name is uploaded, which allows remote attackers to cause a denial of service (CPU consumption) by unloading a multiple files with the same name.",
      "cve": "CVE-2014-0481",
      "specs": [
        "<=1.4.13",
        "==1.4",
        "==1.4.1",
        "==1.4.10",
        "==1.4.11",
        "==1.4.12",
        "==1.4.2",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8",
        "==1.4.9",
        "==1.5",
        "==1.5-alpha",
        "==1.5-beta",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.4",
        "==1.5.5",
        "==1.5.6",
        "==1.5.7",
        "==1.5.8",
        "==1.6",
        "==1.6-beta1",
        "==1.6-beta2",
        "==1.6-beta3",
        "==1.6-beta4",
        "==1.6.1",
        "==1.6.2",
        "==1.6.3",
        "==1.6.4",
        "==1.6.5",
        "==1.7-beta1",
        "==1.7-beta2",
        "==1.7-beta3",
        "==1.7-beta4",
        "==1.7-rc1",
        "==1.7-rc2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2014-0482",
      "advisory": "The contrib.auth.middleware.RemoteUserMiddleware middleware in Django before 1.4.14, 1.5.x before 1.5.9, 1.6.x before 1.6.6, and 1.7 before release candidate 3, when using the contrib.auth.backends.RemoteUserBackend backend, allows remote authenticated users to hijack web sessions via vectors related to the REMOTE_USER header.",
      "cve": "CVE-2014-0482",
      "specs": [
        "<=1.4.13",
        "==1.4",
        "==1.4.1",
        "==1.4.10",
        "==1.4.11",
        "==1.4.12",
        "==1.4.2",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8",
        "==1.4.9",
        "==1.5",
        "==1.5-alpha",
        "==1.5-beta",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.4",
        "==1.5.5",
        "==1.5.6",
        "==1.5.7",
        "==1.5.8",
        "==1.6",
        "==1.6-beta1",
        "==1.6-beta2",
        "==1.6-beta3",
        "==1.6-beta4",
        "==1.6.1",
        "==1.6.2",
        "==1.6.3",
        "==1.6.4",
        "==1.6.5",
        "==1.7-beta1",
        "==1.7-beta2",
        "==1.7-beta3",
        "==1.7-beta4",
        "==1.7-rc1",
        "==1.7-rc2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2014-0483",
      "advisory": "The administrative interface (contrib.admin) in Django before 1.4.14, 1.5.x before 1.5.9, 1.6.x before 1.6.6, and 1.7 before release candidate 3 does not check if a field represents a relationship between models, which allows remote authenticated users to obtain sensitive information via a to_field parameter in a popup action to an admin change form page, as demonstrated by a /admin/auth/user/?pop=1&t=password URI.",
      "cve": "CVE-2014-0483",
      "specs": [
        "<=1.4.13",
        "==1.4",
        "==1.4.1",
        "==1.4.10",
        "==1.4.11",
        "==1.4.12",
        "==1.4.2",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8",
        "==1.4.9",
        "==1.5",
        "==1.5-alpha",
        "==1.5-beta",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.4",
        "==1.5.5",
        "==1.5.6",
        "==1.5.7",
        "==1.5.8",
        "==1.6",
        "==1.6-beta1",
        "==1.6-beta2",
        "==1.6-beta3",
        "==1.6-beta4",
        "==1.6.1",
        "==1.6.2",
        "==1.6.3",
        "==1.6.4",
        "==1.6.5",
        "==1.7-beta1",
        "==1.7-beta2",
        "==1.7-beta3",
        "==1.7-beta4",
        "==1.7-rc1",
        "==1.7-rc2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2014-1418",
      "advisory": "Django 1.4 before 1.4.13, 1.5 before 1.5.8, 1.6 before 1.6.5, and 1.7 before 1.7b4 does not properly include the (1) Vary: Cookie or (2) Cache-Control header in responses, which allows remote attackers to obtain sensitive information or poison the cache via a request from certain browsers.",
      "cve": "CVE-2014-1418",
      "specs": [
        "==1.4",
        "==1.4.1",
        "==1.4.10",
        "==1.4.11",
        "==1.4.12",
        "==1.4.2",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8",
        "==1.4.9",
        "==1.5",
        "==1.5-alpha",
        "==1.5-beta",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.4",
        "==1.5.5",
        "==1.5.6",
        "==1.5.7",
        "==1.6",
        "==1.6-beta1",
        "==1.6-beta2",
        "==1.6-beta3",
        "==1.6-beta4",
        "==1.6.1",
        "==1.6.2",
        "==1.6.3",
        "==1.6.4",
        "==1.7-beta1",
        "==1.7-beta2",
        "==1.7-beta3"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2014-3730",
      "advisory": "The django.util.http.is_safe_url function in Django 1.4 before 1.4.13, 1.5 before 1.5.8, 1.6 before 1.6.5, and 1.7 before 1.7b4 does not properly validate URLs, which allows remote attackers to conduct open redirect attacks via a malformed URL, as demonstrated by \"http:\\\\\\djangoproject.com.\"",
      "cve": "CVE-2014-3730",
      "specs": [
        "==1.4",
        "==1.4.1",
        "==1.4.10",
        "==1.4.11",
        "==1.4.12",
        "==1.4.2",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8",
        "==1.4.9",
        "==1.5",
        "==1.5-alpha",
        "==1.5-beta",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.4",
        "==1.5.5",
        "==1.5.6",
        "==1.5.7",
        "==1.6",
        "==1.6-beta1",
        "==1.6-beta2",
        "==1.6-beta3",
        "==1.6-beta4",
        "==1.6.1",
        "==1.6.2",
        "==1.6.3",
        "==1.6.4",
        "==1.7-beta1",
        "==1.7-beta2",
        "==1.7-beta3"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2015-0219",
      "advisory": "Django before 1.4.18, 1.6.x before 1.6.10, and 1.7.x before 1.7.3 allows remote attackers to spoof WSGI headers by using an _ (underscore) character instead of a - (dash) character in an HTTP header, as demonstrated by an X-Auth_User header.",
      "cve": "CVE-2015-0219",
      "specs": [
        "<=1.4.17",
        "==1.6",
        "==1.6.1",
        "==1.6.2",
        "==1.6.3",
        "==1.6.4",
        "==1.6.5",
        "==1.6.6",
        "==1.6.7",
        "==1.6.8",
        "==1.6.9",
        "==1.7",
        "==1.7.1",
        "==1.7.2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2015-0220",
      "advisory": "The django.util.http.is_safe_url function in Django before 1.4.18, 1.6.x before 1.6.10, and 1.7.x before 1.7.3 does not properly handle leading whitespaces, which allows remote attackers to conduct cross-site scripting (XSS) attacks via a crafted URL, related to redirect URLs, as demonstrated by a \"\\njavascript:\" URL.",
      "cve": "CVE-2015-0220",
      "specs": [
        "<=1.4.17",
        "==1.6",
        "==1.6.1",
        "==1.6.2",
        "==1.6.3",
        "==1.6.4",
        "==1.6.5",
        "==1.6.6",
        "==1.6.7",
        "==1.6.8",
        "==1.6.9",
        "==1.7",
        "==1.7.1",
        "==1.7.2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2015-0221",
      "advisory": "The django.views.static.serve view in Django before 1.4.18, 1.6.x before 1.6.10, and 1.7.x before 1.7.3 reads files an entire line at a time, which allows remote attackers to cause a denial of service (memory consumption) via a long line in a file.",
      "cve": "CVE-2015-0221",
      "specs": [
        "<=1.4.17",
        "==1.6",
        "==1.6.1",
        "==1.6.2",
        "==1.6.3",
        "==1.6.4",
        "==1.6.5",
        "==1.6.6",
        "==1.6.7",
        "==1.6.8",
        "==1.6.9",
        "==1.7",
        "==1.7.1",
        "==1.7.2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2015-0222",
      "advisory": "ModelMultipleChoiceField in Django 1.6.x before 1.6.10 and 1.7.x before 1.7.3, when show_hidden_initial is set to True, allows remote attackers to cause a denial of service by submitting duplicate values, which triggers a large number of SQL queries.",
      "cve": "CVE-2015-0222",
      "specs": [
        "<=1.4.17",
        "==1.6",
        "==1.6.1",
        "==1.6.2",
        "==1.6.3",
        "==1.6.4",
        "==1.6.5",
        "==1.6.6",
        "==1.6.7",
        "==1.6.8",
        "==1.6.9",
        "==1.7",
        "==1.7.1",
        "==1.7.2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2015-2241",
      "advisory": "Cross-site scripting (XSS) vulnerability in the contents function in admin/helpers.py in Django before 1.7.6 and 1.8 before 1.8b2 allows remote attackers to inject arbitrary web script or HTML via a model attribute in ModelAdmin.readonly_fields, as demonstrated by a @property.",
      "cve": "CVE-2015-2241",
      "specs": [
        "<=1.7.5",
        "==1.8-beta1"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2015-2316",
      "advisory": "The utils.html.strip_tags function in Django 1.6.x before 1.6.11, 1.7.x before 1.7.7, and 1.8.x before 1.8c1, when using certain versions of Python, allows remote attackers to cause a denial of service (infinite loop) by increasing the length of the input string.",
      "cve": "CVE-2015-2316",
      "specs": [
        "==1.6",
        "==1.6-beta1",
        "==1.6-beta2",
        "==1.6-beta3",
        "==1.6-beta4",
        "==1.6.1",
        "==1.6.10",
        "==1.6.2",
        "==1.6.3",
        "==1.6.4",
        "==1.6.5",
        "==1.6.6",
        "==1.6.7",
        "==1.6.8",
        "==1.6.9",
        "==1.7-beta1",
        "==1.7-beta2",
        "==1.7-beta3",
        "==1.7-beta4",
        "==1.7-rc1",
        "==1.7-rc2",
        "==1.7-rc3",
        "==1.7.1",
        "==1.7.2",
        "==1.7.3",
        "==1.7.4",
        "==1.7.5",
        "==1.7.6",
        "==1.8.0"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2015-2317",
      "advisory": "The utils.http.is_safe_url function in Django before 1.4.20, 1.5.x, 1.6.x before 1.6.11, 1.7.x before 1.7.7, and 1.8.x before 1.8c1 does not properly validate URLs, which allows remote attackers to conduct cross-site scripting (XSS) attacks via a control character in a URL, as demonstrated by a \\x08javascript: URL.",
      "cve": "CVE-2015-2317",
      "specs": [
        "<=1.4.19",
        "==1.5",
        "==1.5-alpha",
        "==1.5-beta",
        "==1.5.1",
        "==1.5.10",
        "==1.5.11",
        "==1.5.12",
        "==1.5.2",
        "==1.5.3",
        "==1.5.4",
        "==1.5.5",
        "==1.5.6",
        "==1.5.7",
        "==1.5.8",
        "==1.5.9",
        "==1.6",
        "==1.6-beta1",
        "==1.6-beta2",
        "==1.6-beta3",
        "==1.6-beta4",
        "==1.6.1",
        "==1.6.10",
        "==1.6.2",
        "==1.6.3",
        "==1.6.4",
        "==1.6.5",
        "==1.6.6",
        "==1.6.7",
        "==1.6.8",
        "==1.6.9",
        "==1.7-beta1",
        "==1.7-beta2",
        "==1.7-beta3",
        "==1.7-beta4",
        "==1.7-rc1",
        "==1.7-rc2",
        "==1.7-rc3",
        "==1.7.1",
        "==1.7.2",
        "==1.7.3",
        "==1.7.4",
        "==1.7.5",
        "==1.7.6",
        "==1.8.0"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2015-3982",
      "advisory": "The session.flush function in the cached_db backend in Django 1.8.x before 1.8.2 does not properly flush the session, which allows remote attackers to hijack user sessions via an empty string in the session key.",
      "cve": "CVE-2015-3982",
      "specs": [
        "==1.8.0",
        "==1.8.1"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2015-5143",
      "advisory": "The session backends in Django before 1.4.21, 1.5.x through 1.6.x, 1.7.x before 1.7.9, and 1.8.x before 1.8.3 allows remote attackers to cause a denial of service (session store consumption) via multiple requests with unique session keys.",
      "cve": "CVE-2015-5143",
      "specs": [
        "==1.4.20",
        "==1.5",
        "==1.5-alpha",
        "==1.5-beta",
        "==1.5.1",
        "==1.5.10",
        "==1.5.11",
        "==1.5.12",
        "==1.5.2",
        "==1.5.3",
        "==1.5.4",
        "==1.5.5",
        "==1.5.6",
        "==1.5.7",
        "==1.5.8",
        "==1.5.9",
        "==1.6",
        "==1.6-beta1",
        "==1.6-beta2",
        "==1.6-beta3",
        "==1.6-beta4",
        "==1.6.1",
        "==1.6.10",
        "==1.6.2",
        "==1.6.3",
        "==1.6.4",
        "==1.6.5",
        "==1.6.6",
        "==1.6.7",
        "==1.6.8",
        "==1.6.9",
        "==1.7-beta1",
        "==1.7-beta2",
        "==1.7-beta3",
        "==1.7-beta4",
        "==1.7-rc1",
        "==1.7-rc2",
        "==1.7-rc3",
        "==1.7.1",
        "==1.7.2",
        "==1.7.3",
        "==1.7.4",
        "==1.7.5",
        "==1.7.6",
        "==1.7.7",
        "==1.7.8",
        "==1.7.9",
        "==1.8.0",
        "==1.8.1",
        "==1.8.2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2015-5144",
      "advisory": "Django before 1.4.21, 1.5.x through 1.6.x, 1.7.x before 1.7.9, and 1.8.x before 1.8.3 uses an incorrect regular expression, which allows remote attackers to inject arbitrary headers and conduct HTTP response splitting attacks via a newline character in an (1) email message to the EmailValidator, a (2) URL to the URLValidator, or unspecified vectors to the (3) validate_ipv4_address or (4) validate_slug validator.",
      "cve": "CVE-2015-5144",
      "specs": [
        "<=1.4.20",
        "==1.5",
        "==1.5-alpha",
        "==1.5-beta",
        "==1.5.1",
        "==1.5.10",
        "==1.5.11",
        "==1.5.12",
        "==1.5.2",
        "==1.5.3",
        "==1.5.4",
        "==1.5.5",
        "==1.5.6",
        "==1.5.7",
        "==1.5.8",
        "==1.5.9",
        "==1.6",
        "==1.6-beta1",
        "==1.6-beta2",
        "==1.6-beta3",
        "==1.6-beta4",
        "==1.6.1",
        "==1.6.10",
        "==1.6.2",
        "==1.6.3",
        "==1.6.4",
        "==1.6.5",
        "==1.6.6",
        "==1.6.7",
        "==1.6.8",
        "==1.6.9",
        "==1.7-beta1",
        "==1.7-beta2",
        "==1.7-beta3",
        "==1.7-beta4",
        "==1.7-rc1",
        "==1.7-rc2",
        "==1.7-rc3",
        "==1.7.1",
        "==1.7.2",
        "==1.7.3",
        "==1.7.4",
        "==1.7.5",
        "==1.7.6",
        "==1.7.7",
        "==1.7.8",
        "==1.7.9",
        "==1.8-beta1",
        "==1.8.0",
        "==1.8.1",
        "==1.8.2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2015-5145",
      "advisory": "validators.URLValidator in Django 1.8.x before 1.8.3 allows remote attackers to cause a denial of service (CPU consumption) via unspecified vectors.",
      "cve": "CVE-2015-5145",
      "specs": [
        "==1.8.0",
        "==1.8.1",
        "==1.8.2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2015-5963",
      "advisory": "contrib.sessions.middleware.SessionMiddleware in Django 1.8.x before 1.8.4, 1.7.x before 1.7.10, 1.4.x before 1.4.22, and possibly other versions allows remote attackers to cause a denial of service (session store consumption or session record removal) via a large number of requests to contrib.auth.views.logout, which triggers the creation of an empty session record.",
      "cve": "CVE-2015-5963",
      "specs": [
        "==1.4",
        "==1.4.1",
        "==1.4.10",
        "==1.4.11",
        "==1.4.12",
        "==1.4.13",
        "==1.4.14",
        "==1.4.17",
        "==1.4.19",
        "==1.4.2",
        "==1.4.20",
        "==1.4.21",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8",
        "==1.4.9",
        "==1.7-beta1",
        "==1.7-beta2",
        "==1.7-beta3",
        "==1.7-beta4",
        "==1.7-rc1",
        "==1.7-rc2",
        "==1.7-rc3",
        "==1.7.1",
        "==1.7.2",
        "==1.7.3",
        "==1.7.4",
        "==1.7.5",
        "==1.7.6",
        "==1.7.7",
        "==1.7.8",
        "==1.7.9",
        "==1.8-beta1",
        "==1.8.0",
        "==1.8.1",
        "==1.8.2",
        "==1.8.3"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2015-5964",
      "advisory": "The (1) contrib.sessions.backends.base.SessionBase.flush and (2) cache_db.SessionStore.flush functions in Django 1.7.x before 1.7.10, 1.4.x before 1.4.22, and possibly other versions create empty sessions in certain circumstances, which allows remote attackers to cause a denial of service (session store consumption) via unspecified vectors.",
      "cve": "CVE-2015-5964",
      "specs": [
        "==1.4",
        "==1.4.1",
        "==1.4.10",
        "==1.4.11",
        "==1.4.12",
        "==1.4.13",
        "==1.4.14",
        "==1.4.17",
        "==1.4.19",
        "==1.4.2",
        "==1.4.20",
        "==1.4.21",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8",
        "==1.4.9",
        "==1.7-beta1",
        "==1.7-beta2",
        "==1.7-beta3",
        "==1.7-beta4",
        "==1.7-rc1",
        "==1.7-rc2",
        "==1.7-rc3",
        "==1.7.1",
        "==1.7.2",
        "==1.7.3",
        "==1.7.4",
        "==1.7.5",
        "==1.7.6",
        "==1.7.7",
        "==1.7.8",
        "==1.7.9",
        "==1.8-beta1",
        "==1.8.0",
        "==1.8.1",
        "==1.8.2",
        "==1.8.3"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2015-8213",
      "advisory": "The get_format function in utils/formats.py in Django before 1.7.x before 1.7.11, 1.8.x before 1.8.7, and 1.9.x before 1.9rc2 might allow remote attackers to obtain sensitive application secrets via a settings key in place of a date/time format setting, as demonstrated by SECRET_KEY.",
      "cve": "CVE-2015-8213",
      "specs": [
        "<=1.7.10",
        "==1.8.0",
        "==1.8.1",
        "==1.8.2",
        "==1.8.3",
        "==1.8.4",
        "==1.8.5",
        "==1.8.6",
        "==1.9.0-rc1"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2016-2048",
      "advisory": "Django 1.9.x before 1.9.2, when ModelAdmin.save_as is set to True, allows remote authenticated users to bypass intended access restrictions and create ModelAdmin objects via the \"Save as New\" option when editing objects and leveraging the \"change\" permission.",
      "cve": "CVE-2016-2048",
      "specs": [
        "==1.9",
        "==1.9.1"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2016-2512",
      "advisory": "The utils.http.is_safe_url function in Django before 1.8.10 and 1.9.x before 1.9.3 allows remote attackers to redirect users to arbitrary web sites and conduct phishing attacks or possibly conduct cross-site scripting (XSS) attacks via a URL containing basic authentication, as demonstrated by http://mysite.example.com\\@attacker.com.",
      "cve": "CVE-2016-2512",
      "specs": [
        "==1.8.9",
        "==1.9",
        "==1.9.1",
        "==1.9.2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2016-2513",
      "advisory": "The password hasher in contrib/auth/hashers.py in Django before 1.8.10 and 1.9.x before 1.9.3 allows remote attackers to enumerate users via a timing attack involving login requests.",
      "cve": "CVE-2016-2513",
      "specs": [
        "==1.8.9",
        "==1.9",
        "==1.9.1",
        "==1.9.2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2016-6186",
      "advisory": "Cross-site scripting (XSS) vulnerability in the dismissChangeRelatedObjectPopup function in contrib/admin/static/admin/js/admin/RelatedObjectLookups.js in Django before 1.8.14, 1.9.x before 1.9.8, and 1.10.x before 1.10rc1 allows remote attackers to inject arbitrary web script or HTML via vectors involving unsafe usage of Element.innerHTML.",
      "cve": "CVE-2016-6186",
      "specs": [
        "<=1.8.13",
        "==1.10-alpha1",
        "==1.10-beta1",
        "==1.9",
        "==1.9.0-rc1",
        "==1.9.1",
        "==1.9.2",
        "==1.9.3",
        "==1.9.4",
        "==1.9.5",
        "==1.9.6",
        "==1.9.7"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2016-7401",
      "advisory": "The cookie parsing code in Django before 1.8.15 and 1.9.x before 1.9.10, when used on a site with Google Analytics, allows remote attackers to bypass an intended CSRF protection mechanism by setting arbitrary cookies.",
      "cve": "CVE-2016-7401",
      "specs": [
        "<=1.8.14",
        "==1.9.0",
        "==1.9.1",
        "==1.9.2",
        "==1.9.3",
        "==1.9.4",
        "==1.9.5",
        "==1.9.6",
        "==1.9.7",
        "==1.9.8",
        "==1.9.9"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2016-9013",
      "advisory": "Django 1.8.x before 1.8.16, 1.9.x before 1.9.11, and 1.10.x before 1.10.3 use a hardcoded password for a temporary database user created when running tests with an Oracle database, which makes it easier for remote attackers to obtain access to the database server by leveraging failure to manually specify a password in the database settings TEST dictionary.",
      "cve": "CVE-2016-9013",
      "specs": [
        "==1.10",
        "==1.10.1",
        "==1.10.2",
        "==1.8",
        "==1.8.1",
        "==1.8.10",
        "==1.8.11",
        "==1.8.12",
        "==1.8.13",
        "==1.8.14",
        "==1.8.15",
        "==1.8.2",
        "==1.8.3",
        "==1.8.4",
        "==1.8.5",
        "==1.8.6",
        "==1.8.7",
        "==1.8.8",
        "==1.8.9",
        "==1.9",
        "==1.9.1",
        "==1.9.10",
        "==1.9.2",
        "==1.9.3",
        "==1.9.4",
        "==1.9.5",
        "==1.9.6",
        "==1.9.7",
        "==1.9.8",
        "==1.9.9"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2016-9014",
      "advisory": "Django before 1.8.x before 1.8.16, 1.9.x before 1.9.11, and 1.10.x before 1.10.3, when settings.DEBUG is True, allow remote attackers to conduct DNS rebinding attacks by leveraging failure to validate the HTTP Host header against settings.ALLOWED_HOSTS.",
      "cve": "CVE-2016-9014",
      "specs": [
        "==1.10",
        "==1.10.1",
        "==1.10.2",
        "==1.8",
        "==1.8.1",
        "==1.8.10",
        "==1.8.11",
        "==1.8.12",
        "==1.8.13",
        "==1.8.14",
        "==1.8.15",
        "==1.8.2",
        "==1.8.3",
        "==1.8.4",
        "==1.8.5",
        "==1.8.6",
        "==1.8.7",
        "==1.8.8",
        "==1.8.9",
        "==1.9",
        "==1.9.1",
        "==1.9.10",
        "==1.9.2",
        "==1.9.3",
        "==1.9.4",
        "==1.9.5",
        "==1.9.6",
        "==1.9.7",
        "==1.9.8",
        "==1.9.9"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2017-12794",
      "advisory": "In Django 1.10.x before 1.10.8 and 1.11.x before 1.11.5, HTML autoescaping was disabled in a portion of the template for the technical 500 debug page. Given the right circumstances, this allowed a cross-site scripting attack. This vulnerability shouldn't affect most production sites since you shouldn't run with \"DEBUG = True\" (which makes this page accessible) in your production settings.",
      "cve": "CVE-2017-12794",
      "specs": [
        "==1.10.0",
        "==1.10.1",
        "==1.10.2",
        "==1.10.3",
        "==1.10.4",
        "==1.10.5",
        "==1.10.6",
        "==1.10.7",
        "==1.11.0",
        "==1.11.1",
        "==1.11.2",
        "==1.11.3",
        "==1.11.4"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2017-7233",
      "advisory": "Django 1.10 before 1.10.7, 1.9 before 1.9.13, and 1.8 before 1.8.18 relies on user input in some cases to redirect the user to an \"on success\" URL. The security check for these redirects (namely ``django.utils.http.is_safe_url()``) considered some numeric URLs \"safe\" when they shouldn't be, aka an open redirect vulnerability. Also, if a developer relies on ``is_safe_url()`` to provide safe redirect targets and puts such a URL into a link, they could suffer from an XSS attack.",
      "cve": "CVE-2017-7233",
      "specs": [
        "==1.10.0",
        "==1.10.0-a1",
        "==1.10.0-b1",
        "==1.10.0-rc1",
        "==1.10.1",
        "==1.10.2",
        "==1.10.3",
        "==1.10.4",
        "==1.10.5",
        "==1.10.6",
        "==1.8.0",
        "==1.8.0-a1",
        "==1.8.0-b1",
        "==1.8.0-b2",
        "==1.8.0-c1",
        "==1.8.1",
        "==1.8.10",
        "==1.8.11",
        "==1.8.12",
        "==1.8.13",
        "==1.8.14",
        "==1.8.15",
        "==1.8.16",
        "==1.8.17",
        "==1.8.2",
        "==1.8.3",
        "==1.8.4",
        "==1.8.5",
        "==1.8.6",
        "==1.8.7",
        "==1.8.8",
        "==1.8.9",
        "==1.9",
        "==1.9-a1",
        "==1.9-b1",
        "==1.9-rc1",
        "==1.9-rc2",
        "==1.9.1",
        "==1.9.10",
        "==1.9.11",
        "==1.9.12",
        "==1.9.2",
        "==1.9.3",
        "==1.9.4",
        "==1.9.5",
        "==1.9.6",
        "==1.9.7",
        "==1.9.8",
        "==1.9.9"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2017-7234",
      "advisory": "A maliciously crafted URL to a Django (1.10 before 1.10.7, 1.9 before 1.9.13, and 1.8 before 1.8.18) site using the ``django.views.static.serve()`` view could redirect to any other domain, aka an open redirect vulnerability.",
      "cve": "CVE-2017-7234",
      "specs": [
        "==1.10.0",
        "==1.10.0-a1",
        "==1.10.0-b1",
        "==1.10.0-rc1",
        "==1.10.1",
        "==1.10.2",
        "==1.10.3",
        "==1.10.4",
        "==1.10.5",
        "==1.10.6",
        "==1.8.0",
        "==1.8.0-a1",
        "==1.8.0-b1",
        "==1.8.0-b2",
        "==1.8.0-c1",
        "==1.8.1",
        "==1.8.10",
        "==1.8.11",
        "==1.8.12",
        "==1.8.13",
        "==1.8.14",
        "==1.8.15",
        "==1.8.16",
        "==1.8.17",
        "==1.8.2",
        "==1.8.3",
        "==1.8.4",
        "==1.8.5",
        "==1.8.6",
        "==1.8.7",
        "==1.8.8",
        "==1.8.9",
        "==1.9",
        "==1.9-a1",
        "==1.9-b1",
        "==1.9-rc1",
        "==1.9-rc2",
        "==1.9.1",
        "==1.9.10",
        "==1.9.11",
        "==1.9.12",
        "==1.9.2",
        "==1.9.3",
        "==1.9.4",
        "==1.9.5",
        "==1.9.6",
        "==1.9.7",
        "==1.9.8",
        "==1.9.9"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2018-14574",
      "advisory": "django.middleware.common.CommonMiddleware in Django 1.11.x before 1.11.15 and 2.0.x before 2.0.8 has an Open Redirect.",
      "cve": "CVE-2018-14574",
      "specs": [
        ">=1.11,<1.11.15",
        ">=2.0,<2.0.8"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2018-16984",
      "advisory": "An issue was discovered in Django 2.1 before 2.1.2, in which unprivileged users can read the password hashes of arbitrary accounts. The read-only password widget used by the Django Admin to display an obfuscated password hash was bypassed if a user has only the \"view\" permission (new in Django 2.1), resulting in display of the entire password hash to those users. This may result in a vulnerability for sites with legacy user accounts using insecure hashes.",
      "cve": "CVE-2018-16984",
      "specs": [
        ">=2.1,<2.1.2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2018-6188",
      "advisory": "django.contrib.auth.forms.AuthenticationForm in Django 2.0 before 2.0.2, and 1.11.8 and 1.11.9, allows remote attackers to obtain potentially sensitive information by leveraging data exposure from the confirm_login_allowed() method, as demonstrated by discovering whether a user account is inactive.",
      "cve": "CVE-2018-6188",
      "specs": [
        "==1.11.8",
        "==1.11.9",
        "==2.0",
        "==2.0.1"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2018-7536",
      "advisory": "An issue was discovered in Django 2.0 before 2.0.3, 1.11 before 1.11.11, and 1.8 before 1.8.19. The django.utils.html.urlize() function was extremely slow to evaluate certain inputs due to catastrophic backtracking vulnerabilities in two regular expressions (only one regular expression for Django 1.8.x). The urlize() function is used to implement the urlize and urlizetrunc template filters, which were thus vulnerable.",
      "cve": "CVE-2018-7536",
      "specs": [
        ">=1.11,<1.11.11",
        ">=1.8,<1.8.19",
        ">=2.0,<2.0.3"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2018-7537",
      "advisory": "An issue was discovered in Django 2.0 before 2.0.3, 1.11 before 1.11.11, and 1.8 before 1.8.19. If django.utils.text.Truncator's chars() and words() methods were passed the html=True argument, they were extremely slow to evaluate certain inputs due to a catastrophic backtracking vulnerability in a regular expression. The chars() and words() methods are used to implement the truncatechars_html and truncatewords_html template filters, which were thus vulnerable.",
      "cve": "CVE-2018-7537",
      "specs": [
        ">=1.11,<1.11.11",
        ">=1.8,<1.8.19",
        ">=2.0,<2.0.3"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2019-12308",
      "advisory": "An issue was discovered in Django 1.11 before 1.11.21, 2.1 before 2.1.9, and 2.2 before 2.2.2. The clickable Current URL value displayed by the AdminURLFieldWidget displays the provided value without validating it as a safe URL. Thus, an unvalidated value stored in the database, or a value provided as a URL query parameter payload, could result in an clickable JavaScript link.",
      "cve": "CVE-2019-12308",
      "specs": [
        ">=1.11,<1.11.21",
        ">=2.1,<2.1.9",
        ">=2.2,<2.2.2"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2019-12781",
      "advisory": "An issue was discovered in Django 1.11 before 1.11.22, 2.1 before 2.1.10, and 2.2 before 2.2.3. An HTTP request is not redirected to HTTPS when the SECURE_PROXY_SSL_HEADER and SECURE_SSL_REDIRECT settings are used, and the proxy connects to Django via HTTPS. In other words, django.http.HttpRequest.scheme has incorrect behavior when a client uses HTTP.",
      "cve": "CVE-2019-12781",
      "specs": [
        ">=1.11,<1.11.22",
        ">=2.1,<2.1.10",
        ">=2.2,<2.2.3"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2019-14232",
      "advisory": "An issue was discovered in Django 1.11.x before 1.11.23, 2.1.x before 2.1.11, and 2.2.x before 2.2.4. If django.utils.text.Truncator's chars() and words() methods were passed the html=True argument, they were extremely slow to evaluate certain inputs due to a catastrophic backtracking vulnerability in a regular expression. The chars() and words() methods are used to implement the truncatechars_html and truncatewords_html template filters, which were thus vulnerable.",
      "cve": "CVE-2019-14232",
      "specs": [
        ">=1.11,<1.11.23",
        ">=2.1,<2.1.11",
        ">=2.2,<2.2.4"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2019-14233",
      "advisory": "An issue was discovered in Django 1.11.x before 1.11.23, 2.1.x before 2.1.11, and 2.2.x before 2.2.4. Due to the behaviour of the underlying HTMLParser, django.utils.html.strip_tags would be extremely slow to evaluate certain inputs containing large sequences of nested incomplete HTML entities.",
      "cve": "CVE-2019-14233",
      "specs": [
        ">=1.11,<1.11.23",
        ">=2.1,<2.1.11",
        ">=2.2,<2.2.4"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2019-14234",
      "advisory": "An issue was discovered in Django 1.11.x before 1.11.23, 2.1.x before 2.1.11, and 2.2.x before 2.2.4. Due to an error in shallow key transformation, key and index lookups for django.contrib.postgres.fields.JSONField, and key lookups for django.contrib.postgres.fields.HStoreField, were subject to SQL injection. This could, for example, be exploited via crafted use of \"OR 1=1\" in a key or index name to return all records, using a suitably crafted dictionary, with dictionary expansion, as the **kwargs passed to the QuerySet.filter() function.",
      "cve": "CVE-2019-14234",
      "specs": [
        ">=1.11,<1.11.23",
        ">=2.1,<2.1.11",
        ">=2.2,<2.2.4"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2019-14235",
      "advisory": "An issue was discovered in Django 1.11.x before 1.11.23, 2.1.x before 2.1.11, and 2.2.x before 2.2.4. If passed certain inputs, django.utils.encoding.uri_to_iri could lead to significant memory usage due to a recursion when repercent-encoding invalid UTF-8 octet sequences.",
      "cve": "CVE-2019-14235",
      "specs": [
        ">=1.11,<1.11.23",
        ">=2.1,<2.1.11",
        ">=2.2,<2.2.4"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2019-19118",
      "advisory": "Django 2.1 before 2.1.15 and 2.2 before 2.2.8 allows unintended model editing. A Django model admin displaying inline related models, where the user has view-only permissions to a parent model but edit permissions to the inline model, would be presented with an editing UI, allowing POST requests, for updating the inline model. Directly editing the view-only parent model was not possible, but the parent model's save() method was called, triggering potential side effects, and causing pre and post-save signal handlers to be invoked. (To resolve this, the Django admin is adjusted to require edit permissions on the parent model in order for inline models to be editable.)",
      "cve": "CVE-2019-19118",
      "specs": [
        ">=2.1,<2.1.15",
        ">=2.2,<2.2.8"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2019-19844",
      "advisory": "Django before 1.11.27, 2.x before 2.2.9, and 3.x before 3.0.1 allows account takeover. A suitably crafted email address (that is equal to an existing user's email address after case transformation of Unicode characters) would allow an attacker to be sent a password reset token for the matched user account. (One mitigation in the new releases is to send password reset tokens only to the registered user email address.)",
      "cve": "CVE-2019-19844",
      "specs": [
        "<1.11.27",
        "==3.0",
        ">=2.2,<2.2.9"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2019-3498",
      "advisory": "In Django 1.11.x before 1.11.18, 2.0.x before 2.0.10, and 2.1.x before 2.1.5, an Improper Neutralization of Special Elements in Output Used by a Downstream Component issue exists in django.views.defaults.page_not_found(), leading to content spoofing (in a 404 error page) if a user fails to recognize that a crafted URL has malicious content.",
      "cve": "CVE-2019-3498",
      "specs": [
        ">=1.11,<1.11.18",
        ">=2.0,<2.0.10",
        ">=2.1,<2.1.5"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2019-6975",
      "advisory": "Django 1.11.x before 1.11.19, 2.0.x before 2.0.11, and 2.1.x before 2.1.6 allows Uncontrolled Memory Consumption via a malicious attacker-supplied value to the django.utils.numberformat.format() function.",
      "cve": "CVE-2019-6975",
      "specs": [
        ">=1.11.0,<1.11.19",
        ">=2.0.0,<2.0.11",
        ">=2.1.0,<2.1.6"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2020-13254",
      "advisory": "An issue was discovered in Django 2.2 before 2.2.13 and 3.0 before 3.0.7. In cases where a memcached backend does not perform key validation, passing malformed cache keys could result in a key collision, and potential data leakage.",
      "cve": "CVE-2020-13254",
      "specs": [
        ">=2.2,<2.2.13",
        ">=3.0,<3.0.7"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2020-13596",
      "advisory": "An issue was discovered in Django 2.2 before 2.2.13 and 3.0 before 3.0.7. Query parameters generated by the Django admin ForeignKeyRawIdWidget were not properly URL encoded, leading to a possibility of an XSS attack.",
      "cve": "CVE-2020-13596",
      "specs": [
        ">=2.2,<2.2.13",
        ">=3.0,<3.0.7"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2020-24583",
      "advisory": "An issue was discovered in Django 2.2 before 2.2.16, 3.0 before 3.0.10, and 3.1 before 3.1.1 (when Python 3.7+ is used). FILE_UPLOAD_DIRECTORY_PERMISSIONS mode was not applied to intermediate-level directories created in the process of uploading files. It was also not applied to intermediate-level collected static directories when using the collectstatic management command.",
      "cve": "CVE-2020-24583",
      "specs": [
        ">=2.2,<2.2.16",
        ">=3.0,<3.0.10",
        ">=3.1,<3.1.1"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2020-24584",
      "advisory": "An issue was discovered in Django 2.2 before 2.2.16, 3.0 before 3.0.10, and 3.1 before 3.1.1 (when Python 3.7+ is used). The intermediate-level directories of the filesystem cache had the system's standard umask rather than 0o077.",
      "cve": "CVE-2020-24584",
      "specs": [
        ">=2.2,<2.2.16",
        ">=3.0,<3.0.10",
        ">=3.1,<3.1.1"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2020-7471",
      "advisory": "Django 1.11 before 1.11.28, 2.2 before 2.2.10, and 3.0 before 3.0.3 allows SQL Injection if untrusted data is used as a StringAgg delimiter (e.g., in Django applications that offer downloads of data as a series of rows with a user-specified column delimiter). By passing a suitably crafted delimiter to a contrib.postgres.aggregates.StringAgg instance, it was possible to break escaping and inject malicious SQL.",
      "cve": "CVE-2020-7471",
      "specs": [
        ">=1.11,<1.11.28",
        ">=2.2,<2.2.10",
        ">=3.0,<3.0.3"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2020-9402",
      "advisory": "Django 1.11 before 1.11.29, 2.2 before 2.2.11, and 3.0 before 3.0.4 allows SQL Injection if untrusted data is used as a tolerance parameter in GIS functions and aggregates on Oracle. By passing a suitably crafted tolerance to GIS functions and aggregates on Oracle, it was possible to break escaping and inject malicious SQL.",
      "cve": "CVE-2020-9402",
      "specs": [
        ">=1.11,<1.11.29",
        ">=2.2,<2.2.11",
        ">=3.0,<3.0.4"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2021-23336",
      "advisory": "The package python/cpython from 0 and before 3.6.13, from 3.7.0 and before 3.7.10, from 3.8.0 and before 3.8.8, from 3.9.0 and before 3.9.2 are vulnerable to Web Cache Poisoning via urllib.parse.parse_qsl and urllib.parse.parse_qs by using a vector called parameter cloaking. When the attacker can separate query parameters using a semicolon (;), they can cause a difference in the interpretation of the request between the proxy (running with default configuration) and the server. This can result in malicious requests being cached as completely safe ones, as the proxy would usually not see the semicolon as a separator, and therefore would not include it in a cache key of an unkeyed parameter.",
      "cve": "CVE-2021-23336",
      "specs": [
        ">=2.2,<2.2.19",
        ">=3.0,<3.0.13",
        ">=3.1,<3.1.7"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2021-28658",
      "advisory": "In Django 2.2 before 2.2.20, 3.0 before 3.0.14, and 3.1 before 3.1.8, MultiPartParser allowed directory traversal via uploaded files with suitably crafted file names. Built-in upload handlers were not affected by this vulnerability.",
      "cve": "CVE-2021-28658",
      "specs": [
        ">=2.2,<2.2.20",
        ">=3.0,<3.0.14",
        ">=3.1,<3.1.8"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2021-31542",
      "advisory": "In Django 2.2 before 2.2.21, 3.1 before 3.1.9, and 3.2 before 3.2.1, MultiPartParser, UploadedFile, and FieldFile allowed directory traversal via uploaded files with suitably crafted file names.",
      "cve": "CVE-2021-31542",
      "specs": [
        ">=2.2,<2.2.21",
        ">=3.1,<3.1.9",
        ">=3.2,<3.2.1"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2021-3281",
      "advisory": "In Django 2.2 before 2.2.18, 3.0 before 3.0.12, and 3.1 before 3.1.6, the django.utils.archive.extract method (used by \"startapp --template\" and \"startproject --template\") allows directory traversal via an archive with absolute paths or relative paths with dot segments.",
      "cve": "CVE-2021-3281",
      "specs": [
        ">=2.2,<2.2.18",
        ">=3.0,<3.0.12",
        ">=3.1,<3.1.6"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2021-33203",
      "advisory": "Django before 2.2.24, 3.x before 3.1.12, and 3.2.x before 3.2.4 has a potential directory traversal via django.contrib.admindocs. Staff members could use the TemplateDetailView view to check the existence of arbitrary files. Additionally, if (and only if) the default admindocs templates have been customized by application developers to also show file contents, then not only the existence but also the file contents would have been exposed. In other words, there is directory traversal outside of the template root directories.",
      "cve": "CVE-2021-33203",
      "specs": [
        "<2.2.24",
        ">=3.0.0,<3.1.12",
        ">=3.2.0,<3.2.4"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2021-33571",
      "advisory": "In Django 2.2 before 2.2.24, 3.x before 3.1.12, and 3.2 before 3.2.4, URLValidator, validate_ipv4_address, and validate_ipv46_address do not prohibit leading zero characters in octal literals. This may allow a bypass of access control that is based on IP addresses. (validate_ipv4_address and validate_ipv46_address are unaffected with Python 3.9.5+..) .",
      "cve": "CVE-2021-33571",
      "specs": [
        ">=2.2,<2.2.24",
        ">=3.0,<3.1.12",
        ">=3.2,<3.2.4"
      ]
    },
    {
      "id": "pyup.io-django:CVE-2021-35042",
      "advisory": "Django 3.1.x before 3.1.13 and 3.2.x before 3.2.5 allows QuerySet.order_by SQL injection if order_by is untrusted input from a client of a web application.",
      "cve": "CVE-2021-35042",
      "specs": [
        ">=3.1,<3.1.13",
        ">=3.2,<3.2.5"
      ]
    }
  ],
  "django-anymail": [
    {
      "id": "pyup.io-django-anymail:CVE-2018-1000089",
      "advisory": "Anymail django-anymail version version 0.2 through 1.3 contains a CWE-532, CWE-209 vulnerability in WEBHOOK_AUTHORIZATION setting value that can result in An attacker with access to error logs could fabricate email tracking events. This attack appear to be exploitable via If you have exposed your Django error reports, an attacker could discover your ANYMAIL_WEBHOOK setting and use this to post fabricated or malicious Anymail tracking/inbound events to your app. This vulnerability appears to have been fixed in v1.4.",
      "cve": "CVE-2018-1000089",
      "specs": [
        ">=0.2,<=1.3"
      ]
    },
    {
      "id": "pyup.io-django-anymail:CVE-2018-6596",
      "advisory": "webhooks/base.py in Anymail (aka django-anymail) before 1.2.1 is prone to a timing attack vulnerability on the WEBHOOK_AUTHORIZATION secret, which allows remote attackers to post arbitrary e-mail tracking events.",
      "cve": "CVE-2018-6596",
      "specs": [
        "<1.2.1"
      ]
    }
  ],
  "django-basic-auth-ip-whitelist": [
    {
      "id": "pyup.io-django-basic-auth-ip-whitelist:CVE-2020-4071",
      "advisory": "In django-basic-auth-ip-whitelist before 0.3.4, a potential timing attack exists on websites where the basic authentication is used or configured, i.e. BASIC_AUTH_LOGIN and BASIC_AUTH_PASSWORD is set. Currently the string comparison between configured credentials and the ones provided by users is performed through a character-by-character string comparison. This enables a possibility that attacker may time the time it takes the server to validate different usernames and password, and use this knowledge to work out the valid credentials. This attack is understood not to be realistic over the Internet. However, it may be achieved from within local networks where the website is hosted, e.g. from inside a data centre where a website's server is located. Sites protected by IP address whitelisting only are unaffected by this vulnerability. This vulnerability has been fixed on version 0.3.4 of django-basic-auth-ip-whitelist. Update to version 0.3.4 as soon as possible and change basic authentication username and password configured on a Django project using this package. A workaround without upgrading to version 0.3.4 is to stop using basic authentication and use the IP whitelisting component only. It can be achieved by not setting BASIC_AUTH_LOGIN and BASIC_AUTH_PASSWORD in Django project settings.",
      "cve": "CVE-2020-4071",
      "specs": [
        "<0.3.4"
      ]
    }
  ],
  "django-celery-results": [
    {
      "id": "pyup.io-django-celery-results:CVE-2020-17495",
      "advisory": "django-celery-results through 1.2.1 stores task results in the database. Among the data it stores are the variables passed into the tasks. The variables may contain sensitive cleartext information that does not belong unencrypted in the database.",
      "cve": "CVE-2020-17495",
      "specs": [
        "<=1.2.1"
      ]
    }
  ],
  "django-cms": [
    {
      "id": "pyup.io-django-cms:CVE-2015-5081",
      "advisory": "Cross-site request forgery (CSRF) vulnerability in django CMS before 3.0.14, 3.1.x before 3.1.1 allows remote attackers to manipulate privileged users into performing unknown actions via unspecified vectors.",
      "cve": "CVE-2015-5081",
      "specs": [
        "<=3.0.13",
        "==3.1"
      ]
    }
  ],
  "django-crm": [
    {
      "id": "pyup.io-django-crm:CVE-2018-16552",
      "advisory": "MicroPyramid Django-CRM 0.2 allows CSRF for /users/create/, /users/##/edit/, and /accounts/##/delete/ URIs.",
      "cve": "CVE-2018-16552",
      "specs": [
        "==0.2"
      ]
    },
    {
      "id": "pyup.io-django-crm:CVE-2019-11457",
      "advisory": "Multiple CSRF issues exist in MicroPyramid Django CRM 0.2.1 via /change-password-by-admin/, /api/settings/add/, /cases/create/, /change-password-by-admin/, /comment/add/, /documents/1/view/, /documents/create/, /opportunities/create/, and /login/.",
      "cve": "CVE-2019-11457",
      "specs": [
        "==0.2.1"
      ]
    }
  ],
  "django-debug-toolbar": [
    {
      "id": "pyup.io-django-debug-toolbar:CVE-2021-30459",
      "advisory": "A SQL Injection issue in the SQL Panel in Jazzband Django Debug Toolbar before 1.11.1, 2.x before 2.2.1, and 3.x before 3.2.1 allows attackers to execute SQL statements by changing the raw_sql input field of the SQL explain, analyze, or select form.",
      "cve": "CVE-2021-30459",
      "specs": [
        ">=0.10.0,<1.11.1",
        ">=2.0.0,<2.2.1",
        ">=3.0.0,<3.2.1"
      ]
    }
  ],
  "django-epiceditor": [
    {
      "id": "pyup.io-django-epiceditor:CVE-2017-6591",
      "advisory": "There is a cross-site scripting vulnerability in django-epiceditor 0.2.3 via crafted content in a form field.",
      "cve": "CVE-2017-6591",
      "specs": [
        "==0.2.3"
      ]
    }
  ],
  "django-filter": [
    {
      "id": "pyup.io-django-filter:CVE-2020-15225",
      "advisory": "django-filter is a generic system for filtering Django QuerySets based on user selections. In django-filter before version 2.4.0, automatically generated `NumberFilter` instances, whose value was later converted to an integer, were subject to potential DoS from maliciously input using exponential format with sufficiently large exponents. Version 2.4.0+ applies a `MaxValueValidator` with a a default `limit_value` of 1e50 to the form field used by `NumberFilter` instances. In addition, `NumberFilter` implements the new `get_max_validator()` which should return a configured validator instance to customise the limit, or else `None` to disable the additional validation. Users may manually apply an equivalent validator if they are not able to upgrade.",
      "cve": "CVE-2020-15225",
      "specs": [
        "<2.4.0"
      ]
    }
  ],
  "django-js-reverse": [
    {
      "id": "pyup.io-django-js-reverse:CVE-2019-15486",
      "advisory": "django-js-reverse (aka Django JS Reverse) before 0.9.1 has XSS via js_reverse_inline.",
      "cve": "CVE-2019-15486",
      "specs": [
        "<0.9.1"
      ]
    }
  ],
  "django-make-app": [
    {
      "id": "pyup.io-django-make-app:CVE-2017-16764",
      "advisory": "An exploitable vulnerability exists in the YAML parsing functionality in the read_yaml_file method in io_utils.py in django_make_app 0.1.3. A YAML parser can execute arbitrary Python commands resulting in command execution. An attacker can insert Python into loaded YAML to trigger this vulnerability.",
      "cve": "CVE-2017-16764",
      "specs": [
        "==0.1.3"
      ]
    }
  ],
  "django-markupfield": [
    {
      "id": "pyup.io-django-markupfield:CVE-2015-0846",
      "advisory": "django-markupfield before 1.3.2 uses the default docutils RESTRUCTUREDTEXT_FILTER_SETTINGS settings, which allows remote attackers to include and read arbitrary files via unspecified vectors.",
      "cve": "CVE-2015-0846",
      "specs": [
        "<=1.3.1"
      ]
    }
  ],
  "django-nopassword": [
    {
      "id": "pyup.io-django-nopassword:CVE-2019-10682",
      "advisory": "django-nopassword before 5.0.0 stores cleartext secrets in the database.",
      "cve": "CVE-2019-10682",
      "specs": [
        "<5.0.0"
      ]
    }
  ],
  "django-piston": [
    {
      "id": "pyup.io-django-piston:CVE-2011-4103",
      "advisory": "emitters.py in Django Piston before 0.2.3 and 0.2.x before 0.2.2.1 does not properly deserialize YAML data, which allows remote attackers to execute arbitrary Python code via vectors related to the yaml.load method.",
      "cve": "CVE-2011-4103",
      "specs": [
        "<=0.2.2.0"
      ]
    }
  ],
  "django-registration": [
    {
      "id": "pyup.io-django-registration:CVE-2021-21416",
      "advisory": "django-registration is a user registration package for Django. The django-registration package provides tools for implementing user-account registration flows in the Django web framework. In django-registration prior to 3.1.2, the base user-account registration view did not properly apply filters to sensitive data, with the result that sensitive data could be included in error reports rather than removed automatically by Django. Triggering this requires: A site is using django-registration < 3.1.2, The site has detailed error reports (such as Django's emailed error reports to site staff/developers) enabled and a server-side error (HTTP 5xx) occurs during an attempt by a user to register an account. Under these conditions, recipients of the detailed error report will see all submitted data from the account-registration attempt, which may include the user's proposed credentials (such as a password).",
      "cve": "CVE-2021-21416",
      "specs": [
        "<3.1.2"
      ]
    }
  ],
  "django-rest-registration": [
    {
      "id": "pyup.io-django-rest-registration:CVE-2019-13177",
      "advisory": "verification.py in django-rest-registration (aka Django REST Registration library) before 0.5.0 relies on a static string for signatures (i.e., the Django Signing API is misused), which allows remote attackers to spoof the verification process. This occurs because incorrect code refactoring led to calling a security-critical function with an incorrect argument.",
      "cve": "CVE-2019-13177",
      "specs": [
        ">0.1.0,<0.5.0"
      ]
    }
  ],
  "django-tastypie": [
    {
      "id": "pyup.io-django-tastypie:CVE-2011-4104",
      "advisory": "The from_yaml method in serializers.py in Django Tastypie before 0.9.10 does not properly deserialize YAML data, which allows remote attackers to execute arbitrary Python code via vectors related to the yaml.load method.",
      "cve": "CVE-2011-4104",
      "specs": [
        "<=0.9.9"
      ]
    }
  ],
  "django-two-factor-auth": [
    {
      "id": "pyup.io-django-two-factor-auth:CVE-2020-15105",
      "advisory": "Django Two-Factor Authentication before 1.12, stores the user's password in clear text in the user session (base64-encoded). The password is stored in the session when the user submits their username and password, and is removed once they complete authentication by entering a two-factor authentication code. This means that the password is stored in clear text in the session for an arbitrary amount of time, and potentially forever if the user begins the login process by entering their username and password and then leaves before entering their two-factor authentication code. The severity of this issue depends on which type of session storage you have configured: in the worst case, if you're using Django's default database session storage, then users' passwords are stored in clear text in your database. In the best case, if you're using Django's signed cookie session, then users' passwords are only stored in clear text within their browser's cookie store. In the common case of using Django's cache session store, the users' passwords are stored in clear text in whatever cache storage you have configured (typically Memcached or Redis). This has been fixed in 1.12. After upgrading, users should be sure to delete any clear text passwords that have been stored. For example, if you're using the database session backend, you'll likely want to delete any session record from the database and purge that data from any database backups or replicas. In addition, affected organizations who have suffered a database breach while using an affected version should inform their users that their clear text passwords have been compromised. All organizations should encourage users whose passwords were insecurely stored to change these passwords on any sites where they were used. As a workaround, wwitching Django's session storage to use signed cookies instead of the database or cache lessens the impact of this issue, but should not be done without a thorough understanding of the security tradeoffs of using signed cookies rather than a server-side session storage. There is no way to fully mitigate the issue without upgrading.",
      "cve": "CVE-2020-15105",
      "specs": [
        "<1.12"
      ]
    }
  ],
  "django-unicorn": [
    {
      "id": "pyup.io-django-unicorn:CVE-2021-42053",
      "advisory": "The Unicorn framework through 0.35.3 for Django allows XSS via component.name.",
      "cve": "CVE-2021-42053",
      "specs": [
        "<=0.35.3"
      ]
    },
    {
      "id": "pyup.io-django-unicorn:CVE-2021-42134",
      "advisory": "The Unicorn framework before 0.36.1 for Django allows XSS via a component. NOTE: this issue exists because of an incomplete fix for CVE-2021-42053.",
      "cve": "CVE-2021-42134",
      "specs": [
        "<0.36.1"
      ]
    }
  ],
  "django-user-sessions": [
    {
      "id": "pyup.io-django-user-sessions:CVE-2020-5224",
      "advisory": "In Django User Sessions (django-user-sessions) before 1.7.1, the views provided allow users to terminate specific sessions. The session key is used to identify sessions, and thus included in the rendered HTML. In itself this is not a problem. However if the website has an XSS vulnerability, the session key could be extracted by the attacker and a session takeover could happen.",
      "cve": "CVE-2020-5224",
      "specs": [
        "<1.7.1"
      ]
    }
  ],
  "django-widgy": [
    {
      "id": "pyup.io-django-widgy:CVE-2020-18704",
      "advisory": "Unrestricted Upload of File with Dangerous Type in Django-Widgy v0.8.4 allows remote attackers to execute arbitrary code via the 'image' widget in the component 'Change Widgy Page'.",
      "cve": "CVE-2020-18704",
      "specs": [
        "==0.8.4"
      ]
    }
  ],
  "django_make_app": [
    {
      "id": "pyup.io-django_make_app:CVE-2017-16764",
      "advisory": "An exploitable vulnerability exists in the YAML parsing functionality in the read_yaml_file method in io_utils.py in django_make_app 0.1.3. A YAML parser can execute arbitrary Python commands resulting in command execution. An attacker can insert Python into loaded YAML to trigger this vulnerability.",
      "cve": "CVE-2017-16764",
      "specs": [
        "==0.1.3"
      ]
    }
  ],
  "djangorestframework": [
    {
      "id": "pyup.io-djangorestframework:CVE-2020-25626",
      "advisory": "A flaw was found in Django REST Framework versions before 3.12.0 and before 3.11.2. When using the browseable API viewer, Django REST Framework fails to properly escape certain strings that can come from user input. This allows a user who can control those strings to inject malicious <script> tags, leading to a cross-site-scripting (XSS) vulnerability.",
      "cve": "CVE-2020-25626",
      "specs": [
        "<3.12.0"
      ]
    }
  ],
  "djblets": [
    {
      "id": "pyup.io-djblets:CVE-2013-4409",
      "advisory": "An eval() vulnerability exists in Python Software Foundation Djblets 0.7.21 and Beanbag Review Board before 1.7.15 when parsing JSON requests.",
      "cve": "CVE-2013-4409",
      "specs": [
        "==0.7.21"
      ]
    },
    {
      "id": "pyup.io-djblets:CVE-2014-3994",
      "advisory": "Cross-site scripting (XSS) vulnerability in util/templatetags/djblets_js.py in Djblets before 0.7.30 and 0.8.x before 0.8.3 for Django, as used in Review Board, allows remote attackers to inject arbitrary web script or HTML via a JSON object, as demonstrated by the name field when changing a user name.",
      "cve": "CVE-2014-3994",
      "specs": [
        "<=0.7.29",
        "==0.7.27",
        "==0.7.28",
        "==0.8.1",
        "==0.8.2"
      ]
    },
    {
      "id": "pyup.io-djblets:CVE-2014-3995",
      "advisory": "Cross-site scripting (XSS) vulnerability in gravatars/templatetags/gravatars.py in Djblets before 0.7.30 and 0.8.x before 0.8.3 for Django allows remote attackers to inject arbitrary web script or HTML via a user display name.",
      "cve": "CVE-2014-3995",
      "specs": [
        "<=0.7.29",
        "==0.7.27",
        "==0.7.28",
        "==0.8.1",
        "==0.8.2"
      ]
    }
  ],
  "docutils": [
    {
      "id": "pyup.io-docutils:CVE-2009-5042",
      "advisory": "python-docutils allows insecure usage of temporary files",
      "cve": "CVE-2009-5042",
      "specs": [
        "==0.5-2"
      ]
    }
  ],
  "dogtag-pki": [
    {
      "id": "pyup.io-dogtag-pki:CVE-2017-7537",
      "advisory": "It was found that a mock CMC authentication plugin with a hardcoded secret was accidentally enabled by default in the pki-core package before 10.6.4. An attacker could potentially use this flaw to bypass the regular authentication process and trick the CA server into issuing certificates.",
      "cve": "CVE-2017-7537",
      "specs": [
        "<10.6.4"
      ]
    },
    {
      "id": "pyup.io-dogtag-pki:CVE-2018-1080",
      "advisory": "Dogtag PKI, through version 10.6.1, has a vulnerability in AAclAuthz.java that, under certain configurations, causes the application of ACL allow and deny rules to be reversed. If a server is configured to process allow rules before deny rules (authz.evaluateOrder=allow,deny), then allow rules will deny access and deny rules will grant access. This may result in an escalation of privileges or have other unintended consequences.",
      "cve": "CVE-2018-1080",
      "specs": [
        "<=10.6.1"
      ]
    },
    {
      "id": "pyup.io-dogtag-pki:CVE-2019-10146",
      "advisory": "A Reflected Cross Site Scripting flaw was found in all pki-core 10.x.x versions module from the pki-core server due to the CA Agent Service not properly sanitizing the certificate request page. An attacker could inject a specially crafted value that will be executed on the victim's browser.",
      "cve": "CVE-2019-10146",
      "specs": [
        ">=10.0,<=10.7.3"
      ]
    },
    {
      "id": "pyup.io-dogtag-pki:CVE-2019-10179",
      "advisory": "A vulnerability was found in all pki-core 10.x.x versions, where the Key Recovery Authority (KRA) Agent Service did not properly sanitize recovery request search page, enabling a Reflected Cross Site Scripting (XSS) vulnerability. An attacker could trick an authenticated victim into executing specially crafted Javascript code.",
      "cve": "CVE-2019-10179",
      "specs": [
        ">=10.0,<=10.8.3"
      ]
    },
    {
      "id": "pyup.io-dogtag-pki:CVE-2019-10180",
      "advisory": "A vulnerability was found in all pki-core 10.x.x version, where the Token Processing Service (TPS) did not properly sanitize several parameters stored for the tokens, possibly resulting in a Stored Cross Site Scripting (XSS) vulnerability. An attacker able to modify the parameters of any token could use this flaw to trick an authenticated user into executing arbitrary JavaScript code.",
      "cve": "CVE-2019-10180",
      "specs": [
        ">=10.0,<=10.8.3"
      ]
    },
    {
      "id": "pyup.io-dogtag-pki:CVE-2019-10221",
      "advisory": "A Reflected Cross Site Scripting vulnerability was found in all pki-core 10.x.x versions, where the pki-ca module from the pki-core server. This flaw is caused by missing sanitization of the GET URL parameters. An attacker could abuse this flaw to trick an authenticated user into clicking a specially crafted link which can execute arbitrary code when viewed in a browser.",
      "cve": "CVE-2019-10221",
      "specs": [
        ">=10.0,<=10.8.3"
      ]
    },
    {
      "id": "pyup.io-dogtag-pki:CVE-2020-15720",
      "advisory": "In Dogtag PKI through 10.8.3, the pki.client.PKIConnection class did not enable python-requests certificate validation. Since the verify parameter was hard-coded in all request functions, it was not possible to override the setting. As a result, tools making use of this class, such as the pki-server command, may have been vulnerable to Person-in-the-Middle attacks in certain non-localhost use cases. This is fixed in 10.9.0-b1.",
      "cve": "CVE-2020-15720",
      "specs": [
        "<=10.8.3"
      ]
    },
    {
      "id": "pyup.io-dogtag-pki:CVE-2020-1696",
      "advisory": "A flaw was found in the all pki-core 10.x.x versions, where Token Processing Service (TPS) where it did not properly sanitize Profile IDs, enabling a Stored Cross-Site Scripting (XSS) vulnerability when the profile ID is printed. An attacker with sufficient permissions could trick an authenticated victim into executing a specially crafted Javascript code.",
      "cve": "CVE-2020-1696",
      "specs": [
        ">=10.0,<=10.8.3"
      ]
    },
    {
      "id": "pyup.io-dogtag-pki:CVE-2020-1721",
      "advisory": "A flaw was found in the Key Recovery Authority (KRA) Agent Service in pki-core 10.10.5 where it did not properly sanitize the recovery ID during a key recovery request, enabling a reflected cross-site scripting (XSS) vulnerability. An attacker could trick an authenticated victim into executing specially crafted Javascript code.",
      "cve": "CVE-2020-1721",
      "specs": [
        "==10.10.5"
      ]
    },
    {
      "id": "pyup.io-dogtag-pki:CVE-2020-25715",
      "advisory": "A flaw was found in pki-core 10.9.0. A specially crafted POST request can be used to reflect a DOM-based cross-site scripting (XSS) attack to inject code into the search query form which can get automatically executed. The highest threat from this vulnerability is to data integrity.",
      "cve": "CVE-2020-25715",
      "specs": [
        "==10.9.0"
      ]
    },
    {
      "id": "pyup.io-dogtag-pki:CVE-2021-20179",
      "advisory": "A flaw was found in pki-core. An attacker who has successfully compromised a key could use this flaw to renew the corresponding certificate over and over again, as long as it is not explicitly revoked. The highest threat from this vulnerability is to data confidentiality and integrity.",
      "cve": "CVE-2021-20179",
      "specs": [
        "<10.5.0",
        ">=10.10.1,<10.11.0",
        ">=10.5.1,<10.8.0",
        ">=10.8.1,<10.9.0",
        ">=10.9.1,<10.10.0"
      ]
    }
  ],
  "donfig": [
    {
      "id": "pyup.io-donfig:CVE-2019-7537",
      "advisory": "An issue was discovered in Donfig 0.3.0. There is a vulnerability in the collect_yaml method in config_obj.py. It can execute arbitrary Python commands, resulting in command execution.",
      "cve": "CVE-2019-7537",
      "specs": [
        "==0.3.0"
      ]
    }
  ],
  "drf-jwt": [
    {
      "id": "pyup.io-drf-jwt:CVE-2020-10594",
      "advisory": "An issue was discovered in drf-jwt 1.15.x before 1.15.1. It allows attackers with access to a notionally invalidated token to obtain a new, working token via the refresh endpoint, because the blacklist protection mechanism is incompatible with the token-refresh feature. NOTE: drf-jwt is a fork of jpadilla/django-rest-framework-jwt, which is unmaintained.",
      "cve": "CVE-2020-10594",
      "specs": [
        ">=1.15.0,<1.15.1"
      ]
    }
  ],
  "dulwich": [
    {
      "id": "pyup.io-dulwich:CVE-2014-9706",
      "advisory": "The build_index_from_tree function in index.py in Dulwich before 0.9.9 allows remote attackers to execute arbitrary code via a commit with a directory path starting with .git/, which is not properly handled when checking out a working tree.",
      "cve": "CVE-2014-9706",
      "specs": [
        "<=0.9.8"
      ]
    },
    {
      "id": "pyup.io-dulwich:CVE-2015-0838",
      "advisory": "Buffer overflow in the C implementation of the apply_delta function in _pack.c in Dulwich before 0.9.9 allows remote attackers to execute arbitrary code via a crafted pack file.",
      "cve": "CVE-2015-0838",
      "specs": [
        "<=0.9.8"
      ]
    },
    {
      "id": "pyup.io-dulwich:CVE-2017-16228",
      "advisory": "Dulwich before 0.18.5, when an SSH subprocess is used, allows remote attackers to execute arbitrary commands via an ssh URL with an initial dash character in the hostname, a related issue to CVE-2017-9800, CVE-2017-12836, CVE-2017-12976, CVE-2017-1000116, and CVE-2017-1000117.",
      "cve": "CVE-2017-16228",
      "specs": [
        "<=0.18.4"
      ]
    }
  ],
  "easy-xml": [
    {
      "id": "pyup.io-easy-xml:CVE-2020-26705",
      "advisory": "The parseXML function in Easy-XML 0.5.0 was discovered to have a XML External Entity (XXE) vulnerability which allows for an attacker to expose sensitive data or perform a denial of service (DOS) via a crafted external entity entered into the XML content as input.",
      "cve": "CVE-2020-26705",
      "specs": [
        "==0.5.0"
      ]
    }
  ],
  "easybuild-framework": [
    {
      "id": "pyup.io-easybuild-framework:CVE-2020-5262",
      "advisory": "In EasyBuild before version 4.1.2, the GitHub Personal Access Token (PAT) used by EasyBuild for the GitHub integration features (like `--new-pr`, `--fro,-pr`, etc.) is shown in plain text in EasyBuild debug log files. This issue is fixed in EasyBuild v4.1.2, and in the `master`+ `develop` branches of the `easybuild-framework` repository.",
      "cve": "CVE-2020-5262",
      "specs": [
        "<4.1.2"
      ]
    }
  ],
  "ecdsa": [
    {
      "id": "pyup.io-ecdsa:CVE-2019-14853",
      "advisory": "An error-handling flaw was found in python-ecdsa before version 0.13.3. During signature decoding, malformed DER signatures could raise unexpected exceptions (or no exceptions at all), which could lead to a denial of service.",
      "cve": "CVE-2019-14853",
      "specs": [
        "<0.13.3"
      ]
    },
    {
      "id": "pyup.io-ecdsa:CVE-2019-14859",
      "advisory": "A flaw was found in all python-ecdsa versions before 0.13.3, where it did not correctly verify whether signatures used DER encoding. Without this verification, a malformed signature could be accepted, making the signature malleable. Without proper verification, an attacker could use a malleable signature to create false transactions.",
      "cve": "CVE-2019-14859",
      "specs": [
        "<0.13.3"
      ]
    }
  ],
  "elastic-apm": [
    {
      "id": "pyup.io-elastic-apm:CVE-2019-7617",
      "advisory": "When the Elastic APM agent for Python versions before 5.1.0 is run as a CGI script, there is a variable name clash flaw if a remote attacker can control the proxy header. This could result in an attacker redirecting collected APM data to a proxy of their choosing.",
      "cve": "CVE-2019-7617",
      "specs": [
        "<5.1.0"
      ]
    }
  ],
  "eve": [
    {
      "id": "pyup.io-eve:CVE-2018-8097",
      "advisory": "io/mongo/parser.py in Eve (aka pyeve) before 0.7.5 allows remote attackers to execute arbitrary code via Code Injection in the where parameter.",
      "cve": "CVE-2018-8097",
      "specs": [
        "<0.7.5"
      ]
    }
  ],
  "eventlet": [
    {
      "id": "pyup.io-eventlet:CVE-2021-21419",
      "advisory": "Eventlet is a concurrent networking library for Python. A websocket peer may exhaust memory on Eventlet side by sending very large websocket frames. Malicious peer may exhaust memory on Eventlet side by sending highly compressed data frame. A patch in version 0.31.0 restricts websocket frame to reasonable limits. As a workaround, restricting memory usage via OS limits would help against overall machine exhaustion, but there is no workaround to protect Eventlet process.",
      "cve": "CVE-2021-21419",
      "specs": [
        ">=0.10,<0.31.0"
      ]
    }
  ],
  "eyed3": [
    {
      "id": "pyup.io-eyed3:CVE-2014-1934",
      "advisory": "tag.py in eyeD3 (aka python-eyed3) 7.0.3, 0.6.18, and earlier for Python allows local users to modify arbitrary files via a symlink attack on a temporary file.",
      "cve": "CVE-2014-1934",
      "specs": [
        "<=0.6.18",
        "==0.1.0",
        "==0.2.0",
        "==0.3.0",
        "==0.3.1",
        "==0.4.0",
        "==0.5.0",
        "==0.5.1",
        "==0.6.0",
        "==0.6.0-rc1",
        "==0.6.1",
        "==0.6.10",
        "==0.6.11",
        "==0.6.12",
        "==0.6.13",
        "==0.6.14",
        "==0.6.15",
        "==0.6.16",
        "==0.6.17",
        "==0.6.2",
        "==0.6.3",
        "==0.6.4",
        "==0.6.5",
        "==0.6.6",
        "==0.6.8",
        "==0.6.9",
        "==0.7.3"
      ]
    }
  ],
  "fastapi": [
    {
      "id": "pyup.io-fastapi:CVE-2021-32677",
      "advisory": "FastAPI is a web framework for building APIs with Python 3.6+ based on standard Python type hints. FastAPI versions lower than 0.65.2 that used cookies for authentication in path operations that received JSON payloads sent by browsers were vulnerable to a Cross-Site Request Forgery (CSRF) attack. In versions lower than 0.65.2, FastAPI would try to read the request payload as JSON even if the content-type header sent was not set to application/json or a compatible JSON media type (e.g. application/geo+json). A request with a content type of text/plain containing JSON data would be accepted and the JSON data would be extracted. Requests with content type text/plain are exempt from CORS preflights, for being considered Simple requests. The browser will execute them right away including cookies, and the text content could be a JSON string that would be parsed and accepted by the FastAPI application. This is fixed in FastAPI 0.65.2. The request data is now parsed as JSON only if the content-type header is application/json or another JSON compatible media type like application/geo+json. It's best to upgrade to the latest FastAPI, but if updating is not possible then a middleware or a dependency that checks the content-type header and aborts the request if it is not application/json or another JSON compatible content type can act as a mitigating workaround.",
      "cve": "CVE-2021-32677",
      "specs": [
        "<0.65.2"
      ]
    }
  ],
  "fastecdsa": [
    {
      "id": "pyup.io-fastecdsa:CVE-2020-12607",
      "advisory": "An issue was discovered in fastecdsa before 2.1.2. When using the NIST P-256 curve in the ECDSA implementation, the point at infinity is mishandled. This means that for an extreme value in k and s^-1, the signature verification fails even if the signature is correct. This behavior is not solely a usability problem. There are some threat models where an attacker can benefit by successfully guessing users for whom signature verification will fail.",
      "cve": "CVE-2020-12607",
      "specs": [
        "<2.1.2"
      ]
    }
  ],
  "fedmsg": [
    {
      "id": "pyup.io-fedmsg:CVE-2017-1000001",
      "advisory": "FedMsg 0.18.1 and older is vulnerable to a message validation flaw resulting in message validation not being enabled if configured to be on.",
      "cve": "CVE-2017-1000001",
      "specs": [
        "<=0.18.1"
      ]
    }
  ],
  "feedgen": [
    {
      "id": "pyup.io-feedgen:CVE-2020-5227",
      "advisory": "Feedgen (python feedgen) before 0.9.0 is susceptible to XML Denial of Service attacks. The *feedgen* library allows supplying XML as content for some of the available fields. This XML will be parsed and integrated into the existing XML tree. During this process, feedgen is vulnerable to XML Denial of Service Attacks (e.g. XML Bomb). This becomes a concern in particular if feedgen is used to include content from untrused sources and if XML (including XHTML) is directly included instead of providing plain tex content only. This problem has been fixed in feedgen 0.9.0 which disallows XML entity expansion and external resources.",
      "cve": "CVE-2020-5227",
      "specs": [
        "<0.9.0"
      ]
    }
  ],
  "feedparser": [
    {
      "id": "pyup.io-feedparser:CVE-2009-5065",
      "advisory": "Cross-site scripting (XSS) vulnerability in feedparser.py in Universal Feed Parser (aka feedparser or python-feedparser) before 5.0 allows remote attackers to inject arbitrary web script or HTML via vectors involving nested CDATA stanzas.",
      "cve": "CVE-2009-5065",
      "specs": [
        "<=4.1",
        "==3.0",
        "==3.0.1",
        "==3.1",
        "==3.2",
        "==3.3",
        "==4.0",
        "==4.0.1",
        "==4.0.2"
      ]
    },
    {
      "id": "pyup.io-feedparser:CVE-2011-1156",
      "advisory": "feedparser.py in Universal Feed Parser (aka feedparser or python-feedparser) before 5.0.1 allows remote attackers to cause a denial of service (application crash) via a malformed DOCTYPE declaration.",
      "cve": "CVE-2011-1156",
      "specs": [
        "<=5.0",
        "==3.0",
        "==3.0.1",
        "==3.1",
        "==3.2",
        "==3.3",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-feedparser:CVE-2011-1157",
      "advisory": "Cross-site scripting (XSS) vulnerability in feedparser.py in Universal Feed Parser (aka feedparser or python-feedparser) 5.x before 5.0.1 allows remote attackers to inject arbitrary web script or HTML via malformed XML comments.",
      "cve": "CVE-2011-1157",
      "specs": [
        "==5.0"
      ]
    },
    {
      "id": "pyup.io-feedparser:CVE-2011-1158",
      "advisory": "Cross-site scripting (XSS) vulnerability in feedparser.py in Universal Feed Parser (aka feedparser or python-feedparser) 5.x before 5.0.1 allows remote attackers to inject arbitrary web script or HTML via an unexpected URI scheme, as demonstrated by a javascript: URI.",
      "cve": "CVE-2011-1158",
      "specs": [
        "==5.0"
      ]
    },
    {
      "id": "pyup.io-feedparser:CVE-2012-2921",
      "advisory": "Universal Feed Parser (aka feedparser or python-feedparser) before 5.1.2 allows remote attackers to cause a denial of service (memory consumption) via a crafted XML ENTITY declaration in a non-ASCII encoded document.",
      "cve": "CVE-2012-2921",
      "specs": [
        "<=5.1.1",
        "==3.0",
        "==3.0.1",
        "==3.1",
        "==3.2",
        "==3.3",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.1",
        "==5.0",
        "==5.0.1",
        "==5.1",
        "==5.1.2"
      ]
    }
  ],
  "flask": [
    {
      "id": "pyup.io-flask:CVE-2018-1000656",
      "advisory": "The Pallets Project flask version Before 0.12.3 contains a CWE-20: Improper Input Validation vulnerability in flask that can result in Large amount of memory usage possibly leading to denial of service. This attack appear to be exploitable via Attacker provides JSON data in incorrect encoding. This vulnerability appears to have been fixed in 0.12.3. NOTE: this may overlap CVE-2019-1010083.",
      "cve": "CVE-2018-1000656",
      "specs": [
        "<0.12.3"
      ]
    },
    {
      "id": "pyup.io-flask:CVE-2019-1010083",
      "advisory": "The Pallets Project Flask before 1.0 is affected by: unexpected memory usage. The impact is: denial of service. The attack vector is: crafted encoded JSON data. The fixed version is: 1. NOTE: this may overlap CVE-2018-1000656.",
      "cve": "CVE-2019-1010083",
      "specs": [
        "<1.0"
      ]
    }
  ],
  "flask-admin": [
    {
      "id": "pyup.io-flask-admin:CVE-2018-16516",
      "advisory": "helpers.py in Flask-Admin 1.5.2 has Reflected XSS via a crafted URL.",
      "cve": "CVE-2018-16516",
      "specs": [
        "==1.5.2"
      ]
    }
  ],
  "flask-appbuilder": [
    {
      "id": "pyup.io-flask-appbuilder:CVE-2021-29621",
      "advisory": "Flask-AppBuilder is a development framework, built on top of Flask. User enumeration in database authentication in Flask-AppBuilder <= 3.2.3. Allows for a non authenticated user to enumerate existing accounts by timing the response time from the server when you are logging in. Upgrade to version 3.3.0 or higher to resolve.",
      "cve": "CVE-2021-29621",
      "specs": [
        "<=3.2.3"
      ]
    },
    {
      "id": "pyup.io-flask-appbuilder:CVE-2021-32805",
      "advisory": "Flask-AppBuilder is an application development framework, built on top of Flask. In affected versions if using Flask-AppBuilder OAuth, an attacker can share a carefully crafted URL with a trusted domain for an application built with Flask-AppBuilder, this URL can redirect a user to a malicious site. This is an open redirect vulnerability. To resolve this issue upgrade to Flask-AppBuilder 3.2.2 or above. If upgrading is infeasible users may filter HTTP traffic containing `?next={next-site}` where the `next-site` domain is different from the application you are protecting as a workaround.",
      "cve": "CVE-2021-32805",
      "specs": [
        "<3.3.2"
      ]
    }
  ],
  "flask-caching": [
    {
      "id": "pyup.io-flask-caching:CVE-2021-33026",
      "advisory": "The Flask-Caching extension through 1.10.1 for Flask relies on Pickle for serialization, which may lead to remote code execution or local privilege escalation. If an attacker gains access to cache storage (e.g., filesystem, Memcached, Redis, etc.), they can construct a crafted payload, poison the cache, and execute Python code.",
      "cve": "CVE-2021-33026",
      "specs": [
        "<=1.10.1"
      ]
    }
  ],
  "flask-cors": [
    {
      "id": "pyup.io-flask-cors:CVE-2020-25032",
      "advisory": "An issue was discovered in Flask-CORS (aka CORS Middleware for Flask) before 3.0.9. It allows ../ directory traversal to access private resources because resource matching does not ensure that pathnames are in a canonical format.",
      "cve": "CVE-2020-25032",
      "specs": [
        "<3.0.9"
      ]
    }
  ],
  "flask-oidc": [
    {
      "id": "pyup.io-flask-oidc:CVE-2016-1000001",
      "advisory": "flask-oidc version 0.1.2 and earlier is vulnerable to an open redirect",
      "cve": "CVE-2016-1000001",
      "specs": [
        "<=0.1.2"
      ]
    }
  ],
  "flask-restx": [
    {
      "id": "pyup.io-flask-restx:CVE-2021-32838",
      "advisory": "Flask-RESTX (pypi package flask-restx) is a community driven fork of Flask-RESTPlus. Flask-RESTX before version 0.5.1 is vulnerable to ReDoS (Regular Expression Denial of Service) in email_regex. This is fixed in version 0.5.1.",
      "cve": "CVE-2021-32838",
      "specs": [
        "<0.5.1"
      ]
    }
  ],
  "flask-security-too": [
    {
      "id": "pyup.io-flask-security-too:CVE-2021-21241",
      "advisory": "The Python \"Flask-Security-Too\" package is used for adding security features to your Flask application. It is an is a independently maintained version of Flask-Security based on the 3.0.0 version of Flask-Security. In Flask-Security-Too from version 3.3.0 and before version 3.4.5, the /login and /change endpoints can return the authenticated user's authentication token in response to a GET request. Since GET requests aren't protected with a CSRF token, this could lead to a malicious 3rd party site acquiring the authentication token. Version 3.4.5 and version 4.0.0 are patched. As a workaround, if you aren't using authentication tokens - you can set the SECURITY_TOKEN_MAX_AGE to \"0\" (seconds) which should make the token unusable.",
      "cve": "CVE-2021-21241",
      "specs": [
        ">=3.3.0,<3.4.5"
      ]
    }
  ],
  "flask-unchained": [
    {
      "id": "pyup.io-flask-unchained:CVE-2021-23393",
      "advisory": "This affects the package Flask-Unchained before 0.9.0. When using the the _validate_redirect_url function, it is possible to bypass URL validation and redirect a user to an arbitrary URL by providing multiple back slashes such as \\\\\\evil.com/path. This vulnerability is only exploitable if an alternative WSGI server other than Werkzeug is used, or the default behaviour of Werkzeug is modified using 'autocorrect_location_header=False.",
      "cve": "CVE-2021-23393",
      "specs": [
        "<0.9.0"
      ]
    }
  ],
  "formencode": [
    {
      "id": "pyup.io-formencode:CVE-2008-6547",
      "advisory": "schema.py in FormEncode for Python (python-formencode) 1.0 does not apply the chained_validators feature, which allows attackers to bypass intended access restrictions via unknown vectors.",
      "cve": "CVE-2008-6547",
      "specs": [
        "==1.0"
      ]
    }
  ],
  "freewvs": [
    {
      "id": "pyup.io-freewvs:CVE-2020-15100",
      "advisory": "In freewvs before 0.1.1, a user could create a large file that freewvs will try to read, which will terminate a scan process. This has been patched in 0.1.1.",
      "cve": "CVE-2020-15100",
      "specs": [
        "<0.1.1"
      ]
    },
    {
      "id": "pyup.io-freewvs:CVE-2020-15101",
      "advisory": "In freewvs before 0.1.1, a directory structure of more than 1000 nested directories can interrupt a freewvs scan due to Python's recursion limit and os.walk(). This can be problematic in a case where an administrator scans the dirs of potentially untrusted users. This has been patched in 0.1.1.",
      "cve": "CVE-2020-15101",
      "specs": [
        "<0.1.1"
      ]
    }
  ],
  "gateone": [
    {
      "id": "pyup.io-gateone:CVE-2020-19003",
      "advisory": "An issue in Gate One 1.2.0 allows attackers to bypass to the verification check done by the origins list and connect to Gate One instances used by hosts not on the origins list.",
      "cve": "CVE-2020-19003",
      "specs": [
        "==1.2.0"
      ]
    }
  ],
  "gerapy": [
    {
      "id": "pyup.io-gerapy:CVE-2020-7698",
      "advisory": "This affects the package Gerapy from 0 and before 0.9.3. The input being passed to Popen, via the project_configure endpoint, isn\u2019t being sanitized.",
      "cve": "CVE-2020-7698",
      "specs": [
        ">=0.0.0,<0.9.3"
      ]
    }
  ],
  "glances": [
    {
      "id": "pyup.io-glances:CVE-2021-23418",
      "advisory": "The package glances before 3.2.1 are vulnerable to XML External Entity (XXE) Injection via the use of Fault to parse untrusted XML data, which is known to be vulnerable to XML attacks.",
      "cve": "CVE-2021-23418",
      "specs": [
        "<3.2.1"
      ]
    }
  ],
  "google-appengine": [
    {
      "id": "pyup.io-google-appengine:CVE-2011-1364",
      "advisory": "Cross-site request forgery (CSRF) vulnerability in _ah/admin/interactive/execute (aka the Interactive Console) in the SDK Console (aka Admin Console) in the Google App Engine Python SDK before 1.5.4 allows remote attackers to hijack the authentication of administrators for requests that execute arbitrary Python code via the code parameter.",
      "cve": "CVE-2011-1364",
      "specs": [
        "<=1.5.3",
        "==1.0.1",
        "==1.0.2",
        "==1.1.0",
        "==1.1.1",
        "==1.1.2",
        "==1.1.3",
        "==1.1.4",
        "==1.1.5",
        "==1.1.6",
        "==1.1.7",
        "==1.1.8",
        "==1.1.9",
        "==1.2.0",
        "==1.2.1",
        "==1.2.2",
        "==1.2.3",
        "==1.2.4",
        "==1.2.5",
        "==1.2.6",
        "==1.2.7",
        "==1.3.0",
        "==1.3.1",
        "==1.3.2",
        "==1.3.3",
        "==1.3.4",
        "==1.3.5",
        "==1.3.6",
        "==1.3.7",
        "==1.3.8",
        "==1.4.0",
        "==1.4.1",
        "==1.4.2",
        "==1.4.3",
        "==1.5.0",
        "==1.5.1",
        "==1.5.2"
      ]
    },
    {
      "id": "pyup.io-google-appengine:CVE-2011-4211",
      "advisory": "The FakeFile implementation in the sandbox environment in the Google App Engine Python SDK before 1.5.4 does not properly control the opening of files, which allows local users to bypass intended access restrictions and create arbitrary files via ALLOWED_MODES and ALLOWED_DIRS changes within the code parameter to _ah/admin/interactive/execute, a different vulnerability than CVE-2011-1364.",
      "cve": "CVE-2011-4211",
      "specs": [
        "<=1.5.3",
        "==1.0.1",
        "==1.0.2",
        "==1.1.0",
        "==1.1.1",
        "==1.1.2",
        "==1.1.3",
        "==1.1.4",
        "==1.1.5",
        "==1.1.6",
        "==1.1.7",
        "==1.1.8",
        "==1.1.9",
        "==1.2.0",
        "==1.2.1",
        "==1.2.2",
        "==1.2.3",
        "==1.2.4",
        "==1.2.5",
        "==1.2.6",
        "==1.2.7",
        "==1.3.0",
        "==1.3.1",
        "==1.3.2",
        "==1.3.3",
        "==1.3.4",
        "==1.3.5",
        "==1.3.6",
        "==1.3.7",
        "==1.3.8",
        "==1.4.0",
        "==1.4.1",
        "==1.4.2",
        "==1.4.3",
        "==1.5.0",
        "==1.5.1",
        "==1.5.2"
      ]
    },
    {
      "id": "pyup.io-google-appengine:CVE-2011-4212",
      "advisory": "The sandbox environment in the Google App Engine Python SDK before 1.5.4 does not properly prevent os.popen calls, which allows local users to bypass intended access restrictions and execute arbitrary commands via a dev_appserver.RestrictedPathFunction._original_os reference within the code parameter to _ah/admin/interactive/execute, a different vulnerability than CVE-2011-1364.",
      "cve": "CVE-2011-4212",
      "specs": [
        "<=1.5.3",
        "==1.0.1",
        "==1.0.2",
        "==1.1.0",
        "==1.1.1",
        "==1.1.2",
        "==1.1.3",
        "==1.1.4",
        "==1.1.5",
        "==1.1.6",
        "==1.1.7",
        "==1.1.8",
        "==1.1.9",
        "==1.2.0",
        "==1.2.1",
        "==1.2.2",
        "==1.2.3",
        "==1.2.4",
        "==1.2.5",
        "==1.2.6",
        "==1.2.7",
        "==1.3.0",
        "==1.3.1",
        "==1.3.2",
        "==1.3.3",
        "==1.3.4",
        "==1.3.5",
        "==1.3.6",
        "==1.3.7",
        "==1.3.8",
        "==1.4.0",
        "==1.4.1",
        "==1.4.2",
        "==1.4.3",
        "==1.5.0",
        "==1.5.1",
        "==1.5.2"
      ]
    },
    {
      "id": "pyup.io-google-appengine:CVE-2011-4213",
      "advisory": "The sandbox environment in the Google App Engine Python SDK before 1.5.4 does not properly prevent use of the os module, which allows local users to bypass intended access restrictions and execute arbitrary commands via a file_blob_storage.os reference within the code parameter to _ah/admin/interactive/execute, a different vulnerability than CVE-2011-1364.",
      "cve": "CVE-2011-4213",
      "specs": [
        "<1.5.4"
      ]
    }
  ],
  "graphite-web": [
    {
      "id": "pyup.io-graphite-web:CVE-2013-5093",
      "advisory": "The renderLocalView function in render/views.py in graphite-web in Graphite 0.9.5 through 0.9.10 uses the pickle Python module unsafely, which allows remote attackers to execute arbitrary code via a crafted serialized object.",
      "cve": "CVE-2013-5093",
      "specs": [
        "==0.9.10",
        "==0.9.5",
        "==0.9.6",
        "==0.9.7",
        "==0.9.8",
        "==0.9.9"
      ]
    },
    {
      "id": "pyup.io-graphite-web:CVE-2013-5942",
      "advisory": "Graphite 0.9.5 through 0.9.10 uses the pickle Python module unsafely, which allows remote attackers to execute arbitrary code via a crafted serialized object, related to (1) remote_storage.py, (2) storage.py, (3) render/datalib.py, and (4) whitelist/views.py, a different vulnerability than CVE-2013-5093.",
      "cve": "CVE-2013-5942",
      "specs": [
        "==0.9.10",
        "==0.9.5",
        "==0.9.6",
        "==0.9.7",
        "==0.9.8",
        "==0.9.9"
      ]
    },
    {
      "id": "pyup.io-graphite-web:CVE-2013-5943",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in Graphite before 0.9.11 allow remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2013-5943",
      "specs": [
        "<=0.9.10",
        "==0.9.2",
        "==0.9.3",
        "==0.9.4",
        "==0.9.5",
        "==0.9.6",
        "==0.9.7",
        "==0.9.8",
        "==0.9.9"
      ]
    },
    {
      "id": "pyup.io-graphite-web:CVE-2017-18638",
      "advisory": "send_email in graphite-web/webapp/graphite/composer/views.py in Graphite through 1.1.5 is vulnerable to SSRF. The vulnerable SSRF endpoint can be used by an attacker to have the Graphite web server request any resource. The response to this SSRF request is encoded into an image file and then sent to an e-mail address that can be supplied by the attacker. Thus, an attacker can exfiltrate any information.",
      "cve": "CVE-2017-18638",
      "specs": [
        "<=1.1.5"
      ]
    }
  ],
  "grpcio": [
    {
      "id": "pyup.io-grpcio:CVE-2017-7860",
      "advisory": "Google gRPC before 2017-02-22 has an out-of-bounds write caused by a heap-based buffer overflow related to the parse_unix function in core/ext/client_channel/parse_address.c.",
      "cve": "CVE-2017-7860",
      "specs": [
        "<=1.1.2"
      ]
    },
    {
      "id": "pyup.io-grpcio:CVE-2017-7861",
      "advisory": "Google gRPC before 2017-02-22 has an out-of-bounds write related to the gpr_free function in core/lib/support/alloc.c.",
      "cve": "CVE-2017-7861",
      "specs": [
        "<=1.1.2"
      ]
    },
    {
      "id": "pyup.io-grpcio:CVE-2017-8359",
      "advisory": "Google gRPC before 2017-03-29 has an out-of-bounds write caused by a heap-based use-after-free related to the grpc_call_destroy function in core/lib/surface/call.c.",
      "cve": "CVE-2017-8359",
      "specs": [
        "<=1.2.1"
      ]
    },
    {
      "id": "pyup.io-grpcio:CVE-2017-9431",
      "advisory": "Google gRPC before 2017-04-05 has an out-of-bounds write caused by a heap-based buffer overflow related to core/lib/iomgr/error.c.",
      "cve": "CVE-2017-9431",
      "specs": [
        "<=1.2.2"
      ]
    },
    {
      "id": "pyup.io-grpcio:CVE-2020-7768",
      "advisory": "The package grpc before 1.24.4; the package @grpc/grpc-js before 1.1.8 are vulnerable to Prototype Pollution via loadPackageDefinition.",
      "cve": "CVE-2020-7768",
      "specs": [
        "<1.1.8",
        "<1.24.2"
      ]
    }
  ],
  "gunicorn": [
    {
      "id": "pyup.io-gunicorn:CVE-2018-1000164",
      "advisory": "gunicorn version 19.4.5 contains a CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers vulnerability in \"process_headers\" function in \"gunicorn/http/wsgi.py\" that can result in an attacker causing the server to return arbitrary HTTP headers. This vulnerability appears to have been fixed in 19.5.0.",
      "cve": "CVE-2018-1000164",
      "specs": [
        "==19.4.5"
      ]
    }
  ],
  "horizon": [
    {
      "id": "pyup.io-horizon:CVE-2012-2094",
      "advisory": "Cross-site scripting (XSS) vulnerability in the refresh mechanism in the log viewer in horizon/static/horizon/js/horizon.js in OpenStack Dashboard (Horizon) folsom-1 and 2012.1 and earlier allows remote attackers to inject arbitrary web script or HTML via the guest console.",
      "cve": "CVE-2012-2094",
      "specs": [
        "==2012.1",
        "==folsom-1"
      ]
    },
    {
      "id": "pyup.io-horizon:CVE-2012-2144",
      "advisory": "Session fixation vulnerability in OpenStack Dashboard (Horizon) folsom-1 and 2012.1 allows remote attackers to hijack web sessions via the sessionid cookie.",
      "cve": "CVE-2012-2144",
      "specs": [
        "==2012.1",
        "==folsom-1"
      ]
    },
    {
      "id": "pyup.io-horizon:CVE-2012-3426",
      "advisory": "OpenStack Keystone before 2012.1.1, as used in OpenStack Folsom before Folsom-1 and OpenStack Essex, does not properly implement token expiration, which allows remote authenticated users to bypass intended authorization restrictions by (1) creating new tokens through token chaining, (2) leveraging possession of a token for a disabled user account, or (3) leveraging possession of a token for an account with a changed password.",
      "cve": "CVE-2012-3426",
      "specs": [
        "==folsom-1"
      ]
    },
    {
      "id": "pyup.io-horizon:CVE-2012-3540",
      "advisory": "Open redirect vulnerability in views/auth_forms.py in OpenStack Dashboard (Horizon) Essex (2012.1) allows remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via a URL in the next parameter to auth/login/.  NOTE: this issue was originally assigned CVE-2012-3542 by mistake.",
      "cve": "CVE-2012-3540",
      "specs": [
        "==2012.1"
      ]
    },
    {
      "id": "pyup.io-horizon:CVE-2012-3542",
      "advisory": "OpenStack Keystone, as used in OpenStack Folsom before folsom-rc1 and OpenStack Essex (2012.1), allows remote attackers to add an arbitrary user to an arbitrary tenant via a request to update the user's default tenant to the administrative API.  NOTE: this identifier was originally incorrectly assigned to an open redirect issue, but the correct identifier for that issue is CVE-2012-3540.",
      "cve": "CVE-2012-3542",
      "specs": [
        "==folsom-3"
      ]
    },
    {
      "id": "pyup.io-horizon:CVE-2012-5474",
      "advisory": "The file /etc/openstack-dashboard/local_settings within Red Hat OpenStack Platform 2.0 and RHOS Essex Release (python-django-horizon package before 2012.1.1) is world readable and exposes the secret key value.",
      "cve": "CVE-2012-5474",
      "specs": [
        ">=2012.1,<2012.1.1"
      ]
    },
    {
      "id": "pyup.io-horizon:CVE-2012-5476",
      "advisory": "Within the RHOS Essex Preview (2012.2) of the OpenStack dashboard package, the file /etc/quantum/quantum.conf is world readable which exposes the admin password and token value.",
      "cve": "CVE-2012-5476",
      "specs": [
        "==2012.2"
      ]
    },
    {
      "id": "pyup.io-horizon:CVE-2013-4471",
      "advisory": "The Identity v3 API in OpenStack Dashboard (Horizon) before 2013.2 does not require the current password when changing passwords for user accounts, which makes it easier for remote attackers to change a user password by leveraging the authentication token for that user.",
      "cve": "CVE-2013-4471",
      "specs": [
        ">=2013.1,<2013.2"
      ]
    },
    {
      "id": "pyup.io-horizon:CVE-2013-6858",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in OpenStack Dashboard (Horizon) 2013.2 and earlier allow local users to inject arbitrary web script or HTML via an instance name to (1) \"Volumes\" or (2) \"Network Topology\" page.",
      "cve": "CVE-2013-6858",
      "specs": [
        ">=2013.1,<=2013.2"
      ]
    },
    {
      "id": "pyup.io-horizon:CVE-2014-0157",
      "advisory": "Cross-site scripting (XSS) vulnerability in the Horizon Orchestration dashboard in OpenStack Dashboard (aka Horizon) 2013.2 before 2013.2.4 and icehouse before icehouse-rc2 allows remote attackers to inject arbitrary web script or HTML via the description field of a Heat template.",
      "cve": "CVE-2014-0157",
      "specs": [
        "==2013.2",
        "==2013.2.1",
        "==2013.2.2",
        "==2013.2.3"
      ]
    },
    {
      "id": "pyup.io-horizon:CVE-2014-3473",
      "advisory": "Cross-site scripting (XSS) vulnerability in the Orchestration/Stack section in the Horizon Orchestration dashboard in OpenStack Dashboard (Horizon) before 2013.2.4, 2014.1 before 2014.1.2, and Juno before Juno-2, when used with Heat, allows remote Orchestration template owners or catalogs to inject arbitrary web script or HTML via a crafted template.",
      "cve": "CVE-2014-3473",
      "specs": [
        "==juno-1",
        ">=2013.2,<2013.2.4",
        ">=2014.1,<2014.1.2"
      ]
    },
    {
      "id": "pyup.io-horizon:CVE-2014-3474",
      "advisory": "Cross-site scripting (XSS) vulnerability in horizon/static/horizon/js/horizon.instances.js in the Launch Instance menu in OpenStack Dashboard (Horizon) before 2013.2.4, 2014.1 before 2014.1.2, and Juno before Juno-2 allows remote authenticated users to inject arbitrary web script or HTML via a network name.",
      "cve": "CVE-2014-3474",
      "specs": [
        "==juno-1",
        ">=2013.2,<2013.2.4",
        ">=2014.1,<2014.1.2"
      ]
    },
    {
      "id": "pyup.io-horizon:CVE-2014-3475",
      "advisory": "Cross-site scripting (XSS) vulnerability in the Users panel (admin/users/) in OpenStack Dashboard (Horizon) before 2013.2.4, 2014.1 before 2014.1.2, and Juno before Juno-2 allows remote administrators to inject arbitrary web script or HTML via a user email address, a different vulnerability than CVE-2014-8578.",
      "cve": "CVE-2014-3475",
      "specs": [
        "==juno-1",
        ">=2013.2,<2013.2.4",
        ">=2014.1,<2014.1.2"
      ]
    },
    {
      "id": "pyup.io-horizon:CVE-2014-3594",
      "advisory": "Cross-site scripting (XSS) vulnerability in the Host Aggregates interface in OpenStack Dashboard (Horizon) before 2013.2.4, 2014.1 before 2014.1.2, and Juno before Juno-3 allows remote administrators to inject arbitrary web script or HTML via a new host aggregate name.",
      "cve": "CVE-2014-3594",
      "specs": [
        "==juno-1",
        "==juno-2",
        ">=2013.2,<2013.2.4",
        ">=2014.1,<2014.1.2"
      ]
    },
    {
      "id": "pyup.io-horizon:CVE-2014-8124",
      "advisory": "OpenStack Dashboard (Horizon) before 2014.1.3 and 2014.2.x before 2014.2.1 does not properly handle session records when using a db or memcached session engine, which allows remote attackers to cause a denial of service via a large number of requests to the login page.",
      "cve": "CVE-2014-8124",
      "specs": [
        ">=2014.1,<2014.1.3",
        ">=2014.2.0,<2014.2.1"
      ]
    },
    {
      "id": "pyup.io-horizon:CVE-2014-8578",
      "advisory": "Cross-site scripting (XSS) vulnerability in the Groups panel in OpenStack Dashboard (Horizon) before 2013.2.4, 2014.1 before 2014.1.2, and Juno before Juno-2 allows remote administrators to inject arbitrary web script or HTML via a user email address, a different vulnerability than CVE-2014-3475.",
      "cve": "CVE-2014-8578",
      "specs": [
        "<=juno-1",
        "==juno-1",
        ">=2013.2,<2013.2.4",
        ">=2014.1,<2014.1.2"
      ]
    },
    {
      "id": "pyup.io-horizon:CVE-2015-3219",
      "advisory": "Cross-site scripting (XSS) vulnerability in the Orchestration/Stack section in OpenStack Dashboard (Horizon) 2014.2 before 2014.2.4 and 2015.1.x before 2015.1.1 allows remote attackers to inject arbitrary web script or HTML via the description parameter in a heat template, which is not properly handled in the help_text attribute in the Field class.",
      "cve": "CVE-2015-3219",
      "specs": [
        "==2014.2.0",
        "==2014.2.1",
        "==2014.2.2",
        "==2014.2.3",
        "==2015.1.0"
      ]
    },
    {
      "id": "pyup.io-horizon:CVE-2015-3988",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in OpenStack Dashboard (Horizon) 2015.1.0 allow remote authenticated users to inject arbitrary web script or HTML via the metadata to a (1) Glance image, (2) Nova flavor or (3) Host Aggregate.",
      "cve": "CVE-2015-3988",
      "specs": [
        "==2015.1.0"
      ]
    },
    {
      "id": "pyup.io-horizon:CVE-2016-4428",
      "advisory": "Cross-site scripting (XSS) vulnerability in OpenStack Dashboard (Horizon) 8.0.1 and earlier and 9.0.0 through 9.0.1 allows remote authenticated users to inject arbitrary web script or HTML by injecting an AngularJS template in a dashboard form.",
      "cve": "CVE-2016-4428",
      "specs": [
        "==9.0.0",
        "==9.0.1",
        ">=8.0.0,<=8.0.1"
      ]
    },
    {
      "id": "pyup.io-horizon:CVE-2017-7400",
      "advisory": "OpenStack Horizon 9.x through 9.1.1, 10.x through 10.0.2, and 11.0.0 allows remote authenticated administrators to conduct XSS attacks via a crafted federation mapping.",
      "cve": "CVE-2017-7400",
      "specs": [
        "==10.0.0",
        "==10.0.0-b1",
        "==10.0.0-b2",
        "==10.0.0-b3",
        "==10.0.0-rc1",
        "==10.0.0-rc2",
        "==10.0.0-rc3",
        "==10.0.1",
        "==10.0.2",
        "==11.0.0",
        "==9.0.0",
        "==9.0.0-b1",
        "==9.0.0-b2",
        "==9.0.0-b3",
        "==9.0.0-rc1",
        "==9.0.0-rc2",
        "==9.0.1",
        "==9.1.0",
        "==9.1.1"
      ]
    },
    {
      "id": "pyup.io-horizon:CVE-2020-29565",
      "advisory": "An issue was discovered in OpenStack Horizon before 15.3.2, 16.x before 16.2.1, 17.x and 18.x before 18.3.3, 18.4.x, and 18.5.x. There is a lack of validation of the \"next\" parameter, which would allow someone to supply a malicious URL in Horizon that can cause an automatic redirect to the provided malicious URL.",
      "cve": "CVE-2020-29565",
      "specs": [
        ">=15.3.0,<15.3.2",
        ">=16.0.0,<16.2.1",
        ">=17.0.0,<18.3.3",
        ">=18.4.0,<=18.5.0"
      ]
    }
  ],
  "hpack": [
    {
      "id": "pyup.io-hpack:CVE-2016-6581",
      "advisory": "A HTTP/2 implementation built using any version of the Python HPACK library between v1.0.0 and v2.2.0 could be targeted for a denial of service attack, specifically a so-called \"HPACK Bomb\" attack. This attack occurs when an attacker inserts a header field that is exactly the size of the HPACK dynamic header table into the dynamic header table. The attacker can then send a header block that is simply repeated requests to expand that field in the dynamic table. This can lead to a gigantic compression ratio of 4,096 or better, meaning that 16kB of data can decompress to 64MB of data on the target machine.",
      "cve": "CVE-2016-6581",
      "specs": [
        "==1.0",
        "==2.0",
        "==2.0.1",
        "==2.1.1",
        "==2.2"
      ]
    }
  ],
  "html5lib": [
    {
      "id": "pyup.io-html5lib:CVE-2016-9909",
      "advisory": "The serializer in html5lib before 0.99999999 might allow remote attackers to conduct cross-site scripting (XSS) attacks by leveraging mishandling of the < (less than) character in attribute values.",
      "cve": "CVE-2016-9909",
      "specs": [
        "<=0.99999999"
      ]
    },
    {
      "id": "pyup.io-html5lib:CVE-2016-9910",
      "advisory": "The serializer in html5lib before 0.99999999 might allow remote attackers to conduct cross-site scripting (XSS) attacks by leveraging mishandling of special characters in attribute values, a different vulnerability than CVE-2016-9909.",
      "cve": "CVE-2016-9910",
      "specs": [
        "<=0.99999999"
      ]
    }
  ],
  "httplib2": [
    {
      "id": "pyup.io-httplib2:CVE-2013-2037",
      "advisory": "httplib2 0.7.2, 0.8, and earlier, after an initial connection is made, does not verify that the server hostname matches a domain name in the subject's Common Name (CN) or subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
      "cve": "CVE-2013-2037",
      "specs": [
        "<=0.7.2",
        "==0.8"
      ]
    },
    {
      "id": "pyup.io-httplib2:CVE-2020-11078",
      "advisory": "In httplib2 before version 0.18.0, an attacker controlling unescaped part of uri for `httplib2.Http.request()` could change request headers and body, send additional hidden requests to same server. This vulnerability impacts software that uses httplib2 with uri constructed by string concatenation, as opposed to proper urllib building with escaping. This has been fixed in 0.18.0.",
      "cve": "CVE-2020-11078",
      "specs": [
        "<0.18.0"
      ]
    },
    {
      "id": "pyup.io-httplib2:CVE-2021-21240",
      "advisory": "httplib2 is a comprehensive HTTP client library for Python. In httplib2 before version 0.19.0, a malicious server which responds with long series of \"\\xa0\" characters in the \"www-authenticate\" header may cause Denial of Service (CPU burn while parsing header) of the httplib2 client accessing said server. This is fixed in version 0.19.0 which contains a new implementation of auth headers parsing using the pyparsing library.",
      "cve": "CVE-2021-21240",
      "specs": [
        "<0.19.0"
      ]
    }
  ],
  "hyper": [
    {
      "id": "pyup.io-hyper:CVE-2016-6581",
      "advisory": "A HTTP/2 implementation built using any version of the Python HPACK library between v1.0.0 and v2.2.0 could be targeted for a denial of service attack, specifically a so-called \"HPACK Bomb\" attack. This attack occurs when an attacker inserts a header field that is exactly the size of the HPACK dynamic header table into the dynamic header table. The attacker can then send a header block that is simply repeated requests to expand that field in the dynamic table. This can lead to a gigantic compression ratio of 4,096 or better, meaning that 16kB of data can decompress to 64MB of data on the target machine.",
      "cve": "CVE-2016-6581",
      "specs": [
        "==0.4",
        "==0.6"
      ]
    }
  ],
  "hyperkitty": [
    {
      "id": "pyup.io-hyperkitty:CVE-2021-33038",
      "advisory": "An issue was discovered in management/commands/hyperkitty_import.py in HyperKitty through 1.3.4. When importing a private mailing list's archives, these archives are publicly visible for the duration of the import. For example, sensitive information might be available on the web for an hour during a large migration from Mailman 2 to Mailman 3.",
      "cve": "CVE-2021-33038",
      "specs": [
        "<=1.3.4"
      ]
    }
  ],
  "ihatemoney": [
    {
      "id": "pyup.io-ihatemoney:CVE-2020-15120",
      "advisory": "In \"I hate money\" before version 4.1.5, an authenticated member of one project can modify and delete members of another project, without knowledge of this other project's private code. This can be further exploited to access all bills of another project without knowledge of this other project's private code. With the default configuration, anybody is allowed to create a new project. An attacker can create a new project and then use it to become authenticated and exploit this flaw. As such, the exposure is similar to an unauthenticated attack, because it is trivial to become authenticated. This is fixed in version 4.1.5.",
      "cve": "CVE-2020-15120",
      "specs": [
        "<4.1.5"
      ]
    }
  ],
  "impacket": [
    {
      "id": "pyup.io-impacket:CVE-2021-31800",
      "advisory": "Multiple path traversal vulnerabilities exist in smbserver.py in Impacket through 0.9.22. An attacker that connects to a running smbserver instance can list and write to arbitrary files via ../ directory traversal. This could potentially be abused to achieve arbitrary code execution by replacing /etc/shadow or an SSH authorized key.",
      "cve": "CVE-2021-31800",
      "specs": [
        "<=0.9.22"
      ]
    }
  ],
  "indico": [
    {
      "id": "pyup.io-indico:CVE-2021-30185",
      "advisory": "CERN Indico before 2.3.4 can use an attacker-supplied Host header in a password reset link.",
      "cve": "CVE-2021-30185",
      "specs": [
        "<2.3.4"
      ]
    }
  ],
  "indy-node": [
    {
      "id": "pyup.io-indy-node:CVE-2020-11090",
      "advisory": "In Indy Node 1.12.2, there is an Uncontrolled Resource Consumption vulnerability. Indy Node has a bug in TAA handling code. The current primary can be crashed with a malformed transaction from a client, which leads to a view change. Repeated rapid view changes have the potential of bringing down the network. This is fixed in version 1.12.3.",
      "cve": "CVE-2020-11090",
      "specs": [
        "==1.12.2"
      ]
    },
    {
      "id": "pyup.io-indy-node:CVE-2020-11093",
      "advisory": "Hyperledger Indy Node is the server portion of a distributed ledger purpose-built for decentralized identity. In Hyperledger Indy before version 1.12.4, there is lack of signature verification on a specific transaction which enables an attacker to make certain unauthorized alterations to the ledger. Updating a DID with a nym transaction will be written to the ledger if neither ROLE or VERKEY are being changed, regardless of sender. A malicious DID with no particular role can ask an update for another DID (but cannot modify its verkey or role). This is bad because 1) Any DID can write a nym transaction to the ledger (i.e., any DID can spam the ledger with nym transactions), 2) Any DID can change any other DID's alias, 3) The update transaction modifies the ledger metadata associated with a DID.",
      "cve": "CVE-2020-11093",
      "specs": [
        "<1.12.4"
      ]
    }
  ],
  "invenio-app": [
    {
      "id": "pyup.io-invenio-app:CVE-2019-1020006",
      "advisory": "invenio-app before 1.1.1 allows host header injection.",
      "cve": "CVE-2019-1020006",
      "specs": [
        "<1.1.1"
      ]
    }
  ],
  "invenio-communities": [
    {
      "id": "pyup.io-invenio-communities:CVE-2019-1020005",
      "advisory": "invenio-communities before 1.0.0a20 allows XSS.",
      "cve": "CVE-2019-1020005",
      "specs": [
        "==1.0.0-a1",
        "==1.0.0-a10",
        "==1.0.0-a11",
        "==1.0.0-a12",
        "==1.0.0-a13",
        "==1.0.0-a14",
        "==1.0.0-a15",
        "==1.0.0-a16",
        "==1.0.0-a17",
        "==1.0.0-a18",
        "==1.0.0-a19",
        "==1.0.0-a2",
        "==1.0.0-a3",
        "==1.0.0-a4",
        "==1.0.0-a5",
        "==1.0.0-a6",
        "==1.0.0-a7",
        "==1.0.0-a8",
        "==1.0.0-a9"
      ]
    }
  ],
  "invenio-previewer": [
    {
      "id": "pyup.io-invenio-previewer:CVE-2019-1020019",
      "advisory": "invenio-previewer before 1.0.0a12 allows XSS.",
      "cve": "CVE-2019-1020019",
      "specs": [
        "==0.1.0",
        "==1.0.0-a1",
        "==1.0.0-a10",
        "==1.0.0-a11",
        "==1.0.0-a12",
        "==1.0.0-a2",
        "==1.0.0-a3",
        "==1.0.0-a4",
        "==1.0.0-a5",
        "==1.0.0-a6",
        "==1.0.0-a7",
        "==1.0.0-a8",
        "==1.0.0-a9"
      ]
    }
  ],
  "invenio-records": [
    {
      "id": "pyup.io-invenio-records:CVE-2019-1020003",
      "advisory": "invenio-records before 1.2.2 allows XSS.",
      "cve": "CVE-2019-1020003",
      "specs": [
        "<=1.0.1",
        "==1.1.0",
        "==1.2.0",
        "==1.2.1"
      ]
    }
  ],
  "ipsilon": [
    {
      "id": "pyup.io-ipsilon:CVE-2015-5215",
      "advisory": "** DISPUTED ** The default configuration of the Jinja templating engine used in the Identity Provider (IdP) server in Ipsilon 0.1.0 before 1.0.1 does not enable auto-escaping, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks via template variables. NOTE: This may be a duplicate of CVE-2015-5216. Moreover, the Jinja development team does not enable auto-escape by default for performance issues as explained in https://jinja.palletsprojects.com/en/master/faq/#why-is-autoescaping-not-the-default.",
      "cve": "CVE-2015-5215",
      "specs": [
        ">=0.1.0,<1.0.1"
      ]
    },
    {
      "id": "pyup.io-ipsilon:CVE-2015-5216",
      "advisory": "The Identity Provider (IdP) server in Ipsilon 0.1.0 before 1.0.1 does not properly escape certain characters in a Python exception-message template, which makes it easier for remote attackers to conduct cross-site scripting (XSS) attacks via an HTTP response.",
      "cve": "CVE-2015-5216",
      "specs": [
        ">=0.1.0,<1.0.1"
      ]
    },
    {
      "id": "pyup.io-ipsilon:CVE-2015-5217",
      "advisory": "providers/saml2/admin.py in the Identity Provider (IdP) server in Ipsilon 0.1.0 before 1.0.1 does not properly check permissions to update the SAML2 Service Provider (SP) owner, which allows remote authenticated users to cause a denial of service via a duplicate SP name.",
      "cve": "CVE-2015-5217",
      "specs": [
        "==0.1.0",
        "==0.3.0",
        "==0.4.0",
        "==0.5.0",
        "==0.6.0",
        "==1.0.0"
      ]
    },
    {
      "id": "pyup.io-ipsilon:CVE-2015-5301",
      "advisory": "providers/saml2/admin.py in the Identity Provider (IdP) server in Ipsilon 0.1.0 before 1.0.2 and 1.1.x before 1.1.1 does not properly check permissions, which allows remote authenticated users to cause a denial of service by deleting a SAML2 Service Provider (SP).",
      "cve": "CVE-2015-5301",
      "specs": [
        "==0.1.0",
        "==0.3.0",
        "==0.4.0",
        "==0.5.0",
        "==0.6.0",
        "==1.0.0",
        "==1.0.1",
        "==1.1.0"
      ]
    },
    {
      "id": "pyup.io-ipsilon:CVE-2016-8638",
      "advisory": "A vulnerability in ipsilon 2.0 before 2.0.2, 1.2 before 1.2.1, 1.1 before 1.1.2, and 1.0 before 1.0.3 was found that allows attacker to log out active sessions of other users.  This issue is related to how it tracks sessions, and allows an unauthenticated attacker to view and terminate active sessions from other users. It is also called a \"SAML2 multi-session vulnerability.\"",
      "cve": "CVE-2016-8638",
      "specs": [
        "==1.0.0",
        "==1.0.1",
        "==1.0.2",
        "==1.1.0",
        "==1.1.1",
        "==1.2.0",
        "==2.0.0",
        "==2.0.1"
      ]
    }
  ],
  "ipycache": [
    {
      "id": "pyup.io-ipycache:CVE-2019-7539",
      "advisory": "A code injection issue was discovered in ipycache through 2016-05-31.",
      "cve": "CVE-2019-7539",
      "specs": [
        "<=2016-05-31"
      ]
    }
  ],
  "ipython": [
    {
      "id": "pyup.io-ipython:CVE-2015-4706",
      "advisory": "Cross-site scripting (XSS) vulnerability in IPython 3.x before 3.2 allows remote attackers to inject arbitrary web script or HTML via vectors involving JSON error messages and the /api/contents path.",
      "cve": "CVE-2015-4706",
      "specs": [
        "==3.0.0",
        "==3.1.0"
      ]
    },
    {
      "id": "pyup.io-ipython:CVE-2015-4707",
      "advisory": "Cross-site scripting (XSS) vulnerability in IPython before 3.2 allows remote attackers to inject arbitrary web script or HTML via vectors involving JSON error messages and the /api/notebooks path.",
      "cve": "CVE-2015-4707",
      "specs": [
        "<3.2.0"
      ]
    },
    {
      "id": "pyup.io-ipython:CVE-2015-5607",
      "advisory": "Cross-site request forgery in the REST API in IPython 2 and 3.",
      "cve": "CVE-2015-5607",
      "specs": [
        "==2.0.0",
        "==2.1.0",
        "==2.2.0",
        "==2.3.0",
        "==2.3.1",
        "==2.4.0",
        "==2.4.1",
        "==3.0.0",
        "==3.1.0",
        "==3.2.0",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3"
      ]
    }
  ],
  "ironic-inspector": [
    {
      "id": "pyup.io-ironic-inspector:CVE-2019-10141",
      "advisory": "A vulnerability was found in openstack-ironic-inspector all versions excluding 5.0.2, 6.0.3, 7.2.4, 8.0.3 and 8.2.1. A SQL-injection vulnerability was found in openstack-ironic-inspector's node_cache.find_node(). This function makes a SQL query using unfiltered data from a server reporting inspection results (by a POST to the /v1/continue endpoint). Because the API is unauthenticated, the flaw could be exploited by an attacker with access to the network on which ironic-inspector is listening. Because of how ironic-inspector uses the query results, it is unlikely that data could be obtained. However, the attacker could pass malicious data and create a denial of service.",
      "cve": "CVE-2019-10141",
      "specs": [
        "<5.0.2",
        ">=5.1.0,<6.0.3",
        ">=6.1.0,<7.2.4",
        ">=8.0.0,<8.0.3",
        ">=8.1.0,<8.2.1"
      ]
    }
  ],
  "jinja2": [
    {
      "id": "pyup.io-jinja2:CVE-2014-0012",
      "advisory": "FileSystemBytecodeCache in Jinja2 2.7.2 does not properly create temporary directories, which allows local users to gain privileges by pre-creating a temporary directory with a user's uid.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2014-1402.",
      "cve": "CVE-2014-0012",
      "specs": [
        "==2.7.2"
      ]
    },
    {
      "id": "pyup.io-jinja2:CVE-2014-1402",
      "advisory": "The default configuration for bccache.FileSystemBytecodeCache in Jinja2 before 2.7.2 does not properly create temporary files, which allows local users to gain privileges via a crafted .cache file with a name starting with __jinja2_ in /tmp.",
      "cve": "CVE-2014-1402",
      "specs": [
        "<=2.7.1",
        "==2.0",
        "==2.0-rc1",
        "==2.1",
        "==2.1.1",
        "==2.2",
        "==2.2.1",
        "==2.3",
        "==2.3.1",
        "==2.4",
        "==2.4.1",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==2.6",
        "==2.7"
      ]
    },
    {
      "id": "pyup.io-jinja2:CVE-2016-10745",
      "advisory": "In Pallets Jinja before 2.8.1, str.format allows a sandbox escape.",
      "cve": "CVE-2016-10745",
      "specs": [
        "<2.8.1"
      ]
    },
    {
      "id": "pyup.io-jinja2:CVE-2019-10906",
      "advisory": "In Pallets Jinja before 2.10.1, str.format_map allows a sandbox escape.",
      "cve": "CVE-2019-10906",
      "specs": [
        "<2.10.1"
      ]
    },
    {
      "id": "pyup.io-jinja2:CVE-2019-8341",
      "advisory": "** DISPUTED ** An issue was discovered in Jinja2 2.10. The from_string function is prone to Server Side Template Injection (SSTI) where it takes the \"source\" parameter as a template object, renders it, and then returns it. The attacker can exploit it with {{INJECTION COMMANDS}} in a URI. NOTE: The maintainer and multiple third parties believe that this vulnerability isn't valid because users shouldn't use untrusted templates without sandboxing.",
      "cve": "CVE-2019-8341",
      "specs": [
        "==2.10"
      ]
    },
    {
      "id": "pyup.io-jinja2:CVE-2020-28493",
      "advisory": "This affects the package jinja2 from 0.0.0 and before 2.11.3. The ReDoS vulnerability is mainly due to the `_punctuation_re regex` operator and its use of multiple wildcards. The last wildcard is the most exploitable as it searches for trailing punctuation. This issue can be mitigated by Markdown to format user content instead of the urlize filter, or by implementing request timeouts and limiting process memory.",
      "cve": "CVE-2020-28493",
      "specs": [
        "<2.11.3"
      ]
    }
  ],
  "jsnapy": [
    {
      "id": "pyup.io-jsnapy:CVE-2018-0023",
      "advisory": "JSNAPy is an open source python version of Junos Snapshot Administrator developed by Juniper available through github. The default configuration and sample files of JSNAPy automation tool versions prior to 1.3.0 are created world writable. This insecure file and directory permission allows unprivileged local users to alter the files under this directory including inserting operations not intended by the package maintainer, system administrator, or other users. This issue only affects users who downloaded and installed JSNAPy from github.",
      "cve": "CVE-2018-0023",
      "specs": [
        "<1.3.0"
      ]
    }
  ],
  "jsonpickle": [
    {
      "id": "pyup.io-jsonpickle:CVE-2020-22083",
      "advisory": "** DISPUTED ** jsonpickle through 1.4.1 allows remote code execution during deserialization of a malicious payload through the decode() function. Note: It has been argued that this is expected and clearly documented behaviour. pickle is known to be capable of causing arbitrary code execution, and must not be used with un-trusted data.",
      "cve": "CVE-2020-22083",
      "specs": [
        "<=1.4.1"
      ]
    }
  ],
  "jupyter-server": [
    {
      "id": "pyup.io-jupyter-server:CVE-2020-26232",
      "advisory": "Jupyter Server before version 1.0.6 has an Open redirect vulnerability. A maliciously crafted link to a jupyter server could redirect the browser to a different website. All jupyter servers are technically affected, however, these maliciously crafted links can only be reasonably made for known jupyter server hosts. A link to your jupyter server may appear safe, but ultimately redirect to a spoofed server on the public internet.",
      "cve": "CVE-2020-26232",
      "specs": [
        "<1.0.6"
      ]
    },
    {
      "id": "pyup.io-jupyter-server:CVE-2020-26275",
      "advisory": "The Jupyter Server provides the backend (i.e. the core services, APIs, and REST endpoints) for Jupyter web applications like Jupyter notebook, JupyterLab, and Voila. In Jupyter Server before version 1.1.1, an open redirect vulnerability could cause the jupyter server to redirect the browser to a different malicious website. All jupyter servers running without a base_url prefix are technically affected, however, these maliciously crafted links can only be reasonably made for known jupyter server hosts. A link to your jupyter server may *appear* safe, but ultimately redirect to a spoofed server on the public internet. This same vulnerability was patched in upstream notebook v5.7.8. This is fixed in jupyter_server 1.1.1. If upgrade is not available, a workaround can be to run your server on a url prefix: \"jupyter server --ServerApp.base_url=/jupyter/\".",
      "cve": "CVE-2020-26275",
      "specs": [
        "<1.1.1"
      ]
    }
  ],
  "jupyterhub": [
    {
      "id": "pyup.io-jupyterhub:CVE-2019-10255",
      "advisory": "An Open Redirect vulnerability for all browsers in Jupyter Notebook before 5.7.7 and some browsers (Chrome, Firefox) in JupyterHub before 0.9.5 allows crafted links to the login page, which will redirect to a malicious site after successful login. Servers running on a base_url prefix are not affected.",
      "cve": "CVE-2019-10255",
      "specs": [
        "<0.9.5"
      ]
    },
    {
      "id": "pyup.io-jupyterhub:CVE-2020-36191",
      "advisory": "JupyterHub 1.1.0 allows CSRF in the admin panel via a request that lacks an _xsrf field, as demonstrated by a /hub/api/user request (to add or remove a user account).",
      "cve": "CVE-2020-36191",
      "specs": [
        "==1.1.0"
      ]
    },
    {
      "id": "pyup.io-jupyterhub:CVE-2021-41247",
      "advisory": "JupyterHub is an open source multi-user server for Jupyter notebooks. In affected versions users who have multiple JupyterLab tabs open in the same browser session, may see incomplete logout from the single-user server, as fresh credentials (for the single-user server only, not the Hub) reinstated after logout, if another active JupyterLab session is open while the logout takes place. Upgrade to JupyterHub 1.5. For distributed deployments, it is jupyterhub in the _user_ environment that needs patching. There are no patches necessary in the Hub environment. The only workaround is to make sure that only one JupyterLab tab is open when you log out.",
      "cve": "CVE-2021-41247",
      "specs": [
        ">=1.0.0,<1.5.0"
      ]
    }
  ],
  "jupyterhub-firstuseauthenticator": [
    {
      "id": "pyup.io-jupyterhub-firstuseauthenticator:CVE-2021-41194",
      "advisory": "FirstUseAuthenticator is a JupyterHub authenticator that helps new users set their password on their first login to JupyterHub. When JupyterHub is used with FirstUseAuthenticator, a vulnerability in versions prior to 1.0.0 allows unauthorized access to any user's account if `create_users=True` and the username is known or guessed. One may upgrade to version 1.0.0 or apply a patch manually to mitigate the vulnerability. For those who cannot upgrade, there is no complete workaround, but a partial mitigation exists. One can disable user creation with `c.FirstUseAuthenticator.create_users = False`, which will only allow login with fully normalized usernames for already existing users prior to jupyterhub-firstuserauthenticator 1.0.0. If any users have never logged in with their normalized username (i.e. lowercase), they will still be vulnerable until a patch or upgrade occurs.",
      "cve": "CVE-2021-41194",
      "specs": [
        "<1.0.0"
      ]
    }
  ],
  "jupyterhub-kubespawner": [
    {
      "id": "pyup.io-jupyterhub-kubespawner:CVE-2020-15110",
      "advisory": "In jupyterhub-kubespawner before 0.12, certain usernames will be able to craft particular server names which will grant them access to the default server of other users who have matching usernames. This has been fixed in 0.12.",
      "cve": "CVE-2020-15110",
      "specs": [
        "<0.12"
      ]
    }
  ],
  "jupyterhub-systemdspawner": [
    {
      "id": "pyup.io-jupyterhub-systemdspawner:CVE-2020-26261",
      "advisory": "jupyterhub-systemdspawner enables JupyterHub to spawn single-user notebook servers using systemd. In jupyterhub-systemdspawner before version 0.15 user API tokens issued to single-user servers are specified in the environment of systemd units. These tokens are incorrectly accessible to all users. In particular, the-littlest-jupyterhub is affected, which uses systemdspawner by default. This is patched in jupyterhub-systemdspawner v0.15",
      "cve": "CVE-2020-26261",
      "specs": [
        "<0.15"
      ]
    }
  ],
  "jw.util": [
    {
      "id": "pyup.io-jw.util:CVE-2020-13388",
      "advisory": "An exploitable vulnerability exists in the configuration-loading functionality of the jw.util package before 2.3 for Python. When loading a configuration with FromString or FromStream with YAML, one can execute arbitrary Python code, resulting in OS command execution, because safe_load is not used.",
      "cve": "CVE-2020-13388",
      "specs": [
        "<2.3"
      ]
    }
  ],
  "kdcproxy": [
    {
      "id": "pyup.io-kdcproxy:CVE-2015-5159",
      "advisory": "python-kdcproxy before 0.3.2 allows remote attackers to cause a denial of service via a large POST request.",
      "cve": "CVE-2015-5159",
      "specs": [
        "<0.3.2"
      ]
    }
  ],
  "keyring": [
    {
      "id": "pyup.io-keyring:CVE-2012-4571",
      "advisory": "Python Keyring 0.9.1 does not securely initialize the cipher when encrypting passwords for CryptedFileKeyring files, which makes it easier for local users to obtain passwords via a brute-force attack.",
      "cve": "CVE-2012-4571",
      "specs": [
        "==0.9.1"
      ]
    },
    {
      "id": "pyup.io-keyring:CVE-2012-5577",
      "advisory": "Python keyring lib before 0.10 created keyring files with world-readable permissions.",
      "cve": "CVE-2012-5577",
      "specs": [
        "<0.10"
      ]
    },
    {
      "id": "pyup.io-keyring:CVE-2012-5578",
      "advisory": "Python keyring has insecure permissions on new databases allowing world-readable files to be created",
      "cve": "CVE-2012-5578",
      "specs": [
        "<=0.10"
      ]
    }
  ],
  "keystone": [
    {
      "id": "pyup.io-keystone:CVE-2012-3426",
      "advisory": "OpenStack Keystone before 2012.1.1, as used in OpenStack Folsom before Folsom-1 and OpenStack Essex, does not properly implement token expiration, which allows remote authenticated users to bypass intended authorization restrictions by (1) creating new tokens through token chaining, (2) leveraging possession of a token for a disabled user account, or (3) leveraging possession of a token for an account with a changed password.",
      "cve": "CVE-2012-3426",
      "specs": [
        "==2012.1",
        "==2012.1.1"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2012-4413",
      "advisory": "OpenStack Keystone 2012.1.3 does not invalidate existing tokens when granting or revoking roles, which allows remote authenticated users to retain the privileges of the revoked roles.",
      "cve": "CVE-2012-4413",
      "specs": [
        "==2012.1.3"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2012-4456",
      "advisory": "The (1) OS-KSADM/services and (2) tenant APIs in OpenStack Keystone Essex before 2012.1.2 and Folsom before folsom-2 do not properly validate X-Auth-Token, which allow remote attackers to read the roles for an arbitrary user or get, create, or delete arbitrary services.",
      "cve": "CVE-2012-4456",
      "specs": [
        "==2012.2-milestone1",
        ">=2012.1,<2012.1.2"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2012-4457",
      "advisory": "OpenStack Keystone Essex before 2012.1.2 and Folsom before folsom-3 does not properly handle authorization tokens for disabled tenants, which allows remote authenticated users to access the tenant's resources by requesting a token for the tenant.",
      "cve": "CVE-2012-4457",
      "specs": [
        "==2012.2-milestone1",
        "==2012.2-milestone2",
        ">=2012.1,<2012.1.2"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2012-5483",
      "advisory": "tools/sample_data.sh in OpenStack Keystone 2012.1.3, when access to Amazon Elastic Compute Cloud (Amazon EC2) is configured, uses world-readable permissions for /etc/keystone/ec2rc, which allows local users to obtain access to EC2 services by reading administrative access and secret values from this file.",
      "cve": "CVE-2012-5483",
      "specs": [
        "==2012.1.3"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2013-0247",
      "advisory": "OpenStack Keystone Essex 2012.1.3 and earlier, Folsom 2012.2.3 and earlier, and Grizzly grizzly-2 and earlier allows remote attackers to cause a denial of service (disk consumption) via many invalid token requests that trigger excessive generation of log entries.",
      "cve": "CVE-2013-0247",
      "specs": [
        ">=2012.1,<=2012.1.3",
        ">=2012.2,<=2012.2.3",
        ">=2013.1,<=2013.1.2"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2013-0270",
      "advisory": "OpenStack Keystone Grizzly before 2013.1, Folsom, and possibly earlier allows remote attackers to cause a denial of service (CPU and memory consumption) via a large HTTP request, as demonstrated by a long tenant_name when requesting a token.",
      "cve": "CVE-2013-0270",
      "specs": [
        "==2013.1-milestone1",
        "==2013.1-milestone2",
        "==2013.1-milestone3",
        ">=2012.1,<=2012.1.3",
        ">=2012.2,<=2012.2.4"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2013-0282",
      "advisory": "OpenStack Keystone Grizzly before 2013.1, Folsom 2012.1.3 and earlier, and Essex does not properly check if the (1) user, (2) tenant, or (3) domain is enabled when using EC2-style authentication, which allows context-dependent attackers to bypass access restrictions.",
      "cve": "CVE-2013-0282",
      "specs": [
        "==2013.1-milestone1",
        "==2013.1-milestone2",
        "==2013.1-milestone3",
        ">=2012.1,<=2012.1.3",
        ">=2012.2,<=2012.2.4"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2013-2006",
      "advisory": "OpenStack Identity (Keystone) Grizzly 2013.1.1, when DEBUG mode logging is enabled, logs the (1) admin_token and (2) LDAP password in plaintext, which allows local users to obtain sensitive by reading the log file.",
      "cve": "CVE-2013-2006",
      "specs": [
        "==2013.1.1"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2013-2014",
      "advisory": "OpenStack Identity (Keystone) before 2013.1 allows remote attackers to cause a denial of service (memory consumption and crash) via multiple long requests.",
      "cve": "CVE-2013-2014",
      "specs": [
        ">=2013,<2013.1"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2013-2059",
      "advisory": "OpenStack Identity (Keystone) Folsom 2012.2.4 and earlier, Grizzly before 2013.1.1, and Havana does not immediately revoke the authentication token when deleting a user through the Keystone v2 API, which allows remote authenticated users to retain access via the token.",
      "cve": "CVE-2013-2059",
      "specs": [
        "==2012.1",
        "==2013.1"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2013-2157",
      "advisory": "OpenStack Keystone Folsom, Grizzly before 2013.1.3, and Havana, when using LDAP with Anonymous binding, allows remote attackers to bypass authentication via an empty password.",
      "cve": "CVE-2013-2157",
      "specs": [
        ">=2012.2,<=2012.2.4",
        ">=2013.1,<2013.1.3",
        ">=2013.2,<=2013.2.4"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2013-2255",
      "advisory": "HTTPSConnections in OpenStack Keystone 2013, OpenStack Compute 2013.1, and possibly other OpenStack components, fail to validate server-side SSL certificates.",
      "cve": "CVE-2013-2255",
      "specs": [
        "==2013"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2013-4222",
      "advisory": "OpenStack Identity (Keystone) Folsom, Grizzly 2013.1.3 and earlier, and Havana before havana-3 does not properly revoke user tokens when a tenant is disabled, which allows remote authenticated users to retain access via the token.",
      "cve": "CVE-2013-4222",
      "specs": [
        ">=2013.1,<=2013.1.3"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2013-4294",
      "advisory": "The (1) mamcache and (2) KVS token backends in OpenStack Identity (Keystone) Folsom 2012.2.x and Grizzly before 2013.1.4 do not properly compare the PKI token revocation list with PKI tokens, which allow remote attackers to bypass intended access restrictions via a revoked PKI token.",
      "cve": "CVE-2013-4294",
      "specs": [
        "==2012.2",
        "==2012.2.1",
        "==2012.2.2",
        "==2012.2.3",
        "==2012.2.4",
        "==2013.1",
        "==2013.1.1",
        "==2013.1.2",
        "==2013.1.3"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2013-6391",
      "advisory": "The ec2tokens API in OpenStack Identity (Keystone) before Havana 2013.2.1 and Icehouse before icehouse-2 does not return a trust-scoped token when one is received, which allows remote trust users to gain privileges by generating EC2 credentials from a trust-scoped token and using them in an ec2tokens API request.",
      "cve": "CVE-2013-6391",
      "specs": [
        ">=2013.2,<2013.2.1"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2014-0204",
      "advisory": "OpenStack Identity (Keystone) before 2014.1.1 does not properly handle when a role is assigned to a group that has the same ID as a user, which allows remote authenticated users to gain privileges that are assigned to a group with the same ID.",
      "cve": "CVE-2014-0204",
      "specs": [
        ">=2014.1,<2014.1.1"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2014-2237",
      "advisory": "The memcache token backend in OpenStack Identity (Keystone) 2013.1 through 2.013.1.4, 2013.2 through 2013.2.2, and icehouse before icehouse-3, when issuing a trust token with impersonation enabled, does not include this token in the trustee's token-index-list, which prevents the token from being invalidated by bulk token revocation and allows the trustee to bypass intended access restrictions.",
      "cve": "CVE-2014-2237",
      "specs": [
        "==2013.1",
        "==2013.1.1",
        "==2013.1.2",
        "==2013.1.3",
        "==2013.1.4",
        "==2013.2.2"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2014-2828",
      "advisory": "The V3 API in OpenStack Identity (Keystone) 2013.1 before 2013.2.4 and icehouse before icehouse-rc2 allows remote attackers to cause a denial of service (CPU consumption) via a large number of the same authentication method in a request, aka \"authentication chaining.\"",
      "cve": "CVE-2014-2828",
      "specs": [
        "==2013.1",
        "==2013.1.1",
        "==2013.1.2",
        "==2013.1.3",
        "==2013.2",
        "==2013.2.1",
        "==2013.2.2",
        "==2013.2.3"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2014-3476",
      "advisory": "OpenStack Identity (Keystone) before 2013.2.4, 2014.1 before 2014.1.2, and Juno before Juno-2 does not properly handle chained delegation, which allows remote authenticated users to gain privileges by leveraging a (1) trust or (2) OAuth token with impersonation enabled to create a new token with additional roles.",
      "cve": "CVE-2014-3476",
      "specs": [
        ">=2013.2,<2013.2.4",
        ">=2014.1,<2014.1.2"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2014-3520",
      "advisory": "OpenStack Identity (Keystone) before 2013.2.4, 2014.x before 2014.1.2, and Juno before Juno-2 allows remote authenticated trustees to gain access to an unauthorized project for which the trustor has certain roles via the project ID in a V2 API trust token request.",
      "cve": "CVE-2014-3520",
      "specs": [
        ">=2013.2,<2013.2.4",
        ">=2014.1,<2014.1.2"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2014-3621",
      "advisory": "The catalog url replacement in OpenStack Identity (Keystone) before 2013.2.3 and 2014.1 before 2014.1.2.1 allows remote authenticated users to read sensitive configuration options via a crafted endpoint, as demonstrated by \"$(admin_token)\" in the publicurl endpoint field.",
      "cve": "CVE-2014-3621",
      "specs": [
        ">=2013.2,<2013.2.3",
        ">=2014.1,<2014.1.2.1"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2014-5251",
      "advisory": "The MySQL token driver in OpenStack Identity (Keystone) 2014.1.x before 2014.1.2.1 and Juno before Juno-3 stores timestamps with the incorrect precision, which causes the expiration comparison for tokens to fail and allows remote authenticated users to retain access via an expired token.",
      "cve": "CVE-2014-5251",
      "specs": [
        "==2014.1",
        "==2014.1.2",
        "==juno-1",
        "==juno-2"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2014-5252",
      "advisory": "The V3 API in OpenStack Identity (Keystone) 2014.1.x before 2014.1.2.1 and Juno before Juno-3 updates the issued_at value for UUID v2 tokens, which allows remote authenticated users to bypass the token expiration and retain access via a verification (1) GET or (2) HEAD request to v3/auth/tokens/.",
      "cve": "CVE-2014-5252",
      "specs": [
        "==2014.1",
        "==2014.1.2",
        "==juno-1",
        "==juno-2"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2014-5253",
      "advisory": "OpenStack Identity (Keystone) 2014.1.x before 2014.1.2.1 and Juno before Juno-3 does not properly revoke tokens when a domain is invalidated, which allows remote authenticated users to retain access via a domain-scoped token for that domain.",
      "cve": "CVE-2014-5253",
      "specs": [
        "==2014.1",
        "==2014.1.2",
        "==juno-1",
        "==juno-2"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2015-3646",
      "advisory": "OpenStack Identity (Keystone) before 2014.1.5 and 2014.2.x before 2014.2.4 logs the backend_argument configuration option content, which allows remote authenticated users to obtain passwords and other sensitive backend information by reading the Keystone logs.",
      "cve": "CVE-2015-3646",
      "specs": [
        ">=2014.1,<2014.1.5",
        ">=2014.2.0,<2014.2.4"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2015-7546",
      "advisory": "The identity service in OpenStack Identity (Keystone) before 2015.1.3 (Kilo) and 8.0.x before 8.0.2 (Liberty) and keystonemiddleware (formerly python-keystoneclient) before 1.5.4 (Kilo) and Liberty before 2.3.3 does not properly invalidate authorization tokens when using the PKI or PKIZ token providers, which allows remote authenticated users to bypass intended access restrictions and gain access to cloud resources by manipulating byte fields within a revoked token.",
      "cve": "CVE-2015-7546",
      "specs": [
        ">=2015.1.0,<=2015.1.2",
        ">=8.0.0,<8.0.2"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2018-14432",
      "advisory": "In the Federation component of OpenStack Keystone before 11.0.4, 12.0.0, and 13.0.0, an authenticated \"GET /v3/OS-FEDERATION/projects\" request may bypass intended access restrictions on listing projects. An authenticated user may discover projects they have no authority to access, leaking all projects in the deployment and their attributes. Only Keystone with the /v3/OS-FEDERATION endpoint enabled via policy.json is affected.",
      "cve": "CVE-2018-14432",
      "specs": [
        "<11.0.4",
        "==12.0.0",
        "==13.0.0"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2018-20170",
      "advisory": "** DISPUTED ** OpenStack Keystone through 14.0.1 has a user enumeration vulnerability because invalid usernames have much faster responses than valid ones for a POST /v3/auth/tokens request. NOTE: the vendor's position is that this is a hardening opportunity, and not necessarily an issue that should have an OpenStack Security Advisory.",
      "cve": "CVE-2018-20170",
      "specs": [
        "<=14.0.1"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2019-19687",
      "advisory": "OpenStack Keystone 15.0.0 and 16.0.0 is affected by Data Leakage in the list credentials API. Any user with a role on a project is able to list any credentials with the /v3/credentials API when enforce_scope is false. Users with a role on a project are able to view any other users' credentials, which could (for example) leak sign-on information for Time-based One Time Passwords (TOTP). Deployments with enforce_scope set to false are affected. (There will be a slight performance impact for the list credentials API once this issue is fixed.)",
      "cve": "CVE-2019-19687",
      "specs": [
        "==15.0.0",
        "==16.0.0"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2020-12689",
      "advisory": "An issue was discovered in OpenStack Keystone before 15.0.1, and 16.0.0. Any user authenticated within a limited scope (trust/oauth/application credential) can create an EC2 credential with an escalated permission, such as obtaining admin while the user is on a limited viewer role. This potentially allows a malicious user to act as the admin on a project another user has the admin role on, which can effectively grant that user global admin privileges.",
      "cve": "CVE-2020-12689",
      "specs": [
        "<15.0.1",
        "==16.0.0"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2020-12690",
      "advisory": "An issue was discovered in OpenStack Keystone before 15.0.1, and 16.0.0. The list of roles provided for an OAuth1 access token is silently ignored. Thus, when an access token is used to request a keystone token, the keystone token contains every role assignment the creator had for the project. This results in the provided keystone token having more role assignments than the creator intended, possibly giving unintended escalated access.",
      "cve": "CVE-2020-12690",
      "specs": [
        "<15.0.1",
        "==16.0.0"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2020-12691",
      "advisory": "An issue was discovered in OpenStack Keystone before 15.0.1, and 16.0.0. Any authenticated user can create an EC2 credential for themselves for a project that they have a specified role on, and then perform an update to the credential user and project, allowing them to masquerade as another user. This potentially allows a malicious user to act as the admin on a project another user has the admin role on, which can effectively grant that user global admin privileges.",
      "cve": "CVE-2020-12691",
      "specs": [
        "<15.0.1",
        "==16.0.0"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2020-12692",
      "advisory": "An issue was discovered in OpenStack Keystone before 15.0.1, and 16.0.0. The EC2 API doesn't have a signature TTL check for AWS Signature V4. An attacker can sniff the Authorization header, and then use it to reissue an OpenStack token an unlimited number of times.",
      "cve": "CVE-2020-12692",
      "specs": [
        "<15.0.1",
        "==16.0.0"
      ]
    },
    {
      "id": "pyup.io-keystone:CVE-2021-38155",
      "advisory": "OpenStack Keystone 10.x through 16.x before 16.0.2, 17.x before 17.0.1, 18.x before 18.0.1, and 19.x before 19.0.1 allows information disclosure during account locking (related to PCI DSS features). By guessing the name of an account and failing to authenticate multiple times, any unauthenticated actor could both confirm the account exists and obtain that account's corresponding UUID, which might be leveraged for other unrelated attacks. All deployments enabling security_compliance.lockout_failure_attempts are affected.",
      "cve": "CVE-2021-38155",
      "specs": [
        ">=10.0.0,<16.0.2",
        ">=17.0.0,<17.0.1",
        ">=18.0.0,<18.0.1",
        ">=19.0.0,<19.0.1"
      ]
    }
  ],
  "keystonemiddleware": [
    {
      "id": "pyup.io-keystonemiddleware:CVE-2014-7144",
      "advisory": "OpenStack keystonemiddleware (formerly python-keystoneclient) 0.x before 0.11.0 and 1.x before 1.2.0 disables certification verification when the \"insecure\" option is set in a paste configuration (paste.ini) file regardless of the value, which allows remote attackers to conduct man-in-the-middle attacks via a crafted certificate.",
      "cve": "CVE-2014-7144",
      "specs": [
        "==1.0.0",
        "==1.1.0",
        "==1.1.1"
      ]
    },
    {
      "id": "pyup.io-keystonemiddleware:CVE-2015-1852",
      "advisory": "The s3_token middleware in OpenStack keystonemiddleware before 1.6.0 and python-keystoneclient before 1.4.0 disables certification verification when the \"insecure\" option is set in a paste configuration (paste.ini) file regardless of the value, which allows remote attackers to conduct man-in-the-middle attacks via a crafted certificate, a different vulnerability than CVE-2014-7144.",
      "cve": "CVE-2015-1852",
      "specs": [
        "<=1.5.0"
      ]
    },
    {
      "id": "pyup.io-keystonemiddleware:CVE-2015-7546",
      "advisory": "The identity service in OpenStack Identity (Keystone) before 2015.1.3 (Kilo) and 8.0.x before 8.0.2 (Liberty) and keystonemiddleware (formerly python-keystoneclient) before 1.5.4 (Kilo) and Liberty before 2.3.3 does not properly invalidate authorization tokens when using the PKI or PKIZ token providers, which allows remote authenticated users to bypass intended access restrictions and gain access to cloud resources by manipulating byte fields within a revoked token.",
      "cve": "CVE-2015-7546",
      "specs": [
        ">=1.5.0,<=1.5.3",
        ">=1.6.0,<=2.3.2"
      ]
    }
  ],
  "koji": [
    {
      "id": "pyup.io-koji:CVE-2017-1002153",
      "advisory": "Koji 1.13.0 does not properly validate SCM paths, allowing an attacker to work around blacklisted paths for build submission.",
      "cve": "CVE-2017-1002153",
      "specs": [
        "==1.13.0"
      ]
    },
    {
      "id": "pyup.io-koji:CVE-2018-1002150",
      "advisory": "Koji version 1.12, 1.13, 1.14 and 1.15 contain an incorrect access control vulnerability resulting in arbitrary filesystem read/write access. This vulnerability has been fixed in versions 1.12.1, 1.13.1, 1.14.1 and 1.15.1.",
      "cve": "CVE-2018-1002150",
      "specs": [
        "==1.12.0",
        "==1.13.0",
        "==1.14.0",
        "==1.15.0"
      ]
    },
    {
      "id": "pyup.io-koji:CVE-2019-17109",
      "advisory": "Koji through 1.18.0 allows remote Directory Traversal, with resultant Privilege Escalation.",
      "cve": "CVE-2019-17109",
      "specs": [
        "<=1.18.0"
      ]
    }
  ],
  "kotti": [
    {
      "id": "pyup.io-kotti:CVE-2018-9856",
      "advisory": "Kotti before 1.3.2 and 2.x before 2.0.0b2 has CSRF in the local roles implementation, as demonstrated by triggering a permission change via a /admin-document/@@share request.",
      "cve": "CVE-2018-9856",
      "specs": [
        "<1.3.2",
        "==2.0.0-alpha1",
        "==2.0.0b1"
      ]
    }
  ],
  "ladon": [
    {
      "id": "pyup.io-ladon:CVE-2019-1010268",
      "advisory": "Ladon since 0.6.1 (since ebef0aae48af78c159b6fce81bc6f5e7e0ddb059) is affected by: XML External Entity (XXE). The impact is: Information Disclosure, reading files and reaching internal network endpoints. The component is: SOAP request handlers. For instance: https://bitbucket.org/jakobsg/ladon/src/42944fc012a3a48214791c120ee5619434505067/src/ladon/interfaces/soap.py#lines-688. The attack vector is: Send a specially crafted SOAP call.",
      "cve": "CVE-2019-1010268",
      "specs": [
        ">=0.6.1,<=0.9.40"
      ]
    }
  ],
  "leo": [
    {
      "id": "pyup.io-leo:CVE-2020-23478",
      "advisory": "Leo Editor v6.2.1 was discovered to contain a regular expression denial of service (ReDoS) vulnerability in the component plugins/importers/dart.py.",
      "cve": "CVE-2020-23478",
      "specs": [
        "==6.2.1"
      ]
    }
  ],
  "libtaxii": [
    {
      "id": "pyup.io-libtaxii:CVE-2020-27197",
      "advisory": "** DISPUTED ** TAXII libtaxii through 1.1.117, as used in EclecticIQ OpenTAXII through 0.2.0 and other products, allows SSRF via an initial http:// substring to the parse method, even when the no_network setting is used for the XML parser. NOTE: the vendor points out that the parse method \"wraps the lxml library\" and that this may be an issue to \"raise ... to the lxml group.\"",
      "cve": "CVE-2020-27197",
      "specs": [
        "<=1.1.117"
      ]
    }
  ],
  "limnoria": [
    {
      "id": "pyup.io-limnoria:CVE-2019-19010",
      "advisory": "Eval injection in the Math plugin of Limnoria (before 2019.11.09) and Supybot (through 2018-05-09) allows remote unprivileged attackers to disclose information or possibly have unspecified other impact via the calc and icalc IRC commands.",
      "cve": "CVE-2019-19010",
      "specs": [
        "<2019.11.09"
      ]
    }
  ],
  "lin-cms": [
    {
      "id": "pyup.io-lin-cms:CVE-2020-18698",
      "advisory": "Improper Authentication in Lin-CMS-Flask v0.1.1 allows remote attackers to launch brute force login attempts without restriction via the 'login' function in the component 'app/api/cms/user.py'.",
      "cve": "CVE-2020-18698",
      "specs": [
        "==0.1.1"
      ]
    },
    {
      "id": "pyup.io-lin-cms:CVE-2020-18699",
      "advisory": "Cross Site Scripting (XSS) in Lin-CMS-Flask v0.1.1 allows remote attackers to execute arbitrary code by entering scripts in the the 'Username' parameter of the in component 'app/api/cms/user.py'.",
      "cve": "CVE-2020-18699",
      "specs": [
        "==0.1.1"
      ]
    },
    {
      "id": "pyup.io-lin-cms:CVE-2020-18701",
      "advisory": "Incorrect Access Control in Lin-CMS-Flask v0.1.1 allows remote attackers to obtain sensitive information and/or gain privileges due to the application not invalidating a user's authentication token upon logout, which allows for replaying packets.",
      "cve": "CVE-2020-18701",
      "specs": [
        "==0.1.1"
      ]
    }
  ],
  "localstack": [
    {
      "id": "pyup.io-localstack:CVE-2021-32090",
      "advisory": "The dashboard component of StackLift LocalStack 0.12.6 allows attackers to inject arbitrary shell commands via the functionName parameter.",
      "cve": "CVE-2021-32090",
      "specs": [
        "==0.12.6"
      ]
    },
    {
      "id": "pyup.io-localstack:CVE-2021-32091",
      "advisory": "A Cross-site scripting (XSS) vulnerability exists in StackLift LocalStack 0.12.6.",
      "cve": "CVE-2021-32091",
      "specs": [
        "==0.12.6"
      ]
    }
  ],
  "logilab-common": [
    {
      "id": "pyup.io-logilab-common:CVE-2014-1838",
      "advisory": "The (1) extract_keys_from_pdf and (2) fill_pdf functions in pdf_ext.py in logilab-commons before 0.61.0 allows local users to overwrite arbitrary files and possibly have other unspecified impact via a symlink attack on /tmp/toto.fdf.",
      "cve": "CVE-2014-1838",
      "specs": [
        "<=0.60.0"
      ]
    },
    {
      "id": "pyup.io-logilab-common:CVE-2014-1839",
      "advisory": "The Execute class in shellutils in logilab-commons before 0.61.0 uses tempfile.mktemp, which allows local users to have an unspecified impact by pre-creating the temporary file.",
      "cve": "CVE-2014-1839",
      "specs": [
        "<=0.60.0"
      ]
    }
  ],
  "lookatme": [
    {
      "id": "pyup.io-lookatme:CVE-2020-15271",
      "advisory": "In lookatme (python/pypi package) versions prior to 2.3.0, the package automatically loaded the built-in \"terminal\" and \"file_loader\" extensions. Users that use lookatme to render untrusted markdown may have malicious shell commands automatically run on their system. This is fixed in version 2.3.0. As a workaround, the `lookatme/contrib/terminal.py` and `lookatme/contrib/file_loader.py` files may be manually deleted. Additionally, it is always recommended to be aware of what is being rendered with lookatme.",
      "cve": "CVE-2020-15271",
      "specs": [
        "<2.3.0"
      ]
    }
  ],
  "luigi": [
    {
      "id": "pyup.io-luigi:CVE-2018-1000843",
      "advisory": "Luigi version prior to version 2.8.0; after commit 53b52e12745075a8acc016d33945d9d6a7a6aaeb; after GitHub PR spotify/luigi/pull/1870 contains a Cross ite Request Forgery (CSRF) vulnerability in API endpoint: /api/<method> that can result in Task metadata such as task name, id, parameter, etc. will be leaked to unauthorized users. This attack appear to be exploitable via The victim must visit a specially crafted webpage from the network where their Luigi server is accessible.. This vulnerability appears to have been fixed in 2.8.0 and later.",
      "cve": "CVE-2018-1000843",
      "specs": [
        "<2.8.0"
      ]
    }
  ],
  "lxdui": [
    {
      "id": "pyup.io-lxdui:CVE-2021-40494",
      "advisory": "A Hardcoded JWT Secret Key in metadata.py in AdaptiveScale LXDUI through 2.1.3 allows attackers to gain admin access to the host system.",
      "cve": "CVE-2021-40494",
      "specs": [
        "<=2.1.3"
      ]
    }
  ],
  "lxml": [
    {
      "id": "pyup.io-lxml:CVE-2014-3146",
      "advisory": "Incomplete blacklist vulnerability in the lxml.html.clean module in lxml before 3.3.5 allows remote attackers to conduct cross-site scripting (XSS) attacks via control characters in the link scheme to the clean_html function.",
      "cve": "CVE-2014-3146",
      "specs": [
        "<=3.3.4",
        "==0.5",
        "==0.5.1",
        "==0.6",
        "==0.7",
        "==0.8",
        "==0.9",
        "==0.9.1",
        "==0.9.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.1",
        "==1.1.1",
        "==1.1.2",
        "==1.2",
        "==1.2.1",
        "==1.3",
        "==1.3.1",
        "==1.3.2",
        "==1.3.3",
        "==1.3.4",
        "==1.3.5",
        "==1.3.6",
        "==2.0",
        "==2.0.1",
        "==2.0.10",
        "==2.0.11",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.0.6",
        "==2.0.7",
        "==2.0.8",
        "==2.0.9",
        "==2.1-alpha1",
        "==2.1-beta1",
        "==2.1-beta2",
        "==2.1-beta3",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.2",
        "==2.2-alpha1",
        "==2.2-beta1",
        "==2.2-beta2",
        "==2.2-beta3",
        "==2.2-beta4",
        "==2.2.1",
        "==2.2.2",
        "==2.2.3",
        "==2.2.4",
        "==2.2.5",
        "==2.2.6",
        "==2.2.7",
        "==2.2.8",
        "==2.3",
        "==2.3-alpha1",
        "==2.3-alpha2",
        "==2.3-beta1",
        "==2.3.1",
        "==2.3.2",
        "==2.3.3",
        "==2.3.4",
        "==2.3.5",
        "==2.3.6",
        "==3.0",
        "==3.0-alpha1",
        "==3.0-alpha2",
        "==3.0-beta1",
        "==3.0.1",
        "==3.0.2",
        "==3.1-beta1",
        "==3.1.0",
        "==3.1.1",
        "==3.1.2",
        "==3.2.0",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.2.4",
        "==3.2.5",
        "==3.3.0",
        "==3.3.0-beta1",
        "==3.3.0-beta2",
        "==3.3.0-beta3",
        "==3.3.0-beta4",
        "==3.3.0-beta5",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3"
      ]
    },
    {
      "id": "pyup.io-lxml:CVE-2018-19787",
      "advisory": "An issue was discovered in lxml before 4.2.5. lxml/html/clean.py in the lxml.html.clean module does not remove javascript: URLs that use escaping, allowing a remote attacker to conduct XSS attacks, as demonstrated by \"j a v a s c r i p t:\" in Internet Explorer. This is a similar issue to CVE-2014-3146.",
      "cve": "CVE-2018-19787",
      "specs": [
        "<4.2.5"
      ]
    },
    {
      "id": "pyup.io-lxml:CVE-2020-27783",
      "advisory": "A XSS vulnerability was discovered in python-lxml's clean module. The module's parser didn't properly imitate browsers, which caused different behaviors between the sanitizer and the user's page. A remote attacker could exploit this flaw to run arbitrary HTML/JS code.",
      "cve": "CVE-2020-27783",
      "specs": [
        ">=1.2,<4.6.2"
      ]
    },
    {
      "id": "pyup.io-lxml:CVE-2021-28957",
      "advisory": "An XSS vulnerability was discovered in python-lxml's clean module versions before 4.6.3. When disabling the safe_attrs_only and forms arguments, the Cleaner class does not remove the formaction attribute allowing for JS to bypass the sanitizer. A remote attacker could exploit this flaw to run arbitrary JS code on users who interact with incorrectly sanitized HTML. This issue is patched in lxml 4.6.3.",
      "cve": "CVE-2021-28957",
      "specs": [
        "<4.6.3"
      ]
    }
  ],
  "mailman": [
    {
      "id": "pyup.io-mailman:CVE-2000-0701",
      "advisory": "The wrapper program in mailman 2.0beta3 and 2.0beta4 does not properly cleanse untrusted format strings, which allows local users to gain privileges.",
      "cve": "CVE-2000-0701",
      "specs": [
        "==2.0-beta3",
        "==2.0-beta4"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2000-0861",
      "advisory": "Mailman 1.1 allows list administrators to execute arbitrary commands via shell metacharacters in the %(listname) macro expansion.",
      "cve": "CVE-2000-0861",
      "specs": [
        "==1.1"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2001-0290",
      "advisory": "Vulnerability in Mailman 2.0.1 and earlier allows list administrators to obtain user passwords.",
      "cve": "CVE-2001-0290",
      "specs": [
        "<=2.0.2"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2001-0884",
      "advisory": "Cross-site scripting vulnerability in Mailman email archiver before 2.08 allows attackers to obtain sensitive information or authentication credentials via a malicious link that is accessed by other web users.",
      "cve": "CVE-2001-0884",
      "specs": [
        "==5.0",
        "==5.1",
        "==6.0",
        "==7.0"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2001-1132",
      "advisory": "Mailman 2.0.x before 2.0.6 allows remote attackers to gain access to list administrative pages when there is an empty site or list password, which is not properly handled during the call to the crypt function during authentication.",
      "cve": "CVE-2001-1132",
      "specs": [
        "<=2.0.5"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2002-0388",
      "advisory": "Cross-site scripting vulnerabilities in Mailman before 2.0.11 allow remote attackers to execute script via (1) the admin login page, or (2) the Pipermail index summaries.",
      "cve": "CVE-2002-0388",
      "specs": [
        "<=2.0.11"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2002-0855",
      "advisory": "Cross-site scripting vulnerability in Mailman before 2.0.12 allows remote attackers to execute script as other users via a subscriber's list subscription options in the (1) adminpw or (2) info parameters to the ml-name feature.",
      "cve": "CVE-2002-0855",
      "specs": [
        "==2.0.12"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2003-0038",
      "advisory": "Cross-site scripting (XSS) vulnerability in options.py for Mailman 2.1 allows remote attackers to inject script or HTML into web pages via the (1) email or (2) language parameters.",
      "cve": "CVE-2003-0038",
      "specs": [
        "==2.1"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2003-0965",
      "advisory": "Cross-site scripting (XSS) vulnerability in the admin CGI script for Mailman before 2.1.4 allows remote attackers to steal session cookies and conduct unauthorized activities.",
      "cve": "CVE-2003-0965",
      "specs": [
        "<=2.1.4"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2003-0991",
      "advisory": "Unknown vulnerability in the mail command handler in Mailman before 2.0.14 allows remote attackers to cause a denial of service (crash) via malformed e-mail commands.",
      "cve": "CVE-2003-0991",
      "specs": [
        "==1.0",
        "==1.1",
        "==2.0",
        "==2.0-beta3",
        "==2.0-beta4",
        "==2.0-beta5",
        "==2.0.1",
        "==2.0.10",
        "==2.0.11",
        "==2.0.12",
        "==2.0.13",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.0.6",
        "==2.0.7",
        "==2.0.8",
        "==2.0.9",
        "==2.1"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2003-0992",
      "advisory": "Cross-site scripting (XSS) vulnerability in the create CGI script for Mailman before 2.1.3 allows remote attackers to steal cookies of other users.",
      "cve": "CVE-2003-0992",
      "specs": [
        "<=2.1.3"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2004-0182",
      "advisory": "Mailman before 2.0.13 allows remote attackers to cause a denial of service (crash) via an email message with an empty subject field.",
      "cve": "CVE-2004-0182",
      "specs": [
        "<=2.0.12"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2004-0412",
      "advisory": "Mailman before 2.1.5 allows remote attackers to obtain user passwords via a crafted email request to the Mailman server.",
      "cve": "CVE-2004-0412",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.1b1"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2004-1143",
      "advisory": "The password generation in mailman before 2.1.5 generates only 5 million unique passwords, which makes it easier for remote attackers to guess passwords via a brute force attack.",
      "cve": "CVE-2004-1143",
      "specs": [
        "==1.0",
        "==1.1",
        "==2.0",
        "==2.0-beta3",
        "==2.0-beta4",
        "==2.0-beta5",
        "==2.0.1",
        "==2.0.10",
        "==2.0.11",
        "==2.0.12",
        "==2.0.13",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.0.6",
        "==2.0.7",
        "==2.0.8",
        "==2.0.9",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.1b1"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2004-1177",
      "advisory": "Cross-site scripting (XSS) vulnerability in the driver script in mailman before 2.1.5 allows remote attackers to inject arbitrary web script or HTML via a URL, which is not properly escaped in the resulting error page.",
      "cve": "CVE-2004-1177",
      "specs": [
        "==1.0",
        "==1.1",
        "==2.0",
        "==2.0-beta3",
        "==2.0-beta4",
        "==2.0-beta5",
        "==2.0.1",
        "==2.0.10",
        "==2.0.11",
        "==2.0.12",
        "==2.0.13",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.0.6",
        "==2.0.7",
        "==2.0.8",
        "==2.0.9",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.1b1"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2005-0080",
      "advisory": "The 55_options_traceback.dpatch patch for mailman 2.1.5 in Ubuntu 4.10 displays a different error message depending on whether the e-mail address is subscribed to a private list, which allows remote attackers to determine the list membership for a given e-mail address.",
      "cve": "CVE-2005-0080",
      "specs": [
        "==2.1.5"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2005-0202",
      "advisory": "Directory traversal vulnerability in the true_path function in private.py for Mailman 2.1.5 and earlier allows remote attackers to read arbitrary files via \".../....///\" sequences, which are not properly cleansed by regular expressions that are intended to remove \"../\" and \"./\" sequences.",
      "cve": "CVE-2005-0202",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.1.5",
        "==2.1b1"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2005-3573",
      "advisory": "Scrubber.py in Mailman 2.1.5-8 does not properly handle UTF8 character encodings in filenames of e-mail attachments, which allows remote attackers to cause a denial of service (application crash).",
      "cve": "CVE-2005-3573",
      "specs": [
        "==2.0-beta3",
        "==2.0-beta4",
        "==2.0-beta5",
        "==2.0.1",
        "==2.0.10",
        "==2.0.11",
        "==2.0.12",
        "==2.0.13",
        "==2.0.14",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.0.6",
        "==2.0.7",
        "==2.0.8",
        "==2.0.9",
        "==2.1",
        "==2.1.1-beta1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.1.5",
        "==2.1.5.8"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2005-4153",
      "advisory": "Mailman 2.1.4 through 2.1.6 allows remote attackers to cause a denial of service via a message that causes the server to \"fail with an Overflow on bad date data in a processed message,\" a different vulnerability than CVE-2005-3573.",
      "cve": "CVE-2005-4153",
      "specs": [
        "==2.1.4",
        "==2.1.5",
        "==2.1.6"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2006-0052",
      "advisory": "The attachment scrubber (Scrubber.py) in Mailman 2.1.5 and earlier, when using Python's library email module 2.5, allows remote attackers to cause a denial of service (mailing list delivery failure) via a multipart MIME message with a single part that has two blank lines between the first boundary and the end boundary.",
      "cve": "CVE-2006-0052",
      "specs": [
        "==1.0",
        "==1.1",
        "==2.0",
        "==2.0-beta3",
        "==2.0-beta4",
        "==2.0-beta5",
        "==2.0.1",
        "==2.0.10",
        "==2.0.11",
        "==2.0.12",
        "==2.0.13",
        "==2.0.14",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.0.6",
        "==2.0.7",
        "==2.0.8",
        "==2.0.9",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.1.5",
        "==2.1b1"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2006-1712",
      "advisory": "Cross-site scripting (XSS) vulnerability in the private archive script (private.py) in GNU Mailman 2.1.7 allows remote attackers to inject arbitrary web script or HTML via the action argument.",
      "cve": "CVE-2006-1712",
      "specs": [
        "==2.1.7"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2006-2191",
      "advisory": "** DISPUTED **  Format string vulnerability in Mailman before 2.1.9 allows attackers to execute arbitrary code via unspecified vectors. NOTE: the vendor has disputed this vulnerability, stating that it is \"unexploitable.\"",
      "cve": "CVE-2006-2191",
      "specs": [
        "<=2.1.8"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2006-2941",
      "advisory": "Mailman before 2.1.9rc1 allows remote attackers to cause a denial of service via unspecified vectors involving \"standards-breaking RFC 2231 formatted headers\".",
      "cve": "CVE-2006-2941",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.1-beta1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.1.5",
        "==2.1.5.8",
        "==2.1.6",
        "==2.1.7",
        "==2.1.8",
        "==2.1b1"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2006-3636",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in Mailman before 2.1.9rc1 allow remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2006-3636",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.1-beta1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.1.5",
        "==2.1.5.8",
        "==2.1.6",
        "==2.1.7",
        "==2.1.8",
        "==2.1b1"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2006-4624",
      "advisory": "CRLF injection vulnerability in Utils.py in Mailman before 2.1.9rc1 allows remote attackers to spoof messages in the error log and possibly trick the administrator into visiting malicious URLs via CRLF sequences in the URI.",
      "cve": "CVE-2006-4624",
      "specs": [
        "<=2.1.8"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2010-3089",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in GNU Mailman before 2.1.14rc1 allow remote authenticated users to inject arbitrary web script or HTML via vectors involving (1) the list information field or (2) the list description field.",
      "cve": "CVE-2010-3089",
      "specs": [
        "<=2.1.13",
        "==2.1",
        "==2.1-alpha",
        "==2.1-beta",
        "==2.1-stable",
        "==2.1.1",
        "==2.1.10",
        "==2.1.11",
        "==2.1.11-rc1",
        "==2.1.11-rc2",
        "==2.1.12",
        "==2.1.13-rc1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.1.5",
        "==2.1.6",
        "==2.1.7",
        "==2.1.8",
        "==2.1.9"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2011-0707",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in Cgi/confirm.py in GNU Mailman 2.1.14 and earlier allow remote attackers to inject arbitrary web script or HTML via the (1) full name or (2) username field in a confirmation message.",
      "cve": "CVE-2011-0707",
      "specs": [
        "<=2.1.14",
        "==1.0",
        "==1.1",
        "==2.0",
        "==2.0-beta3",
        "==2.0-beta4",
        "==2.0-beta5",
        "==2.0.1",
        "==2.0.10",
        "==2.0.11",
        "==2.0.12",
        "==2.0.13",
        "==2.0.14",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.0.6",
        "==2.0.7",
        "==2.0.8",
        "==2.0.9",
        "==2.1",
        "==2.1-alpha",
        "==2.1-beta",
        "==2.1-stable",
        "==2.1.1",
        "==2.1.1-beta1",
        "==2.1.10",
        "==2.1.11",
        "==2.1.11-rc1",
        "==2.1.11-rc2",
        "==2.1.12",
        "==2.1.13",
        "==2.1.13-rc1",
        "==2.1.14-rc1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.1.5",
        "==2.1.5.8",
        "==2.1.6",
        "==2.1.7",
        "==2.1.8",
        "==2.1.9",
        "==2.1b1"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2011-5024",
      "advisory": "Cross-site scripting (XSS) vulnerability in mmsearch/design in the Mailman/htdig integration patch for Mailman allows remote attackers to inject arbitrary web script or HTML via the config parameter.",
      "cve": "CVE-2011-5024",
      "specs": [
        "==2.0.13",
        "==2.1",
        "==2.1.1",
        "==2.1.10",
        "==2.1.11",
        "==2.1.12",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.1.6",
        "==2.1.7",
        "==2.1.8",
        "==2.1.9"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2015-2775",
      "advisory": "Directory traversal vulnerability in GNU Mailman before 2.1.20, when not using a static alias, allows remote attackers to execute arbitrary files via a .. (dot dot) in a list name.",
      "cve": "CVE-2015-2775",
      "specs": [
        "<=2.1.19"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2016-6893",
      "advisory": "Cross-site request forgery (CSRF) vulnerability in the user options page in GNU Mailman 2.1.x before 2.1.23 allows remote attackers to hijack the authentication of arbitrary users for requests that modify an option, as demonstrated by gaining access to the credentials of a victim's account.",
      "cve": "CVE-2016-6893",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.10",
        "==2.1.10-rc1",
        "==2.1.10b1",
        "==2.1.10b3",
        "==2.1.10b4",
        "==2.1.11",
        "==2.1.11-rc1",
        "==2.1.11-rc2",
        "==2.1.12",
        "==2.1.12-rc1",
        "==2.1.12-rc2",
        "==2.1.13",
        "==2.1.13-rc1",
        "==2.1.14",
        "==2.1.14-1",
        "==2.1.14-rc1",
        "==2.1.15",
        "==2.1.15-rc1",
        "==2.1.16",
        "==2.1.16-rc1",
        "==2.1.16-rc2",
        "==2.1.16-rc3",
        "==2.1.17",
        "==2.1.18",
        "==2.1.18-1",
        "==2.1.18-rc1",
        "==2.1.18-rc2",
        "==2.1.18-rc3",
        "==2.1.19",
        "==2.1.19-rc1",
        "==2.1.19-rc2",
        "==2.1.19-rc3",
        "==2.1.2",
        "==2.1.20",
        "==2.1.21",
        "==2.1.21-rc2",
        "==2.1.22",
        "==2.1.23",
        "==2.1.3",
        "==2.1.4",
        "==2.1.5",
        "==2.1.6",
        "==2.1.8",
        "==2.1.9"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2016-7123",
      "advisory": "Cross-site request forgery (CSRF) vulnerability in the admin web interface in GNU Mailman before 2.1.15 allows remote attackers to hijack the authentication of administrators.",
      "cve": "CVE-2016-7123",
      "specs": [
        "<=2.1.14"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2018-0618",
      "advisory": "Cross-site scripting vulnerability in Mailman 2.1.26 and earlier allows remote authenticated attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2018-0618",
      "specs": [
        "<=2.1.26"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2018-13796",
      "advisory": "An issue was discovered in GNU Mailman before 2.1.28. A crafted URL can cause arbitrary text to be displayed on a web page from a trusted site.",
      "cve": "CVE-2018-13796",
      "specs": [
        "<2.1.28"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2018-5950",
      "advisory": "Cross-site scripting (XSS) vulnerability in the web UI in Mailman before 2.1.26 allows remote attackers to inject arbitrary web script or HTML via a user-options URL.",
      "cve": "CVE-2018-5950",
      "specs": [
        "<2.1.26"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2020-12108",
      "advisory": "/options/mailman in GNU Mailman before 2.1.31 allows Arbitrary Content Injection.",
      "cve": "CVE-2020-12108",
      "specs": [
        "<2.1.31"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2020-12137",
      "advisory": "GNU Mailman 2.x before 2.1.30 uses the .obj extension for scrubbed application/octet-stream MIME parts. This behavior may contribute to XSS attacks against list-archive visitors, because an HTTP reply from an archive web server may lack a MIME type, and a web browser may perform MIME sniffing, conclude that the MIME type should have been text/html, and execute JavaScript code.",
      "cve": "CVE-2020-12137",
      "specs": [
        ">=2.0,<2.1.30"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2020-15011",
      "advisory": "GNU Mailman before 2.1.33 allows arbitrary content injection via the Cgi/private.py private archive login page.",
      "cve": "CVE-2020-15011",
      "specs": [
        "<2.1.33"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2021-42096",
      "advisory": "GNU Mailman before 2.1.35 may allow remote Privilege Escalation. A certain csrf_token value is derived from the admin password, and may be useful in conducting a brute-force attack against that password.",
      "cve": "CVE-2021-42096",
      "specs": [
        "<2.1.35"
      ]
    },
    {
      "id": "pyup.io-mailman:CVE-2021-42097",
      "advisory": "GNU Mailman before 2.1.35 may allow remote Privilege Escalation. A csrf_token value is not specific to a single user account. An attacker can obtain a value within the context of an unprivileged user account, and then use that value in a CSRF attack against an admin (e.g., for account takeover).",
      "cve": "CVE-2021-42097",
      "specs": [
        "<2.1.35"
      ]
    }
  ],
  "mako": [
    {
      "id": "pyup.io-mako:CVE-2010-2480",
      "advisory": "Mako before 0.3.4 relies on the cgi.escape function in the Python standard library for cross-site scripting (XSS) protection, which makes it easier for remote attackers to conduct XSS attacks via vectors involving single-quote characters and a JavaScript onLoad event handler for a BODY element.",
      "cve": "CVE-2010-2480",
      "specs": [
        "<=0.3.3",
        "==0.1.0",
        "==0.1.1",
        "==0.1.10",
        "==0.1.2",
        "==0.1.3",
        "==0.1.4",
        "==0.1.5",
        "==0.1.6",
        "==0.1.7",
        "==0.1.8",
        "==0.1.9",
        "==0.2.0",
        "==0.2.1",
        "==0.2.2",
        "==0.2.3",
        "==0.2.4",
        "==0.2.5",
        "==0.2.6",
        "==0.3",
        "==0.3.1",
        "==0.3.2"
      ]
    }
  ],
  "manila": [
    {
      "id": "pyup.io-manila:CVE-2016-6519",
      "advisory": "Cross-site scripting (XSS) vulnerability in the \"Shares\" overview in Openstack Manila before 2.5.1 allows remote authenticated users to inject arbitrary web script or HTML via the Metadata field in the \"Create Share\" form.",
      "cve": "CVE-2016-6519",
      "specs": [
        "<=2.5"
      ]
    },
    {
      "id": "pyup.io-manila:CVE-2020-9543",
      "advisory": "OpenStack Manila <7.4.1, >=8.0.0 <8.1.1, and >=9.0.0 <9.1.1 allows attackers to view, update, delete, or share resources that do not belong to them, because of a context-free lookup of a UUID. Attackers may also create resources, such as shared file systems and groups of shares on such share networks.",
      "cve": "CVE-2020-9543",
      "specs": [
        "<7.4.1",
        ">=8.0.0,<8.1.1",
        ">=9.0.0,<9.1.1"
      ]
    }
  ],
  "markdown2": [
    {
      "id": "pyup.io-markdown2:CVE-2009-3724",
      "advisory": "python-markdown2 before 1.0.1.14 has multiple cross-site scripting (XSS) issues.",
      "cve": "CVE-2009-3724",
      "specs": [
        "<1.0.1.14"
      ]
    },
    {
      "id": "pyup.io-markdown2:CVE-2018-5773",
      "advisory": "An issue was discovered in markdown2 (aka python-markdown2) through 2.3.5. The safe_mode feature, which is supposed to sanitize user input against XSS, is flawed and does not escape the input properly. With a crafted payload, XSS can be triggered, as demonstrated by omitting the final '>' character from an IMG tag.",
      "cve": "CVE-2018-5773",
      "specs": [
        "<=2.3.5"
      ]
    },
    {
      "id": "pyup.io-markdown2:CVE-2020-11888",
      "advisory": "python-markdown2 through 2.3.8 allows XSS because element names are mishandled unless a \\w+ match succeeds. For example, an attack might use elementname@ or elementname- with an onclick attribute.",
      "cve": "CVE-2020-11888",
      "specs": [
        "<=2.3.8"
      ]
    },
    {
      "id": "pyup.io-markdown2:CVE-2021-26813",
      "advisory": "markdown2 >=1.0.1.18, fixed in 2.4.0, is affected by a regular expression denial of service vulnerability. If an attacker provides a malicious string, it can make markdown2 processing difficult or delayed for an extended period of time.",
      "cve": "CVE-2021-26813",
      "specs": [
        ">=1.0.1.18,<2.4.0"
      ]
    }
  ],
  "marshmallow": [
    {
      "id": "pyup.io-marshmallow:CVE-2018-17175",
      "advisory": "In the marshmallow library before 2.15.1 and 3.x before 3.0.0b9 for Python, the schema \"only\" option treats an empty list as implying no \"only\" option, which allows a request that was intended to expose no fields to instead expose all fields (if the schema is being filtered dynamically using the \"only\" option, and there is a user role that produces an empty value for \"only\").",
      "cve": "CVE-2018-17175",
      "specs": [
        "<2.15.1",
        ">=3.0,<3.0.0b9"
      ]
    }
  ],
  "matrix-sydent": [
    {
      "id": "pyup.io-matrix-sydent:CVE-2019-11340",
      "advisory": "util/emailutils.py in Matrix Sydent before 1.0.2 mishandles registration restrictions that are based on e-mail domain, if the allowed_local_3pids option is enabled. This occurs because of potentially unwanted behavior in Python, in which an email.utils.parseaddr call on user@bad.example.net@good.example.com returns the user@bad.example.net substring.",
      "cve": "CVE-2019-11340",
      "specs": [
        "<1.0.2"
      ]
    },
    {
      "id": "pyup.io-matrix-sydent:CVE-2019-11842",
      "advisory": "An issue was discovered in Matrix Sydent before 1.0.3 and Synapse before 0.99.3.1. Random number generation is mishandled, which makes it easier for attackers to predict a Sydent authentication token or a Synapse random ID.",
      "cve": "CVE-2019-11842",
      "specs": [
        "<1.0.3"
      ]
    },
    {
      "id": "pyup.io-matrix-sydent:CVE-2021-29430",
      "advisory": "Sydent is a reference Matrix identity server. Sydent does not limit the size of requests it receives from HTTP clients. A malicious user could send an HTTP request with a very large body, leading to memory exhaustion and denial of service. Sydent also does not limit response size for requests it makes to remote Matrix homeservers. A malicious homeserver could return a very large response, again leading to memory exhaustion and denial of service. This affects any server which accepts registration requests from untrusted clients. This issue has been patched by releases 89071a1, 0523511, f56eee3. As a workaround request sizes can be limited in an HTTP reverse-proxy. There are no known workarounds for the problem with overlarge responses.",
      "cve": "CVE-2021-29430",
      "specs": [
        "<2.3.0"
      ]
    },
    {
      "id": "pyup.io-matrix-sydent:CVE-2021-29431",
      "advisory": "Sydent is a reference Matrix identity server. Sydent can be induced to send HTTP GET requests to internal systems, due to lack of parameter validation or IP address blacklisting. It is not possible to exfiltrate data or control request headers, but it might be possible to use the attack to perform an internal port enumeration. This issue has been addressed in in 9e57334, 8936925, 3d531ed, 0f00412. A potential workaround would be to use a firewall to ensure that Sydent cannot reach internal HTTP resources.",
      "cve": "CVE-2021-29431",
      "specs": [
        "<2.3.0"
      ]
    },
    {
      "id": "pyup.io-matrix-sydent:CVE-2021-29432",
      "advisory": "Sydent is a reference matrix identity server. A malicious user could abuse Sydent to send out arbitrary emails from the Sydent email address. This could be used to construct plausible phishing emails, for example. This issue has been fixed in 4469d1d.",
      "cve": "CVE-2021-29432",
      "specs": [
        "<2.3.0"
      ]
    },
    {
      "id": "pyup.io-matrix-sydent:CVE-2021-29433",
      "advisory": "Sydent is a reference Matrix identity server. In Sydent versions 2.2.0 and prior, sissing input validation of some parameters on the endpoints used to confirm third-party identifiers could cause excessive use of disk space and memory leading to resource exhaustion. A patch for the vulnerability is in version 2.3.0. No workarounds are known to exist.",
      "cve": "CVE-2021-29433",
      "specs": [
        "<2.3.0"
      ]
    }
  ],
  "matrix-synapse": [
    {
      "id": "pyup.io-matrix-synapse:CVE-2018-10657",
      "advisory": "Matrix Synapse before 0.28.1 is prone to a denial of service flaw where malicious events injected with depth = 2^63 - 1 render rooms unusable, related to federation/federation_base.py and handlers/message.py, as exploited in the wild in April 2018.",
      "cve": "CVE-2018-10657",
      "specs": [
        "<0.28.1"
      ]
    },
    {
      "id": "pyup.io-matrix-synapse:CVE-2018-12291",
      "advisory": "The on_get_missing_events function in handlers/federation.py in Matrix Synapse before 0.31.1 has a security bug in the get_missing_events federation API where event visibility rules were not applied correctly.",
      "cve": "CVE-2018-12291",
      "specs": [
        "<0.31.1"
      ]
    },
    {
      "id": "pyup.io-matrix-synapse:CVE-2018-12423",
      "advisory": "In Synapse before 0.31.2, unauthorised users can hijack rooms when there is no m.room.power_levels event in force.",
      "cve": "CVE-2018-12423",
      "specs": [
        "<0.31.2"
      ]
    },
    {
      "id": "pyup.io-matrix-synapse:CVE-2018-16515",
      "advisory": "Matrix Synapse before 0.33.3.1 allows remote attackers to spoof events and possibly have unspecified other impacts by leveraging improper transaction and event signature validation.",
      "cve": "CVE-2018-16515",
      "specs": [
        "<0.33.3.1"
      ]
    },
    {
      "id": "pyup.io-matrix-synapse:CVE-2019-11842",
      "advisory": "An issue was discovered in Matrix Sydent before 1.0.3 and Synapse before 0.99.3.1. Random number generation is mishandled, which makes it easier for attackers to predict a Sydent authentication token or a Synapse random ID.",
      "cve": "CVE-2019-11842",
      "specs": [
        "<0.99.3.1"
      ]
    },
    {
      "id": "pyup.io-matrix-synapse:CVE-2019-18835",
      "advisory": "Matrix Synapse before 1.5.0 mishandles signature checking on some federation APIs. Events sent over /send_join, /send_leave, and /invite may not be correctly signed, or may not come from the expected servers.",
      "cve": "CVE-2019-18835",
      "specs": [
        "<1.5.0"
      ]
    },
    {
      "id": "pyup.io-matrix-synapse:CVE-2019-5885",
      "advisory": "Matrix Synapse before 0.34.0.1, when the macaroon_secret_key authentication parameter is not set, uses a predictable value to derive a secret key and other secrets which could allow remote attackers to impersonate users.",
      "cve": "CVE-2019-5885",
      "specs": [
        "<0.34.0.1"
      ]
    },
    {
      "id": "pyup.io-matrix-synapse:CVE-2020-26257",
      "advisory": "Matrix is an ecosystem for open federated Instant Messaging and VoIP. Synapse is a reference \"homeserver\" implementation of Matrix. A malicious or poorly-implemented homeserver can inject malformed events into a room by specifying a different room id in the path of a `/send_join`, `/send_leave`, `/invite` or `/exchange_third_party_invite` request. This can lead to a denial of service in which future events will not be correctly sent to other servers over federation. This affects any server which accepts federation requests from untrusted servers. The Matrix Synapse reference implementation before version 1.23.1 the implementation is vulnerable to this injection attack. Issue is fixed in version 1.23.1. As a workaround homeserver administrators could limit access to the federation API to trusted servers (for example via `federation_domain_whitelist`).",
      "cve": "CVE-2020-26257",
      "specs": [
        "<1.23.1"
      ]
    },
    {
      "id": "pyup.io-matrix-synapse:CVE-2020-26890",
      "advisory": "Matrix Synapse before 1.20.0 erroneously permits non-standard NaN, Infinity, and -Infinity JSON values in fields of m.room.member events, allowing remote attackers to execute a denial of service attack against the federation and common Matrix clients. If such a malformed event is accepted into the room's state, the impact is long-lasting and is not fixed by an upgrade to a newer version, requiring the event to be manually redacted instead. Since events are replicated to servers of other room members, the impact is not constrained to the server of the event sender.",
      "cve": "CVE-2020-26890",
      "specs": [
        "<1.20.0"
      ]
    },
    {
      "id": "pyup.io-matrix-synapse:CVE-2020-26891",
      "advisory": "AuthRestServlet in Matrix Synapse before 1.21.0 is vulnerable to XSS due to unsafe interpolation of the session GET parameter. This allows a remote attacker to execute an XSS attack on the domain Synapse is hosted on, by supplying the victim user with a malicious URL to the /_matrix/client/r0/auth/*/fallback/web or /_matrix/client/unstable/auth/*/fallback/web Synapse endpoints.",
      "cve": "CVE-2020-26891",
      "specs": [
        "<1.21.0"
      ]
    },
    {
      "id": "pyup.io-matrix-synapse:CVE-2021-21273",
      "advisory": "Synapse is a Matrix reference homeserver written in python (pypi package matrix-synapse). Matrix is an ecosystem for open federated Instant Messaging and VoIP. In Synapse before version 1.25.0, requests to user provided domains were not restricted to external IP addresses when calculating the key validity for third-party invite events and sending push notifications. This could cause Synapse to make requests to internal infrastructure. The type of request was not controlled by the user, although limited modification of request bodies was possible. For the most thorough protection server administrators should remove the deprecated `federation_ip_range_blacklist` from their settings after upgrading to Synapse v1.25.0 which will result in Synapse using the improved default IP address restrictions. See the new `ip_range_blacklist` and `ip_range_whitelist` settings if more specific control is necessary.",
      "cve": "CVE-2021-21273",
      "specs": [
        "<1.25.0"
      ]
    },
    {
      "id": "pyup.io-matrix-synapse:CVE-2021-21274",
      "advisory": "Synapse is a Matrix reference homeserver written in python (pypi package matrix-synapse). Matrix is an ecosystem for open federated Instant Messaging and VoIP. In Synapse before version 1.25.0, a malicious homeserver could redirect requests to their .well-known file to a large file. This can lead to a denial of service attack where homeservers will consume significantly more resources when requesting the .well-known file of a malicious homeserver. This affects any server which accepts federation requests from untrusted servers. Issue is resolved in version 1.25.0. As a workaround the `federation_domain_whitelist` setting can be used to restrict the homeservers communicated with over federation.",
      "cve": "CVE-2021-21274",
      "specs": [
        ">=0.99.0,<1.25.0"
      ]
    },
    {
      "id": "pyup.io-matrix-synapse:CVE-2021-21332",
      "advisory": "Synapse is a Matrix reference homeserver written in python (pypi package matrix-synapse). Matrix is an ecosystem for open federated Instant Messaging and VoIP. In Synapse before version 1.27.0, the password reset endpoint served via Synapse was vulnerable to cross-site scripting (XSS) attacks. The impact depends on the configuration of the domain that Synapse is deployed on, but may allow access to cookies and other browser data, CSRF vulnerabilities, and access to other resources served on the same domain or parent domains. This is fixed in version 1.27.0.",
      "cve": "CVE-2021-21332",
      "specs": [
        "<1.27.0"
      ]
    },
    {
      "id": "pyup.io-matrix-synapse:CVE-2021-21333",
      "advisory": "Synapse is a Matrix reference homeserver written in python (pypi package matrix-synapse). Matrix is an ecosystem for open federated Instant Messaging and VoIP. In Synapse before version 1.27.0, the notification emails sent for notifications for missed messages or for an expiring account are subject to HTML injection. In the case of the notification for missed messages, this could allow an attacker to insert forged content into the email. The account expiry feature is not enabled by default and the HTML injection is not controllable by an attacker. This is fixed in version 1.27.0.",
      "cve": "CVE-2021-21333",
      "specs": [
        "<1.27.0"
      ]
    },
    {
      "id": "pyup.io-matrix-synapse:CVE-2021-21392",
      "advisory": "Synapse is a Matrix reference homeserver written in python (pypi package matrix-synapse). Matrix is an ecosystem for open federated Instant Messaging and VoIP. In Synapse before version 1.28.0 requests to user provided domains were not restricted to external IP addresses when transitional IPv6 addresses were used. Outbound requests to federation, identity servers, when calculating the key validity for third-party invite events, sending push notifications, and generating URL previews are affected. This could cause Synapse to make requests to internal infrastructure on dual-stack networks. See referenced GitHub security advisory for details and workarounds.",
      "cve": "CVE-2021-21392",
      "specs": [
        "<1.28.0"
      ]
    },
    {
      "id": "pyup.io-matrix-synapse:CVE-2021-21393",
      "advisory": "Synapse is a Matrix reference homeserver written in python (pypi package matrix-synapse). Matrix is an ecosystem for open federated Instant Messaging and VoIP. In Synapse before version 1.28.0 Synapse is missing input validation of some parameters on the endpoints used to confirm third-party identifiers could cause excessive use of disk space and memory leading to resource exhaustion. Note that the groups feature is not part of the Matrix specification and the chosen maximum lengths are arbitrary. Not all clients might abide by them. Refer to referenced GitHub security advisory for additional details including workarounds.",
      "cve": "CVE-2021-21393",
      "specs": [
        ">0.24.0,<1.28.0"
      ]
    },
    {
      "id": "pyup.io-matrix-synapse:CVE-2021-21394",
      "advisory": "Synapse is a Matrix reference homeserver written in python (pypi package matrix-synapse). Matrix is an ecosystem for open federated Instant Messaging and VoIP. In Synapse before version 1.28.0 Synapse is missing input validation of some parameters on the endpoints used to confirm third-party identifiers could cause excessive use of disk space and memory leading to resource exhaustion. Note that the groups feature is not part of the Matrix specification and the chosen maximum lengths are arbitrary. Not all clients might abide by them. Refer to referenced GitHub security advisory for additional details including workarounds.",
      "cve": "CVE-2021-21394",
      "specs": [
        ">0.17.0,<1.28.0"
      ]
    },
    {
      "id": "pyup.io-matrix-synapse:CVE-2021-29471",
      "advisory": "Synapse is a Matrix reference homeserver written in python (pypi package matrix-synapse). Matrix is an ecosystem for open federated Instant Messaging and VoIP. In Synapse before version 1.33.2 \"Push rules\" can specify conditions under which they will match, including `event_match`, which matches event content against a pattern including wildcards. Certain patterns can cause very poor performance in the matching engine, leading to a denial-of-service when processing moderate length events. The issue is patched in version 1.33.2. A potential workaround might be to prevent users from making custom push rules, by blocking such requests at a reverse-proxy.",
      "cve": "CVE-2021-29471",
      "specs": [
        "<1.33.2"
      ]
    },
    {
      "id": "pyup.io-matrix-synapse:CVE-2021-39163",
      "advisory": "Matrix is an ecosystem for open federated Instant Messaging and Voice over IP. In versions 1.41.0 and prior, unauthorised users can access the name, avatar, topic and number of members of a room if they know the ID of the room. This vulnerability is limited to homeservers where the vulnerable homeserver is in the room and untrusted users are permitted to create groups (communities). By default, only homeserver administrators can create groups. However, homeserver administrators can already access this information in the database or using the admin API. As a result, only homeservers where the configuration setting `enable_group_creation` has been set to `true` are impacted. Server administrators should upgrade to 1.41.1 or higher to patch the vulnerability. There are two potential workarounds. Server administrators can set `enable_group_creation` to `false` in their homeserver configuration (this is the default value) to prevent creation of groups by non-administrators. Administrators that are using a reverse proxy could, with partial loss of group functionality, block the endpoints `/_matrix/client/r0/groups/{group_id}/rooms` and `/_matrix/client/unstable/groups/{group_id}/rooms`.",
      "cve": "CVE-2021-39163",
      "specs": [
        "<1.41.1"
      ]
    },
    {
      "id": "pyup.io-matrix-synapse:CVE-2021-39164",
      "advisory": "Matrix is an ecosystem for open federated Instant Messaging and Voice over IP. In versions 1.41.0 and prior, unauthorised users can access the membership (list of members, with their display names) of a room if they know the ID of the room. The vulnerability is limited to rooms with `shared` history visibility. Furthermore, the unauthorised user must be using an account on a vulnerable homeserver that is in the room. Server administrators should upgrade to 1.41.1 or later in order to receive the patch. One workaround is available. Administrators of servers that use a reverse proxy could, with potentially unacceptable loss of functionality, block the endpoints: `/_matrix/client/r0/rooms/{room_id}/members` with `at` query parameter, and `/_matrix/client/unstable/rooms/{room_id}/members` with `at` query parameter.",
      "cve": "CVE-2021-39164",
      "specs": [
        "<1.41.1"
      ]
    }
  ],
  "mayan-edms": [
    {
      "id": "pyup.io-mayan-edms:CVE-2014-3840",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in apps/common/templates/calculate_form_title.html in Mayan EDMS 0.13 allow remote authenticated users to inject arbitrary web script or HTML via a (1) tag or the (2) title of a source in a Staging folder, (3) Name field in a bootstrap setup, or Title field in a (4) smart link or (5) web form.",
      "cve": "CVE-2014-3840",
      "specs": [
        "==0.13"
      ]
    },
    {
      "id": "pyup.io-mayan-edms:CVE-2018-16405",
      "advisory": "An issue was discovered in Mayan EDMS before 3.0.2. The Appearance app sets window.location directly, leading to XSS.",
      "cve": "CVE-2018-16405",
      "specs": [
        "<3.0.2"
      ]
    },
    {
      "id": "pyup.io-mayan-edms:CVE-2018-16406",
      "advisory": "An issue was discovered in Mayan EDMS before 3.0.2. The Cabinets app has XSS via a crafted cabinet label.",
      "cve": "CVE-2018-16406",
      "specs": [
        "<3.0.2"
      ]
    },
    {
      "id": "pyup.io-mayan-edms:CVE-2018-16407",
      "advisory": "An issue was discovered in Mayan EDMS before 3.0.3. The Tags app has XSS because tag label values are mishandled.",
      "cve": "CVE-2018-16407",
      "specs": [
        "<3.0.3"
      ]
    }
  ],
  "meinheld": [
    {
      "id": "pyup.io-meinheld:CVE-2020-7658",
      "advisory": "meinheld prior to 1.0.2 is vulnerable to HTTP Request Smuggling. HTTP pipelining issues and request smuggling attacks might be possible due to incorrect Content-Length and Transfer encoding header parsing.",
      "cve": "CVE-2020-7658",
      "specs": [
        "<1.0.2"
      ]
    }
  ],
  "mercurial": [
    {
      "id": "pyup.io-mercurial:CVE-2008-2942",
      "advisory": "Directory traversal vulnerability in patch.py in Mercurial 1.0.1 allows user-assisted attackers to modify arbitrary files via \"..\" (dot dot) sequences in a patch file.",
      "cve": "CVE-2008-2942",
      "specs": [
        "==1.0.1"
      ]
    },
    {
      "id": "pyup.io-mercurial:CVE-2008-4297",
      "advisory": "Mercurial before 1.0.2 does not enforce the allowpull permission setting for a pull operation from hgweb, which allows remote attackers to read arbitrary files from a repository via an \"hg pull\" request.",
      "cve": "CVE-2008-4297",
      "specs": [
        "<=1.0.1"
      ]
    },
    {
      "id": "pyup.io-mercurial:CVE-2010-4237",
      "advisory": "Mercurial before 1.6.4 fails to verify the Common Name field of SSL certificates which allows remote attackers who acquire a certificate signed by a Certificate Authority to perform a man-in-the-middle attack.",
      "cve": "CVE-2010-4237",
      "specs": [
        "<1.6.4"
      ]
    },
    {
      "id": "pyup.io-mercurial:CVE-2014-9462",
      "advisory": "The _validaterepo function in sshpeer in Mercurial before 3.2.4 allows remote attackers to execute arbitrary commands via a crafted repository name in a clone command.",
      "cve": "CVE-2014-9462",
      "specs": [
        "<=3.2.3"
      ]
    },
    {
      "id": "pyup.io-mercurial:CVE-2016-3068",
      "advisory": "Mercurial before 3.7.3 allows remote attackers to execute arbitrary code via a crafted git ext:: URL when cloning a subrepository.",
      "cve": "CVE-2016-3068",
      "specs": [
        "<=3.7.2"
      ]
    },
    {
      "id": "pyup.io-mercurial:CVE-2016-3069",
      "advisory": "Mercurial before 3.7.3 allows remote attackers to execute arbitrary code via a crafted name when converting a Git repository.",
      "cve": "CVE-2016-3069",
      "specs": [
        "<=3.7.2"
      ]
    },
    {
      "id": "pyup.io-mercurial:CVE-2016-3105",
      "advisory": "The convert extension in Mercurial before 3.8 might allow context-dependent attackers to execute arbitrary code via a crafted git repository name.",
      "cve": "CVE-2016-3105",
      "specs": [
        "<=3.7.3"
      ]
    },
    {
      "id": "pyup.io-mercurial:CVE-2016-3630",
      "advisory": "The binary delta decoder in Mercurial before 3.7.3 allows remote attackers to execute arbitrary code via a (1) clone, (2) push, or (3) pull command, related to (a) a list sizing rounding error and (b) short records.",
      "cve": "CVE-2016-3630",
      "specs": [
        "<=3.7.2"
      ]
    },
    {
      "id": "pyup.io-mercurial:CVE-2017-1000115",
      "advisory": "Mercurial prior to version 4.3 is vulnerable to a missing symlink check that can malicious repositories to modify files outside the repository",
      "cve": "CVE-2017-1000115",
      "specs": [
        "<4.3"
      ]
    },
    {
      "id": "pyup.io-mercurial:CVE-2017-1000116",
      "advisory": "Mercurial prior to 4.3 did not adequately sanitize hostnames passed to ssh, leading to possible shell-injection attacks.",
      "cve": "CVE-2017-1000116",
      "specs": [
        "<4.3"
      ]
    },
    {
      "id": "pyup.io-mercurial:CVE-2017-17458",
      "advisory": "In Mercurial before 4.4.1, it is possible that a specially malformed repository can cause Git subrepositories to run arbitrary code in the form of a .git/hooks/post-update script checked into the repository. Typical use of Mercurial prevents construction of such repositories, but they can be created programmatically.",
      "cve": "CVE-2017-17458",
      "specs": [
        "<4.4.1"
      ]
    },
    {
      "id": "pyup.io-mercurial:CVE-2017-9462",
      "advisory": "In Mercurial before 4.1.3, \"hg serve --stdio\" allows remote authenticated users to launch the Python debugger, and consequently execute arbitrary code, by using --debugger as a repository name.",
      "cve": "CVE-2017-9462",
      "specs": [
        "<4.1.3"
      ]
    },
    {
      "id": "pyup.io-mercurial:CVE-2018-1000132",
      "advisory": "Mercurial version 4.5 and earlier contains a Incorrect Access Control (CWE-285) vulnerability in Protocol server that can result in Unauthorized data access. This attack appear to be exploitable via network connectivity. This vulnerability appears to have been fixed in 4.5.1.",
      "cve": "CVE-2018-1000132",
      "specs": [
        "<4.5.1"
      ]
    },
    {
      "id": "pyup.io-mercurial:CVE-2018-13346",
      "advisory": "The mpatch_apply function in mpatch.c in Mercurial before 4.6.1 incorrectly proceeds in cases where the fragment start is past the end of the original data, aka OVE-20180430-0004.",
      "cve": "CVE-2018-13346",
      "specs": [
        "<4.6.1"
      ]
    },
    {
      "id": "pyup.io-mercurial:CVE-2018-13347",
      "advisory": "mpatch.c in Mercurial before 4.6.1 mishandles integer addition and subtraction, aka OVE-20180430-0002.",
      "cve": "CVE-2018-13347",
      "specs": [
        "<4.6.1"
      ]
    },
    {
      "id": "pyup.io-mercurial:CVE-2018-13348",
      "advisory": "The mpatch_decode function in mpatch.c in Mercurial before 4.6.1 mishandles certain situations where there should be at least 12 bytes remaining after the current position in the patch data, but actually are not, aka OVE-20180430-0001.",
      "cve": "CVE-2018-13348",
      "specs": [
        "<4.6.1"
      ]
    },
    {
      "id": "pyup.io-mercurial:CVE-2018-17983",
      "advisory": "cext/manifest.c in Mercurial before 4.7.2 has an out-of-bounds read during parsing of a malformed manifest entry.",
      "cve": "CVE-2018-17983",
      "specs": [
        "<4.7.2"
      ]
    },
    {
      "id": "pyup.io-mercurial:CVE-2019-3902",
      "advisory": "A flaw was found in Mercurial before 4.9. It was possible to use symlinks and subrepositories to defeat Mercurial's path-checking logic and write files outside a repository.",
      "cve": "CVE-2019-3902",
      "specs": [
        "<4.9"
      ]
    }
  ],
  "misp-maltego": [
    {
      "id": "pyup.io-misp-maltego:CVE-2020-12889",
      "advisory": "MISP MISP-maltego 1.4.4 incorrectly shares a MISP connection across users in a remote-transform use case.",
      "cve": "CVE-2020-12889",
      "specs": [
        "==1.4.4"
      ]
    }
  ],
  "mistral": [
    {
      "id": "pyup.io-mistral:CVE-2018-16848",
      "advisory": "A Denial of Service (DoS) condition is possible in OpenStack Mistral in versions up to and including 7.0.3. Submitting a specially crafted workflow definition YAML file containing nested anchors can lead to resource exhaustion culminating in a denial of service.",
      "cve": "CVE-2018-16848",
      "specs": [
        "<=7.0.3"
      ]
    },
    {
      "id": "pyup.io-mistral:CVE-2018-16849",
      "advisory": "A flaw was found in openstack-mistral. By manipulating the SSH private key filename, the std.ssh action can be used to disclose the presence of arbitrary files within the filesystem of the executor running the action. Since std.ssh private_key_filename can take an absolute path, it can be used to assess whether or not a file exists on the executor's filesystem.",
      "cve": "CVE-2018-16849",
      "specs": [
        "<7.0.1"
      ]
    }
  ],
  "mistune": [
    {
      "id": "pyup.io-mistune:CVE-2017-15612",
      "advisory": "mistune.py in Mistune 0.7.4 allows XSS via an unexpected newline (such as in java\\nscript:) or a crafted email address, related to the escape and autolink functions.",
      "cve": "CVE-2017-15612",
      "specs": [
        "==0.7.4"
      ]
    },
    {
      "id": "pyup.io-mistune:CVE-2017-16876",
      "advisory": "Cross-site scripting (XSS) vulnerability in the _keyify function in mistune.py in Mistune before 0.8.1 allows remote attackers to inject arbitrary web script or HTML by leveraging failure to escape the \"key\" argument.",
      "cve": "CVE-2017-16876",
      "specs": [
        "<0.8.1"
      ]
    }
  ],
  "mitmproxy": [
    {
      "id": "pyup.io-mitmproxy:CVE-2018-14505",
      "advisory": "mitmweb in mitmproxy v4.0.3 allows DNS Rebinding attacks, related to tools/web/app.py.",
      "cve": "CVE-2018-14505",
      "specs": [
        "==4.0.3"
      ]
    },
    {
      "id": "pyup.io-mitmproxy:CVE-2021-39214",
      "advisory": "mitmproxy is an interactive, SSL/TLS-capable intercepting proxy. In mitmproxy 7.0.2 and below, a malicious client or server is able to perform HTTP request smuggling attacks through mitmproxy. This means that a malicious client/server could smuggle a request/response through mitmproxy as part of another request/response's HTTP message body. While a smuggled request is still captured as part of another request's body, it does not appear in the request list and does not go through the usual mitmproxy event hooks, where users may have implemented custom access control checks or input sanitization. Unless one uses mitmproxy to protect an HTTP/1 service, no action is required. The vulnerability has been fixed in mitmproxy 7.0.3 and above.",
      "cve": "CVE-2021-39214",
      "specs": [
        "<=7.0.2"
      ]
    }
  ],
  "mitogen": [
    {
      "id": "pyup.io-mitogen:CVE-2019-15149",
      "advisory": "** DISPUTED ** core.py in Mitogen before 0.2.8 has a typo that drops the unidirectional-routing protection mechanism in the case of a child that is initiated by another child. The Ansible extension is unaffected. NOTE: the vendor disputes this issue because it is exploitable only in conjunction with hypothetical other factors, i.e., an affected use case within a library caller, and a bug in the message receiver policy code that led to reliance on this extra protection mechanism.",
      "cve": "CVE-2019-15149",
      "specs": [
        "<0.2.8"
      ]
    }
  ],
  "mkdocs": [
    {
      "id": "pyup.io-mkdocs:CVE-2021-40978",
      "advisory": "** DISPUTED ** The mkdocs 1.2.2 built-in dev-server allows directory traversal using the port 8000, enabling remote exploitation to obtain :sensitive information. NOTE: the vendor has disputed this as described in https://github.com/mkdocs/mkdocs/issues/2601.] and https://github.com/nisdn/CVE-2021-40978/issues/1.",
      "cve": "CVE-2021-40978",
      "specs": [
        "==1.2.2"
      ]
    }
  ],
  "mlalchemy": [
    {
      "id": "pyup.io-mlalchemy:CVE-2017-16615",
      "advisory": "An exploitable vulnerability exists in the YAML parsing functionality in the parse_yaml_query method in parser.py in MLAlchemy before 0.2.2. When processing YAML-Based queries for data, a YAML parser can execute arbitrary Python commands resulting in command execution because load is used where safe_load should have been used. An attacker can insert Python into loaded YAML to trigger this vulnerability.",
      "cve": "CVE-2017-16615",
      "specs": [
        "==0.1.1",
        "==0.1.2",
        "==0.1.3",
        "==0.2.0",
        "==0.2.1"
      ]
    }
  ],
  "mode": [
    {
      "id": "pyup.io-mode:CVE-2013-5106",
      "advisory": "A Code Execution vulnerability exists in select.py when using python-mode 2012-12-19.",
      "cve": "CVE-2013-5106",
      "specs": [
        "==2012-12-19"
      ]
    }
  ],
  "modulemd": [
    {
      "id": "pyup.io-modulemd:CVE-2017-1002157",
      "advisory": "modulemd 1.3.1 and earlier uses an unsafe function for processing externally provided data, leading to remote code execution.",
      "cve": "CVE-2017-1002157",
      "specs": [
        "<=1.3.1"
      ]
    }
  ],
  "moin": [
    {
      "id": "pyup.io-moin:CVE-2004-0708",
      "advisory": "MoinMoin 1.2.1 and earlier allows remote attackers to gain privileges by creating a user with the same name as an existing group that has higher privileges.",
      "cve": "CVE-2004-0708",
      "specs": [
        "==1.1",
        "==1.2",
        "==1.2.1"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2004-1462",
      "advisory": "Unknown vulnerability in MoinMoin 1.2.2 and earlier allows remote attackers to gain unauthorized access to administrator functions such as (1) revert and (2) delete.",
      "cve": "CVE-2004-1462",
      "specs": [
        "==0.1",
        "==0.10",
        "==0.11",
        "==0.2",
        "==0.3",
        "==0.7",
        "==0.8",
        "==0.9",
        "==1.0",
        "==1.1",
        "==1.2",
        "==1.2.1",
        "==1.2.2"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2004-1463",
      "advisory": "Unknown vulnerability in the PageEditor in MoinMoin 1.2.2 and earlier, related to Access Control Lists (ACL), has unknown impact.",
      "cve": "CVE-2004-1463",
      "specs": [
        "==0.1",
        "==0.10",
        "==0.11",
        "==0.2",
        "==0.3",
        "==0.7",
        "==0.8",
        "==0.9",
        "==1.0",
        "==1.1",
        "==1.2",
        "==1.2.1",
        "==1.2.2"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2007-0857",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in MoinMoin before 1.5.7 allow remote attackers to inject arbitrary web script or HTML via (1) the page info, or the page name in a (2) AttachFile, (3) RenamePage, or (4) LocalSiteMap action.",
      "cve": "CVE-2007-0857",
      "specs": [
        "<=1.5.6",
        "==1.5.0",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.3_rc1",
        "==1.5.3_rc2",
        "==1.5.4",
        "==1.5.5",
        "==1.5.5_rc1",
        "==1.5.5a"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2007-0901",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in Info pages in MoinMoin 1.5.7 allow remote attackers to inject arbitrary web script or HTML via the (1) hitcounts and (2) general parameters, different vectors than CVE-2007-0857.  NOTE: the provenance of this information is unknown; the details are obtained solely from third party information.",
      "cve": "CVE-2007-0901",
      "specs": [
        "==1.5.7"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2007-0902",
      "advisory": "Unspecified vulnerability in the \"Show debugging information\" feature in MoinMoin 1.5.7 allows remote attackers to obtain sensitive information.  NOTE: the provenance of this information is unknown; the details are obtained solely from third party information.",
      "cve": "CVE-2007-0902",
      "specs": [
        "==1.5.7"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2007-2423",
      "advisory": "Cross-site scripting (XSS) vulnerability in index.php in MoinMoin 1.5.7 allows remote attackers to inject arbitrary web script or HTML via the do parameter in an AttachFile action, a different vulnerability than CVE-2007-0857.  NOTE: the provenance of this information is unknown; the details are obtained solely from third party information.",
      "cve": "CVE-2007-2423",
      "specs": [
        "==1.5.7"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2008-0780",
      "advisory": "Cross-site scripting (XSS) vulnerability in MoinMoin 1.5.x through 1.5.8 and 1.6.x before 1.6.1 allows remote attackers to inject arbitrary web script or HTML via the login action.",
      "cve": "CVE-2008-0780",
      "specs": [
        "==1.5.0",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.3_rc1",
        "==1.5.3_rc2",
        "==1.5.4",
        "==1.5.5",
        "==1.5.5_rc1",
        "==1.5.5a",
        "==1.5.6",
        "==1.5.7",
        "==1.5.8",
        "==1.6.0"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2008-0781",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in action/AttachFile.py in MoinMoin 1.5.8 and earlier allow remote attackers to inject arbitrary web script or HTML via (1) message, (2) pagename, and (3) target filenames.",
      "cve": "CVE-2008-0781",
      "specs": [
        "==0.1",
        "==0.10",
        "==0.11",
        "==0.2",
        "==0.3",
        "==0.7",
        "==0.8",
        "==0.9",
        "==1.0",
        "==1.1",
        "==1.2",
        "==1.2.1",
        "==1.2.2",
        "==1.5.0",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.3_rc1",
        "==1.5.3_rc2",
        "==1.5.4",
        "==1.5.5",
        "==1.5.5_rc1",
        "==1.5.5a",
        "==1.5.6",
        "==1.5.7",
        "==1.5.8"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2008-0782",
      "advisory": "Directory traversal vulnerability in MoinMoin 1.5.8 and earlier allows remote attackers to overwrite arbitrary files via a .. (dot dot) in the MOIN_ID user ID in a cookie for a userform action.  NOTE: this issue can be leveraged for PHP code execution via the quicklinks parameter.",
      "cve": "CVE-2008-0782",
      "specs": [
        "==0.1",
        "==0.10",
        "==0.11",
        "==0.2",
        "==0.3",
        "==0.7",
        "==0.8",
        "==0.9",
        "==1.0",
        "==1.1",
        "==1.2",
        "==1.2.1",
        "==1.2.2",
        "==1.5.0",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.3_rc1",
        "==1.5.3_rc2",
        "==1.5.4",
        "==1.5.5",
        "==1.5.5_rc1",
        "==1.5.5a",
        "==1.5.6",
        "==1.5.7",
        "==1.5.8"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2008-1098",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in MoinMoin 1.5.8 and earlier allow remote attackers to inject arbitrary web script or HTML via (1) certain input processed by formatter/text_gedit.py (aka the gui editor formatter); (2) a page name, which triggers an injection in PageEditor.py when the page is successfully deleted by a victim in a DeletePage action; or (3) the destination page name for a RenamePage action, which triggers an injection in PageEditor.py when a victim's rename attempt fails because of a duplicate name.  NOTE: the AttachFile XSS issue is already covered by CVE-2008-0781, and the login XSS issue is already covered by CVE-2008-0780.",
      "cve": "CVE-2008-1098",
      "specs": [
        "<=1.5.8"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2008-1099",
      "advisory": "_macro_Getval in wikimacro.py in MoinMoin 1.5.8 and earlier does not properly enforce ACLs, which allows remote attackers to read protected pages.",
      "cve": "CVE-2008-1099",
      "specs": [
        "<=1.5.8"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2008-1937",
      "advisory": "The user form processing (userform.py) in MoinMoin before 1.6.3, when using ACLs or a non-empty superusers list, does not properly manage users, which allows remote attackers to gain privileges.",
      "cve": "CVE-2008-1937",
      "specs": [
        "==1.6.0",
        "==1.6.1",
        "==1.6.2"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2008-3381",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in macro/AdvancedSearch.py in moin (and MoinMoin) 1.6.3 and 1.7.0 allow remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2008-3381",
      "specs": [
        "==1.6.3",
        "==1.7.0"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2008-6548",
      "advisory": "The rst parser (parser/text_rst.py) in MoinMoin 1.6.1 does not check the ACL of an included page, which allows attackers to read unauthorized include files via unknown vectors.",
      "cve": "CVE-2008-6548",
      "specs": [
        "==1.6.1"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2008-6549",
      "advisory": "The password_checker function in config/multiconfig.py in MoinMoin 1.6.1 uses the cracklib and python-crack features even though they are not thread-safe, which allows remote attackers to cause a denial of service (segmentation fault and crash) via unknown vectors.",
      "cve": "CVE-2008-6549",
      "specs": [
        "==1.6.1"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2008-6603",
      "advisory": "MoinMoin 1.6.2 and 1.7 does not properly enforce ACL checks when acl_hierarchic is set to True, which might allow remote attackers to bypass intended access restrictions, a different vulnerability than CVE-2008-1937.",
      "cve": "CVE-2008-6603",
      "specs": [
        "==1.6.2",
        "==1.7.0"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2009-0260",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in action/AttachFile.py in MoinMoin before 1.8.1 allow remote attackers to inject arbitrary web script or HTML via an AttachFile action to the WikiSandBox component with (1) the rename parameter or (2) the drawing parameter (aka the basename variable).",
      "cve": "CVE-2009-0260",
      "specs": [
        "<=1.8.0",
        "==0.1",
        "==0.10",
        "==0.11",
        "==0.2",
        "==0.3",
        "==0.7",
        "==0.8",
        "==0.9",
        "==1.0",
        "==1.1",
        "==1.2",
        "==1.2.1",
        "==1.2.2",
        "==1.5.0",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.3_rc1",
        "==1.5.3_rc2",
        "==1.5.4",
        "==1.5.5",
        "==1.5.5_rc1",
        "==1.5.5a",
        "==1.5.6",
        "==1.5.7",
        "==1.5.8",
        "==1.6",
        "==1.6.0",
        "==1.6.1",
        "==1.6.2",
        "==1.6.3",
        "==1.7.0",
        "==1.7.1",
        "==1.7.2",
        "==1.7.3"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2009-0312",
      "advisory": "Cross-site scripting (XSS) vulnerability in the antispam feature (security/antispam.py) in MoinMoin 1.7 and 1.8.1 allows remote attackers to inject arbitrary web script or HTML via crafted, disallowed content.",
      "cve": "CVE-2009-0312",
      "specs": [
        "==1.7.0",
        "==1.8.1"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2009-1482",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in action/AttachFile.py in MoinMoin 1.8.2 and earlier allow remote attackers to inject arbitrary web script or HTML via (1) an AttachFile sub-action in the error_msg function or (2) multiple vectors related to package file errors in the upload_form function, different vectors than CVE-2009-0260.",
      "cve": "CVE-2009-1482",
      "specs": [
        "<=1.8.2",
        "==0.1",
        "==0.10",
        "==0.11",
        "==0.2",
        "==0.3",
        "==0.7",
        "==0.8",
        "==0.9",
        "==1.0",
        "==1.1",
        "==1.2",
        "==1.2.1",
        "==1.2.2",
        "==1.5.0",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.3_rc1",
        "==1.5.3_rc2",
        "==1.5.4",
        "==1.5.5",
        "==1.5.5_rc1",
        "==1.5.5a",
        "==1.5.6",
        "==1.5.7",
        "==1.5.8",
        "==1.6",
        "==1.6.0",
        "==1.6.1",
        "==1.6.2",
        "==1.6.3",
        "==1.7",
        "==1.7.0",
        "==1.7.1",
        "==1.7.2",
        "==1.7.3",
        "==1.8.0",
        "==1.8.1"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2009-4762",
      "advisory": "MoinMoin 1.7.x before 1.7.3 and 1.8.x before 1.8.3 checks parent ACLs in certain inappropriate circumstances during processing of hierarchical ACLs, which allows remote attackers to bypass intended access restrictions by requesting an item, a different vulnerability than CVE-2008-6603.",
      "cve": "CVE-2009-4762",
      "specs": [
        "==1.7.0",
        "==1.7.1",
        "==1.7.2",
        "==1.8.0",
        "==1.8.1",
        "==1.8.2"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2010-0667",
      "advisory": "MoinMoin 1.9 before 1.9.1 does not perform the expected clearing of the sys.argv array in situations where the GATEWAY_INTERFACE environment variable is set, which allows remote attackers to obtain sensitive information via unspecified vectors.",
      "cve": "CVE-2010-0667",
      "specs": [
        "==1.9.0"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2010-0668",
      "advisory": "Unspecified vulnerability in MoinMoin 1.5.x through 1.7.x, 1.8.x before 1.8.7, and 1.9.x before 1.9.2 has unknown impact and attack vectors, related to configurations that have a non-empty superuser list, the xmlrpc action enabled, the SyncPages action enabled, or OpenID configured.",
      "cve": "CVE-2010-0668",
      "specs": [
        "==1.5.0",
        "==1.5.0-beta1",
        "==1.5.0-beta2",
        "==1.5.0-beta3",
        "==1.5.0-beta4",
        "==1.5.0-beta5",
        "==1.5.0-beta6",
        "==1.5.0-rc1",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.3-rc1",
        "==1.5.3-rc2",
        "==1.5.4",
        "==1.5.5",
        "==1.5.5-rc1",
        "==1.5.5a",
        "==1.5.6",
        "==1.5.7",
        "==1.5.8",
        "==1.6.0",
        "==1.6.0-beta1",
        "==1.6.0-beta2",
        "==1.6.0-rc1",
        "==1.6.0-rc2",
        "==1.6.1",
        "==1.6.2",
        "==1.6.3",
        "==1.6.4",
        "==1.7.0",
        "==1.7.0-beta1",
        "==1.7.0-beta2",
        "==1.7.0-rc1",
        "==1.7.0-rc2",
        "==1.7.0-rc3",
        "==1.7.1",
        "==1.7.2",
        "==1.7.3",
        "==1.8.0",
        "==1.8.1",
        "==1.8.2",
        "==1.8.3",
        "==1.8.4",
        "==1.8.6",
        "==1.9.0",
        "==1.9.1"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2010-0669",
      "advisory": "MoinMoin before 1.8.7 and 1.9.x before 1.9.2 does not properly sanitize user profiles, which has unspecified impact and attack vectors.",
      "cve": "CVE-2010-0669",
      "specs": [
        "<=1.8.6",
        "==1.5.0",
        "==1.5.0-beta1",
        "==1.5.0-beta2",
        "==1.5.0-beta3",
        "==1.5.0-beta4",
        "==1.5.0-beta5",
        "==1.5.0-beta6",
        "==1.5.0-rc1",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.3-rc1",
        "==1.5.3-rc2",
        "==1.5.4",
        "==1.5.5",
        "==1.5.5-rc1",
        "==1.5.5a",
        "==1.5.6",
        "==1.5.7",
        "==1.5.8",
        "==1.6.0",
        "==1.6.0-beta1",
        "==1.6.0-beta2",
        "==1.6.0-rc1",
        "==1.6.0-rc2",
        "==1.6.1",
        "==1.6.2",
        "==1.6.3",
        "==1.6.4",
        "==1.7.0",
        "==1.7.0-beta1",
        "==1.7.0-beta2",
        "==1.7.0-rc1",
        "==1.7.0-rc2",
        "==1.7.0-rc3",
        "==1.7.1",
        "==1.7.2",
        "==1.7.3",
        "==1.8.0",
        "==1.8.1",
        "==1.8.2",
        "==1.8.3",
        "==1.8.4",
        "==1.9.0",
        "==1.9.1"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2010-0717",
      "advisory": "The default configuration of cfg.packagepages_actions_excluded in MoinMoin before 1.8.7 does not prevent unsafe package actions, which has unspecified impact and attack vectors.",
      "cve": "CVE-2010-0717",
      "specs": [
        "<=1.8.6",
        "==1.5.0",
        "==1.5.0-beta1",
        "==1.5.0-beta2",
        "==1.5.0-beta3",
        "==1.5.0-beta4",
        "==1.5.0-beta5",
        "==1.5.0-beta6",
        "==1.5.0-rc1",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.3-rc1",
        "==1.5.3-rc2",
        "==1.5.4",
        "==1.5.5",
        "==1.5.5-rc1",
        "==1.5.5a",
        "==1.5.6",
        "==1.5.7",
        "==1.5.8",
        "==1.6.0",
        "==1.6.0-beta1",
        "==1.6.0-beta2",
        "==1.6.0-rc1",
        "==1.6.0-rc2",
        "==1.6.1",
        "==1.6.2",
        "==1.6.3",
        "==1.6.4",
        "==1.7.0",
        "==1.7.0-beta1",
        "==1.7.0-beta2",
        "==1.7.0-rc1",
        "==1.7.0-rc2",
        "==1.7.0-rc3",
        "==1.7.1",
        "==1.7.2",
        "==1.7.3",
        "==1.8.0",
        "==1.8.1",
        "==1.8.2",
        "==1.8.3",
        "==1.8.4"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2010-0828",
      "advisory": "Cross-site scripting (XSS) vulnerability in action/Despam.py in the Despam action module in MoinMoin 1.8.7 and 1.9.2 allows remote authenticated users to inject arbitrary web script or HTML by creating a page with a crafted URI.",
      "cve": "CVE-2010-0828",
      "specs": [
        "==1.8.7",
        "==1.9.2"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2010-1238",
      "advisory": "MoinMoin 1.7.1 allows remote attackers to bypass the textcha protection mechanism by modifying the textcha-question and textcha-answer fields to have empty values.",
      "cve": "CVE-2010-1238",
      "specs": [
        "==1.7.1"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2010-2487",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in MoinMoin 1.7.3 and earlier, 1.8.x before 1.8.8, and 1.9.x before 1.9.3 allow remote attackers to inject arbitrary web script or HTML via crafted content, related to (1) Page.py, (2) PageEditor.py, (3) PageGraphicalEditor.py, (4) action/CopyPage.py, (5) action/Load.py, (6) action/RenamePage.py, (7) action/backup.py, (8) action/login.py, (9) action/newaccount.py, and (10) action/recoverpass.py.",
      "cve": "CVE-2010-2487",
      "specs": [
        "<=1.7.3",
        "==0.1",
        "==0.10",
        "==0.11",
        "==0.2",
        "==0.3",
        "==0.4",
        "==0.5",
        "==0.6",
        "==0.7",
        "==0.8",
        "==0.9",
        "==1.0",
        "==1.1",
        "==1.2",
        "==1.2.1",
        "==1.2.2",
        "==1.2.3",
        "==1.2.4",
        "==1.3.0",
        "==1.3.1",
        "==1.3.2",
        "==1.3.3",
        "==1.3.4",
        "==1.3.5",
        "==1.3.5-rc1",
        "==1.4",
        "==1.5.0",
        "==1.5.0-beta1",
        "==1.5.0-beta2",
        "==1.5.0-beta3",
        "==1.5.0-beta4",
        "==1.5.0-beta5",
        "==1.5.0-beta6",
        "==1.5.0-rc1",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.3-rc1",
        "==1.5.3-rc2",
        "==1.5.4",
        "==1.5.5",
        "==1.5.5-rc1",
        "==1.5.5a",
        "==1.5.6",
        "==1.5.7",
        "==1.5.8",
        "==1.6.0",
        "==1.6.0-beta1",
        "==1.6.0-beta2",
        "==1.6.0-rc1",
        "==1.6.0-rc2",
        "==1.6.1",
        "==1.6.2",
        "==1.6.3",
        "==1.6.4",
        "==1.7.0",
        "==1.7.0-beta1",
        "==1.7.0-beta2",
        "==1.7.0-rc1",
        "==1.7.0-rc2",
        "==1.7.0-rc3",
        "==1.7.1",
        "==1.7.2",
        "==1.8.0",
        "==1.8.1",
        "==1.8.2",
        "==1.8.3",
        "==1.8.4",
        "==1.8.6",
        "==1.8.7",
        "==1.9.0",
        "==1.9.1",
        "==1.9.2"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2010-2969",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in MoinMoin 1.7.3 and earlier, and 1.9.x before 1.9.3, allow remote attackers to inject arbitrary web script or HTML via crafted content, related to (1) action/LikePages.py, (2) action/chart.py, and (3) action/userprofile.py, a similar issue to CVE-2010-2487.",
      "cve": "CVE-2010-2969",
      "specs": [
        "<=1.7.3",
        "==0.1",
        "==0.10",
        "==0.11",
        "==0.2",
        "==0.3",
        "==0.4",
        "==0.5",
        "==0.6",
        "==0.7",
        "==0.8",
        "==0.9",
        "==1.0",
        "==1.1",
        "==1.2",
        "==1.2.1",
        "==1.2.2",
        "==1.2.3",
        "==1.2.4",
        "==1.3.0",
        "==1.3.1",
        "==1.3.2",
        "==1.3.3",
        "==1.3.4",
        "==1.3.5",
        "==1.3.5-rc1",
        "==1.4",
        "==1.5.0",
        "==1.5.0-beta1",
        "==1.5.0-beta2",
        "==1.5.0-beta3",
        "==1.5.0-beta4",
        "==1.5.0-beta5",
        "==1.5.0-beta6",
        "==1.5.0-rc1",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.3-rc1",
        "==1.5.3-rc2",
        "==1.5.4",
        "==1.5.5",
        "==1.5.5-rc1",
        "==1.5.5a",
        "==1.5.6",
        "==1.5.7",
        "==1.5.8",
        "==1.6.0",
        "==1.6.0-beta1",
        "==1.6.0-beta2",
        "==1.6.0-rc1",
        "==1.6.0-rc2",
        "==1.6.1",
        "==1.6.2",
        "==1.6.3",
        "==1.6.4",
        "==1.7.0",
        "==1.7.0-beta1",
        "==1.7.0-beta2",
        "==1.7.0-rc1",
        "==1.7.0-rc2",
        "==1.7.0-rc3",
        "==1.7.1",
        "==1.7.2",
        "==1.9.0",
        "==1.9.1",
        "==1.9.2"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2010-2970",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in MoinMoin 1.9.x before 1.9.3 allow remote attackers to inject arbitrary web script or HTML via crafted content, related to (1) action/SlideShow.py, (2) action/anywikidraw.py, and (3) action/language_setup.py, a similar issue to CVE-2010-2487.",
      "cve": "CVE-2010-2970",
      "specs": [
        "==1.9.0",
        "==1.9.1",
        "==1.9.2"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2011-1058",
      "advisory": "Cross-site scripting (XSS) vulnerability in the reStructuredText (rst) parser in parser/text_rst.py in MoinMoin before 1.9.3, when docutils is installed or when \"format rst\" is set, allows remote attackers to inject arbitrary web script or HTML via a javascript: URL in the refuri attribute.  NOTE: some of these details are obtained from third party information.",
      "cve": "CVE-2011-1058",
      "specs": [
        "<=1.9.2",
        "==0.1",
        "==0.10",
        "==0.11",
        "==0.2",
        "==0.3",
        "==0.4",
        "==0.5",
        "==0.6",
        "==0.7",
        "==0.8",
        "==0.9",
        "==1.0",
        "==1.1",
        "==1.2",
        "==1.2.1",
        "==1.2.2",
        "==1.2.3",
        "==1.2.4",
        "==1.3.0",
        "==1.3.1",
        "==1.3.2",
        "==1.3.3",
        "==1.3.4",
        "==1.3.5",
        "==1.3.5-rc1",
        "==1.4",
        "==1.5.0",
        "==1.5.0-beta1",
        "==1.5.0-beta2",
        "==1.5.0-beta3",
        "==1.5.0-beta4",
        "==1.5.0-beta5",
        "==1.5.0-beta6",
        "==1.5.0-rc1",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.3-rc1",
        "==1.5.3-rc2",
        "==1.5.4",
        "==1.5.5",
        "==1.5.5-a",
        "==1.5.5-rc1",
        "==1.5.5a",
        "==1.5.6",
        "==1.5.7",
        "==1.5.8",
        "==1.6.0",
        "==1.6.0-beta1",
        "==1.6.0-beta2",
        "==1.6.0-rc1",
        "==1.6.0-rc2",
        "==1.6.1",
        "==1.6.2",
        "==1.6.3",
        "==1.6.4",
        "==1.7.0",
        "==1.7.0-beta1",
        "==1.7.0-beta2",
        "==1.7.0-rc1",
        "==1.7.0-rc2",
        "==1.7.0-rc3",
        "==1.7.1",
        "==1.7.2",
        "==1.7.3",
        "==1.8.0",
        "==1.8.1",
        "==1.8.2",
        "==1.8.3",
        "==1.8.4",
        "==1.8.6",
        "==1.8.7",
        "==1.8.8",
        "==1.9.0",
        "==1.9.1"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2012-4404",
      "advisory": "security/__init__.py in MoinMoin 1.9 through 1.9.4 does not properly handle group names that contain virtual group names such as \"All,\" \"Known,\" or \"Trusted,\" which allows remote authenticated users with virtual group membership to be treated as a member of the group.",
      "cve": "CVE-2012-4404",
      "specs": [
        "==1.9.0",
        "==1.9.1",
        "==1.9.2",
        "==1.9.3",
        "==1.9.4"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2012-6080",
      "advisory": "Directory traversal vulnerability in the _do_attachment_move function in the AttachFile action (action/AttachFile.py) in MoinMoin 1.9.3 through 1.9.5 allows remote attackers to overwrite arbitrary files via a .. (dot dot) in a file name.",
      "cve": "CVE-2012-6080",
      "specs": [
        "==1.9.3",
        "==1.9.4",
        "==1.9.5"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2012-6081",
      "advisory": "Multiple unrestricted file upload vulnerabilities in the (1) twikidraw (action/twikidraw.py) and (2) anywikidraw (action/anywikidraw.py) actions in MoinMoin before 1.9.6 allow remote authenticated users with write permissions to execute arbitrary code by uploading a file with an executable extension, then accessing it via a direct request to the file in an unspecified directory, as exploited in the wild in July 2012.",
      "cve": "CVE-2012-6081",
      "specs": [
        "<=1.9.5",
        "==0.1",
        "==0.10",
        "==0.11",
        "==0.2",
        "==0.3",
        "==0.4",
        "==0.5",
        "==0.6",
        "==0.7",
        "==0.8",
        "==0.9",
        "==1.0",
        "==1.1",
        "==1.2",
        "==1.2.1",
        "==1.2.2",
        "==1.2.3",
        "==1.2.4",
        "==1.3.0",
        "==1.3.1",
        "==1.3.2",
        "==1.3.3",
        "==1.3.4",
        "==1.3.5",
        "==1.3.5-rc1",
        "==1.4",
        "==1.5.0",
        "==1.5.0-beta1",
        "==1.5.0-beta2",
        "==1.5.0-beta3",
        "==1.5.0-beta4",
        "==1.5.0-beta5",
        "==1.5.0-beta6",
        "==1.5.0-rc1",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.3-rc1",
        "==1.5.3-rc2",
        "==1.5.4",
        "==1.5.5",
        "==1.5.5-a",
        "==1.5.5-rc1",
        "==1.5.5a",
        "==1.5.6",
        "==1.5.7",
        "==1.5.8",
        "==1.6.0",
        "==1.6.0-beta1",
        "==1.6.0-beta2",
        "==1.6.0-rc1",
        "==1.6.0-rc2",
        "==1.6.1",
        "==1.6.2",
        "==1.6.3",
        "==1.6.4",
        "==1.7.0",
        "==1.7.0-beta1",
        "==1.7.0-beta2",
        "==1.7.0-rc1",
        "==1.7.0-rc2",
        "==1.7.0-rc3",
        "==1.7.1",
        "==1.7.2",
        "==1.7.3",
        "==1.8.0",
        "==1.8.1",
        "==1.8.2",
        "==1.8.3",
        "==1.8.4",
        "==1.8.6",
        "==1.8.7",
        "==1.8.8",
        "==1.9.0",
        "==1.9.1",
        "==1.9.2",
        "==1.9.3",
        "==1.9.4"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2012-6082",
      "advisory": "Cross-site scripting (XSS) vulnerability in the rsslink function in theme/__init__.py in MoinMoin 1.9.5 allows remote attackers to inject arbitrary web script or HTML via the page name in a rss link.",
      "cve": "CVE-2012-6082",
      "specs": [
        "==1.9.5"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2012-6495",
      "advisory": "Multiple directory traversal vulnerabilities in the (1) twikidraw (action/twikidraw.py) and (2) anywikidraw (action/anywikidraw.py) actions in MoinMoin before 1.9.6 allow remote authenticated users with write permissions to overwrite arbitrary files via unspecified vectors.  NOTE: this can be leveraged with CVE-2012-6081 to execute arbitrary code.",
      "cve": "CVE-2012-6495",
      "specs": [
        "<=1.9.5",
        "==0.1",
        "==0.10",
        "==0.11",
        "==0.2",
        "==0.3",
        "==0.4",
        "==0.5",
        "==0.6",
        "==0.7",
        "==0.8",
        "==0.9",
        "==1.0",
        "==1.1",
        "==1.2",
        "==1.2.1",
        "==1.2.2",
        "==1.2.3",
        "==1.2.4",
        "==1.3.0",
        "==1.3.1",
        "==1.3.2",
        "==1.3.3",
        "==1.3.4",
        "==1.3.5",
        "==1.3.5-rc1",
        "==1.4",
        "==1.5.0",
        "==1.5.0-beta1",
        "==1.5.0-beta2",
        "==1.5.0-beta3",
        "==1.5.0-beta4",
        "==1.5.0-beta5",
        "==1.5.0-beta6",
        "==1.5.0-rc1",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.3-rc1",
        "==1.5.3-rc2",
        "==1.5.4",
        "==1.5.5",
        "==1.5.5-a",
        "==1.5.5-rc1",
        "==1.5.5a",
        "==1.5.6",
        "==1.5.7",
        "==1.5.8",
        "==1.6.0",
        "==1.6.0-beta1",
        "==1.6.0-beta2",
        "==1.6.0-rc1",
        "==1.6.0-rc2",
        "==1.6.1",
        "==1.6.2",
        "==1.6.3",
        "==1.6.4",
        "==1.7.0",
        "==1.7.0-beta1",
        "==1.7.0-beta2",
        "==1.7.0-rc1",
        "==1.7.0-rc2",
        "==1.7.0-rc3",
        "==1.7.1",
        "==1.7.2",
        "==1.7.3",
        "==1.8.0",
        "==1.8.1",
        "==1.8.2",
        "==1.8.3",
        "==1.8.4",
        "==1.8.6",
        "==1.8.7",
        "==1.8.8",
        "==1.9.0",
        "==1.9.1",
        "==1.9.2",
        "==1.9.3",
        "==1.9.4"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2016-7146",
      "advisory": "MoinMoin 1.9.8 allows remote attackers to conduct \"JavaScript injection\" attacks by using the \"page creation or crafted URL\" approach, related to a \"Cross Site Scripting (XSS)\" issue affecting the action=fckdialog&dialog=attachment (via page name) component.",
      "cve": "CVE-2016-7146",
      "specs": [
        "==1.9.8"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2016-7148",
      "advisory": "MoinMoin 1.9.8 allows remote attackers to conduct \"JavaScript injection\" attacks by using the \"page creation\" approach, related to a \"Cross Site Scripting (XSS)\" issue affecting the action=AttachFile (via page name) component.",
      "cve": "CVE-2016-7148",
      "specs": [
        "==1.9.8"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2016-9119",
      "advisory": "Cross-site scripting (XSS) vulnerability in the link dialogue in GUI editor in MoinMoin before 1.9.8 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2016-9119",
      "specs": [
        "<=1.9.7"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2017-5934",
      "advisory": "Cross-site scripting (XSS) vulnerability in the link dialogue in GUI editor in MoinMoin before 1.9.10 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2017-5934",
      "specs": [
        "<1.9.10"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2020-15275",
      "advisory": "MoinMoin is a wiki engine. In MoinMoin before version 1.9.11, an attacker with write permissions can upload an SVG file that contains malicious javascript. This javascript will be executed in a user's browser when the user is viewing that SVG file on the wiki. Users are strongly advised to upgrade to a patched version. MoinMoin Wiki 1.9.11 has the necessary fixes and also contains other important fixes.",
      "cve": "CVE-2020-15275",
      "specs": [
        "<1.9.11"
      ]
    },
    {
      "id": "pyup.io-moin:CVE-2020-25074",
      "advisory": "The cache action in action/cache.py in MoinMoin through 1.9.10 allows directory traversal through a crafted HTTP request. An attacker who can upload attachments to the wiki can use this to achieve remote code execution.",
      "cve": "CVE-2020-25074",
      "specs": [
        "<=1.9.10"
      ]
    }
  ],
  "mpmath": [
    {
      "id": "pyup.io-mpmath:CVE-2021-29063",
      "advisory": "A Regular Expression Denial of Service (ReDOS) vulnerability was discovered in Mpmath v1.0.0 when the mpmathify function is called.",
      "cve": "CVE-2021-29063",
      "specs": [
        "==1.0.0"
      ]
    }
  ],
  "mpxj": [
    {
      "id": "pyup.io-mpxj:CVE-2020-25020",
      "advisory": "MPXJ through 8.1.3 allows XXE attacks. This affects the GanttProjectReader and PhoenixReader components.",
      "cve": "CVE-2020-25020",
      "specs": [
        "<=8.1.3"
      ]
    },
    {
      "id": "pyup.io-mpxj:CVE-2020-35460",
      "advisory": "common/InputStreamHelper.java in Packwood MPXJ before 8.3.5 allows directory traversal in the zip stream handler flow, leading to the writing of files to arbitrary locations.",
      "cve": "CVE-2020-35460",
      "specs": [
        "<8.3.5"
      ]
    }
  ],
  "murano": [
    {
      "id": "pyup.io-murano:CVE-2016-4972",
      "advisory": "OpenStack Murano before 1.0.3 (liberty) and 2.x before 2.0.1 (mitaka), Murano-dashboard before 1.0.3 (liberty) and 2.x before 2.0.1 (mitaka), and python-muranoclient before 0.7.3 (liberty) and 0.8.x before 0.8.5 (mitaka) improperly use loaders inherited from yaml.Loader when parsing MuranoPL and UI files, which allows remote attackers to create arbitrary Python objects and execute arbitrary code via crafted extended YAML tags in UI definitions in packages.",
      "cve": "CVE-2016-4972",
      "specs": [
        "<=1.0.2"
      ]
    }
  ],
  "murano-client": [
    {
      "id": "pyup.io-murano-client:CVE-2016-4972",
      "advisory": "OpenStack Murano before 1.0.3 (liberty) and 2.x before 2.0.1 (mitaka), Murano-dashboard before 1.0.3 (liberty) and 2.x before 2.0.1 (mitaka), and python-muranoclient before 0.7.3 (liberty) and 0.8.x before 0.8.5 (mitaka) improperly use loaders inherited from yaml.Loader when parsing MuranoPL and UI files, which allows remote attackers to create arbitrary Python objects and execute arbitrary code via crafted extended YAML tags in UI definitions in packages.",
      "cve": "CVE-2016-4972",
      "specs": [
        "<=0.7.2"
      ]
    }
  ],
  "murano-dashboard": [
    {
      "id": "pyup.io-murano-dashboard:CVE-2016-4972",
      "advisory": "OpenStack Murano before 1.0.3 (liberty) and 2.x before 2.0.1 (mitaka), Murano-dashboard before 1.0.3 (liberty) and 2.x before 2.0.1 (mitaka), and python-muranoclient before 0.7.3 (liberty) and 0.8.x before 0.8.5 (mitaka) improperly use loaders inherited from yaml.Loader when parsing MuranoPL and UI files, which allows remote attackers to create arbitrary Python objects and execute arbitrary code via crafted extended YAML tags in UI definitions in packages.",
      "cve": "CVE-2016-4972",
      "specs": [
        "<=1.0.2"
      ]
    }
  ],
  "mysql-connector": [
    {
      "id": "pyup.io-mysql-connector:CVE-2016-5598",
      "advisory": "Unspecified vulnerability in the MySQL Connector component 2.1.3 and earlier and 2.0.4 and earlier in Oracle MySQL allows remote attackers to affect confidentiality, integrity, and availability via vectors related to Connector/Python.",
      "cve": "CVE-2016-5598",
      "specs": [
        ">=2.0.0,<=2.0.4",
        ">=2.1.0,<=2.1.3"
      ]
    }
  ],
  "nameko": [
    {
      "id": "pyup.io-nameko:CVE-2021-41078",
      "advisory": "Nameko through 2.13.0 can be tricked into performing arbitrary code execution when deserializing the config file.",
      "cve": "CVE-2021-41078",
      "specs": [
        "<=2.13.0",
        "==3.0.0-rc1",
        "==3.0.0-rc2",
        "==3.0.0-rc3",
        "==3.0.0-rc4",
        "==3.0.0-rc5",
        "==3.0.0-rc6",
        "==3.0.0-rc7",
        "==3.0.0-rc8",
        "==3.0.0-rc9"
      ]
    }
  ],
  "nanopb": [
    {
      "id": "pyup.io-nanopb:CVE-2020-26243",
      "advisory": "Nanopb is a small code-size Protocol Buffers implementation. In Nanopb before versions 0.4.4 and 0.3.9.7, decoding specifically formed message can leak memory if dynamic allocation is enabled and an oneof field contains a static submessage that contains a dynamic field, and the message being decoded contains the submessage multiple times. This is rare in normal messages, but it is a concern when untrusted data is parsed. This is fixed in versions 0.3.9.7 and 0.4.4. The following workarounds are available: 1) Set the option `no_unions` for the oneof field. This will generate fields as separate instead of C union, and avoids triggering the problematic code. 2) Set the type of the submessage field inside oneof to `FT_POINTER`. This way the whole submessage will be dynamically allocated and the problematic code is not executed. 3) Use an arena allocator for nanopb, to make sure all memory can be released afterwards.",
      "cve": "CVE-2020-26243",
      "specs": [
        "<0.3.9.7",
        ">=0.4.0,<0.4.4"
      ]
    },
    {
      "id": "pyup.io-nanopb:CVE-2020-5235",
      "advisory": "There is a potentially exploitable out of memory condition In Nanopb before 0.4.1, 0.3.9.5, and 0.2.9.4. When nanopb is compiled with PB_ENABLE_MALLOC, the message to be decoded contains a repeated string, bytes or message field and realloc() runs out of memory when expanding the array nanopb can end up calling `free()` on a pointer value that comes from uninitialized memory. Depending on platform this can result in a crash or further memory corruption, which may be exploitable in some cases. This problem is fixed in nanopb-0.4.1, nanopb-0.3.9.5, nanopb-0.2.9.4.",
      "cve": "CVE-2020-5235",
      "specs": [
        "<0.2.9.4",
        ">=0.3.0,<0.3.9.5",
        ">=0.4.0,<0.4.1"
      ]
    },
    {
      "id": "pyup.io-nanopb:CVE-2021-21401",
      "advisory": "Nanopb is a small code-size Protocol Buffers implementation in ansi C. In Nanopb before versions 0.3.9.8 and 0.4.5, decoding a specifically formed message can cause invalid `free()` or `realloc()` calls if the message type contains an `oneof` field, and the `oneof` directly contains both a pointer field and a non-pointer field. If the message data first contains the non-pointer field and then the pointer field, the data of the non-pointer field is incorrectly treated as if it was a pointer value. Such message data rarely occurs in normal messages, but it is a concern when untrusted data is parsed. This has been fixed in versions 0.3.9.8 and 0.4.5. See referenced GitHub Security Advisory for more information including workarounds.",
      "cve": "CVE-2021-21401",
      "specs": [
        "<0.3.9.8",
        ">=0.4.0,<0.4.5"
      ]
    }
  ],
  "nbgitpuller": [
    {
      "id": "pyup.io-nbgitpuller:CVE-2021-39160",
      "advisory": "nbgitpuller is a Jupyter server extension to sync a git repository one-way to a local path. Due to unsanitized input, visiting maliciously crafted links could result in arbitrary code execution in the user environment. This has been resolved in version 0.10.2 and all users are advised to upgrade. No work around exist for users who can not upgrade.",
      "cve": "CVE-2021-39160",
      "specs": [
        ">=0.9.0,<0.10.2"
      ]
    }
  ],
  "netius": [
    {
      "id": "pyup.io-netius:CVE-2020-7655",
      "advisory": "netius prior to 1.17.58 is vulnerable to HTTP Request Smuggling. HTTP pipelining issues and request smuggling attacks might be possible due to incorrect Transfer encoding header parsing which could allow for CL:TE or TE:TE attacks.",
      "cve": "CVE-2020-7655",
      "specs": [
        "<1.17.58"
      ]
    }
  ],
  "neutron": [
    {
      "id": "pyup.io-neutron:CVE-2013-6433",
      "advisory": "The default configuration in the Red Hat openstack-neutron package before 2013.2.3-7 does not properly set a configuration file for rootwrap, which allows remote attackers to gain privileges via a crafted configuration file.",
      "cve": "CVE-2013-6433",
      "specs": [
        ">=2013.1,<=2013.2.3"
      ]
    },
    {
      "id": "pyup.io-neutron:CVE-2014-0056",
      "advisory": "The l3-agent in OpenStack Neutron 2012.2 before 2013.2.3 does not check the tenant id when creating ports, which allows remote authenticated users to plug ports into the routers of arbitrary tenants via the device id in a port-create command.",
      "cve": "CVE-2014-0056",
      "specs": [
        "==2012.2",
        "==2012.2.1",
        "==2012.2.2",
        "==2012.2.3",
        "==2012.2.4",
        "==2013.1",
        "==2013.1.1",
        "==2013.1.2",
        "==2013.1.3",
        "==2013.1.4",
        "==2013.1.5",
        "==2013.2",
        "==2013.2.1",
        "==2013.2.2"
      ]
    },
    {
      "id": "pyup.io-neutron:CVE-2014-0187",
      "advisory": "The openvswitch-agent process in OpenStack Neutron 2013.1 before 2013.2.4 and 2014.1 before 2014.1.1 allows remote authenticated users to bypass security group restrictions via an invalid CIDR in a security group rule, which prevents further rules from being applied.",
      "cve": "CVE-2014-0187",
      "specs": [
        "==2013.1",
        "==2013.1.1",
        "==2013.1.2",
        "==2013.1.3",
        "==2013.1.4",
        "==2013.1.5",
        "==2013.2",
        "==2013.2.1",
        "==2013.2.2",
        "==2013.2.3",
        "==2014.1"
      ]
    },
    {
      "id": "pyup.io-neutron:CVE-2014-3555",
      "advisory": "OpenStack Neutron before 2013.2.4, 2014.x before 2014.1.2, and Juno before Juno-2 allows remote authenticated users to cause a denial of service (crash or long firewall rule updates) by creating a large number of allowed address pairs.",
      "cve": "CVE-2014-3555",
      "specs": [
        "==2013.2.4",
        "==2014.1",
        "==2014.1.1",
        "==juno-1"
      ]
    },
    {
      "id": "pyup.io-neutron:CVE-2014-3632",
      "advisory": "The default configuration in a sudoers file in the Red Hat openstack-neutron package before 2014.1.2-4, as used in Red Hat Enterprise Linux Open Stack Platform 5.0 for Red Hat Enterprise Linux 6, allows remote attackers to gain privileges via a crafted configuration file.  NOTE: this vulnerability exists because of a CVE-2013-6433 regression.",
      "cve": "CVE-2014-3632",
      "specs": [
        ">=2014.1,<=2014.1.2"
      ]
    },
    {
      "id": "pyup.io-neutron:CVE-2014-4167",
      "advisory": "The L3-agent in OpenStack Neutron before 2013.2.4, 2014.x before 2014.1.2, and Juno before Juno-2 allows remote authenticated users to cause a denial of service (IPv4 address attachment outage) by attaching an IPv6 private subnet to a L3 router.",
      "cve": "CVE-2014-4167",
      "specs": [
        "==2014.1",
        "==2014.1.1",
        ">=2011.1,<=2013.2.3"
      ]
    },
    {
      "id": "pyup.io-neutron:CVE-2014-4615",
      "advisory": "The notifier middleware in OpenStack PyCADF 0.5.0 and earlier, Telemetry (Ceilometer) 2013.2 before 2013.2.4 and 2014.x before 2014.1.2, Neutron 2014.x before 2014.1.2 and Juno before Juno-2, and Oslo allows remote authenticated users to obtain X_AUTH_TOKEN values by reading the message queue (v2/meters/http.request).",
      "cve": "CVE-2014-4615",
      "specs": [
        "==2014.1",
        "==2014.1.1",
        "==juno1"
      ]
    },
    {
      "id": "pyup.io-neutron:CVE-2014-6414",
      "advisory": "OpenStack Neutron before 2014.2.4 and 2014.1 before 2014.1.2 allows remote authenticated users to set admin network attributes to default values via unspecified vectors.",
      "cve": "CVE-2014-6414",
      "specs": [
        ">=2013.2,<=2013.2.4",
        ">=2014.1,<2014.1.2",
        ">=2014.2,<=2014.2.4"
      ]
    },
    {
      "id": "pyup.io-neutron:CVE-2014-7821",
      "advisory": "OpenStack Neutron before 2014.1.4 and 2014.2.x before 2014.2.1 allows remote authenticated users to cause a denial of service (crash) via a crafted dns_nameservers value in the DNS configuration.",
      "cve": "CVE-2014-7821",
      "specs": [
        ">=2012.2.1,<2014.1.4",
        ">=2014.2,<2014.2.1"
      ]
    },
    {
      "id": "pyup.io-neutron:CVE-2014-8153",
      "advisory": "The L3 agent in OpenStack Neutron 2014.2.x before 2014.2.2, when using radvd 2.0+, allows remote authenticated users to cause a denial of service (blocked router update processing) by creating eight routers and assigning an ipv6 non-provider subnet to each.",
      "cve": "CVE-2014-8153",
      "specs": [
        "==2014.2",
        "==2014.2.1"
      ]
    },
    {
      "id": "pyup.io-neutron:CVE-2015-3221",
      "advisory": "OpenStack Neutron before 2014.2.4 (juno) and 2015.1.x before 2015.1.1 (kilo), when using the IPTables firewall driver, allows remote authenticated users to cause a denial of service (L2 agent crash) by adding an address pair that is rejected by the ipset tool.",
      "cve": "CVE-2015-3221",
      "specs": [
        ">=2014.2,<2014.2.4",
        ">=2015.1.0,<2015.1.1"
      ]
    },
    {
      "id": "pyup.io-neutron:CVE-2015-5240",
      "advisory": "Race condition in OpenStack Neutron before 2014.2.4 and 2015.1 before 2015.1.2, when using the ML2 plugin or the security groups AMQP API, allows remote authenticated users to bypass IP anti-spoofing controls by changing the device owner of a port to start with network: before the security group rules are applied.",
      "cve": "CVE-2015-5240",
      "specs": [
        "==2014.2.3",
        "==2015.1.0",
        "==2015.1.1"
      ]
    },
    {
      "id": "pyup.io-neutron:CVE-2015-8914",
      "advisory": "The IPTables firewall in OpenStack Neutron before 7.0.4 and 8.0.0 through 8.1.0 allows remote attackers to bypass an intended ICMPv6-spoofing protection mechanism and consequently cause a denial of service or intercept network traffic via a link-local source address.",
      "cve": "CVE-2015-8914",
      "specs": [
        ">=7.0.0,<7.0.4",
        ">=8.0.0,<=8.1.0"
      ]
    },
    {
      "id": "pyup.io-neutron:CVE-2016-5362",
      "advisory": "The IPTables firewall in OpenStack Neutron before 7.0.4 and 8.0.0 through 8.1.0 allows remote attackers to bypass an intended DHCP-spoofing protection mechanism and consequently cause a denial of service or intercept network traffic via a crafted DHCP discovery message.",
      "cve": "CVE-2016-5362",
      "specs": [
        ">=7.0.0,<7.0.4",
        ">=8.0.0,<=8.1.0"
      ]
    },
    {
      "id": "pyup.io-neutron:CVE-2016-5363",
      "advisory": "The IPTables firewall in OpenStack Neutron before 7.0.4 and 8.0.0 through 8.1.0 allows remote attackers to bypass an intended MAC-spoofing protection mechanism and consequently cause a denial of service or intercept network traffic via (1) a crafted DHCP discovery message or (2) crafted non-IP traffic.",
      "cve": "CVE-2016-5363",
      "specs": [
        "==7.0.0",
        "==7.0.1",
        "==7.0.2",
        "==7.0.3",
        "==7.0.4",
        "==8.0.0",
        "==8.1.0"
      ]
    },
    {
      "id": "pyup.io-neutron:CVE-2017-7543",
      "advisory": "A race-condition flaw was discovered in openstack-neutron before 7.2.0-12.1, 8.x before 8.3.0-11.1, 9.x before 9.3.1-2.1, and 10.x before 10.0.2-1.1, where, following a minor overcloud update, neutron security groups were disabled. Specifically, the following were reset to 0: net.bridge.bridge-nf-call-ip6tables and net.bridge.bridge-nf-call-iptables. The race was only triggered by an update, at which point an attacker could access exposed tenant VMs and network resources.",
      "cve": "CVE-2017-7543",
      "specs": [
        ">=10.0.0,<10.0.2-1.1",
        ">=7.0.0,<7.2.0-12.1",
        ">=8.0.0,<8.3.0-11.1",
        ">=9.0.0,<9.3.1-2.1"
      ]
    },
    {
      "id": "pyup.io-neutron:CVE-2018-14635",
      "advisory": "When using the Linux bridge ml2 driver, non-privileged tenants are able to create and attach ports without specifying an IP address, bypassing IP address validation. A potential denial of service could occur if an IP address, conflicting with existing guests or routers, is then assigned from outside of the allowed allocation pool. Versions of openstack-neutron before 13.0.0.0b2, 12.0.3 and 11.0.5 are vulnerable.",
      "cve": "CVE-2018-14635",
      "specs": [
        "==13.0.0.0-b1",
        ">=11.0.0,<=11.0.5",
        ">=12.0.0,<=12.0.3"
      ]
    },
    {
      "id": "pyup.io-neutron:CVE-2018-14636",
      "advisory": "Live-migrated instances are briefly able to inspect traffic for other instances on the same hypervisor. This brief window could be extended indefinitely if the instance's port is set administratively down prior to live-migration and kept down after the migration is complete. This is possible due to the Open vSwitch integration bridge being connected to the instance during migration. When connected to the integration bridge, all traffic for instances using the same Open vSwitch instance would potentially be visible to the migrated guest, as the required Open vSwitch VLAN filters are only applied post-migration. Versions of openstack-neutron before 13.0.0.0b2, 12.0.3, 11.0.5 are vulnerable.",
      "cve": "CVE-2018-14636",
      "specs": [
        "==13.0.0-b1",
        ">=12.0.0,<=12.0.2",
        ">=7.0.0,<=11.0.4"
      ]
    },
    {
      "id": "pyup.io-neutron:CVE-2019-10876",
      "advisory": "An issue was discovered in OpenStack Neutron 11.x before 11.0.7, 12.x before 12.0.6, and 13.x before 13.0.3. By creating two security groups with separate/overlapping port ranges, an authenticated user may prevent Neutron from being able to configure networks on any compute nodes where those security groups are present, because of an Open vSwitch (OVS) firewall KeyError. All Neutron deployments utilizing neutron-openvswitch-agent are affected.",
      "cve": "CVE-2019-10876",
      "specs": [
        ">=11.0.0,<11.0.7",
        ">=12.0.0,<12.0.6",
        ">=13.0.0,<13.0.3"
      ]
    },
    {
      "id": "pyup.io-neutron:CVE-2019-9735",
      "advisory": "An issue was discovered in the iptables firewall module in OpenStack Neutron before 10.0.8, 11.x before 11.0.7, 12.x before 12.0.6, and 13.x before 13.0.3. By setting a destination port in a security group rule along with a protocol that doesn't support that option (for example, VRRP), an authenticated user may block further application of security group rules for instances from any project/tenant on the compute hosts to which it's applied. (Only deployments using the iptables security group driver are affected.)",
      "cve": "CVE-2019-9735",
      "specs": [
        "<10.0.8",
        ">=11.0.0,<11.0.7",
        ">=12.0.0,<12.0.6",
        ">=13.0.0,<13.0.3"
      ]
    },
    {
      "id": "pyup.io-neutron:CVE-2021-20267",
      "advisory": "A flaw was found in openstack-neutron's default Open vSwitch firewall rules. By sending carefully crafted packets, anyone in control of a server instance connected to the virtual switch can impersonate the IPv6 addresses of other systems on the network, resulting in denial of service or in some cases possibly interception of traffic intended for other destinations. Only deployments using the Open vSwitch driver are affected. Source: OpenStack project. Versions before openstack-neutron 15.3.3, openstack-neutron 16.3.1 and openstack-neutron 17.1.1 are affected.",
      "cve": "CVE-2021-20267",
      "specs": [
        "<15.3.3",
        ">=16.0.0,<16.3.1",
        ">=17.0.0,<17.1.1"
      ]
    },
    {
      "id": "pyup.io-neutron:CVE-2021-38598",
      "advisory": "OpenStack Neutron before 16.4.1, 17.x before 17.1.3, and 18.0.0 allows hardware address impersonation when the linuxbridge driver with ebtables-nft is used on a Netfilter-based platform. By sending carefully crafted packets, anyone in control of a server instance connected to the virtual switch can impersonate the hardware addresses of other systems on the network, resulting in denial of service or in some cases possibly interception of traffic intended for other destinations.",
      "cve": "CVE-2021-38598",
      "specs": [
        "<16.4.1",
        "==18.0.0",
        ">=17.0.0,<17.1.3"
      ]
    },
    {
      "id": "pyup.io-neutron:CVE-2021-40085",
      "advisory": "An issue was discovered in OpenStack Neutron before 16.4.1, 17.x before 17.2.1, and 18.x before 18.1.1. Authenticated attackers can reconfigure dnsmasq via a crafted extra_dhcp_opts value.",
      "cve": "CVE-2021-40085",
      "specs": [
        "<16.4.1",
        ">=17.0.0,<17.2.1",
        ">=18.0.0,<18.1.1"
      ]
    },
    {
      "id": "pyup.io-neutron:CVE-2021-40797",
      "advisory": "An issue was discovered in the routes middleware in OpenStack Neutron before 16.4.1, 17.x before 17.2.1, and 18.x before 18.1.1. By making API requests involving nonexistent controllers, an authenticated user may cause the API worker to consume increasing amounts of memory, resulting in API performance degradation or denial of service.",
      "cve": "CVE-2021-40797",
      "specs": [
        "<16.4.1",
        ">=17.0.0,<17.2.1",
        ">=18.0.0,<18.1.1"
      ]
    }
  ],
  "nltk": [
    {
      "id": "pyup.io-nltk:CVE-2019-14751",
      "advisory": "NLTK Downloader before 3.4.5 is vulnerable to a directory traversal, allowing attackers to write arbitrary files via a ../ (dot dot slash) in an NLTK package (ZIP archive) that is mishandled during extraction.",
      "cve": "CVE-2019-14751",
      "specs": [
        "<3.4.5"
      ]
    },
    {
      "id": "pyup.io-nltk:CVE-2021-3828",
      "advisory": "nltk is vulnerable to Inefficient Regular Expression Complexity",
      "cve": "CVE-2021-3828",
      "specs": [
        "<=3.6.3"
      ]
    }
  ],
  "notebook": [
    {
      "id": "pyup.io-notebook:CVE-2014-3429",
      "advisory": "IPython Notebook 0.12 through 1.x before 1.2 does not validate the origin of websocket requests, which allows remote attackers to execute arbitrary code by leveraging knowledge of the kernel id and a crafted page.",
      "cve": "CVE-2014-3429",
      "specs": [
        "==0.12",
        "==0.12.1",
        "==0.13",
        "==0.13.1",
        "==0.13.2",
        "==1.0.0",
        "==1.1.0"
      ]
    },
    {
      "id": "pyup.io-notebook:CVE-2015-6938",
      "advisory": "Cross-site scripting (XSS) vulnerability in the file browser in notebook/notebookapp.py in IPython Notebook before 3.2.2 and Jupyter Notebook 4.0.x before 4.0.5 allows remote attackers to inject arbitrary web script or HTML via a folder name.  NOTE: this was originally reported as a cross-site request forgery (CSRF) vulnerability, but this may be inaccurate.",
      "cve": "CVE-2015-6938",
      "specs": [
        "<=3.2.1",
        "==4.0.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4"
      ]
    },
    {
      "id": "pyup.io-notebook:CVE-2015-7337",
      "advisory": "The editor in IPython Notebook before 3.2.2 and Jupyter Notebook 4.0.x before 4.0.5 allows remote attackers to execute arbitrary JavaScript code via a crafted file, which triggers a redirect to files/, related to MIME types.",
      "cve": "CVE-2015-7337",
      "specs": [
        "<=3.2.1",
        "==4.0.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4"
      ]
    },
    {
      "id": "pyup.io-notebook:CVE-2018-19351",
      "advisory": "Jupyter Notebook before 5.7.1 allows XSS via an untrusted notebook because nbconvert responses are considered to have the same origin as the notebook server. In other words, nbconvert endpoints can execute JavaScript with access to the server API. In notebook/nbconvert/handlers.py, NbconvertFileHandler and NbconvertPostHandler do not set a Content Security Policy to prevent this.",
      "cve": "CVE-2018-19351",
      "specs": [
        "<5.7.1"
      ]
    },
    {
      "id": "pyup.io-notebook:CVE-2018-19352",
      "advisory": "Jupyter Notebook before 5.7.2 allows XSS via a crafted directory name because notebook/static/tree/js/notebooklist.js handles certain URLs unsafely.",
      "cve": "CVE-2018-19352",
      "specs": [
        "<5.7.2"
      ]
    },
    {
      "id": "pyup.io-notebook:CVE-2018-21030",
      "advisory": "Jupyter Notebook before 5.5.0 does not use a CSP header to treat served files as belonging to a separate origin. Thus, for example, an XSS payload can be placed in an SVG document.",
      "cve": "CVE-2018-21030",
      "specs": [
        "<5.5.0"
      ]
    },
    {
      "id": "pyup.io-notebook:CVE-2018-8768",
      "advisory": "In Jupyter Notebook before 5.4.1, a maliciously forged notebook file can bypass sanitization to execute JavaScript in the notebook context. Specifically, invalid HTML is 'fixed' by jQuery after sanitization, making it dangerous.",
      "cve": "CVE-2018-8768",
      "specs": [
        "<5.4.1"
      ]
    },
    {
      "id": "pyup.io-notebook:CVE-2019-10255",
      "advisory": "An Open Redirect vulnerability for all browsers in Jupyter Notebook before 5.7.7 and some browsers (Chrome, Firefox) in JupyterHub before 0.9.5 allows crafted links to the login page, which will redirect to a malicious site after successful login. Servers running on a base_url prefix are not affected.",
      "cve": "CVE-2019-10255",
      "specs": [
        "<5.7.7"
      ]
    },
    {
      "id": "pyup.io-notebook:CVE-2019-10856",
      "advisory": "In Jupyter Notebook before 5.7.8, an open redirect can occur via an empty netloc. This issue exists because of an incomplete fix for CVE-2019-10255.",
      "cve": "CVE-2019-10856",
      "specs": [
        "<5.7.8"
      ]
    },
    {
      "id": "pyup.io-notebook:CVE-2019-9644",
      "advisory": "An XSSI (cross-site inclusion) vulnerability in Jupyter Notebook before 5.7.6 allows inclusion of resources on malicious pages when visited by users who are authenticated with a Jupyter server. Access to the content of resources has been demonstrated with Internet Explorer through capturing of error messages, though not reproduced with other browsers. This occurs because Internet Explorer's error messages can include the content of any invalid JavaScript that was encountered.",
      "cve": "CVE-2019-9644",
      "specs": [
        "<5.7.6"
      ]
    },
    {
      "id": "pyup.io-notebook:CVE-2020-26215",
      "advisory": "Jupyter Notebook before version 6.1.5 has an Open redirect vulnerability. A maliciously crafted link to a notebook server could redirect the browser to a different website. All notebook servers are technically affected, however, these maliciously crafted links can only be reasonably made for known notebook server hosts. A link to your notebook server may appear safe, but ultimately redirect to a spoofed server on the public internet. The issue is patched in version 6.1.5.",
      "cve": "CVE-2020-26215",
      "specs": [
        "<6.1.5"
      ]
    },
    {
      "id": "pyup.io-notebook:CVE-2021-32798",
      "advisory": "The Jupyter notebook is a web-based notebook environment for interactive computing. In affected versions untrusted notebook can execute code on load. Jupyter Notebook uses a deprecated version of Google Caja to sanitize user inputs. A public Caja bypass can be used to trigger an XSS when a victim opens a malicious ipynb document in Jupyter Notebook. The XSS allows an attacker to execute arbitrary code on the victim computer using Jupyter APIs.",
      "cve": "CVE-2021-32798",
      "specs": [
        "==6.4.0",
        ">=5.7.0,<5.7.11"
      ]
    }
  ],
  "nova": [
    {
      "id": "pyup.io-nova:CVE-2011-3147",
      "advisory": "Versions of nova before 2012.1 could expose hypervisor host files to a guest operating system when processing a maliciously constructed qcow filesystem.",
      "cve": "CVE-2011-3147",
      "specs": [
        ">=2010.1,<2012.1"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2011-4076",
      "advisory": "OpenStack Nova before 2012.1 allows someone with access to an EC2_ACCESS_KEY (equivalent to a username) to obtain the EC2_SECRET_KEY (equivalent to a password). Exposing the EC2_ACCESS_KEY via http or tools that allow man-in-the-middle over https could allow an attacker to easily obtain the EC2_SECRET_KEY. An attacker could also presumably brute force values for EC2_ACCESS_KEY.",
      "cve": "CVE-2011-4076",
      "specs": [
        ">=2010.1,<2012.1"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2011-4596",
      "advisory": "Multiple directory traversal vulnerabilities in OpenStack Nova before 2011.3.1, when the EC2 API and the S3/RegisterImage image-registration method are enabled, allow remote authenticated users to overwrite arbitrary files via a crafted (1) tarball or (2) manifest.",
      "cve": "CVE-2011-4596",
      "specs": [
        ">=2011.3,<2011.3.1"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2012-0030",
      "advisory": "Nova 2011.3 and Essex, when using the OpenStack API, allows remote authenticated users to bypass access restrictions for tenants of other users via an OSAPI request with a modified project_id URI parameter.",
      "cve": "CVE-2012-0030",
      "specs": [
        "==2011.3"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2012-1585",
      "advisory": "OpenStack Compute (Nova) Essex before 2011.3 allows remote authenticated users to cause a denial of service (Nova-API log file and disk consumption) via a long server name.",
      "cve": "CVE-2012-1585",
      "specs": [
        ">=2011.1,<2011.3"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2012-2101",
      "advisory": "Openstack Compute (Nova) Folsom, 2012.1, and 2011.3 does not limit the number of security group rules, which allows remote authenticated users with certain permissions to cause a denial of service (CPU and hard drive consumption) via a network request that triggers a large number of iptables rules.",
      "cve": "CVE-2012-2101",
      "specs": [
        "==2011.3",
        "==2012.1",
        "==folsom"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2012-3447",
      "advisory": "virt/disk/api.py in OpenStack Compute (Nova) 2012.1.x before 2012.1.2 and Folsom before Folsom-3 allows remote authenticated users to overwrite arbitrary files via a symlink attack on a file in an image that uses a symlink that is only readable by root.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-3361.",
      "cve": "CVE-2012-3447",
      "specs": [
        "==2012.1"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2013-2256",
      "advisory": "OpenStack Compute (Nova) before 2013.1.3 and Havana before havana-2 does not properly enforce the os-flavor-access:is_public property, which allows remote authenticated users to obtain sensitive information (flavor properties), boot arbitrary flavors, and possibly have other unspecified impacts by guessing the flavor id.",
      "cve": "CVE-2013-2256",
      "specs": [
        "==2013.2-milestone1",
        ">=2013.1,<2013.1.3"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2013-6437",
      "advisory": "The libvirt driver in OpenStack Compute (Nova) before 2013.2.2 and icehouse before icehouse-2 allows remote authenticated users to cause a denial of service (disk consumption) by creating and deleting instances with unique os_type settings, which triggers the creation of a new ephemeral disk backing file.",
      "cve": "CVE-2013-6437",
      "specs": [
        "==2014.1-milestone1",
        ">=2013.1,<2013.1.5",
        ">=2013.2,<2013.2.2"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2013-7048",
      "advisory": "OpenStack Compute (Nova) Grizzly 2013.1.4, Havana 2013.2.1, and earlier uses world-writable and world-readable permissions for the temporary directory used to store live snapshots, which allows local users to read and modify live snapshots.",
      "cve": "CVE-2013-7048",
      "specs": [
        ">=2013.1,<=2013.1.4",
        ">=2013.2,<=2013.2.1"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2014-3517",
      "advisory": "api/metadata/handler.py in OpenStack Compute (Nova) before 2013.2.4, 2014.x before 2014.1.2, and Juno before Juno-2, when proxying metadata requests through Neutron, makes it easier for remote attackers to guess instance ID signatures via a brute-force attack that relies on timing differences in responses to instance metadata requests.",
      "cve": "CVE-2014-3517",
      "specs": [
        "==2014.2.0-milestone1",
        ">=2013.2,<=2013.2.4",
        ">=2014.1,<2014.1.2"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2014-3608",
      "advisory": "The VMWare driver in OpenStack Compute (Nova) before 2014.1.3 allows remote authenticated users to bypass the quota limit and cause a denial of service (resource consumption) by putting the VM into the rescue state, suspending it, which puts into an ERROR state, and then deleting the image.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2014-2573.",
      "cve": "CVE-2014-3608",
      "specs": [
        ">=2013.2,<=2013.2.4",
        ">=2014.1,<2014.1.3"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2014-3708",
      "advisory": "OpenStack Compute (Nova) before 2014.1.4 and 2014.2.x before 2014.2.1 allows remote authenticated users to cause a denial of service (CPU consumption) via an IP filter in a list active servers API request.",
      "cve": "CVE-2014-3708",
      "specs": [
        ">=2014.1,<2014.1.4",
        ">=2014.2,<2014.2.1"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2014-7230",
      "advisory": "The processutils.execute function in OpenStack oslo-incubator, Cinder, Nova, and Trove before 2013.2.4 and 2014.1 before 2014.1.3 allows local users to obtain passwords from commands that cause a ProcessExecutionError by reading the log.",
      "cve": "CVE-2014-7230",
      "specs": [
        ">=2013.2,<2013.2.4",
        ">=2014.1,<2014.1.3"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2014-7231",
      "advisory": "The strutils.mask_password function in the OpenStack Oslo utility library, Cinder, Nova, and Trove before 2013.2.4 and 2014.1 before 2014.1.3 does not properly mask passwords when logging commands, which allows local users to obtain passwords by reading the log.",
      "cve": "CVE-2014-7231",
      "specs": [
        ">=2013.2,<2013.2.4",
        ">=2014.1,<2014.1.3"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2014-8333",
      "advisory": "The VMware driver in OpenStack Compute (Nova) before 2014.1.4 allows remote authenticated users to cause a denial of service (disk consumption) by deleting an instance in the resize state.",
      "cve": "CVE-2014-8333",
      "specs": [
        ">=2014.1,<2014.1.4"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2014-8750",
      "advisory": "Race condition in the VMware driver in OpenStack Compute (Nova) before 2014.1.4 and 2014.2 before 2014.2rc1 allows remote authenticated users to access unintended consoles by spawning an instance that triggers the same VNC port to be allocated to two different instances.",
      "cve": "CVE-2014-8750",
      "specs": [
        "==2014.2-milestone1",
        "==2014.2-milestone2",
        "==2014.2-milestone3",
        ">=2014.1,<2014.1.4"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2015-0259",
      "advisory": "OpenStack Compute (Nova) before 2014.1.4, 2014.2.x before 2014.2.3, and kilo before kilo-3 does not validate the origin of websocket requests, which allows remote attackers to hijack the authentication of users for access to consoles via a crafted webpage.",
      "cve": "CVE-2015-0259",
      "specs": [
        "==2015.1.0-milestone1",
        "==2015.1.0-milestone2",
        ">=2014.1,<2014.1.4",
        ">=2014.2,<2014.2.3"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2015-3241",
      "advisory": "OpenStack Compute (nova) 2015.1 through 2015.1.1, 2014.2.3, and earlier does not stop the migration process when the instance is deleted, which allows remote authenticated users to cause a denial of service (disk, network, and other resource consumption) by resizing and then deleting an instance.",
      "cve": "CVE-2015-3241",
      "specs": [
        ">=2014.2,<=2014.2.3",
        ">=2015.1.0,<=2015.1.1"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2015-3280",
      "advisory": "OpenStack Compute (nova) before 2014.2.4 (juno) and 2015.1.x before 2015.1.2 (kilo) does not properly delete instances from compute nodes, which allows remote authenticated users to cause a denial of service (disk consumption) by deleting instances while in the resize state.",
      "cve": "CVE-2015-3280",
      "specs": [
        ">=2014.2,<2014.2.4",
        ">=2015.1.0,<2015.1.2"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2015-5162",
      "advisory": "The image parser in OpenStack Cinder 7.0.2 and 8.0.0 through 8.1.1; Glance before 11.0.1 and 12.0.0; and Nova before 12.0.4 and 13.0.0 does not properly limit qemu-img calls, which might allow attackers to cause a denial of service (memory and disk consumption) via a crafted disk image.",
      "cve": "CVE-2015-5162",
      "specs": [
        "<=12.0.3",
        "==13.0.0"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2015-7548",
      "advisory": "OpenStack Compute (Nova) before 2015.1.3 (kilo) and 12.0.x before 12.0.1 (liberty), when using libvirt to spawn instances and use_cow_images is set to false, allow remote authenticated users to read arbitrary files by overwriting an instance disk with a crafted image and requesting a snapshot.",
      "cve": "CVE-2015-7548",
      "specs": [
        ">=12.0.0,<12.0.1",
        ">=2015.1.0,<2015.1.3"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2015-7713",
      "advisory": "OpenStack Compute (Nova) before 2014.2.4 (juno) and 2015.1.x before 2015.1.2 (kilo) do not properly apply security group changes, which allows remote attackers to bypass intended restriction by leveraging an instance that was running when the change was made.",
      "cve": "CVE-2015-7713",
      "specs": [
        ">=2014.2,<2014.2.4",
        ">=2015.1.0,<2015.1.2"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2015-8749",
      "advisory": "The volume_utils._parse_volume_info function in OpenStack Compute (Nova) before 2015.1.3 (kilo) and 12.0.x before 12.0.1 (liberty) includes the connection_info dictionary in the StorageError message when using the Xen backend, which might allow attackers to obtain sensitive password information by reading log files or other unspecified vectors.",
      "cve": "CVE-2015-8749",
      "specs": [
        ">=12.0.0,<12.0.1",
        ">=2015.1.0,<2015.1.3"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2015-9543",
      "advisory": "An issue was discovered in OpenStack Nova before 18.2.4, 19.x before 19.1.0, and 20.x before 20.1.0. It can leak consoleauth tokens into log files. An attacker with read access to the service's logs may obtain tokens used for console access. All Nova setups using novncproxy are affected. This is related to NovaProxyRequestHandlerBase.new_websocket_client in console/websocketproxy.py.",
      "cve": "CVE-2015-9543",
      "specs": [
        "<18.2.4",
        ">=19.0.0,<19.1.0",
        ">=20.0.0,<20.1.0"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2016-2140",
      "advisory": "The libvirt driver in OpenStack Compute (Nova) before 2015.1.4 (kilo) and 12.0.x before 12.0.3 (liberty), when using raw storage and use_cow_images is set to false, allows remote authenticated users to read arbitrary files via a crafted qcow2 header in an ephemeral or root disk.",
      "cve": "CVE-2016-2140",
      "specs": [
        ">=12.0.0,<12.0.3",
        ">=2015.1.0,<2015.1.4"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2017-16239",
      "advisory": "In OpenStack Nova through 14.0.9, 15.x through 15.0.7, and 16.x through 16.0.2, by rebuilding an instance, an authenticated user may be able to circumvent the Filter Scheduler bypassing imposed filters (for example, the ImagePropertiesFilter or the IsolatedHostsFilter). All setups using Nova Filter Scheduler are affected. Because of the regression described in Launchpad Bug #1732947, the preferred fix is a 14.x version after 14.0.10, a 15.x version after 15.0.8, or a 16.x version after 16.0.3.",
      "cve": "CVE-2017-16239",
      "specs": [
        "<=14.0.9",
        "==15.0.0",
        "==15.0.1",
        "==15.0.2",
        "==15.0.3",
        "==15.0.4",
        "==15.0.5",
        "==15.0.6",
        "==15.0.7",
        "==16.0.0",
        "==16.0.1",
        "==16.0.2"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2017-17051",
      "advisory": "An issue was discovered in the default FilterScheduler in OpenStack Nova 16.0.3. By repeatedly rebuilding an instance with new images, an authenticated user may consume untracked resources on a hypervisor host leading to a denial of service, aka doubled resource allocations. This regression was introduced with the fix for OSSA-2017-005 (CVE-2017-16239); however, only Nova stable/pike or later deployments with that fix applied and relying on the default FilterScheduler are affected.",
      "cve": "CVE-2017-17051",
      "specs": [
        "==16.0.3"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2017-18191",
      "advisory": "An issue was discovered in OpenStack Nova 15.x through 15.1.0 and 16.x through 16.1.1. By detaching and reattaching an encrypted volume, an attacker may access the underlying raw volume and corrupt the LUKS header, resulting in a denial of service attack on the compute host. (The same code error also results in data loss, but that is not a vulnerability because the user loses their own data.) All Nova setups supporting encrypted volumes are affected.",
      "cve": "CVE-2017-18191",
      "specs": [
        ">=15.0.0,<=15.1.0",
        ">=16.0.0,<=16.1.1"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2017-7214",
      "advisory": "An issue was discovered in exception_wrapper.py in OpenStack Nova 13.x through 13.1.3, 14.x through 14.0.4, and 15.x through 15.0.1. Legacy notification exception contexts appearing in ERROR level logs may include sensitive information such as account passwords and authorization tokens.",
      "cve": "CVE-2017-7214",
      "specs": [
        "==13.0.0",
        "==13.1.0",
        "==13.1.1",
        "==13.1.2",
        "==13.1.3",
        "==14.0.0",
        "==14.0.1",
        "==14.0.2",
        "==14.0.3",
        "==14.0.4",
        "==15.0.0",
        "==15.0.1"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2019-14433",
      "advisory": "An issue was discovered in OpenStack Nova before 17.0.12, 18.x before 18.2.2, and 19.x before 19.0.2. If an API request from an authenticated user ends in a fault condition due to an external exception, details of the underlying environment may be leaked in the response, and could include sensitive configuration or other data.",
      "cve": "CVE-2019-14433",
      "specs": [
        "<17.0.12",
        ">=18.0.0,<18.2.2",
        ">=19.0.0,<19.0.2"
      ]
    },
    {
      "id": "pyup.io-nova:CVE-2020-17376",
      "advisory": "An issue was discovered in Guest.migrate in virt/libvirt/guest.py in OpenStack Nova before 19.3.1, 20.x before 20.3.1, and 21.0.0. By performing a soft reboot of an instance that has previously undergone live migration, a user may gain access to destination host devices that share the same paths as host devices previously referenced by the virtual machine on the source host. This can include block devices that map to different Cinder volumes at the destination than at the source. Only deployments allowing host-based connections (for instance, root and ephemeral devices) are affected.",
      "cve": "CVE-2020-17376",
      "specs": [
        "<19.3.1",
        "==21.0.0",
        ">=20.0.0,<20.3.1"
      ]
    }
  ],
  "novajoin": [
    {
      "id": "pyup.io-novajoin:CVE-2019-10138",
      "advisory": "A flaw was discovered in the python-novajoin plugin, all versions up to, excluding 1.1.1, for Red Hat OpenStack Platform. The novajoin API lacked sufficient access control, allowing any keystone authenticated user to generate FreeIPA tokens.",
      "cve": "CVE-2019-10138",
      "specs": [
        "<1.1.1"
      ]
    }
  ],
  "numpy": [
    {
      "id": "pyup.io-numpy:CVE-2014-1858",
      "advisory": "__init__.py in f2py in NumPy before 1.8.1 allows local users to write to arbitrary files via a symlink attack on a temporary file.",
      "cve": "CVE-2014-1858",
      "specs": [
        "<1.8.1"
      ]
    },
    {
      "id": "pyup.io-numpy:CVE-2014-1859",
      "advisory": "(1) core/tests/test_memmap.py, (2) core/tests/test_multiarray.py, (3) f2py/f2py2e.py, and (4) lib/tests/test_io.py in NumPy before 1.8.1 allow local users to write to arbitrary files via a symlink attack on a temporary file.",
      "cve": "CVE-2014-1859",
      "specs": [
        "<=1.8.0",
        "==1.8.1-rc1"
      ]
    },
    {
      "id": "pyup.io-numpy:CVE-2017-12852",
      "advisory": "The numpy.pad function in Numpy 1.13.1 and older versions is missing input validation. An empty list or ndarray will stick into an infinite loop, which can allow attackers to cause a DoS attack.",
      "cve": "CVE-2017-12852",
      "specs": [
        "<=1.13.1"
      ]
    },
    {
      "id": "pyup.io-numpy:CVE-2019-6446",
      "advisory": "** DISPUTED **   An issue was discovered in NumPy 1.16.0 and earlier. It uses the pickle Python module unsafely, which allows remote attackers to execute arbitrary code via a crafted serialized object, as demonstrated by a numpy.load call. NOTE: third parties dispute this issue because it is  a behavior that might have legitimate applications in (for example)  loading serialized Python object arrays from trusted and authenticated  sources.",
      "cve": "CVE-2019-6446",
      "specs": [
        "<=1.16.0"
      ]
    }
  ],
  "nvidia-tensorflow": [
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2018-10055",
      "advisory": "Invalid memory access and/or a heap buffer overflow in the TensorFlow XLA compiler in Google TensorFlow before 1.7.1 could cause a crash or read from other parts of process memory via a crafted configuration file.",
      "cve": "CVE-2018-10055",
      "specs": [
        "<1.7.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2018-21233",
      "advisory": "TensorFlow before 1.7.0 has an integer overflow that causes an out-of-bounds read, possibly causing disclosure of the contents of process memory. This occurs in the DecodeBmp feature of the BMP decoder in core/kernels/decode_bmp_op.cc.",
      "cve": "CVE-2018-21233",
      "specs": [
        "<1.7.0"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2018-7575",
      "advisory": "Google TensorFlow 1.7.x and earlier is affected by a Buffer Overflow vulnerability. The type of exploitation is context-dependent.",
      "cve": "CVE-2018-7575",
      "specs": [
        "<=1.7.0"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2018-7576",
      "advisory": "Google TensorFlow 1.6.x and earlier is affected by: Null Pointer Dereference. The type of exploitation is: context-dependent.",
      "cve": "CVE-2018-7576",
      "specs": [
        "<=1.6.0"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2018-7577",
      "advisory": "Memcpy parameter overlap in Google Snappy library 1.1.4, as used in Google TensorFlow before 1.7.1, could result in a crash or read from other parts of process memory.",
      "cve": "CVE-2018-7577",
      "specs": [
        "<1.7.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2018-8825",
      "advisory": "Google TensorFlow 1.7 and below is affected by: Buffer Overflow. The impact is: execute arbitrary code (local).",
      "cve": "CVE-2018-8825",
      "specs": [
        "<=1.7.0"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2019-16778",
      "advisory": "In TensorFlow before 1.15, a heap buffer overflow in UnsortedSegmentSum can be produced when the Index template argument is int32. In this case data_size and num_segments fields are truncated from int64 to int32 and can produce negative numbers, resulting in accessing out of bounds heap memory. This is unlikely to be exploitable and was detected and fixed internally in TensorFlow 1.15 and 2.0.",
      "cve": "CVE-2019-16778",
      "specs": [
        ">=1.0.0,<1.15.0"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2019-9635",
      "advisory": "NULL pointer dereference in Google TensorFlow before 1.12.2 could cause a denial of service via an invalid GIF file.",
      "cve": "CVE-2019-9635",
      "specs": [
        "<1.12.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15190",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `tf.raw_ops.Switch` operation takes as input a tensor and a boolean and outputs two tensors. Depending on the boolean value, one of the tensors is exactly the input tensor whereas the other one should be an empty tensor. However, the eager runtime traverses all tensors in the output. Since only one of the tensors is defined, the other one is `nullptr`, hence we are binding a reference to `nullptr`. This is undefined behavior and reported as an error if compiling with `-fsanitize=null`. In this case, this results in a segmentation fault The issue is patched in commit da8558533d925694483d2c136a9220d6d49d843c, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15190",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15191",
      "advisory": "In Tensorflow before versions 2.2.1 and 2.3.1, if a user passes an invalid argument to `dlpack.to_dlpack` the expected validations will cause variables to bind to `nullptr` while setting a `status` variable to the error condition. However, this `status` argument is not properly checked. Hence, code following these methods will bind references to null pointers. This is undefined behavior and reported as an error if compiling with `-fsanitize=null`. The issue is patched in commit 22e07fb204386768e5bcbea563641ea11f96ceb8 and is released in TensorFlow versions 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15191",
      "specs": [
        "==2.2.0",
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15192",
      "advisory": "In Tensorflow before versions 2.2.1 and 2.3.1, if a user passes a list of strings to `dlpack.to_dlpack` there is a memory leak following an expected validation failure. The issue occurs because the `status` argument during validation failures is not properly checked. Since each of the above methods can return an error status, the `status` value must be checked before continuing. The issue is patched in commit 22e07fb204386768e5bcbea563641ea11f96ceb8 and is released in TensorFlow versions 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15192",
      "specs": [
        "==2.2.0",
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15193",
      "advisory": "In Tensorflow before versions 2.2.1 and 2.3.1, the implementation of `dlpack.to_dlpack` can be made to use uninitialized memory resulting in further memory corruption. This is because the pybind11 glue code assumes that the argument is a tensor. However, there is nothing stopping users from passing in a Python object instead of a tensor. The uninitialized memory address is due to a `reinterpret_cast` Since the `PyObject` is a Python object, not a TensorFlow Tensor, the cast to `EagerTensor` fails. The issue is patched in commit 22e07fb204386768e5bcbea563641ea11f96ceb8 and is released in TensorFlow versions 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15193",
      "specs": [
        "==2.2.0",
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15194",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `SparseFillEmptyRowsGrad` implementation has incomplete validation of the shapes of its arguments. Although `reverse_index_map_t` and `grad_values_t` are accessed in a similar pattern, only `reverse_index_map_t` is validated to be of proper shape. Hence, malicious users can pass a bad `grad_values_t` to trigger an assertion failure in `vec`, causing denial of service in serving installations. The issue is patched in commit 390611e0d45c5793c7066110af37c8514e6a6c54, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.\"",
      "cve": "CVE-2020-15194",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15195",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the implementation of `SparseFillEmptyRowsGrad` uses a double indexing pattern. It is possible for `reverse_index_map(i)` to be an index outside of bounds of `grad_values`, thus resulting in a heap buffer overflow. The issue is patched in commit 390611e0d45c5793c7066110af37c8514e6a6c54, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15195",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15196",
      "advisory": "In Tensorflow version 2.3.0, the `SparseCountSparseOutput` and `RaggedCountSparseOutput` implementations don't validate that the `weights` tensor has the same shape as the data. The check exists for `DenseCountSparseOutput`, where both tensors are fully specified. In the sparse and ragged count weights are still accessed in parallel with the data. But, since there is no validation, a user passing fewer weights than the values for the tensors can generate a read from outside the bounds of the heap buffer allocated for the weights. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15196",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15197",
      "advisory": "In Tensorflow before version 2.3.1, the `SparseCountSparseOutput` implementation does not validate that the input arguments form a valid sparse tensor. In particular, there is no validation that the `indices` tensor has rank 2. This tensor must be a matrix because code assumes its elements are accessed as elements of a matrix. However, malicious users can pass in tensors of different rank, resulting in a `CHECK` assertion failure and a crash. This can be used to cause denial of service in serving installations, if users are allowed to control the components of the input sparse tensor. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15197",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15198",
      "advisory": "In Tensorflow before version 2.3.1, the `SparseCountSparseOutput` implementation does not validate that the input arguments form a valid sparse tensor. In particular, there is no validation that the `indices` tensor has the same shape as the `values` one. The values in these tensors are always accessed in parallel. Thus, a shape mismatch can result in accesses outside the bounds of heap allocated buffers. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15198",
      "specs": [
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15199",
      "advisory": "In Tensorflow before version 2.3.1, the `RaggedCountSparseOutput` does not validate that the input arguments form a valid ragged tensor. In particular, there is no validation that the `splits` tensor has the minimum required number of elements. Code uses this quantity to initialize a different data structure. Since `BatchedMap` is equivalent to a vector, it needs to have at least one element to not be `nullptr`. If user passes a `splits` tensor that is empty or has exactly one element, we get a `SIGABRT` signal raised by the operating system. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15199",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15200",
      "advisory": "In Tensorflow before version 2.3.1, the `RaggedCountSparseOutput` implementation does not validate that the input arguments form a valid ragged tensor. In particular, there is no validation that the values in the `splits` tensor generate a valid partitioning of the `values` tensor. Thus, the code sets up conditions to cause a heap buffer overflow. A `BatchedMap` is equivalent to a vector where each element is a hashmap. However, if the first element of `splits_values` is not 0, `batch_idx` will never be 1, hence there will be no hashmap at index 0 in `per_batch_counts`. Trying to access that in the user code results in a segmentation fault. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15200",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15201",
      "advisory": "In Tensorflow before version 2.3.1, the `RaggedCountSparseOutput` implementation does not validate that the input arguments form a valid ragged tensor. In particular, there is no validation that the values in the `splits` tensor generate a valid partitioning of the `values` tensor. Hence, the code is prone to heap buffer overflow. If `split_values` does not end with a value at least `num_values` then the `while` loop condition will trigger a read outside of the bounds of `split_values` once `batch_idx` grows too large. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15201",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15202",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `Shard` API in TensorFlow expects the last argument to be a function taking two `int64` (i.e., `long long`) arguments. However, there are several places in TensorFlow where a lambda taking `int` or `int32` arguments is being used. In these cases, if the amount of work to be parallelized is large enough, integer truncation occurs. Depending on how the two arguments of the lambda are used, this can result in segfaults, read/write outside of heap allocated arrays, stack overflows, or data corruption. The issue is patched in commits 27b417360cbd671ef55915e4bb6bb06af8b8a832 and ca8c013b5e97b1373b3bb1c97ea655e69f31a575, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15202",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15203",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, by controlling the `fill` argument of tf.strings.as_string, a malicious attacker is able to trigger a format string vulnerability due to the way the internal format use in a `printf` call is constructed. This may result in segmentation fault. The issue is patched in commit 33be22c65d86256e6826666662e40dbdfe70ee83, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15203",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15204",
      "advisory": "In eager mode, TensorFlow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1 does not set the session state. Hence, calling `tf.raw_ops.GetSessionHandle` or `tf.raw_ops.GetSessionHandleV2` results in a null pointer dereference In linked snippet, in eager mode, `ctx->session_state()` returns `nullptr`. Since code immediately dereferences this, we get a segmentation fault. The issue is patched in commit 9a133d73ae4b4664d22bd1aa6d654fec13c52ee1, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15204",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15205",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `data_splits` argument of `tf.raw_ops.StringNGrams` lacks validation. This allows a user to pass values that can cause heap overflow errors and even leak contents of memory In the linked code snippet, all the binary strings after `ee ff` are contents from the memory stack. Since these can contain return addresses, this data leak can be used to defeat ASLR. The issue is patched in commit 0462de5b544ed4731aa2fb23946ac22c01856b80, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15205",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15206",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, changing the TensorFlow's `SavedModel` protocol buffer and altering the name of required keys results in segfaults and data corruption while loading the model. This can cause a denial of service in products using `tensorflow-serving` or other inference-as-a-service installments. Fixed were added in commits f760f88b4267d981e13f4b302c437ae800445968 and fcfef195637c6e365577829c4d67681695956e7d (both going into TensorFlow 2.2.0 and 2.3.0 but not yet backported to earlier versions). However, this was not enough, as #41097 reports a different failure mode. The issue is patched in commit adf095206f25471e864a8e63a0f1caef53a0e3a6, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15206",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15207",
      "advisory": "In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, to mimic Python's indexing with negative values, TFLite uses `ResolveAxis` to convert negative values to positive indices. However, the only check that the converted index is now valid is only present in debug builds. If the `DCHECK` does not trigger, then code execution moves ahead with a negative index. This, in turn, results in accessing data out of bounds which results in segfaults and/or data corruption. The issue is patched in commit 2d88f470dea2671b430884260f3626b1fe99830a, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15207",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15208",
      "advisory": "In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, when determining the common dimension size of two tensors, TFLite uses a `DCHECK` which is no-op outside of debug compilation modes. Since the function always returns the dimension of the first tensor, malicious attackers can craft cases where this is larger than that of the second tensor. In turn, this would result in reads/writes outside of bounds since the interpreter will wrongly assume that there is enough data in both tensors. The issue is patched in commit 8ee24e7949a203d234489f9da2c5bf45a7d5157d, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15208",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15209",
      "advisory": "In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, a crafted TFLite model can force a node to have as input a tensor backed by a `nullptr` buffer. This can be achieved by changing a buffer index in the flatbuffer serialization to convert a read-only tensor to a read-write one. The runtime assumes that these buffers are written to before a possible read, hence they are initialized with `nullptr`. However, by changing the buffer index for a tensor and implicitly converting that tensor to be a read-write one, as there is nothing in the model that writes to it, we get a null pointer dereference. The issue is patched in commit 0b5662bc, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15209",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15210",
      "advisory": "In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, if a TFLite saved model uses the same tensor as both input and output of an operator, then, depending on the operator, we can observe a segmentation fault or just memory corruption. We have patched the issue in d58c96946b and will release patch releases for all versions between 1.15 and 2.3. We recommend users to upgrade to TensorFlow 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15210",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15211",
      "advisory": "In TensorFlow Lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, saved models in the flatbuffer format use a double indexing scheme: a model has a set of subgraphs, each subgraph has a set of operators and each operator has a set of input/output tensors. The flatbuffer format uses indices for the tensors, indexing into an array of tensors that is owned by the subgraph. This results in a pattern of double array indexing when trying to get the data of each tensor. However, some operators can have some tensors be optional. To handle this scenario, the flatbuffer model uses a negative `-1` value as index for these tensors. This results in special casing during validation at model loading time. Unfortunately, this means that the `-1` index is a valid tensor index for any operator, including those that don't expect optional inputs and including for output tensors. Thus, this allows writing and reading from outside the bounds of heap allocated arrays, although only at a specific offset from the start of these arrays. This results in both read and write gadgets, albeit very limited in scope. The issue is patched in several commits (46d5b0852, 00302787b7, e11f5558, cd31fd0ce, 1970c21, and fff2c83), and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to the model loading code to ensure that only operators which accept optional inputs use the `-1` special value and only for the tensors that they expect to be optional. Since this allow-list type approach is erro-prone, we advise upgrading to the patched code.",
      "cve": "CVE-2020-15211",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15212",
      "advisory": "In TensorFlow Lite before versions 2.2.1 and 2.3.1, models using segment sum can trigger writes outside of bounds of heap allocated buffers by inserting negative elements in the segment ids tensor. Users having access to `segment_ids_data` can alter `output_index` and then write to outside of `output_data` buffer. This might result in a segmentation fault but it can also be used to further corrupt the memory and can be chained with other vulnerabilities to create more advanced exploits. The issue is patched in commit 204945b19e44b57906c9344c0d00120eeeae178a and is released in TensorFlow versions 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to the model loading code to ensure that the segment ids are all positive, although this only handles the case when the segment ids are stored statically in the model. A similar validation could be done if the segment ids are generated at runtime between inference steps. If the segment ids are generated as outputs of a tensor during inference steps, then there are no possible workaround and users are advised to upgrade to patched code.",
      "cve": "CVE-2020-15212",
      "specs": [
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15213",
      "advisory": "In TensorFlow Lite before versions 2.2.1 and 2.3.1, models using segment sum can trigger a denial of service by causing an out of memory allocation in the implementation of segment sum. Since code uses the last element of the tensor holding them to determine the dimensionality of output tensor, attackers can use a very large value to trigger a large allocation. The issue is patched in commit 204945b19e44b57906c9344c0d00120eeeae178a and is released in TensorFlow versions 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to limit the maximum value in the segment ids tensor. This only handles the case when the segment ids are stored statically in the model, but a similar validation could be done if the segment ids are generated at runtime, between inference steps. However, if the segment ids are generated as outputs of a tensor during inference steps, then there are no possible workaround and users are advised to upgrade to patched code.",
      "cve": "CVE-2020-15213",
      "specs": [
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15214",
      "advisory": "In TensorFlow Lite before versions 2.2.1 and 2.3.1, models using segment sum can trigger a write out bounds / segmentation fault if the segment ids are not sorted. Code assumes that the segment ids are in increasing order, using the last element of the tensor holding them to determine the dimensionality of output tensor. This results in allocating insufficient memory for the output tensor and in a write outside the bounds of the output array. This usually results in a segmentation fault, but depending on runtime conditions it can provide for a write gadget to be used in future memory corruption-based exploits. The issue is patched in commit 204945b19e44b57906c9344c0d00120eeeae178a and is released in TensorFlow versions 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to the model loading code to ensure that the segment ids are sorted, although this only handles the case when the segment ids are stored statically in the model. A similar validation could be done if the segment ids are generated at runtime between inference steps. If the segment ids are generated as outputs of a tensor during inference steps, then there are no possible workaround and users are advised to upgrade to patched code.",
      "cve": "CVE-2020-15214",
      "specs": [
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15265",
      "advisory": "In Tensorflow before version 2.4.0, an attacker can pass an invalid `axis` value to `tf.quantization.quantize_and_dequantize`. This results in accessing a dimension outside the rank of the input tensor in the C++ kernel implementation. However, dim_size only does a DCHECK to validate the argument and then uses it to access the corresponding element of an array. Since in normal builds, `DCHECK`-like macros are no-ops, this results in segfault and access out of bounds of the array. The issue is patched in eccb7ec454e6617738554a255d77f08e60ee0808 and TensorFlow 2.4.0 will be released containing the patch. TensorFlow nightly packages after this commit will also have the issue resolved.",
      "cve": "CVE-2020-15265",
      "specs": [
        "<2.4.0"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-15266",
      "advisory": "In Tensorflow before version 2.4.0, when the `boxes` argument of `tf.image.crop_and_resize` has a very large value, the CPU kernel implementation receives it as a C++ `nan` floating point value. Attempting to operate on this is undefined behavior which later produces a segmentation fault. The issue is patched in eccb7ec454e6617738554a255d77f08e60ee0808 and TensorFlow 2.4.0 will be released containing the patch. TensorFlow nightly packages after this commit will also have the issue resolved.",
      "cve": "CVE-2020-15266",
      "specs": [
        "<2.4.0"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-26266",
      "advisory": "In affected versions of TensorFlow under certain cases a saved model can trigger use of uninitialized values during code execution. This is caused by having tensor buffers be filled with the default value of the type but forgetting to default initialize the quantized floating point types in Eigen. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26266",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-26267",
      "advisory": "In affected versions of TensorFlow the tf.raw_ops.DataFormatVecPermute API does not validate the src_format and dst_format attributes. The code assumes that these two arguments define a permutation of NHWC. This can result in uninitialized memory accesses, read outside of bounds and even crashes. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26267",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-26268",
      "advisory": "In affected versions of TensorFlow the tf.raw_ops.ImmutableConst operation returns a constant tensor created from a memory mapped file which is assumed immutable. However, if the type of the tensor is not an integral type, the operation crashes the Python interpreter as it tries to write to the memory area. If the file is too small, TensorFlow properly returns an error as the memory area has fewer bytes than what is needed for the tensor it creates. However, as soon as there are enough bytes, the above snippet causes a segmentation fault. This is because the allocator used to return the buffer data is not marked as returning an opaque handle since the needed virtual method is not overridden. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26268",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-26269",
      "advisory": "In TensorFlow release candidate versions 2.4.0rc*, the general implementation for matching filesystem paths to globbing pattern is vulnerable to an access out of bounds of the array holding the directories. There are multiple invariants and preconditions that are assumed by the parallel implementation of GetMatchingPaths but are not verified by the PRs introducing it (#40861 and #44310). Thus, we are completely rewriting the implementation to fully specify and validate these. This is patched in version 2.4.0. This issue only impacts master branch and the release candidates for TF version 2.4. The final release of the 2.4 release will be patched.",
      "cve": "CVE-2020-26269",
      "specs": [
        "==2.4.0-rc0",
        "==2.4.0-rc1",
        "==2.4.0-rc2",
        "==2.4.0-rc3",
        "==2.4.0-rc4"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-26270",
      "advisory": "In affected versions of TensorFlow running an LSTM/GRU model where the LSTM/GRU layer receives an input with zero-length results in a CHECK failure when using the CUDA backend. This can result in a query-of-death vulnerability, via denial of service, if users can control the input to the layer. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26270",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-26271",
      "advisory": "In affected versions of TensorFlow under certain cases, loading a saved model can result in accessing uninitialized memory while building the computation graph. The MakeEdge function creates an edge between one output tensor of the src node (given by output_index) and the input slot of the dst node (given by input_index). This is only possible if the types of the tensors on both sides coincide, so the function begins by obtaining the corresponding DataType values and comparing these for equality. However, there is no check that the indices point to inside of the arrays they index into. Thus, this can result in accessing data out of bounds of the corresponding heap allocated arrays. In most scenarios, this can manifest as unitialized data access, but if the index points far away from the boundaries of the arrays this can be used to leak addresses from the library. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26271",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2020-5215",
      "advisory": "In TensorFlow before 1.15.2 and 2.0.1, converting a string (from Python) to a tf.float16 value results in a segmentation fault in eager mode as the format checks for this use case are only in the graph mode. This issue can lead to denial of service in inference/training where a malicious attacker can send a data point which contains a string instead of a tf.float16 value. Similar effects can be obtained by manipulating saved models and checkpoints whereby replacing a scalar tf.float16 value with a scalar string will trigger this issue due to automatic conversions. This can be easily reproduced by tf.constant(\"hello\", tf.float16), if eager execution is enabled. This issue is patched in TensorFlow 1.15.1 and 2.0.1 with this vulnerability patched. TensorFlow 2.1.0 was released after we fixed the issue, thus it is not affected. Users are encouraged to switch to TensorFlow 1.15.1, 2.0.1 or 2.1.0.",
      "cve": "CVE-2020-5215",
      "specs": [
        "<1.15.2",
        ">=2.0.0,<2.0.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29512",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. If the `splits` argument of `RaggedBincount` does not specify a valid `SparseTensor`(https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor), then an attacker can trigger a heap buffer overflow. This will cause a read from outside the bounds of the `splits` tensor buffer in the implementation of the `RaggedBincount` op(https://github.com/tensorflow/tensorflow/blob/8b677d79167799f71c42fd3fa074476e0295413a/tensorflow/core/kernels/bincount_op.cc#L430-L433). Before the `for` loop, `batch_idx` is set to 0. The user controls the `splits` array, making it contain only one element, 0. Thus, the code in the `while` loop would increment `batch_idx` and then try to read `splits(1)`, which is outside of bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3, as these are also affected.",
      "cve": "CVE-2021-29512",
      "specs": [
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29513",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Calling TF operations with tensors of non-numeric types when the operations expect numeric tensors result in null pointer dereferences. The conversion from Python array to C++ array(https://github.com/tensorflow/tensorflow/blob/ff70c47a396ef1e3cb73c90513da4f5cb71bebba/tensorflow/python/lib/core/ndarray_tensor.cc#L113-L169) is vulnerable to a type confusion. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29513",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29514",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. If the `splits` argument of `RaggedBincount` does not specify a valid `SparseTensor`(https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor), then an attacker can trigger a heap buffer overflow. This will cause a read from outside the bounds of the `splits` tensor buffer in the implementation of the `RaggedBincount` op(https://github.com/tensorflow/tensorflow/blob/8b677d79167799f71c42fd3fa074476e0295413a/tensorflow/core/kernels/bincount_op.cc#L430-L446). Before the `for` loop, `batch_idx` is set to 0. The attacker sets `splits(0)` to be 7, hence the `while` loop does not execute and `batch_idx` remains 0. This then results in writing to `out(-1, bin)`, which is before the heap allocated buffer for the output tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3, as these are also affected.",
      "cve": "CVE-2021-29514",
      "specs": [
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29515",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `MatrixDiag*` operations(https://github.com/tensorflow/tensorflow/blob/4c4f420e68f1cfaf8f4b6e8e3eb857e9e4c3ff33/tensorflow/core/kernels/linalg/matrix_diag_op.cc#L195-L197) does not validate that the tensor arguments are non-empty. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29515",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29516",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Calling `tf.raw_ops.RaggedTensorToVariant` with arguments specifying an invalid ragged tensor results in a null pointer dereference. The implementation of `RaggedTensorToVariant` operations(https://github.com/tensorflow/tensorflow/blob/904b3926ed1c6c70380d5313d282d248a776baa1/tensorflow/core/kernels/ragged_tensor_to_variant_op.cc#L39-L40) does not validate that the ragged tensor argument is non-empty. Since `batched_ragged` contains no elements, `batched_ragged.splits` is a null vector, thus `batched_ragged.splits(0)` will result in dereferencing `nullptr`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29516",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29517",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. A malicious user could trigger a division by 0 in `Conv3D` implementation. The implementation(https://github.com/tensorflow/tensorflow/blob/42033603003965bffac51ae171b51801565e002d/tensorflow/core/kernels/conv_ops_3d.cc#L143-L145) does a modulo operation based on user controlled input. Thus, when `filter` has a 0 as the fifth element, this results in a division by 0. Additionally, if the shape of the two tensors is not valid, an Eigen assertion can be triggered, resulting in a program crash. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29517",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29518",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In eager mode (default in TF 2.0 and later), session operations are invalid. However, users could still call the raw ops associated with them and trigger a null pointer dereference. The implementation(https://github.com/tensorflow/tensorflow/blob/eebb96c2830d48597d055d247c0e9aebaea94cd5/tensorflow/core/kernels/session_ops.cc#L104) dereferences the session state pointer without checking if it is valid. Thus, in eager mode, `ctx->session_state()` is nullptr and the call of the member function is undefined behavior. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29518",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29519",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The API of `tf.raw_ops.SparseCross` allows combinations which would result in a `CHECK`-failure and denial of service. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/3d782b7d47b1bf2ed32bd4a246d6d6cadc4c903d/tensorflow/core/kernels/sparse_cross_op.cc#L114-L116) is tricked to consider a tensor of type `tstring` which in fact contains integral elements. Fixing the type confusion by preventing mixing `DT_STRING` and `DT_INT64` types solves this issue. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29519",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29520",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Missing validation between arguments to `tf.raw_ops.Conv3DBackprop*` operations can result in heap buffer overflows. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/4814fafb0ca6b5ab58a09411523b2193fed23fed/tensorflow/core/kernels/conv_grad_shape_utils.cc#L94-L153) assumes that the `input`, `filter_sizes` and `out_backprop` tensors have the same shape, as they are accessed in parallel. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29520",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29521",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Specifying a negative dense shape in `tf.raw_ops.SparseCountSparseOutput` results in a segmentation fault being thrown out from the standard library as `std::vector` invariants are broken. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/8f7b60ee8c0206a2c99802e3a4d1bb55d2bc0624/tensorflow/core/kernels/count_ops.cc#L199-L213) assumes the first element of the dense shape is always positive and uses it to initialize a `BatchedMap<T>` (i.e., `std::vector<absl::flat_hash_map<int64,T>>`(https://github.com/tensorflow/tensorflow/blob/8f7b60ee8c0206a2c99802e3a4d1bb55d2bc0624/tensorflow/core/kernels/count_ops.cc#L27)) data structure. If the `shape` tensor has more than one element, `num_batches` is the first value in `shape`. Ensuring that the `dense_shape` argument is a valid tensor shape (that is, all elements are non-negative) solves this issue. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3.",
      "cve": "CVE-2021-29521",
      "specs": [
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29522",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The `tf.raw_ops.Conv3DBackprop*` operations fail to validate that the input tensors are not empty. In turn, this would result in a division by 0. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a91bb59769f19146d5a0c20060244378e878f140/tensorflow/core/kernels/conv_grad_ops_3d.cc#L430-L450) does not check that the divisor used in computing the shard size is not zero. Thus, if attacker controls the input sizes, they can trigger a denial of service via a division by zero error. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29522",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29523",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.AddManySparseToTensorsMap`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/kernels/sparse_tensors_map_ops.cc#L257) takes the values specified in `sparse_shape` as dimensions for the output shape. The `TensorShape` constructor(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L183-L188) uses a `CHECK` operation which triggers when `InitDims`(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L212-L296) returns a non-OK status. This is a legacy implementation of the constructor and operations should use `BuildTensorShapeBase` or `AddDimWithStatus` to prevent `CHECK`-failures in the presence of overflows. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29523",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29524",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/496c2630e51c1a478f095b084329acedb253db6b/tensorflow/core/kernels/conv_grad_shape_utils.cc#L130) does a modulus operation where the divisor is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29524",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29525",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2DBackpropInput`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/b40060c9f697b044e3107917c797ba052f4506ab/tensorflow/core/kernels/conv_grad_input_ops.h#L625-L655) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29525",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29526",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2D`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/988087bd83f144af14087fe4fecee2d250d93737/tensorflow/core/kernels/conv_ops.cc#L261-L263) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29526",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29527",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.QuantizedConv2D`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/00e9a4d67d76703fa1aee33dac582acf317e0e81/tensorflow/core/kernels/quantized_conv_ops.cc#L257-L259) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29527",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29528",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.QuantizedMul`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/55900e961ed4a23b438392024912154a2c2f5e85/tensorflow/core/kernels/quantized_mul_op.cc#L188-L198) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29528",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29529",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a heap buffer overflow in `tf.raw_ops.QuantizedResizeBilinear` by manipulating input values so that float rounding results in off-by-one error in accessing image elements. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/44b7f486c0143f68b56c34e2d01e146ee445134a/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L62-L66) computes two integers (representing the upper and lower bounds for interpolation) by ceiling and flooring a floating point value. For some values of `in`, `interpolation->upper[i]` might be smaller than `interpolation->lower[i]`. This is an issue if `interpolation->upper[i]` is capped at `in_size-1` as it means that `interpolation->lower[i]` points outside of the image. Then, in the interpolation code(https://github.com/tensorflow/tensorflow/blob/44b7f486c0143f68b56c34e2d01e146ee445134a/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L245-L264), this would result in heap buffer overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29529",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29530",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a null pointer dereference by providing an invalid `permutation` to `tf.raw_ops.SparseMatrixSparseCholesky`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/080f1d9e257589f78b3ffb75debf584168aa6062/tensorflow/core/kernels/sparse/sparse_cholesky_op.cc#L85-L86) fails to properly validate the input arguments. Although `ValidateInputs` is called and there are checks in the body of this function, the code proceeds to the next line in `ValidateInputs` since `OP_REQUIRES`(https://github.com/tensorflow/tensorflow/blob/080f1d9e257589f78b3ffb75debf584168aa6062/tensorflow/core/framework/op_requires.h#L41-L48) is a macro that only exits the current function. Thus, the first validation condition that fails in `ValidateInputs` will cause an early return from that function. However, the caller will continue execution from the next line. The fix is to either explicitly check `context->status()` or to convert `ValidateInputs` to return a `Status`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29530",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29531",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a `CHECK` fail in PNG encoding by providing an empty input tensor as the pixel data. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/e312e0791ce486a80c9d23110841525c6f7c3289/tensorflow/core/kernels/image/encode_png_op.cc#L57-L60) only validates that the total number of pixels in the image does not overflow. Thus, an attacker can send an empty matrix for encoding. However, if the tensor is empty, then the associated buffer is `nullptr`. Hence, when calling `png::WriteImageToBuffer`(https://github.com/tensorflow/tensorflow/blob/e312e0791ce486a80c9d23110841525c6f7c3289/tensorflow/core/kernels/image/encode_png_op.cc#L79-L93), the first argument (i.e., `image.flat<T>().data()`) is `NULL`. This then triggers the `CHECK_NOTNULL` in the first line of `png::WriteImageToBuffer`(https://github.com/tensorflow/tensorflow/blob/e312e0791ce486a80c9d23110841525c6f7c3289/tensorflow/core/lib/png/png_io.cc#L345-L349). Since `image` is null, this results in `abort` being called after printing the stacktrace. Effectively, this allows an attacker to mount a denial of service attack. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29531",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29532",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can force accesses outside the bounds of heap allocated arrays by passing in invalid tensor values to `tf.raw_ops.RaggedCross`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/efea03b38fb8d3b81762237dc85e579cc5fc6e87/tensorflow/core/kernels/ragged_cross_op.cc#L456-L487) lacks validation for the user supplied arguments. Each of the above branches call a helper function after accessing array elements via a `*_list[next_*]` pattern, followed by incrementing the `next_*` index. However, as there is no validation that the `next_*` values are in the valid range for the corresponding `*_list` arrays, this results in heap OOB reads. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29532",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29533",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK` failure by passing an empty image to `tf.raw_ops.DrawBoundingBoxes`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/ea34a18dc3f5c8d80a40ccca1404f343b5d55f91/tensorflow/core/kernels/image/draw_bounding_box_op.cc#L148-L165) uses `CHECK_*` assertions instead of `OP_REQUIRES` to validate user controlled inputs. Whereas `OP_REQUIRES` allows returning an error condition back to the user, the `CHECK_*` macros result in a crash if the condition is false, similar to `assert`. In this case, `height` is 0 from the `images` input. This results in `max_box_row_clamp` being negative and the assertion being falsified, followed by aborting program execution. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29533",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29534",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.SparseConcat`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/b432a38fe0e1b4b904a6c222cbce794c39703e87/tensorflow/core/kernels/sparse_concat_op.cc#L76) takes the values specified in `shapes[0]` as dimensions for the output shape. The `TensorShape` constructor(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L183-L188) uses a `CHECK` operation which triggers when `InitDims`(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L212-L296) returns a non-OK status. This is a legacy implementation of the constructor and operations should use `BuildTensorShapeBase` or `AddDimWithStatus` to prevent `CHECK`-failures in the presence of overflows. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29534",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29535",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedMul` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/87cf4d3ea9949051e50ca3f071fc909538a51cd0/tensorflow/core/kernels/quantized_mul_op.cc#L287-L290) assumes that the 4 arguments are always valid scalars and tries to access the numeric value directly. However, if any of these tensors is empty, then `.flat<T>()` is an empty buffer and accessing the element at position 0 results in overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29535",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29536",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedReshape` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a324ac84e573fba362a5e53d4e74d5de6729933e/tensorflow/core/kernels/quantized_reshape_op.cc#L38-L55) assumes that the 2 arguments are always valid scalars and tries to access the numeric value directly. However, if any of these tensors is empty, then `.flat<T>()` is an empty buffer and accessing the element at position 0 results in overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29536",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29537",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedResizeBilinear` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/50711818d2e61ccce012591eeb4fdf93a8496726/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L705-L706) assumes that the 2 arguments are always valid scalars and tries to access the numeric value directly. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29537",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29538",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a division by zero to occur in `Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1b0296c3b8dd9bd948f924aa8cd62f87dbb7c3da/tensorflow/core/kernels/conv_grad_filter_ops.cc#L513-L522) computes a divisor based on user provided data (i.e., the shape of the tensors given as arguments). If all shapes are empty then `work_unit_size` is 0. Since there is no check for this case before division, this results in a runtime exception, with potential to be abused for a denial of service. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29538",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29539",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Calling `tf.raw_ops.ImmutableConst`(https://www.tensorflow.org/api_docs/python/tf/raw_ops/ImmutableConst) with a `dtype` of `tf.resource` or `tf.variant` results in a segfault in the implementation as code assumes that the tensor contents are pure scalars. We have patched the issue in 4f663d4b8f0bec1b48da6fa091a7d29609980fa4 and will release TensorFlow 2.5.0 containing the patch. TensorFlow nightly packages after this commit will also have the issue resolved. If using `tf.raw_ops.ImmutableConst` in code, you can prevent the segfault by inserting a filter for the `dtype` argument.",
      "cve": "CVE-2021-29539",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29540",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow to occur in `Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1b0296c3b8dd9bd948f924aa8cd62f87dbb7c3da/tensorflow/core/kernels/conv_grad_filter_ops.cc#L495-L497) computes the size of the filter tensor but does not validate that it matches the number of elements in `filter_sizes`. Later, when reading/writing to this buffer, code uses the value computed here, instead of the number of elements in the tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29540",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29541",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a dereference of a null pointer in `tf.raw_ops.StringNGrams`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1cdd4da14282210cc759e468d9781741ac7d01bf/tensorflow/core/kernels/string_ngrams_op.cc#L67-L74) does not fully validate the `data_splits` argument. This would result in `ngrams_data`(https://github.com/tensorflow/tensorflow/blob/1cdd4da14282210cc759e468d9781741ac7d01bf/tensorflow/core/kernels/string_ngrams_op.cc#L106-L110) to be a null pointer when the output would be computed to have 0 or negative size. Later writes to the output tensor would then cause a null pointer dereference. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29541",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29542",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow by passing crafted inputs to `tf.raw_ops.StringNGrams`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1cdd4da14282210cc759e468d9781741ac7d01bf/tensorflow/core/kernels/string_ngrams_op.cc#L171-L185) fails to consider corner cases where input would be split in such a way that the generated tokens should only contain padding elements. If input is such that `num_tokens` is 0, then, for `data_start_index=0` (when left padding is present), the marked line would result in reading `data[-1]`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29542",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29543",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.CTCGreedyDecoder`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1615440b17b364b875eb06f43d087381f1460a65/tensorflow/core/kernels/ctc_decoder_ops.cc#L37-L50) has a `CHECK_LT` inserted to validate some invariants. When this condition is false, the program aborts, instead of returning a valid error to the user. This abnormal termination can be weaponized in denial of service attacks. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29543",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29544",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.QuantizeAndDequantizeV4Grad`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/95078c145b5a7a43ee046144005f733092756ab5/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L162-L163) does not validate the rank of the `input_*` tensors. In turn, this results in the tensors being passes as they are to `QuantizeAndDequantizePerChannelGradientImpl`(https://github.com/tensorflow/tensorflow/blob/95078c145b5a7a43ee046144005f733092756ab5/tensorflow/core/kernels/quantize_and_dequantize_op.h#L295-L306). However, the `vec<T>` method, requires the rank to 1 and triggers a `CHECK` failure otherwise. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 as this is the only other affected version.",
      "cve": "CVE-2021-29544",
      "specs": [
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29545",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in converting sparse tensors to CSR Sparse matrices. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/800346f2c03a27e182dd4fba48295f65e7790739/tensorflow/core/kernels/sparse/kernels.cc#L66) does a double redirection to access an element of an array allocated on the heap. If the value at `indices(i, 0)` is such that `indices(i, 0) + 1` is outside the bounds of `csr_row_ptr`, this results in writing outside of bounds of heap allocated data. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29545",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29546",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger an integer division by zero undefined behavior in `tf.raw_ops.QuantizedBiasAdd`. This is because the implementation of the Eigen kernel(https://github.com/tensorflow/tensorflow/blob/61bca8bd5ba8a68b2d97435ddfafcdf2b85672cd/tensorflow/core/kernels/quantization_utils.h#L812-L849) does a division by the number of elements of the smaller input (based on shape) without checking that this is not zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29546",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29547",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a segfault and denial of service via accessing data outside of bounds in `tf.raw_ops.QuantizedBatchNormWithGlobalNormalization`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/55a97caa9e99c7f37a0bbbeb414dc55553d3ae7f/tensorflow/core/kernels/quantized_batch_norm_op.cc#L176-L189) assumes the inputs are not empty. If any of these inputs is empty, `.flat<T>()` is an empty buffer, so accessing the element at index 0 is accessing data outside of bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29547",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29548",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a runtime division by zero error and denial of service in `tf.raw_ops.QuantizedBatchNormWithGlobalNormalization`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/55a97caa9e99c7f37a0bbbeb414dc55553d3ae7f/tensorflow/core/kernels/quantized_batch_norm_op.cc) does not validate all constraints specified in the op's contract(https://www.tensorflow.org/api_docs/python/tf/raw_ops/QuantizedBatchNormWithGlobalNormalization). The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29548",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29549",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a runtime division by zero error and denial of service in `tf.raw_ops.QuantizedBatchNormWithGlobalNormalization`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/6f26b3f3418201479c264f2a02000880d8df151c/tensorflow/core/kernels/quantized_add_op.cc#L289-L295) computes a modulo operation without validating that the divisor is not zero. Since `vector_num_elements` is determined based on input shapes(https://github.com/tensorflow/tensorflow/blob/6f26b3f3418201479c264f2a02000880d8df151c/tensorflow/core/kernels/quantized_add_op.cc#L522-L544), a user can trigger scenarios where this quantity is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29549",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29550",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a runtime division by zero error and denial of service in `tf.raw_ops.FractionalAvgPool`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/acc8ee69f5f46f92a3f1f11230f49c6ac266f10c/tensorflow/core/kernels/fractional_avg_pool_op.cc#L85-L89) computes a divisor quantity by dividing two user controlled values. The user controls the values of `input_size[i]` and `pooling_ratio_[i]` (via the `value.shape()` and `pooling_ratio` arguments). If the value in `input_size[i]` is smaller than the `pooling_ratio_[i]`, then the floor operation results in `output_size[i]` being 0. The `DCHECK_GT` line is a no-op outside of debug mode, so in released versions of TF this does not trigger. Later, these computed values are used as arguments(https://github.com/tensorflow/tensorflow/blob/acc8ee69f5f46f92a3f1f11230f49c6ac266f10c/tensorflow/core/kernels/fractional_avg_pool_op.cc#L96-L99) to `GeneratePoolingSequence`(https://github.com/tensorflow/tensorflow/blob/acc8ee69f5f46f92a3f1f11230f49c6ac266f10c/tensorflow/core/kernels/fractional_pool_common.cc#L100-L108). There, the first computation is a division in a modulo operation. Since `output_length` can be 0, this results in runtime crashing. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29550",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29551",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `MatrixTriangularSolve`(https://github.com/tensorflow/tensorflow/blob/8cae746d8449c7dda5298327353d68613f16e798/tensorflow/core/kernels/linalg/matrix_triangular_solve_op_impl.h#L160-L240) fails to terminate kernel execution if one validation condition fails. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29551",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29552",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by controlling the values of `num_segments` tensor argument for `UnsortedSegmentJoin`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a2a607db15c7cd01d754d37e5448d72a13491bdb/tensorflow/core/kernels/unsorted_segment_join_op.cc#L92-L93) assumes that the `num_segments` tensor is a valid scalar. Since the tensor is empty the `CHECK` involved in `.scalar<T>()()` that checks that the number of elements is exactly 1 will be invalidated and this would result in process termination. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29552",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29553",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can read data outside of bounds of heap allocated buffer in `tf.raw_ops.QuantizeAndDequantizeV3`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/11ff7f80667e6490d7b5174aa6bf5e01886e770f/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L237) does not validate the value of user supplied `axis` attribute before using it to index in the array backing the `input` argument. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29553",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29554",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.DenseCountSparseOutput`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/efff014f3b2d8ef6141da30c806faf141297eca1/tensorflow/core/kernels/count_ops.cc#L123-L127) computes a divisor value from user data but does not check that the result is 0 before doing the division. Since `data` is given by the `values` argument, `num_batch_elements` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, and TensorFlow 2.3.3, as these are also affected.",
      "cve": "CVE-2021-29554",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29555",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.FusedBatchNorm`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/828f346274841fa7505f7020e88ca36c22e557ab/tensorflow/core/kernels/fused_batch_norm_op.cc#L295-L297) performs a division based on the last dimension of the `x` tensor. Since this is controlled by the user, an attacker can trigger a denial of service. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29555",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29556",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.Reverse`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/36229ea9e9451dac14a8b1f4711c435a1d84a594/tensorflow/core/kernels/reverse_op.cc#L75-L76) performs a division based on the first dimension of the tensor argument. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29556",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29557",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.SparseMatMul`. The division by 0 occurs deep in Eigen code because the `b` tensor is empty. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29557",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29558",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `tf.raw_ops.SparseSplit`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/699bff5d961f0abfde8fa3f876e6d241681fbef8/tensorflow/core/util/sparse/sparse_tensor.h#L528-L530) accesses an array element based on a user controlled offset. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29558",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29559",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can access data outside of bounds of heap allocated array in `tf.raw_ops.UnicodeEncode`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/472c1f12ad9063405737679d4f6bd43094e1d36d/tensorflow/core/kernels/unicode_ops.cc) assumes that the `input_value`/`input_splits` pair specify a valid sparse tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29559",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29560",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `tf.raw_ops.RaggedTensorToTensor`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/d94227d43aa125ad8b54115c03cece54f6a1977b/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L219-L222) uses the same index to access two arrays in parallel. Since the user controls the shape of the input arguments, an attacker could trigger a heap OOB access when `parent_output_index` is shorter than `row_split`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29560",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29561",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by exploiting a `CHECK`-failure coming from `tf.raw_ops.LoadAndRemapMatrix`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/d94227d43aa125ad8b54115c03cece54f6a1977b/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L219-L222) assumes that the `ckpt_path` is always a valid scalar. However, an attacker can send any other tensor as the first argument of `LoadAndRemapMatrix`. This would cause the rank `CHECK` in `scalar<T>()()` to trigger and terminate the process. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29561",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29562",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by exploiting a `CHECK`-failure coming from the implementation of `tf.raw_ops.IRFFT`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29562",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29563",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by exploiting a `CHECK`-failure coming from the implementation of `tf.raw_ops.RFFT`. Eigen code operating on an empty matrix can trigger on an assertion and will cause program termination. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29563",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29564",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a null pointer dereference in the implementation of `tf.raw_ops.EditDistance`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/79865b542f9ffdc9caeb255631f7c56f1d4b6517/tensorflow/core/kernels/edit_distance_op.cc#L103-L159) has incomplete validation of the input parameters. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29564",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29565",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a null pointer dereference in the implementation of `tf.raw_ops.SparseFillEmptyRows`. This is because of missing validation(https://github.com/tensorflow/tensorflow/blob/fdc82089d206e281c628a93771336bf87863d5e8/tensorflow/core/kernels/sparse_fill_empty_rows_op.cc#L230-L231) that was covered under a `TODO`. If the `dense_shape` tensor is empty, then `dense_shape_t.vec<>()` would cause a null pointer dereference in the implementation of the op. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29565",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29566",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can write outside the bounds of heap allocated arrays by passing invalid arguments to `tf.raw_ops.Dilation2DBackpropInput`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/afd954e65f15aea4d438d0a219136fc4a63a573d/tensorflow/core/kernels/dilation_ops.cc#L321-L322) does not validate before writing to the output array. The values for `h_out` and `w_out` are guaranteed to be in range for `out_backprop` (as they are loop indices bounded by the size of the array). However, there are no similar guarantees relating `h_in_max`/`w_in_max` and `in_backprop`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29566",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29567",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.SparseDenseCwiseMul`, an attacker can trigger denial of service via `CHECK`-fails or accesses to outside the bounds of heap allocated data. Since the implementation(https://github.com/tensorflow/tensorflow/blob/38178a2f7a681a7835bb0912702a134bfe3b4d84/tensorflow/core/kernels/sparse_dense_binary_op_shared.cc#L68-L80) only validates the rank of the input arguments but no constraints between dimensions(https://www.tensorflow.org/api_docs/python/tf/raw_ops/SparseDenseCwiseMul), an attacker can abuse them to trigger internal `CHECK` assertions (and cause program termination, denial of service) or to write to memory outside of bounds of heap allocated tensor buffers. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29567",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29568",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger undefined behavior by binding to null pointer in `tf.raw_ops.ParameterizedTruncatedNormal`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/3f6fe4dfef6f57e768260b48166c27d148f3015f/tensorflow/core/kernels/parameterized_truncated_normal_op.cc#L630) does not validate input arguments before accessing the first element of `shape`. If `shape` argument is empty, then `shape_tensor.flat<T>()` is an empty array. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29568",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29569",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` can cause reads outside of bounds of heap allocated data if attacker supplies specially crafted inputs. The implementation(https://github.com/tensorflow/tensorflow/blob/ac328eaa3870491ababc147822cd04e91a790643/tensorflow/core/kernels/requantization_range_op.cc#L49-L50) assumes that the `input_min` and `input_max` tensors have at least one element, as it accesses the first element in two arrays. If the tensors are empty, `.flat<T>()` is an empty object, backed by an empty array. Hence, accesing even the 0th element is a read outside the bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29569",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29570",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` can cause reads outside of bounds of heap allocated data if attacker supplies specially crafted inputs. The implementation(https://github.com/tensorflow/tensorflow/blob/ef0c008ee84bad91ec6725ddc42091e19a30cf0e/tensorflow/core/kernels/maxpooling_op.cc#L1016-L1017) uses the same value to index in two different arrays but there is no guarantee that the sizes are identical. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29570",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29571",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` can cause reads outside of bounds of heap allocated data if attacker supplies specially crafted inputs. The implementation(https://github.com/tensorflow/tensorflow/blob/31bd5026304677faa8a0b77602c6154171b9aec1/tensorflow/core/kernels/image/draw_bounding_box_op.cc#L116-L130) assumes that the last element of `boxes` input is 4, as required by [the op](https://www.tensorflow.org/api_docs/python/tf/raw_ops/DrawBoundingBoxesV2). Since this is not checked attackers passing values less than 4 can write outside of bounds of heap allocated objects and cause memory corruption. If the last dimension in `boxes` is less than 4, accesses similar to `tboxes(b, bb, 3)` will access data outside of bounds. Further during code execution there are also writes to these indices. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29571",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29572",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.SdcaOptimizer` triggers undefined behavior due to dereferencing a null pointer. The implementation(https://github.com/tensorflow/tensorflow/blob/60a45c8b6192a4699f2e2709a2645a751d435cc3/tensorflow/core/kernels/sdca_internal.cc) does not validate that the user supplied arguments satisfy all constraints expected by the op(https://www.tensorflow.org/api_docs/python/tf/raw_ops/SdcaOptimizer). The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29572",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29573",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` is vulnerable to a division by 0. The implementation(https://github.com/tensorflow/tensorflow/blob/279bab6efa22752a2827621b7edb56a730233bd8/tensorflow/core/kernels/maxpooling_op.cc#L1033-L1034) fails to validate that the batch dimension of the tensor is non-zero, before dividing by this quantity. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29573",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29574",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPool3DGradGrad` exhibits undefined behavior by dereferencing null pointers backing attacker-supplied empty tensors. The implementation(https://github.com/tensorflow/tensorflow/blob/72fe792967e7fd25234342068806707bbc116618/tensorflow/core/kernels/pooling_ops_3d.cc#L679-L703) fails to validate that the 3 tensor inputs are not empty. If any of them is empty, then accessing the elements in the tensor results in dereferencing a null pointer. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29574",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29575",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.ReverseSequence` allows for stack overflow and/or `CHECK`-fail based denial of service. The implementation(https://github.com/tensorflow/tensorflow/blob/5b3b071975e01f0d250c928b2a8f901cd53b90a7/tensorflow/core/kernels/reverse_sequence_op.cc#L114-L118) fails to validate that `seq_dim` and `batch_dim` arguments are valid. Negative values for `seq_dim` can result in stack overflow or `CHECK`-failure, depending on the version of Eigen code used to implement the operation. Similar behavior can be exhibited by invalid values of `batch_dim`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29575",
      "specs": [
        "<=2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29576",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPool3DGradGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/596c05a159b6fbb9e39ca10b3f7753b7244fa1e9/tensorflow/core/kernels/pooling_ops_3d.cc#L694-L696) does not check that the initialization of `Pool3dParameters` completes successfully. Since the constructor(https://github.com/tensorflow/tensorflow/blob/596c05a159b6fbb9e39ca10b3f7753b7244fa1e9/tensorflow/core/kernels/pooling_ops_3d.cc#L48-L88) uses `OP_REQUIRES` to validate conditions, the first assertion that fails interrupts the initialization of `params`, making it contain invalid data. In turn, this might cause a heap buffer overflow, depending on default initialized values. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29576",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29577",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.AvgPool3DGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/d80ffba9702dc19d1fac74fc4b766b3fa1ee976b/tensorflow/core/kernels/pooling_ops_3d.cc#L376-L450) assumes that the `orig_input_shape` and `grad` tensors have similar first and last dimensions but does not check that this assumption is validated. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29577",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29578",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.FractionalAvgPoolGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/dcba796a28364d6d7f003f6fe733d82726dda713/tensorflow/core/kernels/fractional_avg_pool_op.cc#L216) fails to validate that the pooling sequence arguments have enough elements as required by the `out_backprop` tensor shape. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29578",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29579",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/ab1e644b48c82cb71493f4362b4dd38f4577a1cf/tensorflow/core/kernels/maxpooling_op.cc#L194-L203) fails to validate that indices used to access elements of input/output arrays are valid. Whereas accesses to `input_backprop_flat` are guarded by `FastBoundsCheck`, the indexing in `out_backprop_flat` can result in OOB access. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29579",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29580",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.FractionalMaxPoolGrad` triggers an undefined behavior if one of the input tensors is empty. The code is also vulnerable to a denial of service attack as a `CHECK` condition becomes false and aborts the process. The implementation(https://github.com/tensorflow/tensorflow/blob/169054888d50ce488dfde9ca55d91d6325efbd5b/tensorflow/core/kernels/fractional_max_pool_op.cc#L215) fails to validate that input and output tensors are not empty and are of the same rank. Each of these unchecked assumptions is responsible for the above issues. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29580",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29581",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.CTCBeamSearchDecoder`, an attacker can trigger denial of service via segmentation faults. The implementation(https://github.com/tensorflow/tensorflow/blob/a74768f8e4efbda4def9f16ee7e13cf3922ac5f7/tensorflow/core/kernels/ctc_decoder_ops.cc#L68-L79) fails to detect cases when the input tensor is empty and proceeds to read data from a null buffer. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29581",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29582",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.Dequantize`, an attacker can trigger a read from outside of bounds of heap allocated data. The implementation(https://github.com/tensorflow/tensorflow/blob/26003593aa94b1742f34dc22ce88a1e17776a67d/tensorflow/core/kernels/dequantize_op.cc#L106-L131) accesses the `min_range` and `max_range` tensors in parallel but fails to check that they have the same shape. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29582",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29583",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.FusedBatchNorm` is vulnerable to a heap buffer overflow. If the tensors are empty, the same implementation can trigger undefined behavior by dereferencing null pointers. The implementation(https://github.com/tensorflow/tensorflow/blob/57d86e0db5d1365f19adcce848dfc1bf89fdd4c7/tensorflow/core/kernels/fused_batch_norm_op.cc) fails to validate that `scale`, `offset`, `mean` and `variance` (the last two only when required) all have the same number of elements as the number of channels of `x`. This results in heap out of bounds reads when the buffers backing these tensors are indexed past their boundary. If the tensors are empty, the validation mentioned in the above paragraph would also trigger and prevent the undefined behavior. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29583",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29584",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in caused by an integer overflow in constructing a new tensor shape. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/0908c2f2397c099338b901b067f6495a5b96760b/tensorflow/core/kernels/sparse_split_op.cc#L66-L70) builds a dense shape without checking that the dimensions would not result in overflow. The `TensorShape` constructor(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L183-L188) uses a `CHECK` operation which triggers when `InitDims`(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L212-L296) returns a non-OK status. This is a legacy implementation of the constructor and operations should use `BuildTensorShapeBase` or `AddDimWithStatus` to prevent `CHECK`-failures in the presence of overflows. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29584",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29585",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The TFLite computation for size of output after padding, `ComputeOutSize`(https://github.com/tensorflow/tensorflow/blob/0c9692ae7b1671c983569e5d3de5565843d500cf/tensorflow/lite/kernels/padding.h#L43-L55), does not check that the `stride` argument is not 0 before doing the division. Users can craft special models such that `ComputeOutSize` is called with `stride` set to 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29585",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29586",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Optimized pooling implementations in TFLite fail to check that the stride arguments are not 0 before calling `ComputePaddingHeightWidth`(https://github.com/tensorflow/tensorflow/blob/3f24ccd932546416ec906a02ddd183b48a1d2c83/tensorflow/lite/kernels/pooling.cc#L90). Since users can craft special models which will have `params->stride_{height,width}` be zero, this will result in a division by zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29586",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29587",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The `Prepare` step of the `SpaceToDepth` TFLite operator does not check for 0 before division(https://github.com/tensorflow/tensorflow/blob/5f7975d09eac0f10ed8a17dbb6f5964977725adc/tensorflow/lite/kernels/space_to_depth.cc#L63-L67). An attacker can craft a model such that `params->block_size` would be zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29587",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29588",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The optimized implementation of the `TransposeConv` TFLite operator is [vulnerable to a division by zero error](https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/internal/optimized/optimized_ops.h#L5221-L5222). An attacker can craft a model such that `stride_{h,w}` values are 0. Code calling this function must validate these arguments. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29588",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29589",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The reference implementation of the `GatherNd` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/internal/reference/reference_ops.h#L966). An attacker can craft a model such that `params` input would be an empty tensor. In turn, `params_shape.Dims(.)` would be zero, in at least one dimension. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29589",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29590",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementations of the `Minimum` and `Maximum` TFLite operators can be used to read data outside of bounds of heap allocated objects, if any of the two input tensor arguments are empty. This is because the broadcasting implementation(https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/internal/reference/maximum_minimum.h#L52-L56) indexes in both tensors with the same index but does not validate that the index is within bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29590",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29591",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. TFlite graphs must not have loops between nodes. However, this condition was not checked and an attacker could craft models that would result in infinite loop during evaluation. In certain cases, the infinite loop would be replaced by stack overflow due to too many recursive calls. For example, the `While` implementation(https://github.com/tensorflow/tensorflow/blob/106d8f4fb89335a2c52d7c895b7a7485465ca8d9/tensorflow/lite/kernels/while.cc) could be tricked into a scneario where both the body and the loop subgraphs are the same. Evaluating one of the subgraphs means calling the `Eval` function for the other and this quickly exhaust all stack space. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range. Please consult our security guide(https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.",
      "cve": "CVE-2021-29591",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29592",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The fix for CVE-2020-15209(https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-15209) missed the case when the target shape of `Reshape` operator is given by the elements of a 1-D tensor. As such, the fix for the vulnerability(https://github.com/tensorflow/tensorflow/blob/9c1dc920d8ffb4893d6c9d27d1f039607b326743/tensorflow/lite/core/subgraph.cc#L1062-L1074) allowed passing a null-buffer-backed tensor with a 1D shape. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29592",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29593",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `BatchToSpaceNd` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/b5ed552fe55895aee8bd8b191f744a069957d18d/tensorflow/lite/kernels/batch_to_space_nd.cc#L81-L82). An attacker can craft a model such that one dimension of the `block` input is 0. Hence, the corresponding value in `block_shape` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29593",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29594",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. TFLite's convolution code(https://github.com/tensorflow/tensorflow/blob/09c73bca7d648e961dd05898292d91a8322a9d45/tensorflow/lite/kernels/conv.cc) has multiple division where the divisor is controlled by the user and not checked to be non-zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29594",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29595",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `DepthToSpace` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/depth_to_space.cc#L63-L69). An attacker can craft a model such that `params->block_size` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29595",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29596",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `EmbeddingLookup` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/e4b29809543b250bc9b19678ec4776299dd569ba/tensorflow/lite/kernels/embedding_lookup.cc#L73-L74). An attacker can craft a model such that the first dimension of the `value` input is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29596",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29597",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `SpaceToBatchNd` TFLite operator is [vulnerable to a division by zero error](https://github.com/tensorflow/tensorflow/blob/412c7d9bb8f8a762c5b266c9e73bfa165f29aac8/tensorflow/lite/kernels/space_to_batch_nd.cc#L82-L83). An attacker can craft a model such that one dimension of the `block` input is 0. Hence, the corresponding value in `block_shape` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29597",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29598",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `SVDF` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/7f283ff806b2031f407db64c4d3edcda8fb9f9f5/tensorflow/lite/kernels/svdf.cc#L99-L102). An attacker can craft a model such that `params->rank` would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29598",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29599",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `Split` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/e2752089ef7ce9bcf3db0ec618ebd23ea119d0c7/tensorflow/lite/kernels/split.cc#L63-L65). An attacker can craft a model such that `num_splits` would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29599",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29600",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `OneHot` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/f61c57bd425878be108ec787f4d96390579fb83e/tensorflow/lite/kernels/one_hot.cc#L68-L72). An attacker can craft a model such that at least one of the dimensions of `indices` would be 0. In turn, the `prefix_dim_size` value would become 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29600",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29601",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The TFLite implementation of concatenation is vulnerable to an integer overflow issue(https://github.com/tensorflow/tensorflow/blob/7b7352a724b690b11bfaae2cd54bc3907daf6285/tensorflow/lite/kernels/concatenation.cc#L70-L76). An attacker can craft a model such that the dimensions of one of the concatenation input overflow the values of `int`. TFLite uses `int` to represent tensor dimensions, whereas TF uses `int64`. Hence, valid TF models can trigger an integer overflow when converted to TFLite format. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29601",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29602",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `DepthwiseConv` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/1a8e885b864c818198a5b2c0cbbeca5a1e833bc8/tensorflow/lite/kernels/depthwise_conv.cc#L287-L288). An attacker can craft a model such that `input`'s fourth dimension would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29602",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29603",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. A specially crafted TFLite model could trigger an OOB write on heap in the TFLite implementation of `ArgMin`/`ArgMax`(https://github.com/tensorflow/tensorflow/blob/102b211d892f3abc14f845a72047809b39cc65ab/tensorflow/lite/kernels/arg_min_max.cc#L52-L59). If `axis_value` is not a value between 0 and `NumDimensions(input)`, then the condition in the `if` is never true, so code writes past the last valid element of `output_dims->data`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29603",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29604",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The TFLite implementation of hashtable lookup is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/1a8e885b864c818198a5b2c0cbbeca5a1e833bc8/tensorflow/lite/kernels/hashtable_lookup.cc#L114-L115) An attacker can craft a model such that `values`'s first dimension would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29604",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29605",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The TFLite code for allocating `TFLiteIntArray`s is vulnerable to an integer overflow issue(https://github.com/tensorflow/tensorflow/blob/4ceffae632721e52bf3501b736e4fe9d1221cdfa/tensorflow/lite/c/common.c#L24-L27). An attacker can craft a model such that the `size` multiplier is so large that the return value overflows the `int` datatype and becomes negative. In turn, this results in invalid value being given to `malloc`(https://github.com/tensorflow/tensorflow/blob/4ceffae632721e52bf3501b736e4fe9d1221cdfa/tensorflow/lite/c/common.c#L47-L52). In this case, `ret->size` would dereference an invalid pointer. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29605",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29606",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. A specially crafted TFLite model could trigger an OOB read on heap in the TFLite implementation of `Split_V`(https://github.com/tensorflow/tensorflow/blob/c59c37e7b2d563967da813fa50fe20b21f4da683/tensorflow/lite/kernels/split_v.cc#L99). If `axis_value` is not a value between 0 and `NumDimensions(input)`, then the `SizeOfDimension` function(https://github.com/tensorflow/tensorflow/blob/102b211d892f3abc14f845a72047809b39cc65ab/tensorflow/lite/kernels/kernel_util.h#L148-L150) will access data outside the bounds of the tensor shape array. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29606",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29607",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `SparseAdd` results in allowing attackers to exploit undefined behavior (dereferencing null pointers) as well as write outside of bounds of heap allocated data. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/sparse_sparse_binary_op_shared.cc) has a large set of validation for the two sparse tensor inputs (6 tensors in total), but does not validate that the tensors are not empty or that the second dimension of `*_indices` matches the size of corresponding `*_shape`. This allows attackers to send tensor triples that represent invalid sparse tensors to abuse code assumptions that are not protected by validation. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29607",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29608",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.RaggedTensorToTensor`, an attacker can exploit an undefined behavior if input arguments are empty. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L356-L360) only checks that one of the tensors is not empty, but does not check for the other ones. There are multiple `DCHECK` validations to prevent heap OOB, but these are no-op in release builds, hence they don't prevent anything. The fix will be included in TensorFlow 2.5.0. We will also cherrypick these commits on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29608",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29609",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `SparseAdd` results in allowing attackers to exploit undefined behavior (dereferencing null pointers) as well as write outside of bounds of heap allocated data. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/sparse_add_op.cc) has a large set of validation for the two sparse tensor inputs (6 tensors in total), but does not validate that the tensors are not empty or that the second dimension of `*_indices` matches the size of corresponding `*_shape`. This allows attackers to send tensor triples that represent invalid sparse tensors to abuse code assumptions that are not protected by validation. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29609",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29610",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The validation in `tf.raw_ops.QuantizeAndDequantizeV2` allows invalid values for `axis` argument:. The validation(https://github.com/tensorflow/tensorflow/blob/eccb7ec454e6617738554a255d77f08e60ee0808/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L74-L77) uses `||` to mix two different conditions. If `axis_ < -1` the condition in `OP_REQUIRES` will still be true, but this value of `axis_` results in heap underflow. This allows attackers to read/write to other data on the heap. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29610",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29611",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `SparseReshape` results in a denial of service based on a `CHECK`-failure. The implementation(https://github.com/tensorflow/tensorflow/blob/e87b51ce05c3eb172065a6ea5f48415854223285/tensorflow/core/kernels/sparse_reshape_op.cc#L40) has no validation that the input arguments specify a valid sparse tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3, as these are the only affected versions.",
      "cve": "CVE-2021-29611",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29612",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a heap buffer overflow in Eigen implementation of `tf.raw_ops.BandedTriangularSolve`. The implementation(https://github.com/tensorflow/tensorflow/blob/eccb7ec454e6617738554a255d77f08e60ee0808/tensorflow/core/kernels/linalg/banded_triangular_solve_op.cc#L269-L278) calls `ValidateInputTensors` for input validation but fails to validate that the two tensors are not empty. Furthermore, since `OP_REQUIRES` macro only stops execution of current function after setting `ctx->status()` to a non-OK value, callers of helper functions that use `OP_REQUIRES` must check value of `ctx->status()` before continuing. This doesn't happen in this op's implementation(https://github.com/tensorflow/tensorflow/blob/eccb7ec454e6617738554a255d77f08e60ee0808/tensorflow/core/kernels/linalg/banded_triangular_solve_op.cc#L219), hence the validation that is present is also not effective. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29612",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29613",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `tf.raw_ops.CTCLoss` allows an attacker to trigger an OOB read from heap. The fix will be included in TensorFlow 2.5.0. We will also cherrypick these commits on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29613",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29614",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.io.decode_raw` produces incorrect results and crashes the Python interpreter when combining `fixed_length` and wider datatypes. The implementation of the padded version(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc) is buggy due to a confusion about pointer arithmetic rules. First, the code computes(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L61) the width of each output element by dividing the `fixed_length` value to the size of the type argument. The `fixed_length` argument is also used to determine the size needed for the output tensor(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L63-L79). This is followed by reencoding code(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L85-L94). The erroneous code is the last line above: it is moving the `out_data` pointer by `fixed_length * sizeof(T)` bytes whereas it only copied at most `fixed_length` bytes from the input. This results in parts of the input not being decoded into the output. Furthermore, because the pointer advance is far wider than desired, this quickly leads to writing to outside the bounds of the backing data. This OOB write leads to interpreter crash in the reproducer mentioned here, but more severe attacks can be mounted too, given that this gadget allows writing to periodically placed locations in memory. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29614",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29615",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `ParseAttrValue`(https://github.com/tensorflow/tensorflow/blob/c22d88d6ff33031aa113e48aa3fc9aa74ed79595/tensorflow/core/framework/attr_value_util.cc#L397-L453) can be tricked into stack overflow due to recursion by giving in a specially crafted input. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29615",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29616",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of TrySimplify(https://github.com/tensorflow/tensorflow/blob/c22d88d6ff33031aa113e48aa3fc9aa74ed79595/tensorflow/core/grappler/optimizers/arithmetic_optimizer.cc#L390-L401) has undefined behavior due to dereferencing a null pointer in corner cases that result in optimizing a node with no inputs. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29616",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29617",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via `CHECK`-fail in `tf.strings.substr` with invalid arguments. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29617",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29618",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Passing a complex argument to `tf.transpose` at the same time as passing `conjugate=True` argument results in a crash. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29618",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-29619",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Passing invalid arguments (e.g., discovered via fuzzing) to `tf.raw_ops.SparseCountSparseOutput` results in segfault. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29619",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-35958",
      "advisory": "** DISPUTED ** TensorFlow through 2.5.0 allows attackers to overwrite arbitrary files via a crafted archive when tf.keras.utils.get_file is used with extract=True. NOTE: the vendor's position is that tf.keras.utils.get_file is not intended for untrusted archives.",
      "cve": "CVE-2021-35958",
      "specs": [
        "<=2.5.0"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37635",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of sparse reduction operations in TensorFlow can trigger accesses outside of bounds of heap allocated data. The [implementation](https://github.com/tensorflow/tensorflow/blob/a1bc56203f21a5a4995311825ffaba7a670d7747/tensorflow/core/kernels/sparse_reduce_op.cc#L217-L228) fails to validate that each reduction group does not overflow and that each corresponding index does not point to outside the bounds of the input tensor. We have patched the issue in GitHub commit 87158f43f05f2720a374f3e6d22a7aaa3a33f750. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37635",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37636",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.SparseDenseCwiseDiv` is vulnerable to a division by 0 error. The [implementation](https://github.com/tensorflow/tensorflow/blob/a1bc56203f21a5a4995311825ffaba7a670d7747/tensorflow/core/kernels/sparse_dense_binary_op_shared.cc#L56) uses a common class for all binary operations but fails to treat the division by 0 case separately. We have patched the issue in GitHub commit d9204be9f49520cdaaeb2541d1dc5187b23f31d9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37636",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37637",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. It is possible to trigger a null pointer dereference in TensorFlow by passing an invalid input to `tf.raw_ops.CompressElement`. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/data/compression_utils.cc#L34) was accessing the size of a buffer obtained from the return of a separate function call before validating that said buffer is valid. We have patched the issue in GitHub commit 5dc7f6981fdaf74c8c5be41f393df705841fb7c5. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37637",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37638",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Sending invalid argument for `row_partition_types` of `tf.raw_ops.RaggedTensorToTensor` API results in a null pointer dereference and undefined behavior. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L328) accesses the first element of a user supplied list of values without validating that the provided list is not empty. We have patched the issue in GitHub commit 301ae88b331d37a2a16159b65b255f4f9eb39314. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37638",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37639",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. When restoring tensors via raw APIs, if the tensor name is not provided, TensorFlow can be tricked into dereferencing a null pointer. Alternatively, attackers can read memory outside the bounds of heap allocated data by providing some tensor names but not enough for a successful restoration. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/kernels/save_restore_tensor.cc#L158-L159) retrieves the tensor list corresponding to the `tensor_name` user controlled input and immediately retrieves the tensor at the restoration index (controlled via `preferred_shard` argument). This occurs without validating that the provided list has enough values. If the list is empty this results in dereferencing a null pointer (undefined behavior). If, however, the list has some elements, if the restoration index is outside the bounds this results in heap OOB read. We have patched the issue in GitHub commit 9e82dce6e6bd1f36a57e08fa85af213e2b2f2622. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37639",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37640",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.SparseReshape` can be made to trigger an integral division by 0 exception. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/reshape_util.cc#L176-L181) calls the reshaping functor whenever there is at least an index in the input but does not check that shape of the input or the target shape have both a non-zero number of elements. The [reshape functor](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/reshape_util.cc#L40-L78) blindly divides by the dimensions of the target shape. Hence, if this is not checked, code will result in a division by 0. We have patched the issue in GitHub commit 4923de56ec94fff7770df259ab7f2288a74feb41. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1 as this is the other affected version.",
      "cve": "CVE-2021-37640",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37641",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions if the arguments to `tf.raw_ops.RaggedGather` don't determine a valid ragged tensor code can trigger a read from outside of bounds of heap allocated buffers. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/ragged_gather_op.cc#L70) directly reads the first dimension of a tensor shape before checking that said tensor has rank of at least 1 (i.e., it is not a scalar). Furthermore, the implementation does not check that the list given by `params_nested_splits` is not an empty list of tensors. We have patched the issue in GitHub commit a2b743f6017d7b97af1fe49087ae15f0ac634373. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37641",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37642",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.ResourceScatterDiv` is vulnerable to a division by 0 error. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/resource_variable_ops.cc#L865) uses a common class for all binary operations but fails to treat the division by 0 case separately. We have patched the issue in GitHub commit 4aacb30888638da75023e6601149415b39763d76. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37642",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37643",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. If a user does not provide a valid padding value to `tf.raw_ops.MatrixDiagPartOp`, then the code triggers a null pointer dereference (if input is empty) or produces invalid behavior, ignoring all values after the first. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/linalg/matrix_diag_op.cc#L89) reads the first value from a tensor buffer without first checking that the tensor has values to read from. We have patched the issue in GitHub commit 482da92095c4d48f8784b1f00dda4f81c28d2988. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37643",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37644",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions providing a negative element to `num_elements` list argument of `tf.raw_ops.TensorListReserve` causes the runtime to abort the process due to reallocating a `std::vector` to have a negative number of elements. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/list_kernels.cc#L312) calls `std::vector.resize()` with the new size controlled by input given by the user, without checking that this input is valid. We have patched the issue in GitHub commit 8a6e874437670045e6c7dc6154c7412b4a2135e2. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37644",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37645",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.QuantizeAndDequantizeV4Grad` is vulnerable to an integer overflow issue caused by converting a signed integer value to an unsigned one and then allocating memory based on this value. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L126) uses the `axis` value as the size argument to `absl::InlinedVector` constructor. But, the constructor uses an unsigned type for the argument, so the implicit conversion transforms the negative value to a large integer. We have patched the issue in GitHub commit 96f364a1ca3009f98980021c4b32be5fdcca33a1. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, and TensorFlow 2.4.3, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37645",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37646",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.StringNGrams` is vulnerable to an integer overflow issue caused by converting a signed integer value to an unsigned one and then allocating memory based on this value. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/string_ngrams_op.cc#L184) calls `reserve` on a `tstring` with a value that sometimes can be negative if user supplies negative `ngram_widths`. The `reserve` method calls `TF_TString_Reserve` which has an `unsigned long` argument for the size of the buffer. Hence, the implicit conversion transforms the negative value to a large integer. We have patched the issue in GitHub commit c283e542a3f422420cfdb332414543b62fc4e4a5. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37646",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37647",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. When a user does not supply arguments that determine a valid sparse tensor, `tf.raw_ops.SparseTensorSliceDataset` implementation can be made to dereference a null pointer. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc#L240-L251) has some argument validation but fails to consider the case when either `indices` or `values` are provided for an empty sparse tensor when the other is not. If `indices` is empty, then [code that performs validation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc#L260-L261) (i.e., checking that the indices are monotonically increasing) results in a null pointer dereference. If `indices` as provided by the user is empty, then `indices` in the C++ code above is backed by an empty `std::vector`, hence calling `indices->dim_size(0)` results in null pointer dereferencing (same as calling `std::vector::at()` on an empty vector). We have patched the issue in GitHub commit 02cc160e29d20631de3859c6653184e3f876b9d7. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37647",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37648",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the code for `tf.raw_ops.SaveV2` does not properly validate the inputs and an attacker can trigger a null pointer dereference. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/save_restore_v2_ops.cc) uses `ValidateInputs` to check that the input arguments are valid. This validation would have caught the illegal state represented by the reproducer above. However, the validation uses `OP_REQUIRES` which translates to setting the `Status` object of the current `OpKernelContext` to an error status, followed by an empty `return` statement which just terminates the execution of the function it is present in. However, this does not mean that the kernel execution is finalized: instead, execution continues from the next line in `Compute` that follows the call to `ValidateInputs`. This is equivalent to lacking the validation. We have patched the issue in GitHub commit 9728c60e136912a12d99ca56e106b7cce7af5986. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37648",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37649",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The code for `tf.raw_ops.UncompressElement` can be made to trigger a null pointer dereference. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/data/experimental/compression_ops.cc#L50-L53) obtains a pointer to a `CompressedElement` from a `Variant` tensor and then proceeds to dereference it for decompressing. There is no check that the `Variant` tensor contained a `CompressedElement`, so the pointer is actually `nullptr`. We have patched the issue in GitHub commit 7bdf50bb4f5c54a4997c379092888546c97c3ebd. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37649",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37650",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.ExperimentalDatasetToTFRecord` and `tf.raw_ops.DatasetToTFRecord` can trigger heap buffer overflow and segmentation fault. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/data/experimental/to_tf_record_op.cc#L93-L102) assumes that all records in the dataset are of string type. However, there is no check for that, and the example given above uses numeric types. We have patched the issue in GitHub commit e0b6e58c328059829c3eb968136f17aa72b6c876. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37650",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37651",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.FractionalAvgPoolGrad` can be tricked into accessing data outside of bounds of heap allocated buffers. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/fractional_avg_pool_op.cc#L205) does not validate that the input tensor is non-empty. Thus, code constructs an empty `EigenDoubleMatrixMap` and then accesses this buffer with indices that are outside of the empty area. We have patched the issue in GitHub commit 0f931751fb20f565c4e94aa6df58d54a003cdb30. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37651",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37652",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.BoostedTreesCreateEnsemble` can result in a use after free error if an attacker supplies specially crafted arguments. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/boosted_trees/resource_ops.cc#L55) uses a reference counted resource and decrements the refcount if the initialization fails, as it should. However, when the code was written, the resource was represented as a naked pointer but later refactoring has changed it to be a smart pointer. Thus, when the pointer leaves the scope, a subsequent `free`-ing of the resource occurs, but this fails to take into account that the refcount has already reached 0, thus the resource has been already freed. During this double-free process, members of the resource object are accessed for cleanup but they are invalid as the entire resource has been freed. We have patched the issue in GitHub commit 5ecec9c6fbdbc6be03295685190a45e7eee726ab. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37652",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37653",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a crash via a floating point exception in `tf.raw_ops.ResourceGather`. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/resource_variable_ops.cc#L725-L731) computes the value of a value, `batch_size`, and then divides by it without checking that this value is not 0. We have patched the issue in GitHub commit ac117ee8a8ea57b73d34665cdf00ef3303bc0b11. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37653",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37654",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a crash via a `CHECK`-fail in debug builds of TensorFlow using `tf.raw_ops.ResourceGather` or a read from outside the bounds of heap allocated data in the same API in a release build. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/resource_variable_ops.cc#L660-L668) does not check that the `batch_dims` value that the user supplies is less than the rank of the input tensor. Since the implementation uses several for loops over the dimensions of `tensor`, this results in reading data from outside the bounds of heap allocated buffer backing the tensor. We have patched the issue in GitHub commit bc9c546ce7015c57c2f15c168b3d9201de679a1d. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37654",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37655",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a read from outside of bounds of heap allocated data by sending invalid arguments to `tf.raw_ops.ResourceScatterUpdate`. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/resource_variable_ops.cc#L919-L923) has an incomplete validation of the relationship between the shapes of `indices` and `updates`: instead of checking that the shape of `indices` is a prefix of the shape of `updates` (so that broadcasting can happen), code only checks that the number of elements in these two tensors are in a divisibility relationship. We have patched the issue in GitHub commit 01cff3f986259d661103412a20745928c727326f. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37655",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37656",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.RaggedTensorToSparse`. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/ragged_tensor_to_sparse_kernel.cc#L30) has an incomplete validation of the splits values: it does not check that they are in increasing order. We have patched the issue in GitHub commit 1071f554dbd09f7e101324d366eec5f4fe5a3ece. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37656",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37657",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in all operations of type `tf.raw_ops.MatrixDiagV*`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/linalg/matrix_diag_op.cc) has incomplete validation that the value of `k` is a valid tensor. We have check that this value is either a scalar or a vector, but there is no check for the number of elements. If this is an empty tensor, then code that accesses the first element of the tensor is wrong. We have patched the issue in GitHub commit f2a673bd34f0d64b8e40a551ac78989d16daad09. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37657",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37658",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in all operations of type `tf.raw_ops.MatrixSetDiagV*`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/linalg/matrix_diag_op.cc) has incomplete validation that the value of `k` is a valid tensor. We have check that this value is either a scalar or a vector, but there is no check for the number of elements. If this is an empty tensor, then code that accesses the first element of the tensor is wrong. We have patched the issue in GitHub commit ff8894044dfae5568ecbf2ed514c1a37dc394f1b. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37658",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37659",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in all binary cwise operations that don't require broadcasting (e.g., gradients of binary cwise operations). The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/cwise_ops_common.h#L264) assumes that the two inputs have exactly the same number of elements but does not check that. Hence, when the eigen functor executes it triggers heap OOB reads and undefined behavior due to binding to nullptr. We have patched the issue in GitHub commit 93f428fd1768df147171ed674fee1fc5ab8309ec. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37659",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37660",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause a floating point exception by calling inplace operations with crafted arguments that would result in a division by 0. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/inplace_ops.cc#L283) has a logic error: it should skip processing if `x` and `v` are empty but the code uses `||` instead of `&&`. We have patched the issue in GitHub commit e86605c0a336c088b638da02135ea6f9f6753618. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37660",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37661",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause a denial of service in `boosted_trees_create_quantile_stream_resource` by using negative arguments. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/quantile_ops.cc#L96) does not validate that `num_streams` only contains non-negative numbers. In turn, [this results in using this value to allocate memory](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/quantiles/quantile_stream_resource.h#L31-L40). However, `reserve` receives an unsigned integer so there is an implicit conversion from a negative value to a large positive unsigned. This results in a crash from the standard library. We have patched the issue in GitHub commit 8a84f7a2b5a2b27ecf88d25bad9ac777cd2f7992. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37661",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37662",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can generate undefined behavior via a reference binding to nullptr in `BoostedTreesCalculateBestGainsPerFeature` and similar attack can occur in `BoostedTreesCalculateBestFeatureSplitV2`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/stats_ops.cc) does not validate the input values. We have patched the issue in GitHub commit 9c87c32c710d0b5b53dc6fd3bfde4046e1f7a5ad and in commit 429f009d2b2c09028647dd4bb7b3f6f414bbaad7. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37662",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37663",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions due to incomplete validation in `tf.raw_ops.QuantizeV2`, an attacker can trigger undefined behavior via binding a reference to a null pointer or can access data outside the bounds of heap allocated arrays. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/quantize_op.cc#L59) has some validation but does not check that `min_range` and `max_range` both have the same non-zero number of elements. If `axis` is provided (i.e., not `-1`), then validation should check that it is a value in range for the rank of `input` tensor and then the lengths of `min_range` and `max_range` inputs match the `axis` dimension of the `input` tensor. We have patched the issue in GitHub commit 6da6620efad397c85493b8f8667b821403516708. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37663",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37664",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can read from outside of bounds of heap allocated data by sending specially crafted illegal arguments to `BoostedTreesSparseCalculateBestFeatureSplit`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/stats_ops.cc) needs to validate that each value in `stats_summary_indices` is in range. We have patched the issue in GitHub commit e84c975313e8e8e38bb2ea118196369c45c51378. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37664",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37665",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions due to incomplete validation in MKL implementation of requantization, an attacker can trigger undefined behavior via binding a reference to a null pointer or can access data outside the bounds of heap allocated arrays. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/mkl/mkl_requantization_range_per_channel_op.cc) does not validate the dimensions of the `input` tensor. A similar issue occurs in `MklRequantizePerChannelOp`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/mkl/mkl_requantize_per_channel_op.cc) does not perform full validation for all the input arguments. We have patched the issue in GitHub commit 9e62869465573cb2d9b5053f1fa02a81fce21d69 and in the Github commit 203214568f5bc237603dbab6e1fd389f1572f5c9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37665",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37666",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.RaggedTensorToVariant`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/ragged_tensor_to_variant_op.cc#L129) has an incomplete validation of the splits values, missing the case when the argument would be empty. We have patched the issue in GitHub commit be7a4de6adfbd303ce08be4332554dff70362612. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37666",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37667",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.UnicodeEncode`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/unicode_ops.cc#L533-L539) reads the first dimension of the `input_splits` tensor before validating that this tensor is not empty. We have patched the issue in GitHub commit 2e0ee46f1a47675152d3d865797a18358881d7a6. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37667",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37668",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause denial of service in applications serving models using `tf.raw_ops.UnravelIndex` by triggering a division by 0. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/unravel_index_op.cc#L36) does not check that the tensor subsumed by `dims` is not empty. Hence, if one element of `dims` is 0, the implementation does a division by 0. We have patched the issue in GitHub commit a776040a5e7ebf76eeb7eb923bf1ae417dd4d233. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37668",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37669",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause denial of service in applications serving models using `tf.raw_ops.NonMaxSuppressionV5` by triggering a division by 0. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/image/non_max_suppression_op.cc#L170-L271) uses a user controlled argument to resize a `std::vector`. However, as `std::vector::resize` takes the size argument as a `size_t` and `output_size` is an `int`, there is an implicit conversion to unsigned. If the attacker supplies a negative value, this conversion results in a crash. A similar issue occurs in `CombinedNonMaxSuppression`. We have patched the issue in GitHub commit 3a7362750d5c372420aa8f0caf7bf5b5c3d0f52d and commit [b5cdbf12ffcaaffecf98f22a6be5a64bb96e4f58. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37669",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37670",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can read from outside of bounds of heap allocated data by sending specially crafted illegal arguments to `tf.raw_ops.UpperBound`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/searchsorted_op.cc#L85-L104) does not validate the rank of `sorted_input` argument. A similar issue occurs in `tf.raw_ops.LowerBound`. We have patched the issue in GitHub commit 42459e4273c2e47a3232cc16c4f4fff3b3a35c38. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37670",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37671",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.Map*` and `tf.raw_ops.OrderedMap*` operations. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/map_stage_op.cc#L222-L248) has a check in place to ensure that `indices` is in ascending order, but does not check that `indices` is not empty. We have patched the issue in GitHub commit 532f5c5a547126c634fefd43bbad1dc6417678ac. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37671",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37672",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can read from outside of bounds of heap allocated data by sending specially crafted illegal arguments to `tf.raw_ops.SdcaOptimizerV2`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/sdca_internal.cc#L320-L353) does not check that the length of `example_labels` is the same as the number of examples. We have patched the issue in GitHub commit a4e138660270e7599793fa438cd7b2fc2ce215a6. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37672",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37673",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.MapStage`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/map_stage_op.cc#L513) does not check that the `key` input is a valid non-empty tensor. We have patched the issue in GitHub commit d7de67733925de196ec8863a33445b73f9562d1d. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37673",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37674",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a denial of service via a segmentation fault in `tf.raw_ops.MaxPoolGrad` caused by missing validation. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/maxpooling_op.cc) misses some validation for the `orig_input` and `orig_output` tensors. The fixes for CVE-2021-29579 were incomplete. We have patched the issue in GitHub commit 136b51f10903e044308cf77117c0ed9871350475. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37674",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37675",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions most implementations of convolution operators in TensorFlow are affected by a division by 0 vulnerability where an attacker can trigger a denial of service via a crash. The shape inference [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/framework/common_shape_fns.cc#L577) is missing several validations before doing divisions and modulo operations. We have patched the issue in GitHub commit 8a793b5d7f59e37ac7f3cd0954a750a2fe76bad4. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37675",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37676",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.SparseFillEmptyRows`. The shape inference [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/ops/sparse_ops.cc#L608-L634) does not validate that the input arguments are not empty tensors. We have patched the issue in GitHub commit 578e634b4f1c1c684d4b4294f9e5281b2133b3ed. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37676",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37677",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the shape inference code for `tf.raw_ops.Dequantize` has a vulnerability that could trigger a denial of service via a segfault if an attacker provides invalid arguments. The shape inference [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/ops/array_ops.cc#L2999-L3014) uses `axis` to select between two different values for `minmax_rank` which is then used to retrieve tensor dimensions. However, code assumes that `axis` can be either `-1` or a value greater than `-1`, with no validation for the other values. We have patched the issue in GitHub commit da857cfa0fde8f79ad0afdbc94e88b5d4bbec764. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37677",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37678",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions TensorFlow and Keras can be tricked to perform arbitrary code execution when deserializing a Keras model from YAML format. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/python/keras/saving/model_config.py#L66-L104) uses `yaml.unsafe_load` which can perform arbitrary code execution on the input. Given that YAML format support requires a significant amount of work, we have removed it for now. We have patched the issue in GitHub commit 23d6383eb6c14084a8fc3bdf164043b974818012. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37678",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37679",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions it is possible to nest a `tf.map_fn` within another `tf.map_fn` call. However, if the input tensor is a `RaggedTensor` and there is no function signature provided, code assumes the output is a fully specified tensor and fills output buffer with uninitialized contents from the heap. The `t` and `z` outputs should be identical, however this is not the case. The last row of `t` contains data from the heap which can be used to leak other memory information. The bug lies in the conversion from a `Variant` tensor to a `RaggedTensor`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/ragged_tensor_from_variant_op.cc#L177-L190) does not check that all inner shapes match and this results in the additional dimensions. The same implementation can result in data loss, if input tensor is tweaked. We have patched the issue in GitHub commit 4e2565483d0ffcadc719bd44893fb7f609bb5f12. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37679",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37680",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of fully connected layers in TFLite is [vulnerable to a division by zero error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/fully_connected.cc#L226). We have patched the issue in GitHub commit 718721986aa137691ee23f03638867151f74935f. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37680",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37681",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of SVDF in TFLite is [vulnerable to a null pointer error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/svdf.cc#L300-L313). The [`GetVariableInput` function](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/kernel_util.cc#L115-L119) can return a null pointer but `GetTensorData` assumes that the argument is always a valid tensor. Furthermore, because `GetVariableInput` calls [`GetMutableInput`](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/kernel_util.cc#L82-L90) which might return `nullptr`, the `tensor->is_variable` expression can also trigger a null pointer exception. We have patched the issue in GitHub commit 5b048e87e4e55990dae6b547add4dae59f4e1c76. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37681",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37682",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions all TFLite operations that use quantization can be made to use unitialized values. [For example](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/depthwise_conv.cc#L198-L200). The issue stems from the fact that `quantization.params` is only valid if `quantization.type` is different that `kTfLiteNoQuantization`. However, these checks are missing in large parts of the code. We have patched the issue in GitHub commits 537bc7c723439b9194a358f64d871dd326c18887, 4a91f2069f7145aab6ba2d8cfe41be8a110c18a5 and 8933b8a21280696ab119b63263babdb54c298538. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37682",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37683",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of division in TFLite is [vulnerable to a division by 0 error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/div.cc). There is no check that the divisor tensor does not contain zero elements. We have patched the issue in GitHub commit 1e206baedf8bef0334cca3eb92bab134ef525a28. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37683",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37684",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementations of pooling in TFLite are vulnerable to division by 0 errors as there are no checks for divisors not being 0. We have patched the issue in GitHub commit [dfa22b348b70bb89d6d6ec0ff53973bacb4f4695](https://github.com/tensorflow/tensorflow/commit/dfa22b348b70bb89d6d6ec0ff53973bacb4f4695). The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37684",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37685",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions TFLite's [`expand_dims.cc`](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/expand_dims.cc#L36-L50) contains a vulnerability which allows reading one element outside of bounds of heap allocated data. If `axis` is a large negative value (e.g., `-100000`), then after the first `if` it would still be negative. The check following the `if` statement will pass and the `for` loop would read one element before the start of `input_dims.data` (when `i = 0`). We have patched the issue in GitHub commit d94ffe08a65400f898241c0374e9edc6fa8ed257. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37685",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37686",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the strided slice implementation in TFLite has a logic bug which can allow an attacker to trigger an infinite loop. This arises from newly introduced support for [ellipsis in axis definition](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/strided_slice.cc#L103-L122). An attacker can craft a model such that `ellipsis_end_idx` is smaller than `i` (e.g., always negative). In this case, the inner loop does not increase `i` and the `continue` statement causes execution to skip over the preincrement at the end of the outer loop. We have patched the issue in GitHub commit dfa22b348b70bb89d6d6ec0ff53973bacb4f4695. TensorFlow 2.6.0 is the only affected version.",
      "cve": "CVE-2021-37686",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37687",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions TFLite's [`GatherNd` implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/gather_nd.cc#L124) does not support negative indices but there are no checks for this situation. Hence, an attacker can read arbitrary data from the heap by carefully crafting a model with negative values in `indices`. Similar issue exists in [`Gather` implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/gather.cc). We have patched the issue in GitHub commits bb6a0383ed553c286f87ca88c207f6774d5c4a8f and eb921122119a6b6e470ee98b89e65d721663179d. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37687",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37688",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can craft a TFLite model that would trigger a null pointer dereference, which would result in a crash and denial of service. The [implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/internal/optimized/optimized_ops.h#L268-L285) unconditionally dereferences a pointer. We have patched the issue in GitHub commit 15691e456c7dc9bd6be203b09765b063bf4a380c. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37688",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37689",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can craft a TFLite model that would trigger a null pointer dereference, which would result in a crash and denial of service. This is caused by the MLIR optimization of `L2NormalizeReduceAxis` operator. The [implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/compiler/mlir/lite/transforms/optimize.cc#L67-L70) unconditionally dereferences a pointer to an iterator to a vector without checking that the vector has elements. We have patched the issue in GitHub commit d6b57f461b39fd1aa8c1b870f1b974aac3554955. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37689",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37690",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions when running shape functions, some functions (such as `MutableHashTableShape`) produce extra output information in the form of a `ShapeAndType` struct. The shapes embedded in this struct are owned by an inference context that is cleaned up almost immediately; if the upstream code attempts to access this shape information, it can trigger a segfault. `ShapeRefiner` is mitigating this for normal output shapes by cloning them (and thus putting the newly created shape under ownership of an inference context that will not die), but we were not doing the same for shapes and types. This commit fixes that by doing similar logic on output shapes and types. We have patched the issue in GitHub commit ee119d4a498979525046fba1c3dd3f13a039fbb1. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37690",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37691",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can craft a TFLite model that would trigger a division by zero error in LSH [implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/lsh_projection.cc#L118). We have patched the issue in GitHub commit 0575b640091680cfb70f4dd93e70658de43b94f9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick thiscommit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37691",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-37692",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions under certain conditions, Go code can trigger a segfault in string deallocation. For string tensors, `C.TF_TString_Dealloc` is called during garbage collection within a finalizer function. However, tensor structure isn't checked until encoding to avoid a performance penalty. The current method for dealloc assumes that encoding succeeded, but segfaults when a string tensor is garbage collected whose encoding failed (e.g., due to mismatched dimensions). To fix this, the call to set the finalizer function is deferred until `NewTensor` returns and, if encoding failed for a string tensor, deallocs are determined based on bytes written. We have patched the issue in GitHub commit 8721ba96e5760c229217b594f6d2ba332beedf22. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, which is the other affected version.",
      "cve": "CVE-2021-37692",
      "specs": [
        ">=2.5.0,<2.6.0"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41195",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `tf.math.segment_*` operations results in a `CHECK`-fail related abort (and denial of service) if a segment id in `segment_ids` is large. This is similar to CVE-2021-29584 (and similar other reported vulnerabilities in TensorFlow, localized to specific APIs): the implementation (both on CPU and GPU) computes the output shape using `AddDim`. However, if the number of elements in the tensor overflows an `int64_t` value, `AddDim` results in a `CHECK` failure which provokes a `std::abort`. Instead, code should use `AddDimWithStatus`. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41195",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41196",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the Keras pooling layers can trigger a segfault if the size of the pool is 0 or if a dimension is negative. This is due to the TensorFlow's implementation of pooling operations where the values in the sliding window are not checked to be strictly positive. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41196",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41197",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions TensorFlow allows tensor to have a large number of dimensions and each dimension can be as large as desired. However, the total number of elements in a tensor must fit within an `int64_t`. If an overflow occurs, `MultiplyWithoutOverflow` would return a negative result. In the majority of TensorFlow codebase this then results in a `CHECK`-failure. Newer constructs exist which return a `Status` instead of crashing the binary. This is similar to CVE-2021-29584. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41197",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41198",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions if `tf.tile` is called with a large input argument then the TensorFlow process will crash due to a `CHECK`-failure caused by an overflow. The number of elements in the output tensor is too much for the `int64_t` type and the overflow is detected via a `CHECK` statement. This aborts the process. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41198",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41199",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions if `tf.image.resize` is called with a large input argument then the TensorFlow process will crash due to a `CHECK`-failure caused by an overflow. The number of elements in the output tensor is too much for the `int64_t` type and the overflow is detected via a `CHECK` statement. This aborts the process. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41199",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41200",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions if `tf.summary.create_file_writer` is called with non-scalar arguments code crashes due to a `CHECK`-fail. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41200",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41201",
      "advisory": "TensorFlow is an open source platform for machine learning. In affeced versions during execution, `EinsumHelper::ParseEquation()` is supposed to set the flags in `input_has_ellipsis` vector and `*output_has_ellipsis` boolean to indicate whether there is ellipsis in the corresponding inputs and output. However, the code only changes these flags to `true` and never assigns `false`. This results in unitialized variable access if callers assume that `EinsumHelper::ParseEquation()` always sets these flags. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41201",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41202",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions while calculating the size of the output within the `tf.range` kernel, there is a conditional statement of type `int64 = condition ? int64 : double`. Due to C++ implicit conversion rules, both branches of the condition will be cast to `double` and the result would be truncated before the assignment. This result in overflows. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41202",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41203",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions an attacker can trigger undefined behavior, integer overflows, segfaults and `CHECK`-fail crashes if they can change saved checkpoints from outside of TensorFlow. This is because the checkpoints loading infrastructure is missing validation for invalid file formats. The fixes will be included in TensorFlow 2.7.0. We will also cherrypick these commits on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41203",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41204",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions during TensorFlow's Grappler optimizer phase, constant folding might attempt to deep copy a resource tensor. This results in a segfault, as these tensors are supposed to not change. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41204",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41205",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference functions for the `QuantizeAndDequantizeV*` operations can trigger a read outside of bounds of heap allocated array. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41205",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41206",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions several TensorFlow operations are missing validation for the shapes of the tensor arguments involved in the call. Depending on the API, this can result in undefined behavior and segfault or `CHECK`-fail related crashes but in some scenarios writes and reads from heap populated arrays are also possible. We have discovered these issues internally via tooling while working on improving/testing GPU op determinism. As such, we don't have reproducers and there will be multiple fixes for these issues. These fixes will be included in TensorFlow 2.7.0. We will also cherrypick these commits on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41206",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41207",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `ParallelConcat` misses some input validation and can produce a division by 0. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41207",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41208",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the code for boosted trees in TensorFlow is still missing validation. As a result, attackers can trigger denial of service (via dereferencing `nullptr`s or via `CHECK`-failures) as well as abuse undefined behavior (binding references to `nullptr`s). An attacker can also read and write from heap buffers, depending on the API that gets used and the arguments that are passed to the call. Given that the boosted trees implementation in TensorFlow is unmaintained, it is recommend to no longer use these APIs. We will deprecate TensorFlow's boosted trees APIs in subsequent releases. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41208",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41209",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementations for convolution operators trigger a division by 0 if passed empty filter tensor arguments. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41209",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41210",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference functions for `SparseCountSparseOutput` can trigger a read outside of bounds of heap allocated array. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41210",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41211",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `QuantizeV2` can trigger a read outside of bounds of heap allocated array. This occurs whenever `axis` is a negative value less than `-1`. In this case, we are accessing data before the start of a heap buffer. The code allows `axis` to be an optional argument (`s` would contain an `error::NOT_FOUND` error code). Otherwise, it assumes that `axis` is a valid index into the dimensions of the `input` tensor. If `axis` is less than `-1` then this results in a heap OOB read. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, as this version is the only one that is also affected.",
      "cve": "CVE-2021-41211",
      "specs": [
        "==2.6.0"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41212",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `tf.ragged.cross` can trigger a read outside of bounds of heap allocated array. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41212",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41213",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the code behind `tf.function` API can be made to deadlock when two `tf.function` decorated Python functions are mutually recursive. This occurs due to using a non-reentrant `Lock` Python object. Loading any model which contains mutually recursive functions is vulnerable. An attacker can cause denial of service by causing users to load such models and calling a recursive `tf.function`, although this is not a frequent scenario. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41213",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41214",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `tf.ragged.cross` has an undefined behavior due to binding a reference to `nullptr`. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41214",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41215",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `DeserializeSparse` can trigger a null pointer dereference. This is because the shape inference function assumes that the `serialize_sparse` tensor is a tensor with positive rank (and having `3` as the last dimension). The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41215",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41216",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference function for `Transpose` is vulnerable to a heap buffer overflow. This occurs whenever `perm` contains negative elements. The shape inference function does not validate that the indices in `perm` are all valid. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41216",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41217",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the process of building the control flow graph for a TensorFlow model is vulnerable to a null pointer exception when nodes that should be paired are not. This occurs because the code assumes that the first node in the pairing (e.g., an `Enter` node) always exists when encountering the second node (e.g., an `Exit` node). When this is not the case, `parent` is `nullptr` so dereferencing it causes a crash. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41217",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41218",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `AllToAll` can be made to execute a division by 0. This occurs whenever the `split_count` argument is 0. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41218",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41219",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the code for sparse matrix multiplication is vulnerable to undefined behavior via binding a reference to `nullptr`. This occurs whenever the dimensions of `a` or `b` are 0 or less. In the case on one of these is 0, an empty output tensor should be allocated (to conserve the invariant that output tensors are always allocated when the operation is successful) but nothing should be written to it (that is, we should return early from the kernel implementation). Otherwise, attempts to write to this empty tensor would result in heap OOB access. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41219",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41220",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the async implementation of `CollectiveReduceV2` suffers from a memory leak and a use after free. This occurs due to the asynchronous computation and the fact that objects that have been `std::move()`d from are still accessed. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, as this version is the only one that is also affected.",
      "cve": "CVE-2021-41220",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41221",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for the `Cudnn*` operations in TensorFlow can be tricked into accessing invalid memory, via a heap buffer overflow. This occurs because the ranks of the `input`, `input_h` and `input_c` parameters are not validated, but code assumes they have certain values. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41221",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41222",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `SplitV` can trigger a segfault is an attacker supplies negative arguments. This occurs whenever `size_splits` contains more than one value and at least one value is negative. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41222",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41223",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `FusedBatchNorm` kernels is vulnerable to a heap OOB access. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41223",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41224",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `SparseFillEmptyRows` can be made to trigger a heap OOB access. This occurs whenever the size of `indices` does not match the size of `values`. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41224",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41225",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions TensorFlow's Grappler optimizer has a use of unitialized variable. If the `train_nodes` vector (obtained from the saved model that gets optimized) does not contain a `Dequeue` node, then `dequeue_node` is left unitialized. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41225",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41226",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `SparseBinCount` is vulnerable to a heap OOB access. This is because of missing validation between the elements of the `values` argument and the shape of the sparse output. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41226",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41227",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the `ImmutableConst` operation in TensorFlow can be tricked into reading arbitrary memory contents. This is because the `tstring` TensorFlow string class has a special case for memory mapped strings but the operation itself does not offer any support for this datatype. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41227",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-nvidia-tensorflow:CVE-2021-41228",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions TensorFlow's `saved_model_cli` tool is vulnerable to a code injection as it calls `eval` on user supplied strings. This can be used by attackers to run arbitrary code on the plaform where the CLI tool runs. However, given that the tool is always run manually, the impact of this is not severe. We have patched this by adding a `safe` flag which defaults to `True` and an explicit warning for users. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41228",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    }
  ],
  "oauthenticator": [
    {
      "id": "pyup.io-oauthenticator:CVE-2018-7206",
      "advisory": "An issue was discovered in Project Jupyter JupyterHub OAuthenticator 0.6.x before 0.6.2 and 0.7.x before 0.7.3. When using JupyterHub with GitLab group whitelisting for access control, group membership was not checked correctly, allowing members not in the whitelisted groups to create accounts on the Hub. (Users were not allowed to access other users' accounts, but could create their own accounts on the Hub linked to their GitLab account. GitLab authentication not using gitlab_group_whitelist is unaffected. No other Authenticators are affected.)",
      "cve": "CVE-2018-7206",
      "specs": [
        "==0.6.0",
        "==0.6.1",
        "==0.7.0",
        "==0.7.1",
        "==0.7.2"
      ]
    },
    {
      "id": "pyup.io-oauthenticator:CVE-2020-26250",
      "advisory": "OAuthenticator is an OAuth login mechanism for JupyterHub. In oauthenticator from version 0.12.0 and before 0.12.2, the deprecated (in jupyterhub 1.2) configuration `Authenticator.whitelist`, which should be transparently mapped to `Authenticator.allowed_users` with a warning, is instead ignored by OAuthenticator classes, resulting in the same behavior as if this configuration has not been set. If this is the only mechanism of authorization restriction (i.e. no group or team restrictions in configuration) then all authenticated users will be allowed. Provider-based restrictions, including deprecated values such as `GitHubOAuthenticator.org_whitelist` are **not** affected. All users of OAuthenticator 0.12.0 and 0.12.1 with JupyterHub 1.2 (JupyterHub Helm chart 0.10.0-0.10.5) who use the `admin.whitelist.users` configuration in the jupyterhub helm chart or the `c.Authenticator.whitelist` configuration directly. Users of other deprecated configuration, e.g. `c.GitHubOAuthenticator.team_whitelist` are **not** affected. If you see a log line like this and expect a specific list of allowed usernames: \"[I 2020-11-27 16:51:54.528 JupyterHub app:1717] Not using allowed_users. Any authenticated user will be allowed.\" you are likely affected. Updating oauthenticator to 0.12.2 is recommended. A workaround is to replace the deprecated `c.Authenticator.whitelist = ...` with `c.Authenticator.allowed_users = ...`. If any users have been authorized during this time who should not have been, they must be deleted via the API or admin interface, per the referenced documentation.",
      "cve": "CVE-2020-26250",
      "specs": [
        ">=0.12.0,<0.12.2"
      ]
    }
  ],
  "octavia": [
    {
      "id": "pyup.io-octavia:CVE-2018-16856",
      "advisory": "In a default Red Hat Openstack Platform Director installation, openstack-octavia before versions openstack-octavia 2.0.2-5 and openstack-octavia-3.0.1-0.20181009115732 creates log files that are readable by all users. Sensitive information such as private keys can appear in these log files allowing for information exposure.",
      "cve": "CVE-2018-16856",
      "specs": [
        ">=2.0.0,<2.0.2-5",
        ">=3.0.0,<3.0.1-0.20181009115732"
      ]
    },
    {
      "id": "pyup.io-octavia:CVE-2019-17134",
      "advisory": "Amphora Images in OpenStack Octavia >=0.10.0 <2.1.2, >=3.0.0 <3.2.0, >=4.0.0 <4.1.0 allows anyone with access to the management network to bypass client-certificate based authentication and retrieve information or issue configuration commands via simple HTTP requests to the Agent on port https/9443, because the cmd/agent.py gunicorn cert_reqs option is True but is supposed to be ssl.CERT_REQUIRED.",
      "cve": "CVE-2019-17134",
      "specs": [
        ">=0.10.0,<2.1.2",
        ">=3.0.0,<3.2.0",
        ">=4.0.0,<4.1.0"
      ]
    },
    {
      "id": "pyup.io-octavia:CVE-2019-3895",
      "advisory": "An access-control flaw was found in the Octavia service when the cloud platform was deployed using Red Hat OpenStack Platform Director. An attacker could cause new amphorae to run based on any arbitrary image. This meant that a remote attacker could upload a new amphorae image and, if requested to spawn new amphorae, Octavia would then pick up the compromised image.",
      "cve": "CVE-2019-3895",
      "specs": [
        "<0.9.0"
      ]
    }
  ],
  "oic": [
    {
      "id": "pyup.io-oic:CVE-2020-26244",
      "advisory": "Python oic is a Python OpenID Connect implementation. In Python oic before version 1.2.1, there are several related cryptographic issues affecting client implementations that use the library. The issues are: 1) The IdToken signature algorithm was not checked automatically, but only if the expected algorithm was passed in as a kwarg. 2) JWA `none` algorithm was allowed in all flows. 3) oic.consumer.Consumer.parse_authz returns an unverified IdToken. The verification of the token was left to the discretion of the implementator. 4) iat claim was not checked for sanity (i.e. it could be in the future). These issues are patched in version 1.2.1.",
      "cve": "CVE-2020-26244",
      "specs": [
        "<1.2.1"
      ]
    }
  ],
  "omero-figure": [
    {
      "id": "pyup.io-omero-figure:CVE-2021-41132",
      "advisory": "OMERO.web provides a web based client and plugin infrastructure. In versions prior to 5.11.0, a variety of templates do not perform proper sanitization through HTML escaping. Due to the lack of sanitization and use of ``jQuery.html()``, there are a whole host of cross-site scripting possibilities with specially crafted input to a variety of fields. This issue is patched in version 5.11.0. There are no known workarounds aside from upgrading.",
      "cve": "CVE-2021-41132",
      "specs": [
        "<4.4.1"
      ]
    }
  ],
  "omero-py": [
    {
      "id": "pyup.io-omero-py:CVE-2014-7198",
      "advisory": "OMERO before 5.0.6 has multiple CSRF vulnerabilities because the framework for OMERO's web interface lacks CSRF protection.",
      "cve": "CVE-2014-7198",
      "specs": [
        "<5.0.6"
      ]
    },
    {
      "id": "pyup.io-omero-py:CVE-2017-1000438",
      "advisory": "In OMERO 5.3.3 or earlier a user could create an OriginalFile and adjust its path such that it now points to another user's file on the underlying filesystem, then manipulate the user's data.",
      "cve": "CVE-2017-1000438",
      "specs": [
        "<=5.3.3"
      ]
    },
    {
      "id": "pyup.io-omero-py:CVE-2018-1000633",
      "advisory": "The Open Microscopy Environment OMERO.web version prior to 5.4.7 contains an Information Exposure Through Log Files vulnerability in the login form and change password form that can result in User's password being revealed. Attacker can log in as that user. This attack appear to be exploitable via an attacker reading the web server log. This vulnerability appears to have been fixed in 5.4.7.",
      "cve": "CVE-2018-1000633",
      "specs": [
        "<5.4.7"
      ]
    },
    {
      "id": "pyup.io-omero-py:CVE-2018-1000634",
      "advisory": "The Open Microscopy Environment OMERO.server version 5.4.0 to 5.4.6 contains an Improper Access Control vulnerability in User management that can result in administrative user with privilege restrictions logging in as a more powerful administrator. This attack appear to be exploitable via Use user administration privilege to set the password of a more powerful administrator. This vulnerability appears to have been fixed in 5.4.7.",
      "cve": "CVE-2018-1000634",
      "specs": [
        ">=5.4.0,<=5.4.6"
      ]
    },
    {
      "id": "pyup.io-omero-py:CVE-2018-1000635",
      "advisory": "The Open Microscopy Environment OMERO.server version 5.4.0 to 5.4.6 contains a Information Exposure Through Sent Data vulnerability in OMERO.server that can result in an Attacker gaining full administrative access to server and may be able to disable it. This vulnerability appears to have been fixed in 5.4.7.",
      "cve": "CVE-2018-1000635",
      "specs": [
        ">=5.4.0,<=5.4.6"
      ]
    },
    {
      "id": "pyup.io-omero-py:CVE-2019-16245",
      "advisory": "OMERO before 5.6.1 makes the details of each user available to all users.",
      "cve": "CVE-2019-16245",
      "specs": [
        "<5.6.1"
      ]
    },
    {
      "id": "pyup.io-omero-py:CVE-2020-6752",
      "advisory": "In OMERO before 5.6.1, group owners can access members' data in other groups.",
      "cve": "CVE-2020-6752",
      "specs": [
        "<5.6.1"
      ]
    }
  ],
  "omero-server": [
    {
      "id": "pyup.io-omero-server:CVE-2019-16244",
      "advisory": "OMERO.server before 5.6.1 allows attackers to bypass the security filters and access hidden objects via a crafted query.",
      "cve": "CVE-2019-16244",
      "specs": [
        "<5.6.1"
      ]
    },
    {
      "id": "pyup.io-omero-server:CVE-2019-9943",
      "advisory": "In ome.services.graphs.GraphTraversal.findObjectDetails in Open Microscopy Environment OMERO.server 5.1.0 through 5.6.0, permissions on OMERO model objects may be circumvented during certain operations such as move and delete, because group permissions are mishandled.",
      "cve": "CVE-2019-9943",
      "specs": [
        ">=5.1.0,<=5.6.0"
      ]
    },
    {
      "id": "pyup.io-omero-server:CVE-2019-9944",
      "advisory": "In Open Microscopy Environment OMERO.server 5.0.0 through 5.6.0, the reading of files from imported image filesets may circumvent OMERO permissions restrictions. This occurs because the Bio-Formats feature allows an image file to have embedded pathnames.",
      "cve": "CVE-2019-9944",
      "specs": [
        ">=5.0.0,<=5.6.0"
      ]
    }
  ],
  "omero-web": [
    {
      "id": "pyup.io-omero-web:CVE-2020-7932",
      "advisory": "OMERO.web before 5.6.3 optionally allows sensitive data elements (e.g., a session key) to be passed as URL query parameters. If an attacker tricks a user into clicking a malicious link in OMERO.web, the information in the query parameters may be exposed in the Referer header seen by the target. Information in the URL path such as object IDs may also be exposed.",
      "cve": "CVE-2020-7932",
      "specs": [
        "<5.6.3"
      ]
    },
    {
      "id": "pyup.io-omero-web:CVE-2021-21376",
      "advisory": "OMERO.web is open source Django-based software for managing microscopy imaging. OMERO.web before version 5.9.0 loads various information about the current user such as their id, name and the groups they are in, and these are available on the main webclient pages. This represents an information exposure vulnerability. Some additional information being loaded is not used by the webclient and is being removed in this release. This is fixed in version 5.9.0.",
      "cve": "CVE-2021-21376",
      "specs": [
        "<5.9.0"
      ]
    },
    {
      "id": "pyup.io-omero-web:CVE-2021-21377",
      "advisory": "OMERO.web is open source Django-based software for managing microscopy imaging. OMERO.web before version 5.9.0 supports redirection to a given URL after performing login or switching the group context. These URLs are not validated, allowing redirection to untrusted sites. OMERO.web 5.9.0 adds URL validation before redirecting. External URLs are not considered valid, unless specified in the omero.web.redirect_allowed_hosts setting.",
      "cve": "CVE-2021-21377",
      "specs": [
        "<5.9.0"
      ]
    },
    {
      "id": "pyup.io-omero-web:CVE-2021-41132",
      "advisory": "OMERO.web provides a web based client and plugin infrastructure. In versions prior to 5.11.0, a variety of templates do not perform proper sanitization through HTML escaping. Due to the lack of sanitization and use of ``jQuery.html()``, there are a whole host of cross-site scripting possibilities with specially crafted input to a variety of fields. This issue is patched in version 5.11.0. There are no known workarounds aside from upgrading.",
      "cve": "CVE-2021-41132",
      "specs": [
        "<5.11.0"
      ]
    }
  ],
  "oncall": [
    {
      "id": "pyup.io-oncall:CVE-2021-26722",
      "advisory": "LinkedIn Oncall through 1.4.0 allows reflected XSS via /query because of mishandling of the \"No results found for\" message in the search bar.",
      "cve": "CVE-2021-26722",
      "specs": [
        "<=1.4.0"
      ]
    }
  ],
  "onefuzz": [
    {
      "id": "pyup.io-onefuzz:CVE-2021-37705",
      "advisory": "OneFuzz is an open source self-hosted Fuzzing-As-A-Service platform. Starting with OneFuzz 2.12.0 or greater, an incomplete authorization check allows an authenticated user from any Azure Active Directory tenant to make authorized API calls to a vulnerable OneFuzz instance. To be vulnerable, a OneFuzz deployment must be both version 2.12.0 or greater and deployed with the non-default --multi_tenant_domain option. This can result in read/write access to private data such as software vulnerability and crash information, security testing tools and proprietary code and symbols. Via authorized API calls, this also enables tampering with existing data and unauthorized code execution on Azure compute resources. This issue is resolved starting in release 2.31.0, via the addition of application-level check of the bearer token's `issuer` against an administrator-configured allowlist. As a workaround users can restrict access to the tenant of a deployed OneFuzz instance < 2.31.0 by redeploying in the default configuration, which omits the `--multi_tenant_domain` option.",
      "cve": "CVE-2021-37705",
      "specs": [
        ">=2.12.0,<2.31.0"
      ]
    }
  ],
  "openapi-python-client": [
    {
      "id": "pyup.io-openapi-python-client:CVE-2020-15141",
      "advisory": "In openapi-python-client before version 0.5.3, there is a path traversal vulnerability. If a user generated a client using a maliciously crafted OpenAPI document, it is possible for generated files to be placed in arbitrary locations on disk.",
      "cve": "CVE-2020-15141",
      "specs": [
        "<0.5.3"
      ]
    },
    {
      "id": "pyup.io-openapi-python-client:CVE-2020-15142",
      "advisory": "In openapi-python-client before version 0.5.3, clients generated with a maliciously crafted OpenAPI Document can generate arbitrary Python code. Subsequent execution of this malicious client is arbitrary code execution.",
      "cve": "CVE-2020-15142",
      "specs": [
        "<0.5.3"
      ]
    }
  ],
  "opencv-contrib-python": [
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2016-1516",
      "advisory": "OpenCV 3.0.0 has a double free issue that allows attackers to execute arbitrary code.",
      "cve": "CVE-2016-1516",
      "specs": [
        "==3.0.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2016-1517",
      "advisory": "OpenCV 3.0.0 allows remote attackers to cause a denial of service (segfault) via vectors involving corrupt chunks.",
      "cve": "CVE-2016-1517",
      "specs": [
        "==3.0.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2017-1000450",
      "advisory": "In opencv/modules/imgcodecs/src/utils.cpp, functions FillUniColor and FillUniGray do not check the input length, which can lead to integer overflow. If the image is from remote, may lead to remote code execution or denial of service. This affects Opencv 3.3 and earlier.",
      "cve": "CVE-2017-1000450",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2017-12597",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds write error in the function FillColorRow1 in utils.cpp when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12597",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2017-12598",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds read error in the cv::RBaseStream::readBlock function in modules/imgcodecs/src/bitstrm.cpp when reading an image file by using cv::imread, as demonstrated by the 8-opencv-invalid-read-fread test case.",
      "cve": "CVE-2017-12598",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2017-12599",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds read error in the function icvCvt_BGRA2BGR_8u_C4C3R when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12599",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2017-12600",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has a denial of service (CPU consumption) issue, as demonstrated by the 11-opencv-dos-cpu-exhaust test case.",
      "cve": "CVE-2017-12600",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2017-12601",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has a buffer overflow in the cv::BmpDecoder::readData function in modules/imgcodecs/src/grfmt_bmp.cpp when reading an image file by using cv::imread, as demonstrated by the 4-buf-overflow-readData-memcpy test case.",
      "cve": "CVE-2017-12601",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2017-12602",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has a denial of service (memory consumption) issue, as demonstrated by the 10-opencv-dos-memory-exhaust test case.",
      "cve": "CVE-2017-12602",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2017-12603",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an invalid write in the cv::RLByteStream::getBytes function in modules/imgcodecs/src/bitstrm.cpp when reading an image file by using cv::imread, as demonstrated by the 2-opencv-heapoverflow-fseek test case.",
      "cve": "CVE-2017-12603",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2017-12604",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds write error in the FillUniColor function in utils.cpp when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12604",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2017-12605",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds write error in the FillColorRow8 function in utils.cpp when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12605",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2017-12606",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds write error in the function FillColorRow4 in utils.cpp when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12606",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2017-12862",
      "advisory": "In modules/imgcodecs/src/grfmt_pxm.cpp, the length of buffer AutoBuffer _src is small than expected, which will cause copy buffer overflow later. If the image is from remote, may lead to remote code execution or denial of service. This affects Opencv 3.3 and earlier.",
      "cve": "CVE-2017-12862",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2017-12863",
      "advisory": "In opencv/modules/imgcodecs/src/grfmt_pxm.cpp, function PxMDecoder::readData has an integer overflow when calculate src_pitch. If the image is from remote, may lead to remote code execution or denial of service. This affects Opencv 3.3 and earlier.",
      "cve": "CVE-2017-12863",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2017-12864",
      "advisory": "In opencv/modules/imgcodecs/src/grfmt_pxm.cpp, function ReadNumber did not checkout the input length, which lead to integer overflow. If the image is from remote, may lead to remote code execution or denial of service. This affects Opencv 3.3 and earlier.",
      "cve": "CVE-2017-12864",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2017-14136",
      "advisory": "OpenCV (Open Source Computer Vision Library) 3.3 has an out-of-bounds write error in the function FillColorRow1 in utils.cpp when reading an image file by using cv::imread. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-12597.",
      "cve": "CVE-2017-14136",
      "specs": [
        "==3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2017-17760",
      "advisory": "OpenCV 3.3.1 has a Buffer Overflow in the cv::PxMDecoder::readData function in grfmt_pxm.cpp, because an incorrect size value is used.",
      "cve": "CVE-2017-17760",
      "specs": [
        "==3.3.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2017-18009",
      "advisory": "In OpenCV 3.3.1, a heap-based buffer over-read exists in the function cv::HdrDecoder::checkSignature in modules/imgcodecs/src/grfmt_hdr.cpp.",
      "cve": "CVE-2017-18009",
      "specs": [
        "==3.3.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2018-5268",
      "advisory": "In OpenCV 3.3.1, a heap-based buffer overflow happens in cv::Jpeg2KDecoder::readComponent8u in modules/imgcodecs/src/grfmt_jpeg2000.cpp when parsing a crafted image file.",
      "cve": "CVE-2018-5268",
      "specs": [
        "==3.3.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2018-5269",
      "advisory": "In OpenCV 3.3.1, an assertion failure happens in cv::RBaseStream::setPos in modules/imgcodecs/src/bitstrm.cpp because of an incorrect integer cast.",
      "cve": "CVE-2018-5269",
      "specs": [
        "==3.3.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2018-7712",
      "advisory": "** DISPUTED ** The validateInputImageSize function in modules/imgcodecs/src/loadsave.cpp in OpenCV 3.4.1 allows remote attackers to cause a denial of service (assertion failure) because (size.height <= (1<<20)) may be false. Note: \u201cOpenCV CV_Assert is not an assertion (C-like assert()), it is regular C++ exception which can raised in case of invalid or non-supported parameters.\u201d",
      "cve": "CVE-2018-7712",
      "specs": [
        "==3.4.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2018-7713",
      "advisory": "** DISPUTED ** The validateInputImageSize function in modules/imgcodecs/src/loadsave.cpp in OpenCV 3.4.1 allows remote attackers to cause a denial of service (assertion failure) because (size.width <= (1<<20)) may be false. Note: \u201cOpenCV CV_Assert is not an assertion (C-like assert()), it is regular C++ exception which can raised in case of invalid or non-supported parameters.\u201d",
      "cve": "CVE-2018-7713",
      "specs": [
        "==3.4.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2018-7714",
      "advisory": "** DISPUTED ** The validateInputImageSize function in modules/imgcodecs/src/loadsave.cpp in OpenCV 3.4.1 allows remote attackers to cause a denial of service (assertion failure) because (pixels <= (1<<30)) may be false. Note: \u201cOpenCV CV_Assert is not an assertion (C-like assert()), it is regular C++ exception which can raised in case of invalid or non-supported parameters.\u201d",
      "cve": "CVE-2018-7714",
      "specs": [
        "==3.4.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2019-14491",
      "advisory": "An issue was discovered in OpenCV before 3.4.7 and 4.x before 4.1.1. There is an out of bounds read in the function cv::predictOrdered<cv::HaarEvaluator> in modules/objdetect/src/cascadedetect.hpp, which leads to denial of service.",
      "cve": "CVE-2019-14491",
      "specs": [
        "<3.4.7",
        ">=4.0.0,<4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2019-14492",
      "advisory": "An issue was discovered in OpenCV before 3.4.7 and 4.x before 4.1.1. There is an out of bounds read/write in the function HaarEvaluator::OptFeature::calc in modules/objdetect/src/cascadedetect.hpp, which leads to denial of service.",
      "cve": "CVE-2019-14492",
      "specs": [
        "<3.4.7",
        ">=4.0.0,<4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2019-14493",
      "advisory": "An issue was discovered in OpenCV before 4.1.1. There is a NULL pointer dereference in the function cv::XMLParser::parse at modules/core/src/persistence.cpp.",
      "cve": "CVE-2019-14493",
      "specs": [
        "<4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2019-15939",
      "advisory": "An issue was discovered in OpenCV 4.1.0. There is a divide-by-zero error in cv::HOGDescriptor::getDescriptorSize in modules/objdetect/src/hog.cpp.",
      "cve": "CVE-2019-15939",
      "specs": [
        "<=4.1.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2019-16249",
      "advisory": "OpenCV 4.1.1 has an out-of-bounds read in hal_baseline::v_load in core/hal/intrin_sse.hpp when called from computeSSDMeanNorm in modules/video/src/dis_flow.cpp.",
      "cve": "CVE-2019-16249",
      "specs": [
        "==4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2019-19624",
      "advisory": "An out-of-bounds read was discovered in OpenCV before 4.1.1. Specifically, variable coarsest_scale is assumed to be greater than or equal to finest_scale within the calc()/ocl_calc() functions in dis_flow.cpp. However, this is not true when dealing with small images, leading to an out-of-bounds read of the heap-allocated arrays Ux and Uy.",
      "cve": "CVE-2019-19624",
      "specs": [
        "<4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2019-5063",
      "advisory": "An exploitable heap buffer overflow vulnerability exists in the data structure persistence functionality of OpenCV 4.1.0. A specially crafted XML file can cause a buffer overflow, resulting in multiple heap corruptions and potential code execution. An attacker can provide a specially crafted file to trigger this vulnerability.",
      "cve": "CVE-2019-5063",
      "specs": [
        "==4.1.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python:CVE-2019-5064",
      "advisory": "An exploitable heap buffer overflow vulnerability exists in the data structure persistence functionality of OpenCV, before version 4.2.0. A specially crafted JSON file can cause a buffer overflow, resulting in multiple heap corruptions and potentially code execution. An attacker can provide a specially crafted file to trigger this vulnerability.",
      "cve": "CVE-2019-5064",
      "specs": [
        ">=4.0.0,<4.2.0"
      ]
    }
  ],
  "opencv-contrib-python-headless": [
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2016-1516",
      "advisory": "OpenCV 3.0.0 has a double free issue that allows attackers to execute arbitrary code.",
      "cve": "CVE-2016-1516",
      "specs": [
        "==3.0.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2016-1517",
      "advisory": "OpenCV 3.0.0 allows remote attackers to cause a denial of service (segfault) via vectors involving corrupt chunks.",
      "cve": "CVE-2016-1517",
      "specs": [
        "==3.0.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2017-1000450",
      "advisory": "In opencv/modules/imgcodecs/src/utils.cpp, functions FillUniColor and FillUniGray do not check the input length, which can lead to integer overflow. If the image is from remote, may lead to remote code execution or denial of service. This affects Opencv 3.3 and earlier.",
      "cve": "CVE-2017-1000450",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2017-12597",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds write error in the function FillColorRow1 in utils.cpp when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12597",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2017-12598",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds read error in the cv::RBaseStream::readBlock function in modules/imgcodecs/src/bitstrm.cpp when reading an image file by using cv::imread, as demonstrated by the 8-opencv-invalid-read-fread test case.",
      "cve": "CVE-2017-12598",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2017-12599",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds read error in the function icvCvt_BGRA2BGR_8u_C4C3R when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12599",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2017-12600",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has a denial of service (CPU consumption) issue, as demonstrated by the 11-opencv-dos-cpu-exhaust test case.",
      "cve": "CVE-2017-12600",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2017-12601",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has a buffer overflow in the cv::BmpDecoder::readData function in modules/imgcodecs/src/grfmt_bmp.cpp when reading an image file by using cv::imread, as demonstrated by the 4-buf-overflow-readData-memcpy test case.",
      "cve": "CVE-2017-12601",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2017-12602",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has a denial of service (memory consumption) issue, as demonstrated by the 10-opencv-dos-memory-exhaust test case.",
      "cve": "CVE-2017-12602",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2017-12603",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an invalid write in the cv::RLByteStream::getBytes function in modules/imgcodecs/src/bitstrm.cpp when reading an image file by using cv::imread, as demonstrated by the 2-opencv-heapoverflow-fseek test case.",
      "cve": "CVE-2017-12603",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2017-12604",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds write error in the FillUniColor function in utils.cpp when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12604",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2017-12605",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds write error in the FillColorRow8 function in utils.cpp when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12605",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2017-12606",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds write error in the function FillColorRow4 in utils.cpp when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12606",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2017-12862",
      "advisory": "In modules/imgcodecs/src/grfmt_pxm.cpp, the length of buffer AutoBuffer _src is small than expected, which will cause copy buffer overflow later. If the image is from remote, may lead to remote code execution or denial of service. This affects Opencv 3.3 and earlier.",
      "cve": "CVE-2017-12862",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2017-12863",
      "advisory": "In opencv/modules/imgcodecs/src/grfmt_pxm.cpp, function PxMDecoder::readData has an integer overflow when calculate src_pitch. If the image is from remote, may lead to remote code execution or denial of service. This affects Opencv 3.3 and earlier.",
      "cve": "CVE-2017-12863",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2017-12864",
      "advisory": "In opencv/modules/imgcodecs/src/grfmt_pxm.cpp, function ReadNumber did not checkout the input length, which lead to integer overflow. If the image is from remote, may lead to remote code execution or denial of service. This affects Opencv 3.3 and earlier.",
      "cve": "CVE-2017-12864",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2017-14136",
      "advisory": "OpenCV (Open Source Computer Vision Library) 3.3 has an out-of-bounds write error in the function FillColorRow1 in utils.cpp when reading an image file by using cv::imread. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-12597.",
      "cve": "CVE-2017-14136",
      "specs": [
        "==3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2017-17760",
      "advisory": "OpenCV 3.3.1 has a Buffer Overflow in the cv::PxMDecoder::readData function in grfmt_pxm.cpp, because an incorrect size value is used.",
      "cve": "CVE-2017-17760",
      "specs": [
        "==3.3.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2017-18009",
      "advisory": "In OpenCV 3.3.1, a heap-based buffer over-read exists in the function cv::HdrDecoder::checkSignature in modules/imgcodecs/src/grfmt_hdr.cpp.",
      "cve": "CVE-2017-18009",
      "specs": [
        "==3.3.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2018-5268",
      "advisory": "In OpenCV 3.3.1, a heap-based buffer overflow happens in cv::Jpeg2KDecoder::readComponent8u in modules/imgcodecs/src/grfmt_jpeg2000.cpp when parsing a crafted image file.",
      "cve": "CVE-2018-5268",
      "specs": [
        "==3.3.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2018-5269",
      "advisory": "In OpenCV 3.3.1, an assertion failure happens in cv::RBaseStream::setPos in modules/imgcodecs/src/bitstrm.cpp because of an incorrect integer cast.",
      "cve": "CVE-2018-5269",
      "specs": [
        "==3.3.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2018-7712",
      "advisory": "** DISPUTED ** The validateInputImageSize function in modules/imgcodecs/src/loadsave.cpp in OpenCV 3.4.1 allows remote attackers to cause a denial of service (assertion failure) because (size.height <= (1<<20)) may be false. Note: \u201cOpenCV CV_Assert is not an assertion (C-like assert()), it is regular C++ exception which can raised in case of invalid or non-supported parameters.\u201d",
      "cve": "CVE-2018-7712",
      "specs": [
        "==3.4.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2018-7713",
      "advisory": "** DISPUTED ** The validateInputImageSize function in modules/imgcodecs/src/loadsave.cpp in OpenCV 3.4.1 allows remote attackers to cause a denial of service (assertion failure) because (size.width <= (1<<20)) may be false. Note: \u201cOpenCV CV_Assert is not an assertion (C-like assert()), it is regular C++ exception which can raised in case of invalid or non-supported parameters.\u201d",
      "cve": "CVE-2018-7713",
      "specs": [
        "==3.4.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2018-7714",
      "advisory": "** DISPUTED ** The validateInputImageSize function in modules/imgcodecs/src/loadsave.cpp in OpenCV 3.4.1 allows remote attackers to cause a denial of service (assertion failure) because (pixels <= (1<<30)) may be false. Note: \u201cOpenCV CV_Assert is not an assertion (C-like assert()), it is regular C++ exception which can raised in case of invalid or non-supported parameters.\u201d",
      "cve": "CVE-2018-7714",
      "specs": [
        "==3.4.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2019-14491",
      "advisory": "An issue was discovered in OpenCV before 3.4.7 and 4.x before 4.1.1. There is an out of bounds read in the function cv::predictOrdered<cv::HaarEvaluator> in modules/objdetect/src/cascadedetect.hpp, which leads to denial of service.",
      "cve": "CVE-2019-14491",
      "specs": [
        "<3.4.7",
        ">=4.0.0,<4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2019-14492",
      "advisory": "An issue was discovered in OpenCV before 3.4.7 and 4.x before 4.1.1. There is an out of bounds read/write in the function HaarEvaluator::OptFeature::calc in modules/objdetect/src/cascadedetect.hpp, which leads to denial of service.",
      "cve": "CVE-2019-14492",
      "specs": [
        "<3.4.7",
        ">=4.0.0,<4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2019-14493",
      "advisory": "An issue was discovered in OpenCV before 4.1.1. There is a NULL pointer dereference in the function cv::XMLParser::parse at modules/core/src/persistence.cpp.",
      "cve": "CVE-2019-14493",
      "specs": [
        "<4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2019-15939",
      "advisory": "An issue was discovered in OpenCV 4.1.0. There is a divide-by-zero error in cv::HOGDescriptor::getDescriptorSize in modules/objdetect/src/hog.cpp.",
      "cve": "CVE-2019-15939",
      "specs": [
        "<=4.1.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2019-16249",
      "advisory": "OpenCV 4.1.1 has an out-of-bounds read in hal_baseline::v_load in core/hal/intrin_sse.hpp when called from computeSSDMeanNorm in modules/video/src/dis_flow.cpp.",
      "cve": "CVE-2019-16249",
      "specs": [
        "==4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2019-19624",
      "advisory": "An out-of-bounds read was discovered in OpenCV before 4.1.1. Specifically, variable coarsest_scale is assumed to be greater than or equal to finest_scale within the calc()/ocl_calc() functions in dis_flow.cpp. However, this is not true when dealing with small images, leading to an out-of-bounds read of the heap-allocated arrays Ux and Uy.",
      "cve": "CVE-2019-19624",
      "specs": [
        "<4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2019-5063",
      "advisory": "An exploitable heap buffer overflow vulnerability exists in the data structure persistence functionality of OpenCV 4.1.0. A specially crafted XML file can cause a buffer overflow, resulting in multiple heap corruptions and potential code execution. An attacker can provide a specially crafted file to trigger this vulnerability.",
      "cve": "CVE-2019-5063",
      "specs": [
        "==4.1.0"
      ]
    },
    {
      "id": "pyup.io-opencv-contrib-python-headless:CVE-2019-5064",
      "advisory": "An exploitable heap buffer overflow vulnerability exists in the data structure persistence functionality of OpenCV, before version 4.2.0. A specially crafted JSON file can cause a buffer overflow, resulting in multiple heap corruptions and potentially code execution. An attacker can provide a specially crafted file to trigger this vulnerability.",
      "cve": "CVE-2019-5064",
      "specs": [
        ">=4.0.0,<4.2.0"
      ]
    }
  ],
  "opencv-opencv-contrib-python-headless": [
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2016-1516",
      "advisory": "OpenCV 3.0.0 has a double free issue that allows attackers to execute arbitrary code.",
      "cve": "CVE-2016-1516",
      "specs": [
        "==3.0.0"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2016-1517",
      "advisory": "OpenCV 3.0.0 allows remote attackers to cause a denial of service (segfault) via vectors involving corrupt chunks.",
      "cve": "CVE-2016-1517",
      "specs": [
        "==3.0.0"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2017-1000450",
      "advisory": "In opencv/modules/imgcodecs/src/utils.cpp, functions FillUniColor and FillUniGray do not check the input length, which can lead to integer overflow. If the image is from remote, may lead to remote code execution or denial of service. This affects Opencv 3.3 and earlier.",
      "cve": "CVE-2017-1000450",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2017-12597",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds write error in the function FillColorRow1 in utils.cpp when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12597",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2017-12598",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds read error in the cv::RBaseStream::readBlock function in modules/imgcodecs/src/bitstrm.cpp when reading an image file by using cv::imread, as demonstrated by the 8-opencv-invalid-read-fread test case.",
      "cve": "CVE-2017-12598",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2017-12599",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds read error in the function icvCvt_BGRA2BGR_8u_C4C3R when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12599",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2017-12600",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has a denial of service (CPU consumption) issue, as demonstrated by the 11-opencv-dos-cpu-exhaust test case.",
      "cve": "CVE-2017-12600",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2017-12601",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has a buffer overflow in the cv::BmpDecoder::readData function in modules/imgcodecs/src/grfmt_bmp.cpp when reading an image file by using cv::imread, as demonstrated by the 4-buf-overflow-readData-memcpy test case.",
      "cve": "CVE-2017-12601",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2017-12602",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has a denial of service (memory consumption) issue, as demonstrated by the 10-opencv-dos-memory-exhaust test case.",
      "cve": "CVE-2017-12602",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2017-12603",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an invalid write in the cv::RLByteStream::getBytes function in modules/imgcodecs/src/bitstrm.cpp when reading an image file by using cv::imread, as demonstrated by the 2-opencv-heapoverflow-fseek test case.",
      "cve": "CVE-2017-12603",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2017-12604",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds write error in the FillUniColor function in utils.cpp when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12604",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2017-12605",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds write error in the FillColorRow8 function in utils.cpp when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12605",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2017-12606",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds write error in the function FillColorRow4 in utils.cpp when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12606",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2017-12862",
      "advisory": "In modules/imgcodecs/src/grfmt_pxm.cpp, the length of buffer AutoBuffer _src is small than expected, which will cause copy buffer overflow later. If the image is from remote, may lead to remote code execution or denial of service. This affects Opencv 3.3 and earlier.",
      "cve": "CVE-2017-12862",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2017-12863",
      "advisory": "In opencv/modules/imgcodecs/src/grfmt_pxm.cpp, function PxMDecoder::readData has an integer overflow when calculate src_pitch. If the image is from remote, may lead to remote code execution or denial of service. This affects Opencv 3.3 and earlier.",
      "cve": "CVE-2017-12863",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2017-12864",
      "advisory": "In opencv/modules/imgcodecs/src/grfmt_pxm.cpp, function ReadNumber did not checkout the input length, which lead to integer overflow. If the image is from remote, may lead to remote code execution or denial of service. This affects Opencv 3.3 and earlier.",
      "cve": "CVE-2017-12864",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2017-14136",
      "advisory": "OpenCV (Open Source Computer Vision Library) 3.3 has an out-of-bounds write error in the function FillColorRow1 in utils.cpp when reading an image file by using cv::imread. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-12597.",
      "cve": "CVE-2017-14136",
      "specs": [
        "==3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2017-17760",
      "advisory": "OpenCV 3.3.1 has a Buffer Overflow in the cv::PxMDecoder::readData function in grfmt_pxm.cpp, because an incorrect size value is used.",
      "cve": "CVE-2017-17760",
      "specs": [
        "==3.3.1"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2017-18009",
      "advisory": "In OpenCV 3.3.1, a heap-based buffer over-read exists in the function cv::HdrDecoder::checkSignature in modules/imgcodecs/src/grfmt_hdr.cpp.",
      "cve": "CVE-2017-18009",
      "specs": [
        "==3.3.1"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2018-5268",
      "advisory": "In OpenCV 3.3.1, a heap-based buffer overflow happens in cv::Jpeg2KDecoder::readComponent8u in modules/imgcodecs/src/grfmt_jpeg2000.cpp when parsing a crafted image file.",
      "cve": "CVE-2018-5268",
      "specs": [
        "==3.3.1"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2018-5269",
      "advisory": "In OpenCV 3.3.1, an assertion failure happens in cv::RBaseStream::setPos in modules/imgcodecs/src/bitstrm.cpp because of an incorrect integer cast.",
      "cve": "CVE-2018-5269",
      "specs": [
        "==3.3.1"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2018-7712",
      "advisory": "** DISPUTED ** The validateInputImageSize function in modules/imgcodecs/src/loadsave.cpp in OpenCV 3.4.1 allows remote attackers to cause a denial of service (assertion failure) because (size.height <= (1<<20)) may be false. Note: \u201cOpenCV CV_Assert is not an assertion (C-like assert()), it is regular C++ exception which can raised in case of invalid or non-supported parameters.\u201d",
      "cve": "CVE-2018-7712",
      "specs": [
        "==3.4.1"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2018-7713",
      "advisory": "** DISPUTED ** The validateInputImageSize function in modules/imgcodecs/src/loadsave.cpp in OpenCV 3.4.1 allows remote attackers to cause a denial of service (assertion failure) because (size.width <= (1<<20)) may be false. Note: \u201cOpenCV CV_Assert is not an assertion (C-like assert()), it is regular C++ exception which can raised in case of invalid or non-supported parameters.\u201d",
      "cve": "CVE-2018-7713",
      "specs": [
        "==3.4.1"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2018-7714",
      "advisory": "** DISPUTED ** The validateInputImageSize function in modules/imgcodecs/src/loadsave.cpp in OpenCV 3.4.1 allows remote attackers to cause a denial of service (assertion failure) because (pixels <= (1<<30)) may be false. Note: \u201cOpenCV CV_Assert is not an assertion (C-like assert()), it is regular C++ exception which can raised in case of invalid or non-supported parameters.\u201d",
      "cve": "CVE-2018-7714",
      "specs": [
        "==3.4.1"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2019-14491",
      "advisory": "An issue was discovered in OpenCV before 3.4.7 and 4.x before 4.1.1. There is an out of bounds read in the function cv::predictOrdered<cv::HaarEvaluator> in modules/objdetect/src/cascadedetect.hpp, which leads to denial of service.",
      "cve": "CVE-2019-14491",
      "specs": [
        "<3.4.7",
        ">=4.0.0,<4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2019-14492",
      "advisory": "An issue was discovered in OpenCV before 3.4.7 and 4.x before 4.1.1. There is an out of bounds read/write in the function HaarEvaluator::OptFeature::calc in modules/objdetect/src/cascadedetect.hpp, which leads to denial of service.",
      "cve": "CVE-2019-14492",
      "specs": [
        "<3.4.7",
        ">=4.0.0,<4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2019-14493",
      "advisory": "An issue was discovered in OpenCV before 4.1.1. There is a NULL pointer dereference in the function cv::XMLParser::parse at modules/core/src/persistence.cpp.",
      "cve": "CVE-2019-14493",
      "specs": [
        "<4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2019-15939",
      "advisory": "An issue was discovered in OpenCV 4.1.0. There is a divide-by-zero error in cv::HOGDescriptor::getDescriptorSize in modules/objdetect/src/hog.cpp.",
      "cve": "CVE-2019-15939",
      "specs": [
        "<=4.1.0"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2019-16249",
      "advisory": "OpenCV 4.1.1 has an out-of-bounds read in hal_baseline::v_load in core/hal/intrin_sse.hpp when called from computeSSDMeanNorm in modules/video/src/dis_flow.cpp.",
      "cve": "CVE-2019-16249",
      "specs": [
        "==4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2019-19624",
      "advisory": "An out-of-bounds read was discovered in OpenCV before 4.1.1. Specifically, variable coarsest_scale is assumed to be greater than or equal to finest_scale within the calc()/ocl_calc() functions in dis_flow.cpp. However, this is not true when dealing with small images, leading to an out-of-bounds read of the heap-allocated arrays Ux and Uy.",
      "cve": "CVE-2019-19624",
      "specs": [
        "<4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2019-5063",
      "advisory": "An exploitable heap buffer overflow vulnerability exists in the data structure persistence functionality of OpenCV 4.1.0. A specially crafted XML file can cause a buffer overflow, resulting in multiple heap corruptions and potential code execution. An attacker can provide a specially crafted file to trigger this vulnerability.",
      "cve": "CVE-2019-5063",
      "specs": [
        "==4.1.0"
      ]
    },
    {
      "id": "pyup.io-opencv-opencv-contrib-python-headless:CVE-2019-5064",
      "advisory": "An exploitable heap buffer overflow vulnerability exists in the data structure persistence functionality of OpenCV, before version 4.2.0. A specially crafted JSON file can cause a buffer overflow, resulting in multiple heap corruptions and potentially code execution. An attacker can provide a specially crafted file to trigger this vulnerability.",
      "cve": "CVE-2019-5064",
      "specs": [
        ">=4.0.0,<4.2.0"
      ]
    }
  ],
  "opencv-python": [
    {
      "id": "pyup.io-opencv-python:CVE-2016-1516",
      "advisory": "OpenCV 3.0.0 has a double free issue that allows attackers to execute arbitrary code.",
      "cve": "CVE-2016-1516",
      "specs": [
        "==3.0.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2016-1517",
      "advisory": "OpenCV 3.0.0 allows remote attackers to cause a denial of service (segfault) via vectors involving corrupt chunks.",
      "cve": "CVE-2016-1517",
      "specs": [
        "==3.0.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2017-1000450",
      "advisory": "In opencv/modules/imgcodecs/src/utils.cpp, functions FillUniColor and FillUniGray do not check the input length, which can lead to integer overflow. If the image is from remote, may lead to remote code execution or denial of service. This affects Opencv 3.3 and earlier.",
      "cve": "CVE-2017-1000450",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2017-12597",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds write error in the function FillColorRow1 in utils.cpp when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12597",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2017-12598",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds read error in the cv::RBaseStream::readBlock function in modules/imgcodecs/src/bitstrm.cpp when reading an image file by using cv::imread, as demonstrated by the 8-opencv-invalid-read-fread test case.",
      "cve": "CVE-2017-12598",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2017-12599",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds read error in the function icvCvt_BGRA2BGR_8u_C4C3R when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12599",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2017-12600",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has a denial of service (CPU consumption) issue, as demonstrated by the 11-opencv-dos-cpu-exhaust test case.",
      "cve": "CVE-2017-12600",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2017-12601",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has a buffer overflow in the cv::BmpDecoder::readData function in modules/imgcodecs/src/grfmt_bmp.cpp when reading an image file by using cv::imread, as demonstrated by the 4-buf-overflow-readData-memcpy test case.",
      "cve": "CVE-2017-12601",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2017-12602",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has a denial of service (memory consumption) issue, as demonstrated by the 10-opencv-dos-memory-exhaust test case.",
      "cve": "CVE-2017-12602",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2017-12603",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an invalid write in the cv::RLByteStream::getBytes function in modules/imgcodecs/src/bitstrm.cpp when reading an image file by using cv::imread, as demonstrated by the 2-opencv-heapoverflow-fseek test case.",
      "cve": "CVE-2017-12603",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2017-12604",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds write error in the FillUniColor function in utils.cpp when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12604",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2017-12605",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds write error in the FillColorRow8 function in utils.cpp when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12605",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2017-12606",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds write error in the function FillColorRow4 in utils.cpp when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12606",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2017-12862",
      "advisory": "In modules/imgcodecs/src/grfmt_pxm.cpp, the length of buffer AutoBuffer _src is small than expected, which will cause copy buffer overflow later. If the image is from remote, may lead to remote code execution or denial of service. This affects Opencv 3.3 and earlier.",
      "cve": "CVE-2017-12862",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2017-12863",
      "advisory": "In opencv/modules/imgcodecs/src/grfmt_pxm.cpp, function PxMDecoder::readData has an integer overflow when calculate src_pitch. If the image is from remote, may lead to remote code execution or denial of service. This affects Opencv 3.3 and earlier.",
      "cve": "CVE-2017-12863",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2017-12864",
      "advisory": "In opencv/modules/imgcodecs/src/grfmt_pxm.cpp, function ReadNumber did not checkout the input length, which lead to integer overflow. If the image is from remote, may lead to remote code execution or denial of service. This affects Opencv 3.3 and earlier.",
      "cve": "CVE-2017-12864",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2017-14136",
      "advisory": "OpenCV (Open Source Computer Vision Library) 3.3 has an out-of-bounds write error in the function FillColorRow1 in utils.cpp when reading an image file by using cv::imread. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-12597.",
      "cve": "CVE-2017-14136",
      "specs": [
        "==3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2017-17760",
      "advisory": "OpenCV 3.3.1 has a Buffer Overflow in the cv::PxMDecoder::readData function in grfmt_pxm.cpp, because an incorrect size value is used.",
      "cve": "CVE-2017-17760",
      "specs": [
        "==3.3.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2017-18009",
      "advisory": "In OpenCV 3.3.1, a heap-based buffer over-read exists in the function cv::HdrDecoder::checkSignature in modules/imgcodecs/src/grfmt_hdr.cpp.",
      "cve": "CVE-2017-18009",
      "specs": [
        "==3.3.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2018-5268",
      "advisory": "In OpenCV 3.3.1, a heap-based buffer overflow happens in cv::Jpeg2KDecoder::readComponent8u in modules/imgcodecs/src/grfmt_jpeg2000.cpp when parsing a crafted image file.",
      "cve": "CVE-2018-5268",
      "specs": [
        "==3.3.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2018-5269",
      "advisory": "In OpenCV 3.3.1, an assertion failure happens in cv::RBaseStream::setPos in modules/imgcodecs/src/bitstrm.cpp because of an incorrect integer cast.",
      "cve": "CVE-2018-5269",
      "specs": [
        "==3.3.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2018-7712",
      "advisory": "** DISPUTED ** The validateInputImageSize function in modules/imgcodecs/src/loadsave.cpp in OpenCV 3.4.1 allows remote attackers to cause a denial of service (assertion failure) because (size.height <= (1<<20)) may be false. Note: \u201cOpenCV CV_Assert is not an assertion (C-like assert()), it is regular C++ exception which can raised in case of invalid or non-supported parameters.\u201d",
      "cve": "CVE-2018-7712",
      "specs": [
        "==3.4.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2018-7713",
      "advisory": "** DISPUTED ** The validateInputImageSize function in modules/imgcodecs/src/loadsave.cpp in OpenCV 3.4.1 allows remote attackers to cause a denial of service (assertion failure) because (size.width <= (1<<20)) may be false. Note: \u201cOpenCV CV_Assert is not an assertion (C-like assert()), it is regular C++ exception which can raised in case of invalid or non-supported parameters.\u201d",
      "cve": "CVE-2018-7713",
      "specs": [
        "==3.4.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2018-7714",
      "advisory": "** DISPUTED ** The validateInputImageSize function in modules/imgcodecs/src/loadsave.cpp in OpenCV 3.4.1 allows remote attackers to cause a denial of service (assertion failure) because (pixels <= (1<<30)) may be false. Note: \u201cOpenCV CV_Assert is not an assertion (C-like assert()), it is regular C++ exception which can raised in case of invalid or non-supported parameters.\u201d",
      "cve": "CVE-2018-7714",
      "specs": [
        "==3.4.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2019-14491",
      "advisory": "An issue was discovered in OpenCV before 3.4.7 and 4.x before 4.1.1. There is an out of bounds read in the function cv::predictOrdered<cv::HaarEvaluator> in modules/objdetect/src/cascadedetect.hpp, which leads to denial of service.",
      "cve": "CVE-2019-14491",
      "specs": [
        "<3.4.7",
        ">=4.0.0,<4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2019-14492",
      "advisory": "An issue was discovered in OpenCV before 3.4.7 and 4.x before 4.1.1. There is an out of bounds read/write in the function HaarEvaluator::OptFeature::calc in modules/objdetect/src/cascadedetect.hpp, which leads to denial of service.",
      "cve": "CVE-2019-14492",
      "specs": [
        "<3.4.7",
        ">=4.0.0,<4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2019-14493",
      "advisory": "An issue was discovered in OpenCV before 4.1.1. There is a NULL pointer dereference in the function cv::XMLParser::parse at modules/core/src/persistence.cpp.",
      "cve": "CVE-2019-14493",
      "specs": [
        "<4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2019-15939",
      "advisory": "An issue was discovered in OpenCV 4.1.0. There is a divide-by-zero error in cv::HOGDescriptor::getDescriptorSize in modules/objdetect/src/hog.cpp.",
      "cve": "CVE-2019-15939",
      "specs": [
        "<=4.1.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2019-16249",
      "advisory": "OpenCV 4.1.1 has an out-of-bounds read in hal_baseline::v_load in core/hal/intrin_sse.hpp when called from computeSSDMeanNorm in modules/video/src/dis_flow.cpp.",
      "cve": "CVE-2019-16249",
      "specs": [
        "==4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2019-19624",
      "advisory": "An out-of-bounds read was discovered in OpenCV before 4.1.1. Specifically, variable coarsest_scale is assumed to be greater than or equal to finest_scale within the calc()/ocl_calc() functions in dis_flow.cpp. However, this is not true when dealing with small images, leading to an out-of-bounds read of the heap-allocated arrays Ux and Uy.",
      "cve": "CVE-2019-19624",
      "specs": [
        "<4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2019-5063",
      "advisory": "An exploitable heap buffer overflow vulnerability exists in the data structure persistence functionality of OpenCV 4.1.0. A specially crafted XML file can cause a buffer overflow, resulting in multiple heap corruptions and potential code execution. An attacker can provide a specially crafted file to trigger this vulnerability.",
      "cve": "CVE-2019-5063",
      "specs": [
        "==4.1.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python:CVE-2019-5064",
      "advisory": "An exploitable heap buffer overflow vulnerability exists in the data structure persistence functionality of OpenCV, before version 4.2.0. A specially crafted JSON file can cause a buffer overflow, resulting in multiple heap corruptions and potentially code execution. An attacker can provide a specially crafted file to trigger this vulnerability.",
      "cve": "CVE-2019-5064",
      "specs": [
        ">=4.0.0,<4.2.0"
      ]
    }
  ],
  "opencv-python-headless": [
    {
      "id": "pyup.io-opencv-python-headless:CVE-2016-1516",
      "advisory": "OpenCV 3.0.0 has a double free issue that allows attackers to execute arbitrary code.",
      "cve": "CVE-2016-1516",
      "specs": [
        "==3.0.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2016-1517",
      "advisory": "OpenCV 3.0.0 allows remote attackers to cause a denial of service (segfault) via vectors involving corrupt chunks.",
      "cve": "CVE-2016-1517",
      "specs": [
        "==3.0.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2017-1000450",
      "advisory": "In opencv/modules/imgcodecs/src/utils.cpp, functions FillUniColor and FillUniGray do not check the input length, which can lead to integer overflow. If the image is from remote, may lead to remote code execution or denial of service. This affects Opencv 3.3 and earlier.",
      "cve": "CVE-2017-1000450",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2017-12597",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds write error in the function FillColorRow1 in utils.cpp when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12597",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2017-12598",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds read error in the cv::RBaseStream::readBlock function in modules/imgcodecs/src/bitstrm.cpp when reading an image file by using cv::imread, as demonstrated by the 8-opencv-invalid-read-fread test case.",
      "cve": "CVE-2017-12598",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2017-12599",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds read error in the function icvCvt_BGRA2BGR_8u_C4C3R when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12599",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2017-12600",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has a denial of service (CPU consumption) issue, as demonstrated by the 11-opencv-dos-cpu-exhaust test case.",
      "cve": "CVE-2017-12600",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2017-12601",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has a buffer overflow in the cv::BmpDecoder::readData function in modules/imgcodecs/src/grfmt_bmp.cpp when reading an image file by using cv::imread, as demonstrated by the 4-buf-overflow-readData-memcpy test case.",
      "cve": "CVE-2017-12601",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2017-12602",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has a denial of service (memory consumption) issue, as demonstrated by the 10-opencv-dos-memory-exhaust test case.",
      "cve": "CVE-2017-12602",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2017-12603",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an invalid write in the cv::RLByteStream::getBytes function in modules/imgcodecs/src/bitstrm.cpp when reading an image file by using cv::imread, as demonstrated by the 2-opencv-heapoverflow-fseek test case.",
      "cve": "CVE-2017-12603",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2017-12604",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds write error in the FillUniColor function in utils.cpp when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12604",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2017-12605",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds write error in the FillColorRow8 function in utils.cpp when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12605",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2017-12606",
      "advisory": "OpenCV (Open Source Computer Vision Library) through 3.3 has an out-of-bounds write error in the function FillColorRow4 in utils.cpp when reading an image file by using cv::imread.",
      "cve": "CVE-2017-12606",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2017-12862",
      "advisory": "In modules/imgcodecs/src/grfmt_pxm.cpp, the length of buffer AutoBuffer _src is small than expected, which will cause copy buffer overflow later. If the image is from remote, may lead to remote code execution or denial of service. This affects Opencv 3.3 and earlier.",
      "cve": "CVE-2017-12862",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2017-12863",
      "advisory": "In opencv/modules/imgcodecs/src/grfmt_pxm.cpp, function PxMDecoder::readData has an integer overflow when calculate src_pitch. If the image is from remote, may lead to remote code execution or denial of service. This affects Opencv 3.3 and earlier.",
      "cve": "CVE-2017-12863",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2017-12864",
      "advisory": "In opencv/modules/imgcodecs/src/grfmt_pxm.cpp, function ReadNumber did not checkout the input length, which lead to integer overflow. If the image is from remote, may lead to remote code execution or denial of service. This affects Opencv 3.3 and earlier.",
      "cve": "CVE-2017-12864",
      "specs": [
        "<=3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2017-14136",
      "advisory": "OpenCV (Open Source Computer Vision Library) 3.3 has an out-of-bounds write error in the function FillColorRow1 in utils.cpp when reading an image file by using cv::imread. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-12597.",
      "cve": "CVE-2017-14136",
      "specs": [
        "==3.3.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2017-17760",
      "advisory": "OpenCV 3.3.1 has a Buffer Overflow in the cv::PxMDecoder::readData function in grfmt_pxm.cpp, because an incorrect size value is used.",
      "cve": "CVE-2017-17760",
      "specs": [
        "==3.3.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2017-18009",
      "advisory": "In OpenCV 3.3.1, a heap-based buffer over-read exists in the function cv::HdrDecoder::checkSignature in modules/imgcodecs/src/grfmt_hdr.cpp.",
      "cve": "CVE-2017-18009",
      "specs": [
        "==3.3.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2018-5268",
      "advisory": "In OpenCV 3.3.1, a heap-based buffer overflow happens in cv::Jpeg2KDecoder::readComponent8u in modules/imgcodecs/src/grfmt_jpeg2000.cpp when parsing a crafted image file.",
      "cve": "CVE-2018-5268",
      "specs": [
        "==3.3.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2018-5269",
      "advisory": "In OpenCV 3.3.1, an assertion failure happens in cv::RBaseStream::setPos in modules/imgcodecs/src/bitstrm.cpp because of an incorrect integer cast.",
      "cve": "CVE-2018-5269",
      "specs": [
        "==3.3.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2018-7712",
      "advisory": "** DISPUTED ** The validateInputImageSize function in modules/imgcodecs/src/loadsave.cpp in OpenCV 3.4.1 allows remote attackers to cause a denial of service (assertion failure) because (size.height <= (1<<20)) may be false. Note: \u201cOpenCV CV_Assert is not an assertion (C-like assert()), it is regular C++ exception which can raised in case of invalid or non-supported parameters.\u201d",
      "cve": "CVE-2018-7712",
      "specs": [
        "==3.4.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2018-7713",
      "advisory": "** DISPUTED ** The validateInputImageSize function in modules/imgcodecs/src/loadsave.cpp in OpenCV 3.4.1 allows remote attackers to cause a denial of service (assertion failure) because (size.width <= (1<<20)) may be false. Note: \u201cOpenCV CV_Assert is not an assertion (C-like assert()), it is regular C++ exception which can raised in case of invalid or non-supported parameters.\u201d",
      "cve": "CVE-2018-7713",
      "specs": [
        "==3.4.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2018-7714",
      "advisory": "** DISPUTED ** The validateInputImageSize function in modules/imgcodecs/src/loadsave.cpp in OpenCV 3.4.1 allows remote attackers to cause a denial of service (assertion failure) because (pixels <= (1<<30)) may be false. Note: \u201cOpenCV CV_Assert is not an assertion (C-like assert()), it is regular C++ exception which can raised in case of invalid or non-supported parameters.\u201d",
      "cve": "CVE-2018-7714",
      "specs": [
        "==3.4.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2019-14491",
      "advisory": "An issue was discovered in OpenCV before 3.4.7 and 4.x before 4.1.1. There is an out of bounds read in the function cv::predictOrdered<cv::HaarEvaluator> in modules/objdetect/src/cascadedetect.hpp, which leads to denial of service.",
      "cve": "CVE-2019-14491",
      "specs": [
        "<3.4.7",
        ">=4.0.0,<4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2019-14492",
      "advisory": "An issue was discovered in OpenCV before 3.4.7 and 4.x before 4.1.1. There is an out of bounds read/write in the function HaarEvaluator::OptFeature::calc in modules/objdetect/src/cascadedetect.hpp, which leads to denial of service.",
      "cve": "CVE-2019-14492",
      "specs": [
        "<3.4.7",
        ">=4.0.0,<4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2019-14493",
      "advisory": "An issue was discovered in OpenCV before 4.1.1. There is a NULL pointer dereference in the function cv::XMLParser::parse at modules/core/src/persistence.cpp.",
      "cve": "CVE-2019-14493",
      "specs": [
        "<4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2019-15939",
      "advisory": "An issue was discovered in OpenCV 4.1.0. There is a divide-by-zero error in cv::HOGDescriptor::getDescriptorSize in modules/objdetect/src/hog.cpp.",
      "cve": "CVE-2019-15939",
      "specs": [
        "<=4.1.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2019-16249",
      "advisory": "OpenCV 4.1.1 has an out-of-bounds read in hal_baseline::v_load in core/hal/intrin_sse.hpp when called from computeSSDMeanNorm in modules/video/src/dis_flow.cpp.",
      "cve": "CVE-2019-16249",
      "specs": [
        "==4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2019-19624",
      "advisory": "An out-of-bounds read was discovered in OpenCV before 4.1.1. Specifically, variable coarsest_scale is assumed to be greater than or equal to finest_scale within the calc()/ocl_calc() functions in dis_flow.cpp. However, this is not true when dealing with small images, leading to an out-of-bounds read of the heap-allocated arrays Ux and Uy.",
      "cve": "CVE-2019-19624",
      "specs": [
        "<4.1.1"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2019-5063",
      "advisory": "An exploitable heap buffer overflow vulnerability exists in the data structure persistence functionality of OpenCV 4.1.0. A specially crafted XML file can cause a buffer overflow, resulting in multiple heap corruptions and potential code execution. An attacker can provide a specially crafted file to trigger this vulnerability.",
      "cve": "CVE-2019-5063",
      "specs": [
        "==4.1.0"
      ]
    },
    {
      "id": "pyup.io-opencv-python-headless:CVE-2019-5064",
      "advisory": "An exploitable heap buffer overflow vulnerability exists in the data structure persistence functionality of OpenCV, before version 4.2.0. A specially crafted JSON file can cause a buffer overflow, resulting in multiple heap corruptions and potentially code execution. An attacker can provide a specially crafted file to trigger this vulnerability.",
      "cve": "CVE-2019-5064",
      "specs": [
        ">=4.0.0,<4.2.0"
      ]
    }
  ],
  "openpyxl": [
    {
      "id": "pyup.io-openpyxl:CVE-2017-5992",
      "advisory": "Openpyxl 2.4.1 resolves external entities by default, which allows remote attackers to conduct XXE attacks via a crafted .xlsx document.",
      "cve": "CVE-2017-5992",
      "specs": [
        "==2.4.1"
      ]
    }
  ],
  "opentaxii": [
    {
      "id": "pyup.io-opentaxii:CVE-2020-27197",
      "advisory": "** DISPUTED ** TAXII libtaxii through 1.1.117, as used in EclecticIQ OpenTAXII through 0.2.0 and other products, allows SSRF via an initial http:// substring to the parse method, even when the no_network setting is used for the XML parser. NOTE: the vendor points out that the parse method \"wraps the lxml library\" and that this may be an issue to \"raise ... to the lxml group.\"",
      "cve": "CVE-2020-27197",
      "specs": [
        "<=0.2.0"
      ]
    }
  ],
  "osc": [
    {
      "id": "pyup.io-osc:CVE-2012-1095",
      "advisory": "osc before 0.134 might allow remote OBS repository servers or package maintainers to execute arbitrary commands via a crafted (1) build log or (2) build status that contains an escape sequence for a terminal emulator.",
      "cve": "CVE-2012-1095",
      "specs": [
        "<=0.133"
      ]
    }
  ],
  "oslo.middleware": [
    {
      "id": "pyup.io-oslo.middleware:CVE-2017-2592",
      "advisory": "python-oslo-middleware before versions 3.8.1, 3.19.1, 3.23.1 is vulnerable to an information disclosure. Software using the CatchError class could include sensitive values in a traceback's error message. System users could exploit this flaw to obtain sensitive information from OpenStack component error logs (for example, keystone tokens).",
      "cve": "CVE-2017-2592",
      "specs": [
        "<=3.8.0",
        ">=3.20.0,<=3.23.0",
        ">=3.9.0,<=3.19.0"
      ]
    }
  ],
  "ovirt-engine-sdk-python": [
    {
      "id": "pyup.io-ovirt-engine-sdk-python:CVE-2014-0161",
      "advisory": "ovirt-engine-sdk-python before 3.4.0.7 and 3.5.0.4 does not verify that the hostname of the remote endpoint matches the Common Name (CN) or subjectAltName as specified by its x.509 certificate in a TLS/SSL session. This could allow man-in-the-middle attackers to spoof remote endpoints via an arbitrary valid certificate.",
      "cve": "CVE-2014-0161",
      "specs": [
        "<3.4.0.7",
        ">=3.5.0.0,<3.5.0.4"
      ]
    }
  ],
  "owlmixin": [
    {
      "id": "pyup.io-owlmixin:CVE-2017-16618",
      "advisory": "An exploitable vulnerability exists in the YAML loading functionality of util.py in OwlMixin before 2.0.0a12. A \"Load YAML\" string or file (aka load_yaml or load_yamlf) can execute arbitrary Python commands resulting in command execution because load is used where safe_load should have been used. An attacker can insert Python into loaded YAML to trigger this vulnerability.",
      "cve": "CVE-2017-16618",
      "specs": [
        "<2.0.0",
        "==2.0.0-alpha1",
        "==2.0.0-alpha10",
        "==2.0.0-alpha11",
        "==2.0.0-alpha2",
        "==2.0.0-alpha3",
        "==2.0.0-alpha4",
        "==2.0.0-alpha5",
        "==2.0.0-alpha6",
        "==2.0.0-alpha7",
        "==2.0.0-alpha8",
        "==2.0.0-alpha9"
      ]
    }
  ],
  "pandas": [
    {
      "id": "pyup.io-pandas:CVE-2020-13091",
      "advisory": "** DISPUTED ** pandas through 1.0.3 can unserialize and execute commands from an untrusted file that is passed to the read_pickle() function, if __reduce__ makes an os.system call. NOTE: third parties dispute this issue because the read_pickle() function is documented as unsafe and it is the user's responsibility to use the function in a secure manner.",
      "cve": "CVE-2020-13091",
      "specs": [
        "<=1.0.3"
      ]
    }
  ],
  "papermerge": [
    {
      "id": "pyup.io-papermerge:CVE-2020-29456",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in Papermerge before 1.5.2 allow remote attackers to inject arbitrary web script or HTML via the rename, tag, upload, or create folder function. The payload can be in a folder, a tag, or a document's filename. If email consumption is configured in Papermerge, a malicious document can be sent by email and is automatically uploaded into the Papermerge web application. Therefore, no authentication is required to exploit XSS if email consumption is configured. Otherwise authentication is required.",
      "cve": "CVE-2020-29456",
      "specs": [
        "<1.5.2"
      ]
    }
  ],
  "paramiko": [
    {
      "id": "pyup.io-paramiko:CVE-2008-0299",
      "advisory": "common.py in Paramiko 1.7.1 and earlier, when using threads or forked processes, does not properly use RandomPool, which allows one session to obtain sensitive information from another session by predicting the state of the pool.",
      "cve": "CVE-2008-0299",
      "specs": [
        "==1.7.1"
      ]
    },
    {
      "id": "pyup.io-paramiko:CVE-2018-1000805",
      "advisory": "Paramiko version 2.4.1, 2.3.2, 2.2.3, 2.1.5, 2.0.8, 1.18.5, 1.17.6 contains a Incorrect Access Control vulnerability in SSH server that can result in RCE. This attack appear to be exploitable via network connectivity.",
      "cve": "CVE-2018-1000805",
      "specs": [
        "==1.17.6",
        "==1.18.5",
        "==2.0.8",
        "==2.1.5",
        "==2.2.3",
        "==2.3.2",
        "==2.4.1"
      ]
    },
    {
      "id": "pyup.io-paramiko:CVE-2018-7750",
      "advisory": "transport.py in the SSH server implementation of Paramiko before 1.17.6, 1.18.x before 1.18.5, 2.0.x before 2.0.8, 2.1.x before 2.1.5, 2.2.x before 2.2.3, 2.3.x before 2.3.2, and 2.4.x before 2.4.1 does not properly check whether authentication is completed before processing other requests, as demonstrated by channel-open. A customized SSH client can simply skip the authentication step.",
      "cve": "CVE-2018-7750",
      "specs": [
        "<1.17.6",
        "==2.4.0",
        ">=1.18.0,<1.18.5",
        ">=2.0.0,<2.0.8",
        ">=2.1.0,<2.1.5",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.2"
      ]
    }
  ],
  "parlai": [
    {
      "id": "pyup.io-parlai:CVE-2021-24040",
      "advisory": "Due to use of unsafe YAML deserialization logic, an attacker with the ability to modify local YAML configuration files could provide malicious input, resulting in remote code execution or similar risks. This issue affects ParlAI prior to v1.1.0.",
      "cve": "CVE-2021-24040",
      "specs": [
        "<1.1.0"
      ]
    },
    {
      "id": "pyup.io-parlai:CVE-2021-39207",
      "advisory": "parlai is a framework for training and evaluating AI models on a variety of openly available dialogue datasets. In affected versions the package is vulnerable to YAML deserialization attack caused by unsafe loading which leads to Arbitary code execution. This security bug is patched by avoiding unsafe loader users should update to version above v1.1.0. If upgrading is not possible then users can change the Loader used to SafeLoader as a workaround. See commit 507d066ef432ea27d3e201da08009872a2f37725 for details.",
      "cve": "CVE-2021-39207",
      "specs": [
        "<1.1.0"
      ]
    }
  ],
  "parso": [
    {
      "id": "pyup.io-parso:CVE-2019-12760",
      "advisory": "** DISPUTED ** A deserialization vulnerability exists in the way parso through 0.4.0 handles grammar parsing from the cache. Cache loading relies on pickle and, provided that an evil pickle can be written to a cache grammar file and that its parsing can be triggered, this flaw leads to Arbitrary Code Execution. NOTE: This is disputed because \"the cache directory is not under control of the attacker in any common configuration.\"",
      "cve": "CVE-2019-12760",
      "specs": [
        "<=0.4.0"
      ]
    }
  ],
  "paste": [
    {
      "id": "pyup.io-paste:CVE-2010-2477",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in the paste.httpexceptions implementation in Paste before 1.7.4 allow remote attackers to inject arbitrary web script or HTML via vectors involving a 404 status code, related to (1) paste.urlparser.StaticURLParser, (2) paste.urlparser.PkgResourcesParser, (3) paste.urlmap.URLMap, and (4) HTTPNotFound.",
      "cve": "CVE-2010-2477",
      "specs": [
        "<=1.7.3.1",
        "==0.1.0",
        "==0.3",
        "==0.4.1",
        "==0.5",
        "==0.9.1",
        "==0.9.2",
        "==0.9.3",
        "==0.9.4",
        "==1.0.1",
        "==1.1",
        "==1.1.1",
        "==1.2",
        "==1.3",
        "==1.4",
        "==1.4.2",
        "==1.5",
        "==1.6",
        "==1.7",
        "==1.7.1",
        "==1.7.2",
        "==1.7.3"
      ]
    },
    {
      "id": "pyup.io-paste:CVE-2012-0878",
      "advisory": "Paste Script 1.7.5 and earlier does not properly set group memberships during execution with root privileges, which might allow remote attackers to bypass intended file-access restrictions by leveraging a web application that uses the local filesystem.",
      "cve": "CVE-2012-0878",
      "specs": [
        "<=1.7.5"
      ]
    }
  ],
  "petl": [
    {
      "id": "pyup.io-petl:CVE-2020-29128",
      "advisory": "petl before 1.68, in some configurations, allows resolution of entities in an XML document.",
      "cve": "CVE-2020-29128",
      "specs": [
        "<1.6.8"
      ]
    }
  ],
  "pikepdf": [
    {
      "id": "pyup.io-pikepdf:CVE-2021-29421",
      "advisory": "models/metadata.py in the pikepdf package 1.3.0 through 2.9.2 for Python allows XXE when parsing XMP metadata entries.",
      "cve": "CVE-2021-29421",
      "specs": [
        ">=1.3.0,<=2.9.2"
      ]
    }
  ],
  "pil": [
    {
      "id": "pyup.io-pil:CVE-2014-1932",
      "advisory": "The (1) load_djpeg function in JpegImagePlugin.py, (2) Ghostscript function in EpsImagePlugin.py, (3) load function in IptcImagePlugin.py, and (4) _copy function in Image.py in Python Image Library (PIL) 1.1.7 and earlier and Pillow before 2.3.1 do not properly create temporary files, which allow local users to overwrite arbitrary files and obtain sensitive information via a symlink attack on the temporary file.",
      "cve": "CVE-2014-1932",
      "specs": [
        "<=1.1.7"
      ]
    },
    {
      "id": "pyup.io-pil:CVE-2014-1933",
      "advisory": "The (1) JpegImagePlugin.py and (2) EpsImagePlugin.py scripts in Python Image Library (PIL) 1.1.7 and earlier and Pillow before 2.3.1 uses the names of temporary files on the command line, which makes it easier for local users to conduct symlink attacks by listing the processes.",
      "cve": "CVE-2014-1933",
      "specs": [
        "<=1.1.7"
      ]
    },
    {
      "id": "pyup.io-pil:CVE-2014-3007",
      "advisory": "Python Image Library (PIL) 1.1.7 and earlier and Pillow 2.3 might allow remote attackers to execute arbitrary commands via shell metacharacters in unspecified vectors related to CVE-2014-1932, possibly JpegImagePlugin.py.",
      "cve": "CVE-2014-3007",
      "specs": [
        "<=1.1.7"
      ]
    },
    {
      "id": "pyup.io-pil:CVE-2016-2533",
      "advisory": "Buffer overflow in the ImagingPcdDecode function in PcdDecode.c in Pillow before 3.1.1 and Python Imaging Library (PIL) 1.1.7 and earlier allows remote attackers to cause a denial of service (crash) via a crafted PhotoCD file.",
      "cve": "CVE-2016-2533",
      "specs": [
        "<=1.1.7"
      ]
    }
  ],
  "pillow": [
    {
      "id": "pyup.io-pillow:CVE-2014-1932",
      "advisory": "The (1) load_djpeg function in JpegImagePlugin.py, (2) Ghostscript function in EpsImagePlugin.py, (3) load function in IptcImagePlugin.py, and (4) _copy function in Image.py in Python Image Library (PIL) 1.1.7 and earlier and Pillow before 2.3.1 do not properly create temporary files, which allow local users to overwrite arbitrary files and obtain sensitive information via a symlink attack on the temporary file.",
      "cve": "CVE-2014-1932",
      "specs": [
        "<=1.1.7",
        "<=2.3.0"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2014-1933",
      "advisory": "The (1) JpegImagePlugin.py and (2) EpsImagePlugin.py scripts in Python Image Library (PIL) 1.1.7 and earlier and Pillow before 2.3.1 uses the names of temporary files on the command line, which makes it easier for local users to conduct symlink attacks by listing the processes.",
      "cve": "CVE-2014-1933",
      "specs": [
        "<=1.1.7",
        "<=2.3.0"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2014-3007",
      "advisory": "Python Image Library (PIL) 1.1.7 and earlier and Pillow 2.3 might allow remote attackers to execute arbitrary commands via shell metacharacters in unspecified vectors related to CVE-2014-1932, possibly JpegImagePlugin.py.",
      "cve": "CVE-2014-3007",
      "specs": [
        "<=1.1.7",
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2014-3589",
      "advisory": "PIL/IcnsImagePlugin.py in Python Imaging Library (PIL) and Pillow before 2.3.2 and 2.5.x before 2.5.2 allows remote attackers to cause a denial of service via a crafted block size.",
      "cve": "CVE-2014-3589",
      "specs": [
        "<=2.3.1",
        "==2.3.0",
        "==2.5.0",
        "==2.5.1",
        "==2.5.2"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2014-3598",
      "advisory": "The Jpeg2KImagePlugin plugin in Pillow before 2.5.3 allows remote attackers to cause a denial of service via a crafted image.",
      "cve": "CVE-2014-3598",
      "specs": [
        "<=2.5.2"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2014-9601",
      "advisory": "Pillow before 2.7.0 allows remote attackers to cause a denial of service via a compressed text chunk in a PNG image that has a large size when it is decompressed.",
      "cve": "CVE-2014-9601",
      "specs": [
        "<=2.6.2"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2016-0740",
      "advisory": "Buffer overflow in the ImagingLibTiffDecode function in libImaging/TiffDecode.c in Pillow before 3.1.1 allows remote attackers to overwrite memory via a crafted TIFF file.",
      "cve": "CVE-2016-0740",
      "specs": [
        "<=3.1.0"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2016-0775",
      "advisory": "Buffer overflow in the ImagingFliDecode function in libImaging/FliDecode.c in Pillow before 3.1.1 allows remote attackers to cause a denial of service (crash) via a crafted FLI file.",
      "cve": "CVE-2016-0775",
      "specs": [
        "<=3.1.0"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2016-2533",
      "advisory": "Buffer overflow in the ImagingPcdDecode function in PcdDecode.c in Pillow before 3.1.1 and Python Imaging Library (PIL) 1.1.7 and earlier allows remote attackers to cause a denial of service (crash) via a crafted PhotoCD file.",
      "cve": "CVE-2016-2533",
      "specs": [
        "<=1.1.7",
        "<=3.1.0"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2016-3076",
      "advisory": "Heap-based buffer overflow in the j2k_encode_entry function in Pillow 2.5.0 through 3.1.1 allows remote attackers to cause a denial of service (memory corruption) via a crafted Jpeg2000 file.",
      "cve": "CVE-2016-3076",
      "specs": [
        "==2.5.0",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.6.0",
        "==2.6.0-rc1",
        "==2.6.1",
        "==2.6.2",
        "==2.7.0",
        "==2.8.0",
        "==2.8.1",
        "==2.8.2",
        "==2.9.0",
        "==2.9.0-dev0",
        "==2.9.0-dev1",
        "==2.9.0-dev2",
        "==3.0.0",
        "==3.0.0-rc1",
        "==3.1.0"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2016-4009",
      "advisory": "Integer overflow in the ImagingResampleHorizontal function in libImaging/Resample.c in Pillow before 3.1.1 allows remote attackers to have unspecified impact via negative values of the new size, which triggers a heap-based buffer overflow.",
      "cve": "CVE-2016-4009",
      "specs": [
        "<=3.1.0"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2016-9189",
      "advisory": "Pillow before 3.3.2 allows context-dependent attackers to obtain sensitive information by using the \"crafted image file\" approach, related to an \"Integer Overflow\" issue affecting the Image.core.map_buffer in map.c component.",
      "cve": "CVE-2016-9189",
      "specs": [
        "<=3.3.1"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2016-9190",
      "advisory": "Pillow before 3.3.2 allows context-dependent attackers to execute arbitrary code by using the \"crafted image file\" approach, related to an \"Insecure Sign Extension\" issue affecting the ImagingNew in Storage.c component.",
      "cve": "CVE-2016-9190",
      "specs": [
        "<=3.3.1"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2019-16865",
      "advisory": "An issue was discovered in Pillow before 6.2.0. When reading specially crafted invalid image files, the library can either allocate very large amounts of memory or take an extremely long period of time to process the image.",
      "cve": "CVE-2019-16865",
      "specs": [
        "<6.2.0"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2019-19911",
      "advisory": "There is a DoS vulnerability in Pillow before 6.2.2 caused by FpxImagePlugin.py calling the range function on an unvalidated 32-bit integer if the number of bands is large. On Windows running 32-bit Python, this results in an OverflowError or MemoryError due to the 2 GB limit. However, on Linux running 64-bit Python this results in the process being terminated by the OOM killer.",
      "cve": "CVE-2019-19911",
      "specs": [
        "<6.2.2"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2020-10177",
      "advisory": "Pillow before 7.1.0 has multiple out-of-bounds reads in libImaging/FliDecode.c.",
      "cve": "CVE-2020-10177",
      "specs": [
        "<6.2.3",
        "==7.0.0"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2020-10378",
      "advisory": "In libImaging/PcxDecode.c in Pillow before 7.1.0, an out-of-bounds read can occur when reading PCX files where state->shuffle is instructed to read beyond state->buffer.",
      "cve": "CVE-2020-10378",
      "specs": [
        "<6.2.3",
        "==7.0.0"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2020-10379",
      "advisory": "In Pillow before 7.1.0, there are two Buffer Overflows in libImaging/TiffDecode.c.",
      "cve": "CVE-2020-10379",
      "specs": [
        "<6.2.3",
        "==7.0.0"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2020-10994",
      "advisory": "In libImaging/Jpeg2KDecode.c in Pillow before 7.1.0, there are multiple out-of-bounds reads via a crafted JP2 file.",
      "cve": "CVE-2020-10994",
      "specs": [
        "<7.0.0"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2020-11538",
      "advisory": "In libImaging/SgiRleDecode.c in Pillow through 7.0.0, a number of out-of-bounds reads exist in the parsing of SGI image files, a different issue than CVE-2020-5311.",
      "cve": "CVE-2020-11538",
      "specs": [
        "<=7.0.0"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2020-35653",
      "advisory": "In Pillow before 8.1.0, PcxDecode has a buffer over-read when decoding a crafted PCX file because the user-supplied stride value is trusted for buffer calculations.",
      "cve": "CVE-2020-35653",
      "specs": [
        "<8.1.0"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2020-35654",
      "advisory": "In Pillow before 8.1.0, TiffDecode has a heap-based buffer overflow when decoding crafted YCbCr files because of certain interpretation conflicts with LibTIFF in RGBA mode.",
      "cve": "CVE-2020-35654",
      "specs": [
        "<8.1.0"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2020-35655",
      "advisory": "In Pillow before 8.1.0, SGIRleDecode has a 4-byte buffer over-read when decoding crafted SGI RLE image files because offsets and length tables are mishandled.",
      "cve": "CVE-2020-35655",
      "specs": [
        ">=4.3.0,<8.1.0"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2020-5310",
      "advisory": "libImaging/TiffDecode.c in Pillow before 6.2.2 has a TIFF decoding integer overflow, related to realloc.",
      "cve": "CVE-2020-5310",
      "specs": [
        "<6.2.2"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2020-5311",
      "advisory": "libImaging/SgiRleDecode.c in Pillow before 6.2.2 has an SGI buffer overflow.",
      "cve": "CVE-2020-5311",
      "specs": [
        "<6.2.2"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2020-5312",
      "advisory": "libImaging/PcxDecode.c in Pillow before 6.2.2 has a PCX P mode buffer overflow.",
      "cve": "CVE-2020-5312",
      "specs": [
        "<6.2.2"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2020-5313",
      "advisory": "libImaging/FliDecode.c in Pillow before 6.2.2 has an FLI buffer overflow.",
      "cve": "CVE-2020-5313",
      "specs": [
        "<6.2.2"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2021-23437",
      "advisory": "The package pillow 5.2.0 and before 8.3.2 are vulnerable to Regular Expression Denial of Service (ReDoS) via the getrgb function.",
      "cve": "CVE-2021-23437",
      "specs": [
        "<8.3.2"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2021-25287",
      "advisory": "An issue was discovered in Pillow before 8.2.0. There is an out-of-bounds read in J2kDecode, in j2ku_graya_la.",
      "cve": "CVE-2021-25287",
      "specs": [
        "<8.2.0"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2021-25288",
      "advisory": "An issue was discovered in Pillow before 8.2.0. There is an out-of-bounds read in J2kDecode, in j2ku_gray_i.",
      "cve": "CVE-2021-25288",
      "specs": [
        "<8.2.0"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2021-25289",
      "advisory": "An issue was discovered in Pillow before 8.1.1. TiffDecode has a heap-based buffer overflow when decoding crafted YCbCr files because of certain interpretation conflicts with LibTIFF in RGBA mode. NOTE: this issue exists because of an incomplete fix for CVE-2020-35654.",
      "cve": "CVE-2021-25289",
      "specs": [
        "<8.1.1"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2021-25290",
      "advisory": "An issue was discovered in Pillow before 8.1.1. In TiffDecode.c, there is a negative-offset memcpy with an invalid size.",
      "cve": "CVE-2021-25290",
      "specs": [
        "<8.1.1"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2021-25291",
      "advisory": "An issue was discovered in Pillow before 8.1.1. In TiffDecode.c, there is an out-of-bounds read in TiffreadRGBATile via invalid tile boundaries.",
      "cve": "CVE-2021-25291",
      "specs": [
        "<8.1.1"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2021-25292",
      "advisory": "An issue was discovered in Pillow before 8.1.1. The PDF parser allows a regular expression DoS (ReDoS) attack via a crafted PDF file because of a catastrophic backtracking regex.",
      "cve": "CVE-2021-25292",
      "specs": [
        "<8.1.1"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2021-25293",
      "advisory": "An issue was discovered in Pillow before 8.1.1. There is an out-of-bounds read in SGIRleDecode.c.",
      "cve": "CVE-2021-25293",
      "specs": [
        "<8.1.1"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2021-27921",
      "advisory": "Pillow before 8.1.1 allows attackers to cause a denial of service (memory consumption) because the reported size of a contained image is not properly checked for a BLP container, and thus an attempted memory allocation can be very large.",
      "cve": "CVE-2021-27921",
      "specs": [
        "<8.1.1"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2021-27922",
      "advisory": "Pillow before 8.1.1 allows attackers to cause a denial of service (memory consumption) because the reported size of a contained image is not properly checked for an ICNS container, and thus an attempted memory allocation can be very large.",
      "cve": "CVE-2021-27922",
      "specs": [
        "<8.1.1"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2021-27923",
      "advisory": "Pillow before 8.1.1 allows attackers to cause a denial of service (memory consumption) because the reported size of a contained image is not properly checked for an ICO container, and thus an attempted memory allocation can be very large.",
      "cve": "CVE-2021-27923",
      "specs": [
        "<8.1.1"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2021-28675",
      "advisory": "An issue was discovered in Pillow before 8.2.0. PSDImagePlugin.PsdImageFile lacked a sanity check on the number of input layers relative to the size of the data block. This could lead to a DoS on Image.open prior to Image.load.",
      "cve": "CVE-2021-28675",
      "specs": [
        "<8.2.0"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2021-28676",
      "advisory": "An issue was discovered in Pillow before 8.2.0. For FLI data, FliDecode did not properly check that the block advance was non-zero, potentially leading to an infinite loop on load.",
      "cve": "CVE-2021-28676",
      "specs": [
        "<8.2.0"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2021-28677",
      "advisory": "An issue was discovered in Pillow before 8.2.0. For EPS data, the readline implementation used in EPSImageFile has to deal with any combination of \\r and \\n as line endings. It used an accidentally quadratic method of accumulating lines while looking for a line ending. A malicious EPS file could use this to perform a DoS of Pillow in the open phase, before an image was accepted for opening.",
      "cve": "CVE-2021-28677",
      "specs": [
        "<8.2.0"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2021-28678",
      "advisory": "An issue was discovered in Pillow before 8.2.0. For BLP data, BlpImagePlugin did not properly check that reads (after jumping to file offsets) returned data. This could lead to a DoS where the decoder could be run a large number of times on empty data.",
      "cve": "CVE-2021-28678",
      "specs": [
        "<8.2.0"
      ]
    },
    {
      "id": "pyup.io-pillow:CVE-2021-34552",
      "advisory": "Pillow through 8.2.0 and PIL (aka Python Imaging Library) through 1.1.7 allow an attacker to pass controlled parameters directly into a convert function to trigger a buffer overflow in Convert.c.",
      "cve": "CVE-2021-34552",
      "specs": [
        ">=1.0,<=1.1.7",
        ">=1.2,<=8.2.0"
      ]
    }
  ],
  "pip": [
    {
      "id": "pyup.io-pip:CVE-2013-1629",
      "advisory": "pip before 1.3 uses HTTP to retrieve packages from the PyPI repository, and does not perform integrity checks on package contents, which allows man-in-the-middle attackers to execute arbitrary code via a crafted response to a \"pip install\" operation.",
      "cve": "CVE-2013-1629",
      "specs": [
        "<1.3"
      ]
    },
    {
      "id": "pyup.io-pip:CVE-2013-1888",
      "advisory": "pip before 1.3 allows local users to overwrite arbitrary files via a symlink attack on a file in the /tmp/pip-build temporary directory.",
      "cve": "CVE-2013-1888",
      "specs": [
        "<1.3"
      ]
    },
    {
      "id": "pyup.io-pip:CVE-2013-5123",
      "advisory": "The mirroring support (-M, --use-mirrors) in Python Pip before 1.5 uses insecure DNS querying and authenticity checks which allows attackers to perform man-in-the-middle attacks.",
      "cve": "CVE-2013-5123",
      "specs": [
        "<1.5"
      ]
    },
    {
      "id": "pyup.io-pip:CVE-2014-8991",
      "advisory": "pip 1.3 through 1.5.6 allows local users to cause a denial of service (prevention of package installation) by creating a /tmp/pip-build-* file for another user.",
      "cve": "CVE-2014-8991",
      "specs": [
        ">=1.3,<=1.5.6"
      ]
    },
    {
      "id": "pyup.io-pip:CVE-2019-20916",
      "advisory": "The pip package before 19.2 for Python allows Directory Traversal when a URL is given in an install command, because a Content-Disposition header can have ../ in a filename, as demonstrated by overwriting the /root/.ssh/authorized_keys file. This occurs in _download_http_url in _internal/download.py.",
      "cve": "CVE-2019-20916",
      "specs": [
        "<19.2"
      ]
    }
  ],
  "plone": [
    {
      "id": "pyup.io-plone:CVE-2006-1711",
      "advisory": "Plone 2.0.5, 2.1.2, and 2.5-beta1 does not restrict access to the (1) changeMemberPortrait, (2) deletePersonalPortrait, and (3) testCurrentPassword methods, which allows remote attackers to modify portraits.",
      "cve": "CVE-2006-1711",
      "specs": [
        "==2.0.5",
        "==2.1.2",
        "==2.5_beta1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2006-4247",
      "advisory": "Unspecified vulnerability in the Password Reset Tool before 0.4.1 on Plone 2.5 and 2.5.1 Release Candidate allows attackers to reset the passwords of other users, related to \"an erroneous security declaration.\"",
      "cve": "CVE-2006-4247",
      "specs": [
        "==2.5",
        "==2.5.1_rc"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2006-4249",
      "advisory": "Unspecified vulnerability in PlonePAS in Plone 2.5 and 2.5.1, when anonymous member registration is enabled, allows an attacker to \"masquerade as a group.\"",
      "cve": "CVE-2006-4249",
      "specs": [
        "==2.5",
        "==2.5.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2007-5741",
      "advisory": "Plone 2.5 through 2.5.4 and 3.0 through 3.0.2 allows remote attackers to execute arbitrary Python code via network data containing pickled objects for the (1) statusmessages or (2) linkintegrity module, which the module unpickles and executes.",
      "cve": "CVE-2007-5741",
      "specs": [
        "==2.5",
        "==2.5.1",
        "==2.5.1_rc",
        "==2.5.4",
        "==2.5_beta1",
        "==3.0",
        "==3.0.1",
        "==3.0.2"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2008-0164",
      "advisory": "Multiple cross-site request forgery (CSRF) vulnerabilities in Plone CMS 3.0.5 and 3.0.6 allow remote attackers to (1) add arbitrary accounts via the join_form page and (2) change the privileges of arbitrary groups via the prefs_groups_overview page.",
      "cve": "CVE-2008-0164",
      "specs": [
        "==3.0.5",
        "==3.0.6"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2008-1393",
      "advisory": "Plone CMS 3.0.5, and probably other 3.x versions, places a base64 encoded form of the username and password in the __ac cookie for the admin account, which makes it easier for remote attackers to obtain administrative privileges by sniffing the network.",
      "cve": "CVE-2008-1393",
      "specs": [
        "<=3",
        "<=3.0.5"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2008-1394",
      "advisory": "Plone CMS before 3 places a base64 encoded form of the username and password in the __ac cookie for all user accounts, which makes it easier for remote attackers to obtain access by sniffing the network.",
      "cve": "CVE-2008-1394",
      "specs": [
        "<=2.5.1",
        "==2.0.5",
        "==2.1.2",
        "==2.1.3-rc1",
        "==2.5",
        "==2.5-beta1",
        "==2.5-beta2"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2008-4571",
      "advisory": "Cross-site scripting (XSS) vulnerability in the LiveSearch module in Plone before 3.0.4 allows remote attackers to inject arbitrary web script or HTML via the Description field for search results, as demonstrated using the onerror Javascript even in an IMG tag.",
      "cve": "CVE-2008-4571",
      "specs": [
        "<=3.0.3",
        "==2.0.5",
        "==2.1.2",
        "==2.5",
        "==2.5.1",
        "==2.5.1_rc",
        "==2.5.4",
        "==2.5_beta1",
        "==3.0",
        "==3.0.1",
        "==3.0.2"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2010-2422",
      "advisory": "Cross-site scripting (XSS) vulnerability in PortalTransforms in Plone 2.1 through 3.3.4 before hotfix 20100612 allows remote attackers to inject arbitrary web script or HTML via the safe_html transform.",
      "cve": "CVE-2010-2422",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2011-1340",
      "advisory": "Cross-site scripting (XSS) vulnerability in skins/plone_templates/default_error_message.pt in Plone before 2.5.3 allows remote attackers to inject arbitrary web script or HTML via the type_name parameter to Members/ipa/createObject.",
      "cve": "CVE-2011-1340",
      "specs": [
        "<=2.5.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2011-1948",
      "advisory": "Cross-site scripting (XSS) vulnerability in Plone 4.1 and earlier allows remote attackers to inject arbitrary web script or HTML via a crafted URL.",
      "cve": "CVE-2011-1948",
      "specs": [
        "<=4.1",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2011-1949",
      "advisory": "Cross-site scripting (XSS) vulnerability in the safe_html filter in Products.PortalTransforms in Plone 2.1 through 4.1 allows remote authenticated users to inject arbitrary web script or HTML via unspecified vectors, a different vulnerability than CVE-2010-2422.",
      "cve": "CVE-2011-1949",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2011-1950",
      "advisory": "plone.app.users in Plone 4.0 and 4.1 allows remote authenticated users to modify the properties of arbitrary accounts via unspecified vectors, as exploited in the wild in June 2011.",
      "cve": "CVE-2011-1950",
      "specs": [
        "==4.0",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2011-2528",
      "advisory": "Unspecified vulnerability in (1) Zope 2.12.x before 2.12.19 and 2.13.x before 2.13.8, as used in Plone 4.x and other products, and (2) PloneHotfix20110720 for Plone 3.x allows attackers to gain privileges via unspecified vectors, related to a \"highly serious vulnerability.\" NOTE: this vulnerability exists because of an incorrect fix for CVE-2011-0720.",
      "cve": "CVE-2011-2528",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2011-3587",
      "advisory": "Unspecified vulnerability in Zope 2.12.x and 2.13.x, as used in Plone 4.0.x through 4.0.9, 4.1, and 4.2 through 4.2a2, allows remote attackers to execute arbitrary commands via vectors related to the p_ class in OFS/misc_.py and the use of Python modules.",
      "cve": "CVE-2011-3587",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.2",
        "==4.2a1",
        "==4.2a2"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2011-4030",
      "advisory": "The CMFEditions component 2.x in Plone 4.0.x through 4.0.9, 4.1, and 4.2 through 4.2a2 does not prevent the KwAsAttributes classes from being publishable, which allows remote attackers to access sub-objects via unspecified vectors, a different vulnerability than CVE-2011-3587.",
      "cve": "CVE-2011-4030",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.2",
        "==4.2a1",
        "==4.2a2"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2011-4462",
      "advisory": "Plone 4.1.3 and earlier computes hash values for form parameters without restricting the ability to trigger hash collisions predictably, which allows remote attackers to cause a denial of service (CPU consumption) by sending many crafted parameters.",
      "cve": "CVE-2011-4462",
      "specs": [
        "<=4.1.3",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5485",
      "advisory": "registerConfiglet.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via unspecified vectors, related to the admin interface.",
      "cve": "CVE-2012-5485",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5486",
      "advisory": "ZPublisher.HTTPRequest._scrubHeader in Zope 2 before 2.13.19, as used in Plone before 4.3 beta 1, allows remote attackers to inject arbitrary HTTP headers via a linefeed (LF) character.",
      "cve": "CVE-2012-5486",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5487",
      "advisory": "The sandbox whitelisting function (allowmodule.py) in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with certain privileges to bypass the Python sandbox restriction and execute arbitrary Python code via vectors related to importing.",
      "cve": "CVE-2012-5487",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5488",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via a crafted URL, related to createObject.",
      "cve": "CVE-2012-5488",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5489",
      "advisory": "The App.Undo.UndoSupport.get_request_var_or_attr function in Zope before 2.12.21 and 3.13.x before 2.13.11, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote authenticated users to gain access to restricted attributes via unspecified vectors.",
      "cve": "CVE-2012-5489",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5490",
      "advisory": "Cross-site scripting (XSS) vulnerability in kssdevel.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5490",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5491",
      "advisory": "z3c.form, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote attackers to obtain the default form field values by leveraging knowledge of the form location and the element id.",
      "cve": "CVE-2012-5491",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5492",
      "advisory": "uid_catalog.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to obtain metadata about hidden objects via a crafted URL.",
      "cve": "CVE-2012-5492",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5493",
      "advisory": "gtbn.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with certain permissions to bypass the Python sandbox and execute arbitrary Python code via unspecified vectors.",
      "cve": "CVE-2012-5493",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5494",
      "advisory": "Cross-site scripting (XSS) vulnerability in python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors, related to \"{u,}translate.\"",
      "cve": "CVE-2012-5494",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5495",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via a crafted URL, related to \"go_back.\"",
      "cve": "CVE-2012-5495",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5496",
      "advisory": "kupu_spellcheck.py in Kupu in Plone before 4.0 allows remote attackers to cause a denial of service (ZServer thread lock) via a crafted URL.",
      "cve": "CVE-2012-5496",
      "specs": [
        "<=3.3.5",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5497",
      "advisory": "membership_tool.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to enumerate user account names via a crafted URL.",
      "cve": "CVE-2012-5497",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5498",
      "advisory": "queryCatalog.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to bypass caching and cause a denial of service via a crafted request to a collection.",
      "cve": "CVE-2012-5498",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5499",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to cause a denial of service (memory consumption) via a large value, related to formatColumns.",
      "cve": "CVE-2012-5499",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5500",
      "advisory": "The batch id change script (renameObjectsByPaths.py) in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to change the titles of content items by leveraging a valid CSRF token in a crafted request.",
      "cve": "CVE-2012-5500",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5501",
      "advisory": "at_download.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read arbitrary BLOBs (Files and Images) stored on custom content types via a crafted URL.",
      "cve": "CVE-2012-5501",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5502",
      "advisory": "Cross-site scripting (XSS) vulnerability in safe_html.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with permissions to edit content to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5502",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5503",
      "advisory": "ftp.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read hidden folder contents via unspecified vectors.",
      "cve": "CVE-2012-5503",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5504",
      "advisory": "Cross-site scripting (XSS) vulnerability in widget_traversal.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5504",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5505",
      "advisory": "atat.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read private data structures via a request for a view without a name.",
      "cve": "CVE-2012-5505",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5506",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to cause a denial of service (infinite loop) via an RSS feed request for a folder the user does not have permission to access.",
      "cve": "CVE-2012-5506",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5507",
      "advisory": "AccessControl/AuthEncoding.py in Zope before 2.13.19, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote attackers to obtain passwords via vectors involving timing discrepancies in password validation.",
      "cve": "CVE-2012-5507",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-5508",
      "advisory": "The error pages in Plone before 4.2.3 and 4.3 before beta 1 allow remote attackers to obtain random numbers and derive the PRNG state for password resets via unspecified vectors.  NOTE: this identifier was SPLIT per ADT2 due to different vulnerability types. CVE-2012-6661 was assigned for the PRNG reseeding issue in Zope.",
      "cve": "CVE-2012-5508",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2012-6661",
      "advisory": "Zope before 2.13.19, as used in Plone before 4.2.3 and 4.3 before beta 1, does not reseed the pseudo-random number generator (PRNG), which makes it easier for remote attackers to guess the value via unspecified vectors.  NOTE: this issue was SPLIT from CVE-2012-5508 due to different vulnerability types (ADT2).",
      "cve": "CVE-2012-6661",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2013-4188",
      "advisory": "traverser.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote attackers with administrator privileges to cause a denial of service (infinite loop and resource consumption) via unspecified vectors related to \"retrieving information for certain resources.\"",
      "cve": "CVE-2013-4188",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2013-4189",
      "advisory": "Multiple unspecified vulnerabilities in (1) dataitems.py, (2) get.py, and (3) traverseName.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote authenticated users with administrator access to a subtree to access nodes above the subtree via unknown vectors.",
      "cve": "CVE-2013-4189",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2013-4190",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in (1) spamProtect.py, (2) pts.py, and (3) request.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2013-4190",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2013-4191",
      "advisory": "zip.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly enforce access restrictions when including content in a zip archive, which allows remote attackers to obtain sensitive information by reading a generated archive.",
      "cve": "CVE-2013-4191",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2013-4192",
      "advisory": "sendto.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to spoof emails via unspecified vectors.",
      "cve": "CVE-2013-4192",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2013-4193",
      "advisory": "typeswidget.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly enforce the immutable setting on unspecified content edit forms, which allows remote attackers to hide fields on the forms via a crafted URL.",
      "cve": "CVE-2013-4193",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2013-4194",
      "advisory": "The WYSIWYG component (wysiwyg.py) in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote attackers to obtain sensitive information via a crafted URL, which reveals the installation path in an error message.",
      "cve": "CVE-2013-4194",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2013-4195",
      "advisory": "Multiple open redirect vulnerabilities in (1) marmoset_patch.py, (2) publish.py, and (3) principiaredirect.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via unspecified vectors.",
      "cve": "CVE-2013-4195",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2013-4196",
      "advisory": "The object manager implementation (objectmanager.py) in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly restrict access to internal methods, which allows remote attackers to obtain sensitive information via a crafted request.",
      "cve": "CVE-2013-4196",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2013-4197",
      "advisory": "member_portrait.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to modify or delete portraits of other users via unspecified vectors.",
      "cve": "CVE-2013-4197",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2013-4198",
      "advisory": "mail_password.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to bypass the prohibition on password changes via the forgotten password email functionality.",
      "cve": "CVE-2013-4198",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2013-4199",
      "advisory": "(1) cb_decode.py and (2) linkintegrity.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote authenticated users to cause a denial of service (resource consumption) via a large zip archive, which is expanded (decompressed).",
      "cve": "CVE-2013-4199",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2013-4200",
      "advisory": "The isURLInPortal method in the URLTool class in in_portal.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 treats URLs starting with a space as a relative URL, which allows remote attackers to bypass the allow_external_login_sites filtering property,  redirect users to arbitrary web sites, and conduct phishing attacks via a space before a URL in the \"next\" parameter to acl_users/credentials_cookie_auth/require_login.",
      "cve": "CVE-2013-4200",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2013-7060",
      "advisory": "Products/CMFPlone/FactoryTool.py in Plone 3.3 through 4.3.2 allows remote attackers to obtain the installation path via vectors related to a file object for unspecified documentation which is initialized in class scope.",
      "cve": "CVE-2013-7060",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2013-7061",
      "advisory": "Products/CMFPlone/CatalogTool.py in Plone 3.3 through 4.3.2 allows remote administrators to bypass restrictions and obtain sensitive information via an unspecified search API.",
      "cve": "CVE-2013-7061",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2013-7062",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in Zope, as used in Plone 3.3.x through 3.3.6, 4.0.x through 4.0.9, 4.1.x through 4.1.6, 4.2.x through 4.2.7, and 4.3 through 4.3.2, allow remote attackers to inject arbitrary web script or HTML via unspecified input in the (1) browser_id_manager or (2) OFS.Image method.",
      "cve": "CVE-2013-7062",
      "specs": [
        ">=3.3.0,<=3.3.6",
        ">=4.0.0,<=4.0.9",
        ">=4.1.0,<=4.1.6",
        ">=4.2.0,<=4.2.7",
        ">=4.3.0,<=4.3.2"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2015-7293",
      "advisory": "Multiple cross-site request forgery (CSRF) vulnerabilities in Zope Management Interface 4.3.7 and earlier, and Plone before 5.x.",
      "cve": "CVE-2015-7293",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2015-7315",
      "advisory": "Plone 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, 4.2.0 through 4.2.7, 4.3.0 through 4.3.6, and 5.0rc1 allows remote attackers to add a new member to a Plone site with registration enabled, without acknowledgment of site administrator.",
      "cve": "CVE-2015-7315",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==5.0-rc1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2015-7316",
      "advisory": "Cross-site scripting (XSS) vulnerability in Plone 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, 4.2.0 through 4.2.7, 4.3.x before 4.3.7, and 5.0rc1.",
      "cve": "CVE-2015-7316",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==5.0-rc1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2015-7317",
      "advisory": "Kupu 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, and 4.2.0 through 4.2.7 allows remote authenticated users to edit Kupu settings.",
      "cve": "CVE-2015-7317",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2015-7318",
      "advisory": "Plone 3.3.0 through 3.3.6 allows remote attackers to inject headers into HTTP responses.",
      "cve": "CVE-2015-7318",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2016-4041",
      "advisory": "Plone 4.0 through 5.1a1 does not have security declarations for Dexterity content-related WebDAV requests, which allows remote attackers to gain webdav access via unspecified vectors.",
      "cve": "CVE-2016-4041",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2016-4042",
      "advisory": "Plone 3.3 through 5.1a1 allows remote attackers to obtain information about the ID of sensitive content via unspecified vectors.",
      "cve": "CVE-2016-4042",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2016-4043",
      "advisory": "Chameleon (five.pt) in Plone 5.0rc1 through 5.1a1 allows remote authenticated users to bypass Restricted Python by leveraging permissions to create or edit templates.",
      "cve": "CVE-2016-4043",
      "specs": [
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2016-7135",
      "advisory": "Directory traversal vulnerability in Plone CMS 5.x through 5.0.6 and 4.2.x through 4.3.11 allows remote administrators to read arbitrary files via a .. (dot dot) in the path parameter in a getFile action to Plone/++theme++barceloneta/@@plone.resourceeditor.filemanager-actions.",
      "cve": "CVE-2016-7135",
      "specs": [
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2016-7136",
      "advisory": "z3c.form in Plone CMS 5.x through 5.0.6 and 4.x through 4.3.11 allows remote attackers to conduct cross-site scripting (XSS) attacks via a crafted GET request.",
      "cve": "CVE-2016-7136",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2016-7137",
      "advisory": "Multiple open redirect vulnerabilities in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allow remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via a URL in the referer parameter to (1) %2b%2bgroupdashboard%2b%2bplone.dashboard1%2bgroup/%2b/portlets.Actions or (2) folder/%2b%2bcontextportlets%2b%2bplone.footerportlets/%2b /portlets.Actions or the (3) came_from parameter to /login_form.",
      "cve": "CVE-2016-7137",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2016-7138",
      "advisory": "Cross-site scripting (XSS) vulnerability in the URL checking infrastructure in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allows remote attackers to inject arbitrary web script or HTML via a crafted URL.",
      "cve": "CVE-2016-7138",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2016-7139",
      "advisory": "Cross-site scripting (XSS) vulnerability in an unspecified page template in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allows remote attackers to inject arbitrary web script or HTML via unknown vectors.",
      "cve": "CVE-2016-7139",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2016-7140",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in the ZMI page in Zope2 in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allow remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2016-7140",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2016-7147",
      "advisory": "Cross-site scripting (XSS) vulnerability in the manage_findResult component in the search feature in Zope ZMI in Plone before 4.3.12 and 5.x before 5.0.7 allows remote attackers to inject arbitrary web script or HTML via vectors involving double quotes, as demonstrated by the obj_ids:tokens parameter. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-7140.",
      "cve": "CVE-2016-7147",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1-a1",
        "==5.1-a2"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2017-1000481",
      "advisory": "When you visit a page where you need to login, Plone 2.5-5.1rc1 sends you to the login form with a 'came_from' parameter set to the previous url. After you login, you get redirected to the page you tried to view before. An attacker might try to abuse this by letting you click on a specially crafted link. You would login, and get redirected to the site of the attacker, letting you think that you are still on the original Plone site. Or some javascript of the attacker could be executed. Most of these types of attacks are already blocked by Plone, using the `isURLInPortal` check to make sure we only redirect to a page on the same Plone site. But a few more ways of tricking Plone into accepting a malicious link were discovered, and fixed with this hotfix.",
      "cve": "CVE-2017-1000481",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2017-1000482",
      "advisory": "A member of the Plone 2.5-5.1rc1 site could set javascript in the home_page property of his profile, and have this executed when a visitor click the home page link on the author page.",
      "cve": "CVE-2017-1000482",
      "specs": [
        "<=5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2017-1000483",
      "advisory": "Accessing private content via str.format in through-the-web templates and scripts in Plone 2.5-5.1rc1. This improves an earlier hotfix. Since the format method was introduced in Python 2.6, this part of the hotfix is only relevant for Plone 4 and 5.",
      "cve": "CVE-2017-1000483",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2017-1000484",
      "advisory": "By linking to a specific url in Plone 2.5-5.1rc1 with a parameter, an attacker could send you to his own website. On its own this is not so bad: the attacker could more easily link directly to his own website instead. But in combination with another attack, you could be sent to the Plone login form and login, then get redirected to the specific url, and then get a second redirect to the attacker website. (The specific url can be seen by inspecting the hotfix code, but we don't want to make it too easy for attackers by spelling it out here.)",
      "cve": "CVE-2017-1000484",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2017-5524",
      "advisory": "Plone 4.x through 4.3.11 and 5.x through 5.0.6 allow remote attackers to bypass a sandbox protection mechanism and obtain sensitive information by leveraging the Python string format method.",
      "cve": "CVE-2017-5524",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1-a1",
        "==5.1-a2"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2020-28734",
      "advisory": "Plone before 5.2.3 allows XXE attacks via a feature that is explicitly only available to the Manager role.",
      "cve": "CVE-2020-28734",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2020-28735",
      "advisory": "Plone before 5.2.3 allows SSRF attacks via the tracebacks feature (only available to the Manager role).",
      "cve": "CVE-2020-28735",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2020-28736",
      "advisory": "Plone before 5.2.3 allows XXE attacks via a feature that is protected by an unapplied permission of plone.schemaeditor.ManageSchemata (therefore, only available to the Manager role).",
      "cve": "CVE-2020-28736",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2020-35190",
      "advisory": "The official plone Docker images before version of 4.3.18-alpine (Alpine specific) contain a blank password for a root user. System using the plone docker container deployed by affected versions of the docker image may allow a remote attacker to achieve root access with a blank password.",
      "cve": "CVE-2020-35190",
      "specs": [
        ">=4.0.0-alpine,<4.3.18-alpine"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2020-7936",
      "advisory": "An open redirect on the login form (and possibly other places) in Plone 4.0 through 5.2.1 allows an attacker to craft a link to a Plone Site that, when followed, and possibly after login, will redirect to an attacker's site.",
      "cve": "CVE-2020-7936",
      "specs": [
        ">=4.0.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2020-7937",
      "advisory": "An XSS issue in the title field in Plone 5.0 through 5.2.1 allows users with a certain privilege level to insert JavaScript that will be executed when other users access the site.",
      "cve": "CVE-2020-7937",
      "specs": [
        ">=5.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2020-7938",
      "advisory": "plone.restapi in Plone 5.2.0 through 5.2.1 allows users with a certain privilege level to escalate their privileges up to the highest level.",
      "cve": "CVE-2020-7938",
      "specs": [
        ">=5.2.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2020-7939",
      "advisory": "SQL Injection in DTML or in connection objects in Plone 4.0 through 5.2.1 allows users to perform unwanted SQL queries. (This is a problem in Zope.)",
      "cve": "CVE-2020-7939",
      "specs": [
        ">=4.0.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2020-7940",
      "advisory": "Missing password strength checks on some forms in Plone 4.3 through 5.2.0 allow users to set weak passwords, leading to easier cracking.",
      "cve": "CVE-2020-7940",
      "specs": [
        ">=4.3.0,<=5.2.0"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2020-7941",
      "advisory": "A privilege escalation issue in plone.app.contenttypes in Plone 4.3 through 5.2.1 allows users to PUT (overwrite) some content without needing write permission.",
      "cve": "CVE-2020-7941",
      "specs": [
        ">=4.3.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2021-29002",
      "advisory": "A stored cross-site scripting (XSS) vulnerability in Plone CMS 5.2.3 exists in site-controlpanel via the \"form.widgets.site_title\" parameter.",
      "cve": "CVE-2021-29002",
      "specs": [
        "==5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2021-32633",
      "advisory": "Zope is an open-source web application server. In Zope versions prior to 4.6 and 5.2, users can access untrusted modules indirectly through Python modules that are available for direct use. By default, only users with the Manager role can add or edit Zope Page Templates through the web, but sites that allow untrusted users to add/edit Zope Page Templates through the web are at risk from this vulnerability. The problem has been fixed in Zope 5.2 and 4.6. As a workaround, a site administrator can restrict adding/editing Zope Page Templates through the web using the standard Zope user/role permission mechanisms. Untrusted users should not be assigned the Zope Manager role and adding/editing Zope Page Templates through the web should be restricted to trusted users only.",
      "cve": "CVE-2021-32633",
      "specs": [
        "<=4.3.20",
        ">=5.0,<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2021-3313",
      "advisory": "Plone CMS until version 5.2.4 has a stored Cross-Site Scripting (XSS) vulnerability in the user fullname property and the file upload functionality. The user's input data is not properly encoded when being echoed back to the user. This data can be interpreted as executable code by the browser and allows an attacker to execute JavaScript in the context of the victim's browser if the victim opens a vulnerable page containing an XSS payload.",
      "cve": "CVE-2021-3313",
      "specs": [
        "<5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2021-33507",
      "advisory": "Zope Products.CMFCore before 2.5.1 and Products.PluggableAuthService before 2.6.2, as used in Plone through 5.2.4 and other products, allow Reflected XSS.",
      "cve": "CVE-2021-33507",
      "specs": [
        "<=4.3.20",
        ">=5.0,<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2021-33508",
      "advisory": "Plone through 5.2.4 allows XSS via a full name that is mishandled during rendering of the ownership tab of a content item.",
      "cve": "CVE-2021-33508",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2021-33509",
      "advisory": "Plone through 5.2.4 allows remote authenticated managers to perform disk I/O via crafted keyword arguments to the ReStructuredText transform in a Python script.",
      "cve": "CVE-2021-33509",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2021-33510",
      "advisory": "Plone through 5.2.4 allows remote authenticated managers to conduct SSRF attacks via an event ical URL, to read one line of a file.",
      "cve": "CVE-2021-33510",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2021-33511",
      "advisory": "Plone though 5.2.4 allows SSRF via the lxml parser. This affects Diazo themes, Dexterity TTW schemas, and modeleditors in plone.app.theming, plone.app.dexterity, and plone.supermodel.",
      "cve": "CVE-2021-33511",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2021-33512",
      "advisory": "Plone through 5.2.4 allows stored XSS attacks (by a Contributor) by uploading an SVG or HTML document.",
      "cve": "CVE-2021-33512",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2021-33513",
      "advisory": "Plone through 5.2.4 allows XSS via the inline_diff methods in Products.CMFDiffTool.",
      "cve": "CVE-2021-33513",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone:CVE-2021-35959",
      "advisory": "In Plone 5.0 through 5.2.4, Editors are vulnerable to XSS in the folder contents view, if a Contributor has created a folder with a SCRIPT tag in the description field.",
      "cve": "CVE-2021-35959",
      "specs": [
        ">=5.0,<=5.2.4"
      ]
    }
  ],
  "plone.app.dexterity": [
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2006-1711",
      "advisory": "Plone 2.0.5, 2.1.2, and 2.5-beta1 does not restrict access to the (1) changeMemberPortrait, (2) deletePersonalPortrait, and (3) testCurrentPassword methods, which allows remote attackers to modify portraits.",
      "cve": "CVE-2006-1711",
      "specs": [
        "==2.0.5",
        "==2.1.2",
        "==2.5_beta1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2006-4247",
      "advisory": "Unspecified vulnerability in the Password Reset Tool before 0.4.1 on Plone 2.5 and 2.5.1 Release Candidate allows attackers to reset the passwords of other users, related to \"an erroneous security declaration.\"",
      "cve": "CVE-2006-4247",
      "specs": [
        "==2.5",
        "==2.5.1_rc"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2006-4249",
      "advisory": "Unspecified vulnerability in PlonePAS in Plone 2.5 and 2.5.1, when anonymous member registration is enabled, allows an attacker to \"masquerade as a group.\"",
      "cve": "CVE-2006-4249",
      "specs": [
        "==2.5",
        "==2.5.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2007-5741",
      "advisory": "Plone 2.5 through 2.5.4 and 3.0 through 3.0.2 allows remote attackers to execute arbitrary Python code via network data containing pickled objects for the (1) statusmessages or (2) linkintegrity module, which the module unpickles and executes.",
      "cve": "CVE-2007-5741",
      "specs": [
        "==2.5",
        "==2.5.1",
        "==2.5.1_rc",
        "==2.5.4",
        "==2.5_beta1",
        "==3.0",
        "==3.0.1",
        "==3.0.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2008-0164",
      "advisory": "Multiple cross-site request forgery (CSRF) vulnerabilities in Plone CMS 3.0.5 and 3.0.6 allow remote attackers to (1) add arbitrary accounts via the join_form page and (2) change the privileges of arbitrary groups via the prefs_groups_overview page.",
      "cve": "CVE-2008-0164",
      "specs": [
        "==3.0.5",
        "==3.0.6"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2008-1393",
      "advisory": "Plone CMS 3.0.5, and probably other 3.x versions, places a base64 encoded form of the username and password in the __ac cookie for the admin account, which makes it easier for remote attackers to obtain administrative privileges by sniffing the network.",
      "cve": "CVE-2008-1393",
      "specs": [
        "<=3",
        "<=3.0.5"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2008-1394",
      "advisory": "Plone CMS before 3 places a base64 encoded form of the username and password in the __ac cookie for all user accounts, which makes it easier for remote attackers to obtain access by sniffing the network.",
      "cve": "CVE-2008-1394",
      "specs": [
        "<=2.5.1",
        "==2.0.5",
        "==2.1.2",
        "==2.1.3-rc1",
        "==2.5",
        "==2.5-beta1",
        "==2.5-beta2"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2008-4571",
      "advisory": "Cross-site scripting (XSS) vulnerability in the LiveSearch module in Plone before 3.0.4 allows remote attackers to inject arbitrary web script or HTML via the Description field for search results, as demonstrated using the onerror Javascript even in an IMG tag.",
      "cve": "CVE-2008-4571",
      "specs": [
        "<=3.0.3",
        "==2.0.5",
        "==2.1.2",
        "==2.5",
        "==2.5.1",
        "==2.5.1_rc",
        "==2.5.4",
        "==2.5_beta1",
        "==3.0",
        "==3.0.1",
        "==3.0.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2010-2422",
      "advisory": "Cross-site scripting (XSS) vulnerability in PortalTransforms in Plone 2.1 through 3.3.4 before hotfix 20100612 allows remote attackers to inject arbitrary web script or HTML via the safe_html transform.",
      "cve": "CVE-2010-2422",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2011-1340",
      "advisory": "Cross-site scripting (XSS) vulnerability in skins/plone_templates/default_error_message.pt in Plone before 2.5.3 allows remote attackers to inject arbitrary web script or HTML via the type_name parameter to Members/ipa/createObject.",
      "cve": "CVE-2011-1340",
      "specs": [
        "<=2.5.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2011-1948",
      "advisory": "Cross-site scripting (XSS) vulnerability in Plone 4.1 and earlier allows remote attackers to inject arbitrary web script or HTML via a crafted URL.",
      "cve": "CVE-2011-1948",
      "specs": [
        "<=4.1",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2011-1949",
      "advisory": "Cross-site scripting (XSS) vulnerability in the safe_html filter in Products.PortalTransforms in Plone 2.1 through 4.1 allows remote authenticated users to inject arbitrary web script or HTML via unspecified vectors, a different vulnerability than CVE-2010-2422.",
      "cve": "CVE-2011-1949",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2011-1950",
      "advisory": "plone.app.users in Plone 4.0 and 4.1 allows remote authenticated users to modify the properties of arbitrary accounts via unspecified vectors, as exploited in the wild in June 2011.",
      "cve": "CVE-2011-1950",
      "specs": [
        "==4.0",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2011-2528",
      "advisory": "Unspecified vulnerability in (1) Zope 2.12.x before 2.12.19 and 2.13.x before 2.13.8, as used in Plone 4.x and other products, and (2) PloneHotfix20110720 for Plone 3.x allows attackers to gain privileges via unspecified vectors, related to a \"highly serious vulnerability.\" NOTE: this vulnerability exists because of an incorrect fix for CVE-2011-0720.",
      "cve": "CVE-2011-2528",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2011-3587",
      "advisory": "Unspecified vulnerability in Zope 2.12.x and 2.13.x, as used in Plone 4.0.x through 4.0.9, 4.1, and 4.2 through 4.2a2, allows remote attackers to execute arbitrary commands via vectors related to the p_ class in OFS/misc_.py and the use of Python modules.",
      "cve": "CVE-2011-3587",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.2",
        "==4.2a1",
        "==4.2a2"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2011-4030",
      "advisory": "The CMFEditions component 2.x in Plone 4.0.x through 4.0.9, 4.1, and 4.2 through 4.2a2 does not prevent the KwAsAttributes classes from being publishable, which allows remote attackers to access sub-objects via unspecified vectors, a different vulnerability than CVE-2011-3587.",
      "cve": "CVE-2011-4030",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.2",
        "==4.2a1",
        "==4.2a2"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2011-4462",
      "advisory": "Plone 4.1.3 and earlier computes hash values for form parameters without restricting the ability to trigger hash collisions predictably, which allows remote attackers to cause a denial of service (CPU consumption) by sending many crafted parameters.",
      "cve": "CVE-2011-4462",
      "specs": [
        "<=4.1.3",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5485",
      "advisory": "registerConfiglet.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via unspecified vectors, related to the admin interface.",
      "cve": "CVE-2012-5485",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5486",
      "advisory": "ZPublisher.HTTPRequest._scrubHeader in Zope 2 before 2.13.19, as used in Plone before 4.3 beta 1, allows remote attackers to inject arbitrary HTTP headers via a linefeed (LF) character.",
      "cve": "CVE-2012-5486",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5487",
      "advisory": "The sandbox whitelisting function (allowmodule.py) in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with certain privileges to bypass the Python sandbox restriction and execute arbitrary Python code via vectors related to importing.",
      "cve": "CVE-2012-5487",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5488",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via a crafted URL, related to createObject.",
      "cve": "CVE-2012-5488",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5489",
      "advisory": "The App.Undo.UndoSupport.get_request_var_or_attr function in Zope before 2.12.21 and 3.13.x before 2.13.11, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote authenticated users to gain access to restricted attributes via unspecified vectors.",
      "cve": "CVE-2012-5489",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5490",
      "advisory": "Cross-site scripting (XSS) vulnerability in kssdevel.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5490",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5491",
      "advisory": "z3c.form, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote attackers to obtain the default form field values by leveraging knowledge of the form location and the element id.",
      "cve": "CVE-2012-5491",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5492",
      "advisory": "uid_catalog.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to obtain metadata about hidden objects via a crafted URL.",
      "cve": "CVE-2012-5492",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5493",
      "advisory": "gtbn.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with certain permissions to bypass the Python sandbox and execute arbitrary Python code via unspecified vectors.",
      "cve": "CVE-2012-5493",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5494",
      "advisory": "Cross-site scripting (XSS) vulnerability in python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors, related to \"{u,}translate.\"",
      "cve": "CVE-2012-5494",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5495",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via a crafted URL, related to \"go_back.\"",
      "cve": "CVE-2012-5495",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5496",
      "advisory": "kupu_spellcheck.py in Kupu in Plone before 4.0 allows remote attackers to cause a denial of service (ZServer thread lock) via a crafted URL.",
      "cve": "CVE-2012-5496",
      "specs": [
        "<=3.3.5",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5497",
      "advisory": "membership_tool.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to enumerate user account names via a crafted URL.",
      "cve": "CVE-2012-5497",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5498",
      "advisory": "queryCatalog.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to bypass caching and cause a denial of service via a crafted request to a collection.",
      "cve": "CVE-2012-5498",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5499",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to cause a denial of service (memory consumption) via a large value, related to formatColumns.",
      "cve": "CVE-2012-5499",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5500",
      "advisory": "The batch id change script (renameObjectsByPaths.py) in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to change the titles of content items by leveraging a valid CSRF token in a crafted request.",
      "cve": "CVE-2012-5500",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5501",
      "advisory": "at_download.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read arbitrary BLOBs (Files and Images) stored on custom content types via a crafted URL.",
      "cve": "CVE-2012-5501",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5502",
      "advisory": "Cross-site scripting (XSS) vulnerability in safe_html.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with permissions to edit content to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5502",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5503",
      "advisory": "ftp.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read hidden folder contents via unspecified vectors.",
      "cve": "CVE-2012-5503",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5504",
      "advisory": "Cross-site scripting (XSS) vulnerability in widget_traversal.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5504",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5505",
      "advisory": "atat.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read private data structures via a request for a view without a name.",
      "cve": "CVE-2012-5505",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5506",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to cause a denial of service (infinite loop) via an RSS feed request for a folder the user does not have permission to access.",
      "cve": "CVE-2012-5506",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5507",
      "advisory": "AccessControl/AuthEncoding.py in Zope before 2.13.19, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote attackers to obtain passwords via vectors involving timing discrepancies in password validation.",
      "cve": "CVE-2012-5507",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-5508",
      "advisory": "The error pages in Plone before 4.2.3 and 4.3 before beta 1 allow remote attackers to obtain random numbers and derive the PRNG state for password resets via unspecified vectors.  NOTE: this identifier was SPLIT per ADT2 due to different vulnerability types. CVE-2012-6661 was assigned for the PRNG reseeding issue in Zope.",
      "cve": "CVE-2012-5508",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2012-6661",
      "advisory": "Zope before 2.13.19, as used in Plone before 4.2.3 and 4.3 before beta 1, does not reseed the pseudo-random number generator (PRNG), which makes it easier for remote attackers to guess the value via unspecified vectors.  NOTE: this issue was SPLIT from CVE-2012-5508 due to different vulnerability types (ADT2).",
      "cve": "CVE-2012-6661",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2013-4188",
      "advisory": "traverser.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote attackers with administrator privileges to cause a denial of service (infinite loop and resource consumption) via unspecified vectors related to \"retrieving information for certain resources.\"",
      "cve": "CVE-2013-4188",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2013-4189",
      "advisory": "Multiple unspecified vulnerabilities in (1) dataitems.py, (2) get.py, and (3) traverseName.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote authenticated users with administrator access to a subtree to access nodes above the subtree via unknown vectors.",
      "cve": "CVE-2013-4189",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2013-4190",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in (1) spamProtect.py, (2) pts.py, and (3) request.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2013-4190",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2013-4191",
      "advisory": "zip.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly enforce access restrictions when including content in a zip archive, which allows remote attackers to obtain sensitive information by reading a generated archive.",
      "cve": "CVE-2013-4191",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2013-4192",
      "advisory": "sendto.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to spoof emails via unspecified vectors.",
      "cve": "CVE-2013-4192",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2013-4193",
      "advisory": "typeswidget.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly enforce the immutable setting on unspecified content edit forms, which allows remote attackers to hide fields on the forms via a crafted URL.",
      "cve": "CVE-2013-4193",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2013-4194",
      "advisory": "The WYSIWYG component (wysiwyg.py) in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote attackers to obtain sensitive information via a crafted URL, which reveals the installation path in an error message.",
      "cve": "CVE-2013-4194",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2013-4195",
      "advisory": "Multiple open redirect vulnerabilities in (1) marmoset_patch.py, (2) publish.py, and (3) principiaredirect.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via unspecified vectors.",
      "cve": "CVE-2013-4195",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2013-4196",
      "advisory": "The object manager implementation (objectmanager.py) in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly restrict access to internal methods, which allows remote attackers to obtain sensitive information via a crafted request.",
      "cve": "CVE-2013-4196",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2013-4197",
      "advisory": "member_portrait.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to modify or delete portraits of other users via unspecified vectors.",
      "cve": "CVE-2013-4197",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2013-4198",
      "advisory": "mail_password.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to bypass the prohibition on password changes via the forgotten password email functionality.",
      "cve": "CVE-2013-4198",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2013-4199",
      "advisory": "(1) cb_decode.py and (2) linkintegrity.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote authenticated users to cause a denial of service (resource consumption) via a large zip archive, which is expanded (decompressed).",
      "cve": "CVE-2013-4199",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2013-4200",
      "advisory": "The isURLInPortal method in the URLTool class in in_portal.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 treats URLs starting with a space as a relative URL, which allows remote attackers to bypass the allow_external_login_sites filtering property,  redirect users to arbitrary web sites, and conduct phishing attacks via a space before a URL in the \"next\" parameter to acl_users/credentials_cookie_auth/require_login.",
      "cve": "CVE-2013-4200",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2013-7060",
      "advisory": "Products/CMFPlone/FactoryTool.py in Plone 3.3 through 4.3.2 allows remote attackers to obtain the installation path via vectors related to a file object for unspecified documentation which is initialized in class scope.",
      "cve": "CVE-2013-7060",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2013-7061",
      "advisory": "Products/CMFPlone/CatalogTool.py in Plone 3.3 through 4.3.2 allows remote administrators to bypass restrictions and obtain sensitive information via an unspecified search API.",
      "cve": "CVE-2013-7061",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2013-7062",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in Zope, as used in Plone 3.3.x through 3.3.6, 4.0.x through 4.0.9, 4.1.x through 4.1.6, 4.2.x through 4.2.7, and 4.3 through 4.3.2, allow remote attackers to inject arbitrary web script or HTML via unspecified input in the (1) browser_id_manager or (2) OFS.Image method.",
      "cve": "CVE-2013-7062",
      "specs": [
        ">=3.3.0,<=3.3.6",
        ">=4.0.0,<=4.0.9",
        ">=4.1.0,<=4.1.6",
        ">=4.2.0,<=4.2.7",
        ">=4.3.0,<=4.3.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2015-7293",
      "advisory": "Multiple cross-site request forgery (CSRF) vulnerabilities in Zope Management Interface 4.3.7 and earlier, and Plone before 5.x.",
      "cve": "CVE-2015-7293",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2015-7315",
      "advisory": "Plone 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, 4.2.0 through 4.2.7, 4.3.0 through 4.3.6, and 5.0rc1 allows remote attackers to add a new member to a Plone site with registration enabled, without acknowledgment of site administrator.",
      "cve": "CVE-2015-7315",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==5.0-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2015-7316",
      "advisory": "Cross-site scripting (XSS) vulnerability in Plone 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, 4.2.0 through 4.2.7, 4.3.x before 4.3.7, and 5.0rc1.",
      "cve": "CVE-2015-7316",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==5.0-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2015-7317",
      "advisory": "Kupu 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, and 4.2.0 through 4.2.7 allows remote authenticated users to edit Kupu settings.",
      "cve": "CVE-2015-7317",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2015-7318",
      "advisory": "Plone 3.3.0 through 3.3.6 allows remote attackers to inject headers into HTTP responses.",
      "cve": "CVE-2015-7318",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2016-4041",
      "advisory": "Plone 4.0 through 5.1a1 does not have security declarations for Dexterity content-related WebDAV requests, which allows remote attackers to gain webdav access via unspecified vectors.",
      "cve": "CVE-2016-4041",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2016-4042",
      "advisory": "Plone 3.3 through 5.1a1 allows remote attackers to obtain information about the ID of sensitive content via unspecified vectors.",
      "cve": "CVE-2016-4042",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2016-4043",
      "advisory": "Chameleon (five.pt) in Plone 5.0rc1 through 5.1a1 allows remote authenticated users to bypass Restricted Python by leveraging permissions to create or edit templates.",
      "cve": "CVE-2016-4043",
      "specs": [
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2016-7135",
      "advisory": "Directory traversal vulnerability in Plone CMS 5.x through 5.0.6 and 4.2.x through 4.3.11 allows remote administrators to read arbitrary files via a .. (dot dot) in the path parameter in a getFile action to Plone/++theme++barceloneta/@@plone.resourceeditor.filemanager-actions.",
      "cve": "CVE-2016-7135",
      "specs": [
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2016-7136",
      "advisory": "z3c.form in Plone CMS 5.x through 5.0.6 and 4.x through 4.3.11 allows remote attackers to conduct cross-site scripting (XSS) attacks via a crafted GET request.",
      "cve": "CVE-2016-7136",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2016-7137",
      "advisory": "Multiple open redirect vulnerabilities in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allow remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via a URL in the referer parameter to (1) %2b%2bgroupdashboard%2b%2bplone.dashboard1%2bgroup/%2b/portlets.Actions or (2) folder/%2b%2bcontextportlets%2b%2bplone.footerportlets/%2b /portlets.Actions or the (3) came_from parameter to /login_form.",
      "cve": "CVE-2016-7137",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2016-7138",
      "advisory": "Cross-site scripting (XSS) vulnerability in the URL checking infrastructure in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allows remote attackers to inject arbitrary web script or HTML via a crafted URL.",
      "cve": "CVE-2016-7138",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2016-7139",
      "advisory": "Cross-site scripting (XSS) vulnerability in an unspecified page template in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allows remote attackers to inject arbitrary web script or HTML via unknown vectors.",
      "cve": "CVE-2016-7139",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2016-7140",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in the ZMI page in Zope2 in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allow remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2016-7140",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2016-7147",
      "advisory": "Cross-site scripting (XSS) vulnerability in the manage_findResult component in the search feature in Zope ZMI in Plone before 4.3.12 and 5.x before 5.0.7 allows remote attackers to inject arbitrary web script or HTML via vectors involving double quotes, as demonstrated by the obj_ids:tokens parameter. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-7140.",
      "cve": "CVE-2016-7147",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1-a1",
        "==5.1-a2"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2017-1000481",
      "advisory": "When you visit a page where you need to login, Plone 2.5-5.1rc1 sends you to the login form with a 'came_from' parameter set to the previous url. After you login, you get redirected to the page you tried to view before. An attacker might try to abuse this by letting you click on a specially crafted link. You would login, and get redirected to the site of the attacker, letting you think that you are still on the original Plone site. Or some javascript of the attacker could be executed. Most of these types of attacks are already blocked by Plone, using the `isURLInPortal` check to make sure we only redirect to a page on the same Plone site. But a few more ways of tricking Plone into accepting a malicious link were discovered, and fixed with this hotfix.",
      "cve": "CVE-2017-1000481",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2017-1000482",
      "advisory": "A member of the Plone 2.5-5.1rc1 site could set javascript in the home_page property of his profile, and have this executed when a visitor click the home page link on the author page.",
      "cve": "CVE-2017-1000482",
      "specs": [
        "<=5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2017-1000483",
      "advisory": "Accessing private content via str.format in through-the-web templates and scripts in Plone 2.5-5.1rc1. This improves an earlier hotfix. Since the format method was introduced in Python 2.6, this part of the hotfix is only relevant for Plone 4 and 5.",
      "cve": "CVE-2017-1000483",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2017-1000484",
      "advisory": "By linking to a specific url in Plone 2.5-5.1rc1 with a parameter, an attacker could send you to his own website. On its own this is not so bad: the attacker could more easily link directly to his own website instead. But in combination with another attack, you could be sent to the Plone login form and login, then get redirected to the specific url, and then get a second redirect to the attacker website. (The specific url can be seen by inspecting the hotfix code, but we don't want to make it too easy for attackers by spelling it out here.)",
      "cve": "CVE-2017-1000484",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2017-5524",
      "advisory": "Plone 4.x through 4.3.11 and 5.x through 5.0.6 allow remote attackers to bypass a sandbox protection mechanism and obtain sensitive information by leveraging the Python string format method.",
      "cve": "CVE-2017-5524",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1-a1",
        "==5.1-a2"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2020-28734",
      "advisory": "Plone before 5.2.3 allows XXE attacks via a feature that is explicitly only available to the Manager role.",
      "cve": "CVE-2020-28734",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2020-28735",
      "advisory": "Plone before 5.2.3 allows SSRF attacks via the tracebacks feature (only available to the Manager role).",
      "cve": "CVE-2020-28735",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2020-28736",
      "advisory": "Plone before 5.2.3 allows XXE attacks via a feature that is protected by an unapplied permission of plone.schemaeditor.ManageSchemata (therefore, only available to the Manager role).",
      "cve": "CVE-2020-28736",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2020-35190",
      "advisory": "The official plone Docker images before version of 4.3.18-alpine (Alpine specific) contain a blank password for a root user. System using the plone docker container deployed by affected versions of the docker image may allow a remote attacker to achieve root access with a blank password.",
      "cve": "CVE-2020-35190",
      "specs": [
        ">=4.0.0-alpine,<4.3.18-alpine"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2020-7936",
      "advisory": "An open redirect on the login form (and possibly other places) in Plone 4.0 through 5.2.1 allows an attacker to craft a link to a Plone Site that, when followed, and possibly after login, will redirect to an attacker's site.",
      "cve": "CVE-2020-7936",
      "specs": [
        ">=4.0.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2020-7937",
      "advisory": "An XSS issue in the title field in Plone 5.0 through 5.2.1 allows users with a certain privilege level to insert JavaScript that will be executed when other users access the site.",
      "cve": "CVE-2020-7937",
      "specs": [
        ">=5.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2020-7938",
      "advisory": "plone.restapi in Plone 5.2.0 through 5.2.1 allows users with a certain privilege level to escalate their privileges up to the highest level.",
      "cve": "CVE-2020-7938",
      "specs": [
        ">=5.2.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2020-7939",
      "advisory": "SQL Injection in DTML or in connection objects in Plone 4.0 through 5.2.1 allows users to perform unwanted SQL queries. (This is a problem in Zope.)",
      "cve": "CVE-2020-7939",
      "specs": [
        ">=4.0.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2020-7940",
      "advisory": "Missing password strength checks on some forms in Plone 4.3 through 5.2.0 allow users to set weak passwords, leading to easier cracking.",
      "cve": "CVE-2020-7940",
      "specs": [
        ">=4.3.0,<=5.2.0"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2020-7941",
      "advisory": "A privilege escalation issue in plone.app.contenttypes in Plone 4.3 through 5.2.1 allows users to PUT (overwrite) some content without needing write permission.",
      "cve": "CVE-2020-7941",
      "specs": [
        ">=4.3.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2021-29002",
      "advisory": "A stored cross-site scripting (XSS) vulnerability in Plone CMS 5.2.3 exists in site-controlpanel via the \"form.widgets.site_title\" parameter.",
      "cve": "CVE-2021-29002",
      "specs": [
        "==5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2021-32633",
      "advisory": "Zope is an open-source web application server. In Zope versions prior to 4.6 and 5.2, users can access untrusted modules indirectly through Python modules that are available for direct use. By default, only users with the Manager role can add or edit Zope Page Templates through the web, but sites that allow untrusted users to add/edit Zope Page Templates through the web are at risk from this vulnerability. The problem has been fixed in Zope 5.2 and 4.6. As a workaround, a site administrator can restrict adding/editing Zope Page Templates through the web using the standard Zope user/role permission mechanisms. Untrusted users should not be assigned the Zope Manager role and adding/editing Zope Page Templates through the web should be restricted to trusted users only.",
      "cve": "CVE-2021-32633",
      "specs": [
        "<=4.3.20",
        ">=5.0,<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2021-3313",
      "advisory": "Plone CMS until version 5.2.4 has a stored Cross-Site Scripting (XSS) vulnerability in the user fullname property and the file upload functionality. The user's input data is not properly encoded when being echoed back to the user. This data can be interpreted as executable code by the browser and allows an attacker to execute JavaScript in the context of the victim's browser if the victim opens a vulnerable page containing an XSS payload.",
      "cve": "CVE-2021-3313",
      "specs": [
        "<5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2021-33507",
      "advisory": "Zope Products.CMFCore before 2.5.1 and Products.PluggableAuthService before 2.6.2, as used in Plone through 5.2.4 and other products, allow Reflected XSS.",
      "cve": "CVE-2021-33507",
      "specs": [
        "<=4.3.20",
        ">=5.0,<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2021-33508",
      "advisory": "Plone through 5.2.4 allows XSS via a full name that is mishandled during rendering of the ownership tab of a content item.",
      "cve": "CVE-2021-33508",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2021-33509",
      "advisory": "Plone through 5.2.4 allows remote authenticated managers to perform disk I/O via crafted keyword arguments to the ReStructuredText transform in a Python script.",
      "cve": "CVE-2021-33509",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2021-33510",
      "advisory": "Plone through 5.2.4 allows remote authenticated managers to conduct SSRF attacks via an event ical URL, to read one line of a file.",
      "cve": "CVE-2021-33510",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2021-33511",
      "advisory": "Plone though 5.2.4 allows SSRF via the lxml parser. This affects Diazo themes, Dexterity TTW schemas, and modeleditors in plone.app.theming, plone.app.dexterity, and plone.supermodel.",
      "cve": "CVE-2021-33511",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2021-33512",
      "advisory": "Plone through 5.2.4 allows stored XSS attacks (by a Contributor) by uploading an SVG or HTML document.",
      "cve": "CVE-2021-33512",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2021-33513",
      "advisory": "Plone through 5.2.4 allows XSS via the inline_diff methods in Products.CMFDiffTool.",
      "cve": "CVE-2021-33513",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.dexterity:CVE-2021-35959",
      "advisory": "In Plone 5.0 through 5.2.4, Editors are vulnerable to XSS in the folder contents view, if a Contributor has created a folder with a SCRIPT tag in the description field.",
      "cve": "CVE-2021-35959",
      "specs": [
        ">=5.0,<=5.2.4"
      ]
    }
  ],
  "plone.app.event": [
    {
      "id": "pyup.io-plone.app.event:CVE-2006-1711",
      "advisory": "Plone 2.0.5, 2.1.2, and 2.5-beta1 does not restrict access to the (1) changeMemberPortrait, (2) deletePersonalPortrait, and (3) testCurrentPassword methods, which allows remote attackers to modify portraits.",
      "cve": "CVE-2006-1711",
      "specs": [
        "==2.0.5",
        "==2.1.2",
        "==2.5_beta1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2006-4247",
      "advisory": "Unspecified vulnerability in the Password Reset Tool before 0.4.1 on Plone 2.5 and 2.5.1 Release Candidate allows attackers to reset the passwords of other users, related to \"an erroneous security declaration.\"",
      "cve": "CVE-2006-4247",
      "specs": [
        "==2.5",
        "==2.5.1_rc"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2006-4249",
      "advisory": "Unspecified vulnerability in PlonePAS in Plone 2.5 and 2.5.1, when anonymous member registration is enabled, allows an attacker to \"masquerade as a group.\"",
      "cve": "CVE-2006-4249",
      "specs": [
        "==2.5",
        "==2.5.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2007-5741",
      "advisory": "Plone 2.5 through 2.5.4 and 3.0 through 3.0.2 allows remote attackers to execute arbitrary Python code via network data containing pickled objects for the (1) statusmessages or (2) linkintegrity module, which the module unpickles and executes.",
      "cve": "CVE-2007-5741",
      "specs": [
        "==2.5",
        "==2.5.1",
        "==2.5.1_rc",
        "==2.5.4",
        "==2.5_beta1",
        "==3.0",
        "==3.0.1",
        "==3.0.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2008-0164",
      "advisory": "Multiple cross-site request forgery (CSRF) vulnerabilities in Plone CMS 3.0.5 and 3.0.6 allow remote attackers to (1) add arbitrary accounts via the join_form page and (2) change the privileges of arbitrary groups via the prefs_groups_overview page.",
      "cve": "CVE-2008-0164",
      "specs": [
        "==3.0.5",
        "==3.0.6"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2008-1393",
      "advisory": "Plone CMS 3.0.5, and probably other 3.x versions, places a base64 encoded form of the username and password in the __ac cookie for the admin account, which makes it easier for remote attackers to obtain administrative privileges by sniffing the network.",
      "cve": "CVE-2008-1393",
      "specs": [
        "<=3",
        "<=3.0.5"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2008-1394",
      "advisory": "Plone CMS before 3 places a base64 encoded form of the username and password in the __ac cookie for all user accounts, which makes it easier for remote attackers to obtain access by sniffing the network.",
      "cve": "CVE-2008-1394",
      "specs": [
        "<=2.5.1",
        "==2.0.5",
        "==2.1.2",
        "==2.1.3-rc1",
        "==2.5",
        "==2.5-beta1",
        "==2.5-beta2"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2008-4571",
      "advisory": "Cross-site scripting (XSS) vulnerability in the LiveSearch module in Plone before 3.0.4 allows remote attackers to inject arbitrary web script or HTML via the Description field for search results, as demonstrated using the onerror Javascript even in an IMG tag.",
      "cve": "CVE-2008-4571",
      "specs": [
        "<=3.0.3",
        "==2.0.5",
        "==2.1.2",
        "==2.5",
        "==2.5.1",
        "==2.5.1_rc",
        "==2.5.4",
        "==2.5_beta1",
        "==3.0",
        "==3.0.1",
        "==3.0.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2010-2422",
      "advisory": "Cross-site scripting (XSS) vulnerability in PortalTransforms in Plone 2.1 through 3.3.4 before hotfix 20100612 allows remote attackers to inject arbitrary web script or HTML via the safe_html transform.",
      "cve": "CVE-2010-2422",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2011-1340",
      "advisory": "Cross-site scripting (XSS) vulnerability in skins/plone_templates/default_error_message.pt in Plone before 2.5.3 allows remote attackers to inject arbitrary web script or HTML via the type_name parameter to Members/ipa/createObject.",
      "cve": "CVE-2011-1340",
      "specs": [
        "<=2.5.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2011-1948",
      "advisory": "Cross-site scripting (XSS) vulnerability in Plone 4.1 and earlier allows remote attackers to inject arbitrary web script or HTML via a crafted URL.",
      "cve": "CVE-2011-1948",
      "specs": [
        "<=4.1",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2011-1949",
      "advisory": "Cross-site scripting (XSS) vulnerability in the safe_html filter in Products.PortalTransforms in Plone 2.1 through 4.1 allows remote authenticated users to inject arbitrary web script or HTML via unspecified vectors, a different vulnerability than CVE-2010-2422.",
      "cve": "CVE-2011-1949",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2011-1950",
      "advisory": "plone.app.users in Plone 4.0 and 4.1 allows remote authenticated users to modify the properties of arbitrary accounts via unspecified vectors, as exploited in the wild in June 2011.",
      "cve": "CVE-2011-1950",
      "specs": [
        "==4.0",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2011-2528",
      "advisory": "Unspecified vulnerability in (1) Zope 2.12.x before 2.12.19 and 2.13.x before 2.13.8, as used in Plone 4.x and other products, and (2) PloneHotfix20110720 for Plone 3.x allows attackers to gain privileges via unspecified vectors, related to a \"highly serious vulnerability.\" NOTE: this vulnerability exists because of an incorrect fix for CVE-2011-0720.",
      "cve": "CVE-2011-2528",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2011-3587",
      "advisory": "Unspecified vulnerability in Zope 2.12.x and 2.13.x, as used in Plone 4.0.x through 4.0.9, 4.1, and 4.2 through 4.2a2, allows remote attackers to execute arbitrary commands via vectors related to the p_ class in OFS/misc_.py and the use of Python modules.",
      "cve": "CVE-2011-3587",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.2",
        "==4.2a1",
        "==4.2a2"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2011-4030",
      "advisory": "The CMFEditions component 2.x in Plone 4.0.x through 4.0.9, 4.1, and 4.2 through 4.2a2 does not prevent the KwAsAttributes classes from being publishable, which allows remote attackers to access sub-objects via unspecified vectors, a different vulnerability than CVE-2011-3587.",
      "cve": "CVE-2011-4030",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.2",
        "==4.2a1",
        "==4.2a2"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2011-4462",
      "advisory": "Plone 4.1.3 and earlier computes hash values for form parameters without restricting the ability to trigger hash collisions predictably, which allows remote attackers to cause a denial of service (CPU consumption) by sending many crafted parameters.",
      "cve": "CVE-2011-4462",
      "specs": [
        "<=4.1.3",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5485",
      "advisory": "registerConfiglet.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via unspecified vectors, related to the admin interface.",
      "cve": "CVE-2012-5485",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5486",
      "advisory": "ZPublisher.HTTPRequest._scrubHeader in Zope 2 before 2.13.19, as used in Plone before 4.3 beta 1, allows remote attackers to inject arbitrary HTTP headers via a linefeed (LF) character.",
      "cve": "CVE-2012-5486",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5487",
      "advisory": "The sandbox whitelisting function (allowmodule.py) in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with certain privileges to bypass the Python sandbox restriction and execute arbitrary Python code via vectors related to importing.",
      "cve": "CVE-2012-5487",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5488",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via a crafted URL, related to createObject.",
      "cve": "CVE-2012-5488",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5489",
      "advisory": "The App.Undo.UndoSupport.get_request_var_or_attr function in Zope before 2.12.21 and 3.13.x before 2.13.11, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote authenticated users to gain access to restricted attributes via unspecified vectors.",
      "cve": "CVE-2012-5489",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5490",
      "advisory": "Cross-site scripting (XSS) vulnerability in kssdevel.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5490",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5491",
      "advisory": "z3c.form, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote attackers to obtain the default form field values by leveraging knowledge of the form location and the element id.",
      "cve": "CVE-2012-5491",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5492",
      "advisory": "uid_catalog.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to obtain metadata about hidden objects via a crafted URL.",
      "cve": "CVE-2012-5492",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5493",
      "advisory": "gtbn.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with certain permissions to bypass the Python sandbox and execute arbitrary Python code via unspecified vectors.",
      "cve": "CVE-2012-5493",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5494",
      "advisory": "Cross-site scripting (XSS) vulnerability in python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors, related to \"{u,}translate.\"",
      "cve": "CVE-2012-5494",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5495",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via a crafted URL, related to \"go_back.\"",
      "cve": "CVE-2012-5495",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5496",
      "advisory": "kupu_spellcheck.py in Kupu in Plone before 4.0 allows remote attackers to cause a denial of service (ZServer thread lock) via a crafted URL.",
      "cve": "CVE-2012-5496",
      "specs": [
        "<=3.3.5",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5497",
      "advisory": "membership_tool.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to enumerate user account names via a crafted URL.",
      "cve": "CVE-2012-5497",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5498",
      "advisory": "queryCatalog.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to bypass caching and cause a denial of service via a crafted request to a collection.",
      "cve": "CVE-2012-5498",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5499",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to cause a denial of service (memory consumption) via a large value, related to formatColumns.",
      "cve": "CVE-2012-5499",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5500",
      "advisory": "The batch id change script (renameObjectsByPaths.py) in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to change the titles of content items by leveraging a valid CSRF token in a crafted request.",
      "cve": "CVE-2012-5500",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5501",
      "advisory": "at_download.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read arbitrary BLOBs (Files and Images) stored on custom content types via a crafted URL.",
      "cve": "CVE-2012-5501",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5502",
      "advisory": "Cross-site scripting (XSS) vulnerability in safe_html.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with permissions to edit content to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5502",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5503",
      "advisory": "ftp.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read hidden folder contents via unspecified vectors.",
      "cve": "CVE-2012-5503",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5504",
      "advisory": "Cross-site scripting (XSS) vulnerability in widget_traversal.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5504",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5505",
      "advisory": "atat.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read private data structures via a request for a view without a name.",
      "cve": "CVE-2012-5505",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5506",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to cause a denial of service (infinite loop) via an RSS feed request for a folder the user does not have permission to access.",
      "cve": "CVE-2012-5506",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5507",
      "advisory": "AccessControl/AuthEncoding.py in Zope before 2.13.19, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote attackers to obtain passwords via vectors involving timing discrepancies in password validation.",
      "cve": "CVE-2012-5507",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-5508",
      "advisory": "The error pages in Plone before 4.2.3 and 4.3 before beta 1 allow remote attackers to obtain random numbers and derive the PRNG state for password resets via unspecified vectors.  NOTE: this identifier was SPLIT per ADT2 due to different vulnerability types. CVE-2012-6661 was assigned for the PRNG reseeding issue in Zope.",
      "cve": "CVE-2012-5508",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2012-6661",
      "advisory": "Zope before 2.13.19, as used in Plone before 4.2.3 and 4.3 before beta 1, does not reseed the pseudo-random number generator (PRNG), which makes it easier for remote attackers to guess the value via unspecified vectors.  NOTE: this issue was SPLIT from CVE-2012-5508 due to different vulnerability types (ADT2).",
      "cve": "CVE-2012-6661",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2013-4188",
      "advisory": "traverser.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote attackers with administrator privileges to cause a denial of service (infinite loop and resource consumption) via unspecified vectors related to \"retrieving information for certain resources.\"",
      "cve": "CVE-2013-4188",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2013-4189",
      "advisory": "Multiple unspecified vulnerabilities in (1) dataitems.py, (2) get.py, and (3) traverseName.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote authenticated users with administrator access to a subtree to access nodes above the subtree via unknown vectors.",
      "cve": "CVE-2013-4189",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2013-4190",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in (1) spamProtect.py, (2) pts.py, and (3) request.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2013-4190",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2013-4191",
      "advisory": "zip.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly enforce access restrictions when including content in a zip archive, which allows remote attackers to obtain sensitive information by reading a generated archive.",
      "cve": "CVE-2013-4191",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2013-4192",
      "advisory": "sendto.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to spoof emails via unspecified vectors.",
      "cve": "CVE-2013-4192",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2013-4193",
      "advisory": "typeswidget.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly enforce the immutable setting on unspecified content edit forms, which allows remote attackers to hide fields on the forms via a crafted URL.",
      "cve": "CVE-2013-4193",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2013-4194",
      "advisory": "The WYSIWYG component (wysiwyg.py) in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote attackers to obtain sensitive information via a crafted URL, which reveals the installation path in an error message.",
      "cve": "CVE-2013-4194",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2013-4195",
      "advisory": "Multiple open redirect vulnerabilities in (1) marmoset_patch.py, (2) publish.py, and (3) principiaredirect.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via unspecified vectors.",
      "cve": "CVE-2013-4195",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2013-4196",
      "advisory": "The object manager implementation (objectmanager.py) in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly restrict access to internal methods, which allows remote attackers to obtain sensitive information via a crafted request.",
      "cve": "CVE-2013-4196",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2013-4197",
      "advisory": "member_portrait.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to modify or delete portraits of other users via unspecified vectors.",
      "cve": "CVE-2013-4197",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2013-4198",
      "advisory": "mail_password.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to bypass the prohibition on password changes via the forgotten password email functionality.",
      "cve": "CVE-2013-4198",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2013-4199",
      "advisory": "(1) cb_decode.py and (2) linkintegrity.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote authenticated users to cause a denial of service (resource consumption) via a large zip archive, which is expanded (decompressed).",
      "cve": "CVE-2013-4199",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2013-4200",
      "advisory": "The isURLInPortal method in the URLTool class in in_portal.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 treats URLs starting with a space as a relative URL, which allows remote attackers to bypass the allow_external_login_sites filtering property,  redirect users to arbitrary web sites, and conduct phishing attacks via a space before a URL in the \"next\" parameter to acl_users/credentials_cookie_auth/require_login.",
      "cve": "CVE-2013-4200",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2013-7060",
      "advisory": "Products/CMFPlone/FactoryTool.py in Plone 3.3 through 4.3.2 allows remote attackers to obtain the installation path via vectors related to a file object for unspecified documentation which is initialized in class scope.",
      "cve": "CVE-2013-7060",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2013-7061",
      "advisory": "Products/CMFPlone/CatalogTool.py in Plone 3.3 through 4.3.2 allows remote administrators to bypass restrictions and obtain sensitive information via an unspecified search API.",
      "cve": "CVE-2013-7061",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2013-7062",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in Zope, as used in Plone 3.3.x through 3.3.6, 4.0.x through 4.0.9, 4.1.x through 4.1.6, 4.2.x through 4.2.7, and 4.3 through 4.3.2, allow remote attackers to inject arbitrary web script or HTML via unspecified input in the (1) browser_id_manager or (2) OFS.Image method.",
      "cve": "CVE-2013-7062",
      "specs": [
        ">=3.3.0,<=3.3.6",
        ">=4.0.0,<=4.0.9",
        ">=4.1.0,<=4.1.6",
        ">=4.2.0,<=4.2.7",
        ">=4.3.0,<=4.3.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2015-7293",
      "advisory": "Multiple cross-site request forgery (CSRF) vulnerabilities in Zope Management Interface 4.3.7 and earlier, and Plone before 5.x.",
      "cve": "CVE-2015-7293",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2015-7315",
      "advisory": "Plone 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, 4.2.0 through 4.2.7, 4.3.0 through 4.3.6, and 5.0rc1 allows remote attackers to add a new member to a Plone site with registration enabled, without acknowledgment of site administrator.",
      "cve": "CVE-2015-7315",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==5.0-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2015-7316",
      "advisory": "Cross-site scripting (XSS) vulnerability in Plone 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, 4.2.0 through 4.2.7, 4.3.x before 4.3.7, and 5.0rc1.",
      "cve": "CVE-2015-7316",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==5.0-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2015-7317",
      "advisory": "Kupu 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, and 4.2.0 through 4.2.7 allows remote authenticated users to edit Kupu settings.",
      "cve": "CVE-2015-7317",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2015-7318",
      "advisory": "Plone 3.3.0 through 3.3.6 allows remote attackers to inject headers into HTTP responses.",
      "cve": "CVE-2015-7318",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2016-4041",
      "advisory": "Plone 4.0 through 5.1a1 does not have security declarations for Dexterity content-related WebDAV requests, which allows remote attackers to gain webdav access via unspecified vectors.",
      "cve": "CVE-2016-4041",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2016-4042",
      "advisory": "Plone 3.3 through 5.1a1 allows remote attackers to obtain information about the ID of sensitive content via unspecified vectors.",
      "cve": "CVE-2016-4042",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2016-4043",
      "advisory": "Chameleon (five.pt) in Plone 5.0rc1 through 5.1a1 allows remote authenticated users to bypass Restricted Python by leveraging permissions to create or edit templates.",
      "cve": "CVE-2016-4043",
      "specs": [
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2016-7135",
      "advisory": "Directory traversal vulnerability in Plone CMS 5.x through 5.0.6 and 4.2.x through 4.3.11 allows remote administrators to read arbitrary files via a .. (dot dot) in the path parameter in a getFile action to Plone/++theme++barceloneta/@@plone.resourceeditor.filemanager-actions.",
      "cve": "CVE-2016-7135",
      "specs": [
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2016-7136",
      "advisory": "z3c.form in Plone CMS 5.x through 5.0.6 and 4.x through 4.3.11 allows remote attackers to conduct cross-site scripting (XSS) attacks via a crafted GET request.",
      "cve": "CVE-2016-7136",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2016-7137",
      "advisory": "Multiple open redirect vulnerabilities in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allow remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via a URL in the referer parameter to (1) %2b%2bgroupdashboard%2b%2bplone.dashboard1%2bgroup/%2b/portlets.Actions or (2) folder/%2b%2bcontextportlets%2b%2bplone.footerportlets/%2b /portlets.Actions or the (3) came_from parameter to /login_form.",
      "cve": "CVE-2016-7137",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2016-7138",
      "advisory": "Cross-site scripting (XSS) vulnerability in the URL checking infrastructure in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allows remote attackers to inject arbitrary web script or HTML via a crafted URL.",
      "cve": "CVE-2016-7138",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2016-7139",
      "advisory": "Cross-site scripting (XSS) vulnerability in an unspecified page template in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allows remote attackers to inject arbitrary web script or HTML via unknown vectors.",
      "cve": "CVE-2016-7139",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2016-7140",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in the ZMI page in Zope2 in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allow remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2016-7140",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2016-7147",
      "advisory": "Cross-site scripting (XSS) vulnerability in the manage_findResult component in the search feature in Zope ZMI in Plone before 4.3.12 and 5.x before 5.0.7 allows remote attackers to inject arbitrary web script or HTML via vectors involving double quotes, as demonstrated by the obj_ids:tokens parameter. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-7140.",
      "cve": "CVE-2016-7147",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1-a1",
        "==5.1-a2"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2017-1000481",
      "advisory": "When you visit a page where you need to login, Plone 2.5-5.1rc1 sends you to the login form with a 'came_from' parameter set to the previous url. After you login, you get redirected to the page you tried to view before. An attacker might try to abuse this by letting you click on a specially crafted link. You would login, and get redirected to the site of the attacker, letting you think that you are still on the original Plone site. Or some javascript of the attacker could be executed. Most of these types of attacks are already blocked by Plone, using the `isURLInPortal` check to make sure we only redirect to a page on the same Plone site. But a few more ways of tricking Plone into accepting a malicious link were discovered, and fixed with this hotfix.",
      "cve": "CVE-2017-1000481",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2017-1000482",
      "advisory": "A member of the Plone 2.5-5.1rc1 site could set javascript in the home_page property of his profile, and have this executed when a visitor click the home page link on the author page.",
      "cve": "CVE-2017-1000482",
      "specs": [
        "<=5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2017-1000483",
      "advisory": "Accessing private content via str.format in through-the-web templates and scripts in Plone 2.5-5.1rc1. This improves an earlier hotfix. Since the format method was introduced in Python 2.6, this part of the hotfix is only relevant for Plone 4 and 5.",
      "cve": "CVE-2017-1000483",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2017-1000484",
      "advisory": "By linking to a specific url in Plone 2.5-5.1rc1 with a parameter, an attacker could send you to his own website. On its own this is not so bad: the attacker could more easily link directly to his own website instead. But in combination with another attack, you could be sent to the Plone login form and login, then get redirected to the specific url, and then get a second redirect to the attacker website. (The specific url can be seen by inspecting the hotfix code, but we don't want to make it too easy for attackers by spelling it out here.)",
      "cve": "CVE-2017-1000484",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2017-5524",
      "advisory": "Plone 4.x through 4.3.11 and 5.x through 5.0.6 allow remote attackers to bypass a sandbox protection mechanism and obtain sensitive information by leveraging the Python string format method.",
      "cve": "CVE-2017-5524",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1-a1",
        "==5.1-a2"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2020-28734",
      "advisory": "Plone before 5.2.3 allows XXE attacks via a feature that is explicitly only available to the Manager role.",
      "cve": "CVE-2020-28734",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2020-28735",
      "advisory": "Plone before 5.2.3 allows SSRF attacks via the tracebacks feature (only available to the Manager role).",
      "cve": "CVE-2020-28735",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2020-28736",
      "advisory": "Plone before 5.2.3 allows XXE attacks via a feature that is protected by an unapplied permission of plone.schemaeditor.ManageSchemata (therefore, only available to the Manager role).",
      "cve": "CVE-2020-28736",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2020-35190",
      "advisory": "The official plone Docker images before version of 4.3.18-alpine (Alpine specific) contain a blank password for a root user. System using the plone docker container deployed by affected versions of the docker image may allow a remote attacker to achieve root access with a blank password.",
      "cve": "CVE-2020-35190",
      "specs": [
        ">=4.0.0-alpine,<4.3.18-alpine"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2020-7936",
      "advisory": "An open redirect on the login form (and possibly other places) in Plone 4.0 through 5.2.1 allows an attacker to craft a link to a Plone Site that, when followed, and possibly after login, will redirect to an attacker's site.",
      "cve": "CVE-2020-7936",
      "specs": [
        ">=4.0.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2020-7937",
      "advisory": "An XSS issue in the title field in Plone 5.0 through 5.2.1 allows users with a certain privilege level to insert JavaScript that will be executed when other users access the site.",
      "cve": "CVE-2020-7937",
      "specs": [
        ">=5.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2020-7938",
      "advisory": "plone.restapi in Plone 5.2.0 through 5.2.1 allows users with a certain privilege level to escalate their privileges up to the highest level.",
      "cve": "CVE-2020-7938",
      "specs": [
        ">=5.2.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2020-7939",
      "advisory": "SQL Injection in DTML or in connection objects in Plone 4.0 through 5.2.1 allows users to perform unwanted SQL queries. (This is a problem in Zope.)",
      "cve": "CVE-2020-7939",
      "specs": [
        ">=4.0.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2020-7940",
      "advisory": "Missing password strength checks on some forms in Plone 4.3 through 5.2.0 allow users to set weak passwords, leading to easier cracking.",
      "cve": "CVE-2020-7940",
      "specs": [
        ">=4.3.0,<=5.2.0"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2020-7941",
      "advisory": "A privilege escalation issue in plone.app.contenttypes in Plone 4.3 through 5.2.1 allows users to PUT (overwrite) some content without needing write permission.",
      "cve": "CVE-2020-7941",
      "specs": [
        ">=4.3.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2021-29002",
      "advisory": "A stored cross-site scripting (XSS) vulnerability in Plone CMS 5.2.3 exists in site-controlpanel via the \"form.widgets.site_title\" parameter.",
      "cve": "CVE-2021-29002",
      "specs": [
        "==5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2021-32633",
      "advisory": "Zope is an open-source web application server. In Zope versions prior to 4.6 and 5.2, users can access untrusted modules indirectly through Python modules that are available for direct use. By default, only users with the Manager role can add or edit Zope Page Templates through the web, but sites that allow untrusted users to add/edit Zope Page Templates through the web are at risk from this vulnerability. The problem has been fixed in Zope 5.2 and 4.6. As a workaround, a site administrator can restrict adding/editing Zope Page Templates through the web using the standard Zope user/role permission mechanisms. Untrusted users should not be assigned the Zope Manager role and adding/editing Zope Page Templates through the web should be restricted to trusted users only.",
      "cve": "CVE-2021-32633",
      "specs": [
        "<=4.3.20",
        ">=5.0,<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2021-3313",
      "advisory": "Plone CMS until version 5.2.4 has a stored Cross-Site Scripting (XSS) vulnerability in the user fullname property and the file upload functionality. The user's input data is not properly encoded when being echoed back to the user. This data can be interpreted as executable code by the browser and allows an attacker to execute JavaScript in the context of the victim's browser if the victim opens a vulnerable page containing an XSS payload.",
      "cve": "CVE-2021-3313",
      "specs": [
        "<5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2021-33507",
      "advisory": "Zope Products.CMFCore before 2.5.1 and Products.PluggableAuthService before 2.6.2, as used in Plone through 5.2.4 and other products, allow Reflected XSS.",
      "cve": "CVE-2021-33507",
      "specs": [
        "<=4.3.20",
        ">=5.0,<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2021-33508",
      "advisory": "Plone through 5.2.4 allows XSS via a full name that is mishandled during rendering of the ownership tab of a content item.",
      "cve": "CVE-2021-33508",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2021-33509",
      "advisory": "Plone through 5.2.4 allows remote authenticated managers to perform disk I/O via crafted keyword arguments to the ReStructuredText transform in a Python script.",
      "cve": "CVE-2021-33509",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2021-33510",
      "advisory": "Plone through 5.2.4 allows remote authenticated managers to conduct SSRF attacks via an event ical URL, to read one line of a file.",
      "cve": "CVE-2021-33510",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2021-33511",
      "advisory": "Plone though 5.2.4 allows SSRF via the lxml parser. This affects Diazo themes, Dexterity TTW schemas, and modeleditors in plone.app.theming, plone.app.dexterity, and plone.supermodel.",
      "cve": "CVE-2021-33511",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2021-33512",
      "advisory": "Plone through 5.2.4 allows stored XSS attacks (by a Contributor) by uploading an SVG or HTML document.",
      "cve": "CVE-2021-33512",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2021-33513",
      "advisory": "Plone through 5.2.4 allows XSS via the inline_diff methods in Products.CMFDiffTool.",
      "cve": "CVE-2021-33513",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.event:CVE-2021-35959",
      "advisory": "In Plone 5.0 through 5.2.4, Editors are vulnerable to XSS in the folder contents view, if a Contributor has created a folder with a SCRIPT tag in the description field.",
      "cve": "CVE-2021-35959",
      "specs": [
        ">=5.0,<=5.2.4"
      ]
    }
  ],
  "plone.app.theming": [
    {
      "id": "pyup.io-plone.app.theming:CVE-2006-1711",
      "advisory": "Plone 2.0.5, 2.1.2, and 2.5-beta1 does not restrict access to the (1) changeMemberPortrait, (2) deletePersonalPortrait, and (3) testCurrentPassword methods, which allows remote attackers to modify portraits.",
      "cve": "CVE-2006-1711",
      "specs": [
        "==2.0.5",
        "==2.1.2",
        "==2.5_beta1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2006-4247",
      "advisory": "Unspecified vulnerability in the Password Reset Tool before 0.4.1 on Plone 2.5 and 2.5.1 Release Candidate allows attackers to reset the passwords of other users, related to \"an erroneous security declaration.\"",
      "cve": "CVE-2006-4247",
      "specs": [
        "==2.5",
        "==2.5.1_rc"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2006-4249",
      "advisory": "Unspecified vulnerability in PlonePAS in Plone 2.5 and 2.5.1, when anonymous member registration is enabled, allows an attacker to \"masquerade as a group.\"",
      "cve": "CVE-2006-4249",
      "specs": [
        "==2.5",
        "==2.5.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2007-5741",
      "advisory": "Plone 2.5 through 2.5.4 and 3.0 through 3.0.2 allows remote attackers to execute arbitrary Python code via network data containing pickled objects for the (1) statusmessages or (2) linkintegrity module, which the module unpickles and executes.",
      "cve": "CVE-2007-5741",
      "specs": [
        "==2.5",
        "==2.5.1",
        "==2.5.1_rc",
        "==2.5.4",
        "==2.5_beta1",
        "==3.0",
        "==3.0.1",
        "==3.0.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2008-0164",
      "advisory": "Multiple cross-site request forgery (CSRF) vulnerabilities in Plone CMS 3.0.5 and 3.0.6 allow remote attackers to (1) add arbitrary accounts via the join_form page and (2) change the privileges of arbitrary groups via the prefs_groups_overview page.",
      "cve": "CVE-2008-0164",
      "specs": [
        "==3.0.5",
        "==3.0.6"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2008-1393",
      "advisory": "Plone CMS 3.0.5, and probably other 3.x versions, places a base64 encoded form of the username and password in the __ac cookie for the admin account, which makes it easier for remote attackers to obtain administrative privileges by sniffing the network.",
      "cve": "CVE-2008-1393",
      "specs": [
        "<=3",
        "<=3.0.5"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2008-1394",
      "advisory": "Plone CMS before 3 places a base64 encoded form of the username and password in the __ac cookie for all user accounts, which makes it easier for remote attackers to obtain access by sniffing the network.",
      "cve": "CVE-2008-1394",
      "specs": [
        "<=2.5.1",
        "==2.0.5",
        "==2.1.2",
        "==2.1.3-rc1",
        "==2.5",
        "==2.5-beta1",
        "==2.5-beta2"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2008-4571",
      "advisory": "Cross-site scripting (XSS) vulnerability in the LiveSearch module in Plone before 3.0.4 allows remote attackers to inject arbitrary web script or HTML via the Description field for search results, as demonstrated using the onerror Javascript even in an IMG tag.",
      "cve": "CVE-2008-4571",
      "specs": [
        "<=3.0.3",
        "==2.0.5",
        "==2.1.2",
        "==2.5",
        "==2.5.1",
        "==2.5.1_rc",
        "==2.5.4",
        "==2.5_beta1",
        "==3.0",
        "==3.0.1",
        "==3.0.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2010-2422",
      "advisory": "Cross-site scripting (XSS) vulnerability in PortalTransforms in Plone 2.1 through 3.3.4 before hotfix 20100612 allows remote attackers to inject arbitrary web script or HTML via the safe_html transform.",
      "cve": "CVE-2010-2422",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2011-1340",
      "advisory": "Cross-site scripting (XSS) vulnerability in skins/plone_templates/default_error_message.pt in Plone before 2.5.3 allows remote attackers to inject arbitrary web script or HTML via the type_name parameter to Members/ipa/createObject.",
      "cve": "CVE-2011-1340",
      "specs": [
        "<=2.5.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2011-1948",
      "advisory": "Cross-site scripting (XSS) vulnerability in Plone 4.1 and earlier allows remote attackers to inject arbitrary web script or HTML via a crafted URL.",
      "cve": "CVE-2011-1948",
      "specs": [
        "<=4.1",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2011-1949",
      "advisory": "Cross-site scripting (XSS) vulnerability in the safe_html filter in Products.PortalTransforms in Plone 2.1 through 4.1 allows remote authenticated users to inject arbitrary web script or HTML via unspecified vectors, a different vulnerability than CVE-2010-2422.",
      "cve": "CVE-2011-1949",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2011-1950",
      "advisory": "plone.app.users in Plone 4.0 and 4.1 allows remote authenticated users to modify the properties of arbitrary accounts via unspecified vectors, as exploited in the wild in June 2011.",
      "cve": "CVE-2011-1950",
      "specs": [
        "==4.0",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2011-2528",
      "advisory": "Unspecified vulnerability in (1) Zope 2.12.x before 2.12.19 and 2.13.x before 2.13.8, as used in Plone 4.x and other products, and (2) PloneHotfix20110720 for Plone 3.x allows attackers to gain privileges via unspecified vectors, related to a \"highly serious vulnerability.\" NOTE: this vulnerability exists because of an incorrect fix for CVE-2011-0720.",
      "cve": "CVE-2011-2528",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2011-3587",
      "advisory": "Unspecified vulnerability in Zope 2.12.x and 2.13.x, as used in Plone 4.0.x through 4.0.9, 4.1, and 4.2 through 4.2a2, allows remote attackers to execute arbitrary commands via vectors related to the p_ class in OFS/misc_.py and the use of Python modules.",
      "cve": "CVE-2011-3587",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.2",
        "==4.2a1",
        "==4.2a2"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2011-4030",
      "advisory": "The CMFEditions component 2.x in Plone 4.0.x through 4.0.9, 4.1, and 4.2 through 4.2a2 does not prevent the KwAsAttributes classes from being publishable, which allows remote attackers to access sub-objects via unspecified vectors, a different vulnerability than CVE-2011-3587.",
      "cve": "CVE-2011-4030",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.2",
        "==4.2a1",
        "==4.2a2"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2011-4462",
      "advisory": "Plone 4.1.3 and earlier computes hash values for form parameters without restricting the ability to trigger hash collisions predictably, which allows remote attackers to cause a denial of service (CPU consumption) by sending many crafted parameters.",
      "cve": "CVE-2011-4462",
      "specs": [
        "<=4.1.3",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5485",
      "advisory": "registerConfiglet.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via unspecified vectors, related to the admin interface.",
      "cve": "CVE-2012-5485",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5486",
      "advisory": "ZPublisher.HTTPRequest._scrubHeader in Zope 2 before 2.13.19, as used in Plone before 4.3 beta 1, allows remote attackers to inject arbitrary HTTP headers via a linefeed (LF) character.",
      "cve": "CVE-2012-5486",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5487",
      "advisory": "The sandbox whitelisting function (allowmodule.py) in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with certain privileges to bypass the Python sandbox restriction and execute arbitrary Python code via vectors related to importing.",
      "cve": "CVE-2012-5487",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5488",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via a crafted URL, related to createObject.",
      "cve": "CVE-2012-5488",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5489",
      "advisory": "The App.Undo.UndoSupport.get_request_var_or_attr function in Zope before 2.12.21 and 3.13.x before 2.13.11, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote authenticated users to gain access to restricted attributes via unspecified vectors.",
      "cve": "CVE-2012-5489",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5490",
      "advisory": "Cross-site scripting (XSS) vulnerability in kssdevel.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5490",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5491",
      "advisory": "z3c.form, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote attackers to obtain the default form field values by leveraging knowledge of the form location and the element id.",
      "cve": "CVE-2012-5491",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5492",
      "advisory": "uid_catalog.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to obtain metadata about hidden objects via a crafted URL.",
      "cve": "CVE-2012-5492",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5493",
      "advisory": "gtbn.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with certain permissions to bypass the Python sandbox and execute arbitrary Python code via unspecified vectors.",
      "cve": "CVE-2012-5493",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5494",
      "advisory": "Cross-site scripting (XSS) vulnerability in python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors, related to \"{u,}translate.\"",
      "cve": "CVE-2012-5494",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5495",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via a crafted URL, related to \"go_back.\"",
      "cve": "CVE-2012-5495",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5496",
      "advisory": "kupu_spellcheck.py in Kupu in Plone before 4.0 allows remote attackers to cause a denial of service (ZServer thread lock) via a crafted URL.",
      "cve": "CVE-2012-5496",
      "specs": [
        "<=3.3.5",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5497",
      "advisory": "membership_tool.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to enumerate user account names via a crafted URL.",
      "cve": "CVE-2012-5497",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5498",
      "advisory": "queryCatalog.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to bypass caching and cause a denial of service via a crafted request to a collection.",
      "cve": "CVE-2012-5498",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5499",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to cause a denial of service (memory consumption) via a large value, related to formatColumns.",
      "cve": "CVE-2012-5499",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5500",
      "advisory": "The batch id change script (renameObjectsByPaths.py) in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to change the titles of content items by leveraging a valid CSRF token in a crafted request.",
      "cve": "CVE-2012-5500",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5501",
      "advisory": "at_download.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read arbitrary BLOBs (Files and Images) stored on custom content types via a crafted URL.",
      "cve": "CVE-2012-5501",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5502",
      "advisory": "Cross-site scripting (XSS) vulnerability in safe_html.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with permissions to edit content to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5502",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5503",
      "advisory": "ftp.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read hidden folder contents via unspecified vectors.",
      "cve": "CVE-2012-5503",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5504",
      "advisory": "Cross-site scripting (XSS) vulnerability in widget_traversal.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5504",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5505",
      "advisory": "atat.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read private data structures via a request for a view without a name.",
      "cve": "CVE-2012-5505",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5506",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to cause a denial of service (infinite loop) via an RSS feed request for a folder the user does not have permission to access.",
      "cve": "CVE-2012-5506",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5507",
      "advisory": "AccessControl/AuthEncoding.py in Zope before 2.13.19, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote attackers to obtain passwords via vectors involving timing discrepancies in password validation.",
      "cve": "CVE-2012-5507",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-5508",
      "advisory": "The error pages in Plone before 4.2.3 and 4.3 before beta 1 allow remote attackers to obtain random numbers and derive the PRNG state for password resets via unspecified vectors.  NOTE: this identifier was SPLIT per ADT2 due to different vulnerability types. CVE-2012-6661 was assigned for the PRNG reseeding issue in Zope.",
      "cve": "CVE-2012-5508",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2012-6661",
      "advisory": "Zope before 2.13.19, as used in Plone before 4.2.3 and 4.3 before beta 1, does not reseed the pseudo-random number generator (PRNG), which makes it easier for remote attackers to guess the value via unspecified vectors.  NOTE: this issue was SPLIT from CVE-2012-5508 due to different vulnerability types (ADT2).",
      "cve": "CVE-2012-6661",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2013-4188",
      "advisory": "traverser.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote attackers with administrator privileges to cause a denial of service (infinite loop and resource consumption) via unspecified vectors related to \"retrieving information for certain resources.\"",
      "cve": "CVE-2013-4188",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2013-4189",
      "advisory": "Multiple unspecified vulnerabilities in (1) dataitems.py, (2) get.py, and (3) traverseName.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote authenticated users with administrator access to a subtree to access nodes above the subtree via unknown vectors.",
      "cve": "CVE-2013-4189",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2013-4190",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in (1) spamProtect.py, (2) pts.py, and (3) request.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2013-4190",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2013-4191",
      "advisory": "zip.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly enforce access restrictions when including content in a zip archive, which allows remote attackers to obtain sensitive information by reading a generated archive.",
      "cve": "CVE-2013-4191",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2013-4192",
      "advisory": "sendto.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to spoof emails via unspecified vectors.",
      "cve": "CVE-2013-4192",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2013-4193",
      "advisory": "typeswidget.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly enforce the immutable setting on unspecified content edit forms, which allows remote attackers to hide fields on the forms via a crafted URL.",
      "cve": "CVE-2013-4193",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2013-4194",
      "advisory": "The WYSIWYG component (wysiwyg.py) in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote attackers to obtain sensitive information via a crafted URL, which reveals the installation path in an error message.",
      "cve": "CVE-2013-4194",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2013-4195",
      "advisory": "Multiple open redirect vulnerabilities in (1) marmoset_patch.py, (2) publish.py, and (3) principiaredirect.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via unspecified vectors.",
      "cve": "CVE-2013-4195",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2013-4196",
      "advisory": "The object manager implementation (objectmanager.py) in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly restrict access to internal methods, which allows remote attackers to obtain sensitive information via a crafted request.",
      "cve": "CVE-2013-4196",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2013-4197",
      "advisory": "member_portrait.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to modify or delete portraits of other users via unspecified vectors.",
      "cve": "CVE-2013-4197",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2013-4198",
      "advisory": "mail_password.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to bypass the prohibition on password changes via the forgotten password email functionality.",
      "cve": "CVE-2013-4198",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2013-4199",
      "advisory": "(1) cb_decode.py and (2) linkintegrity.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote authenticated users to cause a denial of service (resource consumption) via a large zip archive, which is expanded (decompressed).",
      "cve": "CVE-2013-4199",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2013-4200",
      "advisory": "The isURLInPortal method in the URLTool class in in_portal.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 treats URLs starting with a space as a relative URL, which allows remote attackers to bypass the allow_external_login_sites filtering property,  redirect users to arbitrary web sites, and conduct phishing attacks via a space before a URL in the \"next\" parameter to acl_users/credentials_cookie_auth/require_login.",
      "cve": "CVE-2013-4200",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2013-7060",
      "advisory": "Products/CMFPlone/FactoryTool.py in Plone 3.3 through 4.3.2 allows remote attackers to obtain the installation path via vectors related to a file object for unspecified documentation which is initialized in class scope.",
      "cve": "CVE-2013-7060",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2013-7061",
      "advisory": "Products/CMFPlone/CatalogTool.py in Plone 3.3 through 4.3.2 allows remote administrators to bypass restrictions and obtain sensitive information via an unspecified search API.",
      "cve": "CVE-2013-7061",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2013-7062",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in Zope, as used in Plone 3.3.x through 3.3.6, 4.0.x through 4.0.9, 4.1.x through 4.1.6, 4.2.x through 4.2.7, and 4.3 through 4.3.2, allow remote attackers to inject arbitrary web script or HTML via unspecified input in the (1) browser_id_manager or (2) OFS.Image method.",
      "cve": "CVE-2013-7062",
      "specs": [
        ">=3.3.0,<=3.3.6",
        ">=4.0.0,<=4.0.9",
        ">=4.1.0,<=4.1.6",
        ">=4.2.0,<=4.2.7",
        ">=4.3.0,<=4.3.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2015-7293",
      "advisory": "Multiple cross-site request forgery (CSRF) vulnerabilities in Zope Management Interface 4.3.7 and earlier, and Plone before 5.x.",
      "cve": "CVE-2015-7293",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2015-7315",
      "advisory": "Plone 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, 4.2.0 through 4.2.7, 4.3.0 through 4.3.6, and 5.0rc1 allows remote attackers to add a new member to a Plone site with registration enabled, without acknowledgment of site administrator.",
      "cve": "CVE-2015-7315",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==5.0-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2015-7316",
      "advisory": "Cross-site scripting (XSS) vulnerability in Plone 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, 4.2.0 through 4.2.7, 4.3.x before 4.3.7, and 5.0rc1.",
      "cve": "CVE-2015-7316",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==5.0-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2015-7317",
      "advisory": "Kupu 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, and 4.2.0 through 4.2.7 allows remote authenticated users to edit Kupu settings.",
      "cve": "CVE-2015-7317",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2015-7318",
      "advisory": "Plone 3.3.0 through 3.3.6 allows remote attackers to inject headers into HTTP responses.",
      "cve": "CVE-2015-7318",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2016-4041",
      "advisory": "Plone 4.0 through 5.1a1 does not have security declarations for Dexterity content-related WebDAV requests, which allows remote attackers to gain webdav access via unspecified vectors.",
      "cve": "CVE-2016-4041",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2016-4042",
      "advisory": "Plone 3.3 through 5.1a1 allows remote attackers to obtain information about the ID of sensitive content via unspecified vectors.",
      "cve": "CVE-2016-4042",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2016-4043",
      "advisory": "Chameleon (five.pt) in Plone 5.0rc1 through 5.1a1 allows remote authenticated users to bypass Restricted Python by leveraging permissions to create or edit templates.",
      "cve": "CVE-2016-4043",
      "specs": [
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2016-7135",
      "advisory": "Directory traversal vulnerability in Plone CMS 5.x through 5.0.6 and 4.2.x through 4.3.11 allows remote administrators to read arbitrary files via a .. (dot dot) in the path parameter in a getFile action to Plone/++theme++barceloneta/@@plone.resourceeditor.filemanager-actions.",
      "cve": "CVE-2016-7135",
      "specs": [
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2016-7136",
      "advisory": "z3c.form in Plone CMS 5.x through 5.0.6 and 4.x through 4.3.11 allows remote attackers to conduct cross-site scripting (XSS) attacks via a crafted GET request.",
      "cve": "CVE-2016-7136",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2016-7137",
      "advisory": "Multiple open redirect vulnerabilities in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allow remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via a URL in the referer parameter to (1) %2b%2bgroupdashboard%2b%2bplone.dashboard1%2bgroup/%2b/portlets.Actions or (2) folder/%2b%2bcontextportlets%2b%2bplone.footerportlets/%2b /portlets.Actions or the (3) came_from parameter to /login_form.",
      "cve": "CVE-2016-7137",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2016-7138",
      "advisory": "Cross-site scripting (XSS) vulnerability in the URL checking infrastructure in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allows remote attackers to inject arbitrary web script or HTML via a crafted URL.",
      "cve": "CVE-2016-7138",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2016-7139",
      "advisory": "Cross-site scripting (XSS) vulnerability in an unspecified page template in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allows remote attackers to inject arbitrary web script or HTML via unknown vectors.",
      "cve": "CVE-2016-7139",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2016-7140",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in the ZMI page in Zope2 in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allow remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2016-7140",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2016-7147",
      "advisory": "Cross-site scripting (XSS) vulnerability in the manage_findResult component in the search feature in Zope ZMI in Plone before 4.3.12 and 5.x before 5.0.7 allows remote attackers to inject arbitrary web script or HTML via vectors involving double quotes, as demonstrated by the obj_ids:tokens parameter. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-7140.",
      "cve": "CVE-2016-7147",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1-a1",
        "==5.1-a2"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2017-1000481",
      "advisory": "When you visit a page where you need to login, Plone 2.5-5.1rc1 sends you to the login form with a 'came_from' parameter set to the previous url. After you login, you get redirected to the page you tried to view before. An attacker might try to abuse this by letting you click on a specially crafted link. You would login, and get redirected to the site of the attacker, letting you think that you are still on the original Plone site. Or some javascript of the attacker could be executed. Most of these types of attacks are already blocked by Plone, using the `isURLInPortal` check to make sure we only redirect to a page on the same Plone site. But a few more ways of tricking Plone into accepting a malicious link were discovered, and fixed with this hotfix.",
      "cve": "CVE-2017-1000481",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2017-1000482",
      "advisory": "A member of the Plone 2.5-5.1rc1 site could set javascript in the home_page property of his profile, and have this executed when a visitor click the home page link on the author page.",
      "cve": "CVE-2017-1000482",
      "specs": [
        "<=5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2017-1000483",
      "advisory": "Accessing private content via str.format in through-the-web templates and scripts in Plone 2.5-5.1rc1. This improves an earlier hotfix. Since the format method was introduced in Python 2.6, this part of the hotfix is only relevant for Plone 4 and 5.",
      "cve": "CVE-2017-1000483",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2017-1000484",
      "advisory": "By linking to a specific url in Plone 2.5-5.1rc1 with a parameter, an attacker could send you to his own website. On its own this is not so bad: the attacker could more easily link directly to his own website instead. But in combination with another attack, you could be sent to the Plone login form and login, then get redirected to the specific url, and then get a second redirect to the attacker website. (The specific url can be seen by inspecting the hotfix code, but we don't want to make it too easy for attackers by spelling it out here.)",
      "cve": "CVE-2017-1000484",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2017-5524",
      "advisory": "Plone 4.x through 4.3.11 and 5.x through 5.0.6 allow remote attackers to bypass a sandbox protection mechanism and obtain sensitive information by leveraging the Python string format method.",
      "cve": "CVE-2017-5524",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1-a1",
        "==5.1-a2"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2020-28734",
      "advisory": "Plone before 5.2.3 allows XXE attacks via a feature that is explicitly only available to the Manager role.",
      "cve": "CVE-2020-28734",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2020-28735",
      "advisory": "Plone before 5.2.3 allows SSRF attacks via the tracebacks feature (only available to the Manager role).",
      "cve": "CVE-2020-28735",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2020-28736",
      "advisory": "Plone before 5.2.3 allows XXE attacks via a feature that is protected by an unapplied permission of plone.schemaeditor.ManageSchemata (therefore, only available to the Manager role).",
      "cve": "CVE-2020-28736",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2020-35190",
      "advisory": "The official plone Docker images before version of 4.3.18-alpine (Alpine specific) contain a blank password for a root user. System using the plone docker container deployed by affected versions of the docker image may allow a remote attacker to achieve root access with a blank password.",
      "cve": "CVE-2020-35190",
      "specs": [
        ">=4.0.0-alpine,<4.3.18-alpine"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2020-7936",
      "advisory": "An open redirect on the login form (and possibly other places) in Plone 4.0 through 5.2.1 allows an attacker to craft a link to a Plone Site that, when followed, and possibly after login, will redirect to an attacker's site.",
      "cve": "CVE-2020-7936",
      "specs": [
        ">=4.0.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2020-7937",
      "advisory": "An XSS issue in the title field in Plone 5.0 through 5.2.1 allows users with a certain privilege level to insert JavaScript that will be executed when other users access the site.",
      "cve": "CVE-2020-7937",
      "specs": [
        ">=5.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2020-7938",
      "advisory": "plone.restapi in Plone 5.2.0 through 5.2.1 allows users with a certain privilege level to escalate their privileges up to the highest level.",
      "cve": "CVE-2020-7938",
      "specs": [
        ">=5.2.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2020-7939",
      "advisory": "SQL Injection in DTML or in connection objects in Plone 4.0 through 5.2.1 allows users to perform unwanted SQL queries. (This is a problem in Zope.)",
      "cve": "CVE-2020-7939",
      "specs": [
        ">=4.0.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2020-7940",
      "advisory": "Missing password strength checks on some forms in Plone 4.3 through 5.2.0 allow users to set weak passwords, leading to easier cracking.",
      "cve": "CVE-2020-7940",
      "specs": [
        ">=4.3.0,<=5.2.0"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2020-7941",
      "advisory": "A privilege escalation issue in plone.app.contenttypes in Plone 4.3 through 5.2.1 allows users to PUT (overwrite) some content without needing write permission.",
      "cve": "CVE-2020-7941",
      "specs": [
        ">=4.3.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2021-29002",
      "advisory": "A stored cross-site scripting (XSS) vulnerability in Plone CMS 5.2.3 exists in site-controlpanel via the \"form.widgets.site_title\" parameter.",
      "cve": "CVE-2021-29002",
      "specs": [
        "==5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2021-32633",
      "advisory": "Zope is an open-source web application server. In Zope versions prior to 4.6 and 5.2, users can access untrusted modules indirectly through Python modules that are available for direct use. By default, only users with the Manager role can add or edit Zope Page Templates through the web, but sites that allow untrusted users to add/edit Zope Page Templates through the web are at risk from this vulnerability. The problem has been fixed in Zope 5.2 and 4.6. As a workaround, a site administrator can restrict adding/editing Zope Page Templates through the web using the standard Zope user/role permission mechanisms. Untrusted users should not be assigned the Zope Manager role and adding/editing Zope Page Templates through the web should be restricted to trusted users only.",
      "cve": "CVE-2021-32633",
      "specs": [
        "<=4.3.20",
        ">=5.0,<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2021-3313",
      "advisory": "Plone CMS until version 5.2.4 has a stored Cross-Site Scripting (XSS) vulnerability in the user fullname property and the file upload functionality. The user's input data is not properly encoded when being echoed back to the user. This data can be interpreted as executable code by the browser and allows an attacker to execute JavaScript in the context of the victim's browser if the victim opens a vulnerable page containing an XSS payload.",
      "cve": "CVE-2021-3313",
      "specs": [
        "<5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2021-33507",
      "advisory": "Zope Products.CMFCore before 2.5.1 and Products.PluggableAuthService before 2.6.2, as used in Plone through 5.2.4 and other products, allow Reflected XSS.",
      "cve": "CVE-2021-33507",
      "specs": [
        "<=4.3.20",
        ">=5.0,<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2021-33508",
      "advisory": "Plone through 5.2.4 allows XSS via a full name that is mishandled during rendering of the ownership tab of a content item.",
      "cve": "CVE-2021-33508",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2021-33509",
      "advisory": "Plone through 5.2.4 allows remote authenticated managers to perform disk I/O via crafted keyword arguments to the ReStructuredText transform in a Python script.",
      "cve": "CVE-2021-33509",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2021-33510",
      "advisory": "Plone through 5.2.4 allows remote authenticated managers to conduct SSRF attacks via an event ical URL, to read one line of a file.",
      "cve": "CVE-2021-33510",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2021-33511",
      "advisory": "Plone though 5.2.4 allows SSRF via the lxml parser. This affects Diazo themes, Dexterity TTW schemas, and modeleditors in plone.app.theming, plone.app.dexterity, and plone.supermodel.",
      "cve": "CVE-2021-33511",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2021-33512",
      "advisory": "Plone through 5.2.4 allows stored XSS attacks (by a Contributor) by uploading an SVG or HTML document.",
      "cve": "CVE-2021-33512",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2021-33513",
      "advisory": "Plone through 5.2.4 allows XSS via the inline_diff methods in Products.CMFDiffTool.",
      "cve": "CVE-2021-33513",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.theming:CVE-2021-35959",
      "advisory": "In Plone 5.0 through 5.2.4, Editors are vulnerable to XSS in the folder contents view, if a Contributor has created a folder with a SCRIPT tag in the description field.",
      "cve": "CVE-2021-35959",
      "specs": [
        ">=5.0,<=5.2.4"
      ]
    }
  ],
  "plone.app.users": [
    {
      "id": "pyup.io-plone.app.users:CVE-2006-1711",
      "advisory": "Plone 2.0.5, 2.1.2, and 2.5-beta1 does not restrict access to the (1) changeMemberPortrait, (2) deletePersonalPortrait, and (3) testCurrentPassword methods, which allows remote attackers to modify portraits.",
      "cve": "CVE-2006-1711",
      "specs": [
        "==2.0.5",
        "==2.1.2",
        "==2.5_beta1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2006-4247",
      "advisory": "Unspecified vulnerability in the Password Reset Tool before 0.4.1 on Plone 2.5 and 2.5.1 Release Candidate allows attackers to reset the passwords of other users, related to \"an erroneous security declaration.\"",
      "cve": "CVE-2006-4247",
      "specs": [
        "==2.5",
        "==2.5.1_rc"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2006-4249",
      "advisory": "Unspecified vulnerability in PlonePAS in Plone 2.5 and 2.5.1, when anonymous member registration is enabled, allows an attacker to \"masquerade as a group.\"",
      "cve": "CVE-2006-4249",
      "specs": [
        "==2.5",
        "==2.5.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2007-5741",
      "advisory": "Plone 2.5 through 2.5.4 and 3.0 through 3.0.2 allows remote attackers to execute arbitrary Python code via network data containing pickled objects for the (1) statusmessages or (2) linkintegrity module, which the module unpickles and executes.",
      "cve": "CVE-2007-5741",
      "specs": [
        "==2.5",
        "==2.5.1",
        "==2.5.1_rc",
        "==2.5.4",
        "==2.5_beta1",
        "==3.0",
        "==3.0.1",
        "==3.0.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2008-0164",
      "advisory": "Multiple cross-site request forgery (CSRF) vulnerabilities in Plone CMS 3.0.5 and 3.0.6 allow remote attackers to (1) add arbitrary accounts via the join_form page and (2) change the privileges of arbitrary groups via the prefs_groups_overview page.",
      "cve": "CVE-2008-0164",
      "specs": [
        "==3.0.5",
        "==3.0.6"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2008-1393",
      "advisory": "Plone CMS 3.0.5, and probably other 3.x versions, places a base64 encoded form of the username and password in the __ac cookie for the admin account, which makes it easier for remote attackers to obtain administrative privileges by sniffing the network.",
      "cve": "CVE-2008-1393",
      "specs": [
        "<=3",
        "<=3.0.5"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2008-1394",
      "advisory": "Plone CMS before 3 places a base64 encoded form of the username and password in the __ac cookie for all user accounts, which makes it easier for remote attackers to obtain access by sniffing the network.",
      "cve": "CVE-2008-1394",
      "specs": [
        "<=2.5.1",
        "==2.0.5",
        "==2.1.2",
        "==2.1.3-rc1",
        "==2.5",
        "==2.5-beta1",
        "==2.5-beta2"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2008-4571",
      "advisory": "Cross-site scripting (XSS) vulnerability in the LiveSearch module in Plone before 3.0.4 allows remote attackers to inject arbitrary web script or HTML via the Description field for search results, as demonstrated using the onerror Javascript even in an IMG tag.",
      "cve": "CVE-2008-4571",
      "specs": [
        "<=3.0.3",
        "==2.0.5",
        "==2.1.2",
        "==2.5",
        "==2.5.1",
        "==2.5.1_rc",
        "==2.5.4",
        "==2.5_beta1",
        "==3.0",
        "==3.0.1",
        "==3.0.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2010-2422",
      "advisory": "Cross-site scripting (XSS) vulnerability in PortalTransforms in Plone 2.1 through 3.3.4 before hotfix 20100612 allows remote attackers to inject arbitrary web script or HTML via the safe_html transform.",
      "cve": "CVE-2010-2422",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2011-1340",
      "advisory": "Cross-site scripting (XSS) vulnerability in skins/plone_templates/default_error_message.pt in Plone before 2.5.3 allows remote attackers to inject arbitrary web script or HTML via the type_name parameter to Members/ipa/createObject.",
      "cve": "CVE-2011-1340",
      "specs": [
        "<=2.5.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2011-1948",
      "advisory": "Cross-site scripting (XSS) vulnerability in Plone 4.1 and earlier allows remote attackers to inject arbitrary web script or HTML via a crafted URL.",
      "cve": "CVE-2011-1948",
      "specs": [
        "<=4.1",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2011-1949",
      "advisory": "Cross-site scripting (XSS) vulnerability in the safe_html filter in Products.PortalTransforms in Plone 2.1 through 4.1 allows remote authenticated users to inject arbitrary web script or HTML via unspecified vectors, a different vulnerability than CVE-2010-2422.",
      "cve": "CVE-2011-1949",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2011-1950",
      "advisory": "plone.app.users in Plone 4.0 and 4.1 allows remote authenticated users to modify the properties of arbitrary accounts via unspecified vectors, as exploited in the wild in June 2011.",
      "cve": "CVE-2011-1950",
      "specs": [
        "==4.0",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2011-2528",
      "advisory": "Unspecified vulnerability in (1) Zope 2.12.x before 2.12.19 and 2.13.x before 2.13.8, as used in Plone 4.x and other products, and (2) PloneHotfix20110720 for Plone 3.x allows attackers to gain privileges via unspecified vectors, related to a \"highly serious vulnerability.\" NOTE: this vulnerability exists because of an incorrect fix for CVE-2011-0720.",
      "cve": "CVE-2011-2528",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2011-3587",
      "advisory": "Unspecified vulnerability in Zope 2.12.x and 2.13.x, as used in Plone 4.0.x through 4.0.9, 4.1, and 4.2 through 4.2a2, allows remote attackers to execute arbitrary commands via vectors related to the p_ class in OFS/misc_.py and the use of Python modules.",
      "cve": "CVE-2011-3587",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.2",
        "==4.2a1",
        "==4.2a2"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2011-4030",
      "advisory": "The CMFEditions component 2.x in Plone 4.0.x through 4.0.9, 4.1, and 4.2 through 4.2a2 does not prevent the KwAsAttributes classes from being publishable, which allows remote attackers to access sub-objects via unspecified vectors, a different vulnerability than CVE-2011-3587.",
      "cve": "CVE-2011-4030",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.2",
        "==4.2a1",
        "==4.2a2"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2011-4462",
      "advisory": "Plone 4.1.3 and earlier computes hash values for form parameters without restricting the ability to trigger hash collisions predictably, which allows remote attackers to cause a denial of service (CPU consumption) by sending many crafted parameters.",
      "cve": "CVE-2011-4462",
      "specs": [
        "<=4.1.3",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5485",
      "advisory": "registerConfiglet.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via unspecified vectors, related to the admin interface.",
      "cve": "CVE-2012-5485",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5486",
      "advisory": "ZPublisher.HTTPRequest._scrubHeader in Zope 2 before 2.13.19, as used in Plone before 4.3 beta 1, allows remote attackers to inject arbitrary HTTP headers via a linefeed (LF) character.",
      "cve": "CVE-2012-5486",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5487",
      "advisory": "The sandbox whitelisting function (allowmodule.py) in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with certain privileges to bypass the Python sandbox restriction and execute arbitrary Python code via vectors related to importing.",
      "cve": "CVE-2012-5487",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5488",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via a crafted URL, related to createObject.",
      "cve": "CVE-2012-5488",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5489",
      "advisory": "The App.Undo.UndoSupport.get_request_var_or_attr function in Zope before 2.12.21 and 3.13.x before 2.13.11, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote authenticated users to gain access to restricted attributes via unspecified vectors.",
      "cve": "CVE-2012-5489",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5490",
      "advisory": "Cross-site scripting (XSS) vulnerability in kssdevel.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5490",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5491",
      "advisory": "z3c.form, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote attackers to obtain the default form field values by leveraging knowledge of the form location and the element id.",
      "cve": "CVE-2012-5491",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5492",
      "advisory": "uid_catalog.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to obtain metadata about hidden objects via a crafted URL.",
      "cve": "CVE-2012-5492",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5493",
      "advisory": "gtbn.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with certain permissions to bypass the Python sandbox and execute arbitrary Python code via unspecified vectors.",
      "cve": "CVE-2012-5493",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5494",
      "advisory": "Cross-site scripting (XSS) vulnerability in python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors, related to \"{u,}translate.\"",
      "cve": "CVE-2012-5494",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5495",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via a crafted URL, related to \"go_back.\"",
      "cve": "CVE-2012-5495",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5496",
      "advisory": "kupu_spellcheck.py in Kupu in Plone before 4.0 allows remote attackers to cause a denial of service (ZServer thread lock) via a crafted URL.",
      "cve": "CVE-2012-5496",
      "specs": [
        "<=3.3.5",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5497",
      "advisory": "membership_tool.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to enumerate user account names via a crafted URL.",
      "cve": "CVE-2012-5497",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5498",
      "advisory": "queryCatalog.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to bypass caching and cause a denial of service via a crafted request to a collection.",
      "cve": "CVE-2012-5498",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5499",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to cause a denial of service (memory consumption) via a large value, related to formatColumns.",
      "cve": "CVE-2012-5499",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5500",
      "advisory": "The batch id change script (renameObjectsByPaths.py) in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to change the titles of content items by leveraging a valid CSRF token in a crafted request.",
      "cve": "CVE-2012-5500",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5501",
      "advisory": "at_download.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read arbitrary BLOBs (Files and Images) stored on custom content types via a crafted URL.",
      "cve": "CVE-2012-5501",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5502",
      "advisory": "Cross-site scripting (XSS) vulnerability in safe_html.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with permissions to edit content to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5502",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5503",
      "advisory": "ftp.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read hidden folder contents via unspecified vectors.",
      "cve": "CVE-2012-5503",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5504",
      "advisory": "Cross-site scripting (XSS) vulnerability in widget_traversal.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5504",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5505",
      "advisory": "atat.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read private data structures via a request for a view without a name.",
      "cve": "CVE-2012-5505",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5506",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to cause a denial of service (infinite loop) via an RSS feed request for a folder the user does not have permission to access.",
      "cve": "CVE-2012-5506",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5507",
      "advisory": "AccessControl/AuthEncoding.py in Zope before 2.13.19, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote attackers to obtain passwords via vectors involving timing discrepancies in password validation.",
      "cve": "CVE-2012-5507",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-5508",
      "advisory": "The error pages in Plone before 4.2.3 and 4.3 before beta 1 allow remote attackers to obtain random numbers and derive the PRNG state for password resets via unspecified vectors.  NOTE: this identifier was SPLIT per ADT2 due to different vulnerability types. CVE-2012-6661 was assigned for the PRNG reseeding issue in Zope.",
      "cve": "CVE-2012-5508",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2012-6661",
      "advisory": "Zope before 2.13.19, as used in Plone before 4.2.3 and 4.3 before beta 1, does not reseed the pseudo-random number generator (PRNG), which makes it easier for remote attackers to guess the value via unspecified vectors.  NOTE: this issue was SPLIT from CVE-2012-5508 due to different vulnerability types (ADT2).",
      "cve": "CVE-2012-6661",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2013-4188",
      "advisory": "traverser.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote attackers with administrator privileges to cause a denial of service (infinite loop and resource consumption) via unspecified vectors related to \"retrieving information for certain resources.\"",
      "cve": "CVE-2013-4188",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2013-4189",
      "advisory": "Multiple unspecified vulnerabilities in (1) dataitems.py, (2) get.py, and (3) traverseName.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote authenticated users with administrator access to a subtree to access nodes above the subtree via unknown vectors.",
      "cve": "CVE-2013-4189",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2013-4190",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in (1) spamProtect.py, (2) pts.py, and (3) request.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2013-4190",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2013-4191",
      "advisory": "zip.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly enforce access restrictions when including content in a zip archive, which allows remote attackers to obtain sensitive information by reading a generated archive.",
      "cve": "CVE-2013-4191",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2013-4192",
      "advisory": "sendto.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to spoof emails via unspecified vectors.",
      "cve": "CVE-2013-4192",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2013-4193",
      "advisory": "typeswidget.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly enforce the immutable setting on unspecified content edit forms, which allows remote attackers to hide fields on the forms via a crafted URL.",
      "cve": "CVE-2013-4193",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2013-4194",
      "advisory": "The WYSIWYG component (wysiwyg.py) in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote attackers to obtain sensitive information via a crafted URL, which reveals the installation path in an error message.",
      "cve": "CVE-2013-4194",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2013-4195",
      "advisory": "Multiple open redirect vulnerabilities in (1) marmoset_patch.py, (2) publish.py, and (3) principiaredirect.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via unspecified vectors.",
      "cve": "CVE-2013-4195",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2013-4196",
      "advisory": "The object manager implementation (objectmanager.py) in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly restrict access to internal methods, which allows remote attackers to obtain sensitive information via a crafted request.",
      "cve": "CVE-2013-4196",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2013-4197",
      "advisory": "member_portrait.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to modify or delete portraits of other users via unspecified vectors.",
      "cve": "CVE-2013-4197",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2013-4198",
      "advisory": "mail_password.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to bypass the prohibition on password changes via the forgotten password email functionality.",
      "cve": "CVE-2013-4198",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2013-4199",
      "advisory": "(1) cb_decode.py and (2) linkintegrity.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote authenticated users to cause a denial of service (resource consumption) via a large zip archive, which is expanded (decompressed).",
      "cve": "CVE-2013-4199",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2013-4200",
      "advisory": "The isURLInPortal method in the URLTool class in in_portal.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 treats URLs starting with a space as a relative URL, which allows remote attackers to bypass the allow_external_login_sites filtering property,  redirect users to arbitrary web sites, and conduct phishing attacks via a space before a URL in the \"next\" parameter to acl_users/credentials_cookie_auth/require_login.",
      "cve": "CVE-2013-4200",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2013-7060",
      "advisory": "Products/CMFPlone/FactoryTool.py in Plone 3.3 through 4.3.2 allows remote attackers to obtain the installation path via vectors related to a file object for unspecified documentation which is initialized in class scope.",
      "cve": "CVE-2013-7060",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2013-7061",
      "advisory": "Products/CMFPlone/CatalogTool.py in Plone 3.3 through 4.3.2 allows remote administrators to bypass restrictions and obtain sensitive information via an unspecified search API.",
      "cve": "CVE-2013-7061",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2013-7062",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in Zope, as used in Plone 3.3.x through 3.3.6, 4.0.x through 4.0.9, 4.1.x through 4.1.6, 4.2.x through 4.2.7, and 4.3 through 4.3.2, allow remote attackers to inject arbitrary web script or HTML via unspecified input in the (1) browser_id_manager or (2) OFS.Image method.",
      "cve": "CVE-2013-7062",
      "specs": [
        ">=3.3.0,<=3.3.6",
        ">=4.0.0,<=4.0.9",
        ">=4.1.0,<=4.1.6",
        ">=4.2.0,<=4.2.7",
        ">=4.3.0,<=4.3.2"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2015-7293",
      "advisory": "Multiple cross-site request forgery (CSRF) vulnerabilities in Zope Management Interface 4.3.7 and earlier, and Plone before 5.x.",
      "cve": "CVE-2015-7293",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2015-7315",
      "advisory": "Plone 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, 4.2.0 through 4.2.7, 4.3.0 through 4.3.6, and 5.0rc1 allows remote attackers to add a new member to a Plone site with registration enabled, without acknowledgment of site administrator.",
      "cve": "CVE-2015-7315",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==5.0-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2015-7316",
      "advisory": "Cross-site scripting (XSS) vulnerability in Plone 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, 4.2.0 through 4.2.7, 4.3.x before 4.3.7, and 5.0rc1.",
      "cve": "CVE-2015-7316",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==5.0-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2015-7317",
      "advisory": "Kupu 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, and 4.2.0 through 4.2.7 allows remote authenticated users to edit Kupu settings.",
      "cve": "CVE-2015-7317",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2015-7318",
      "advisory": "Plone 3.3.0 through 3.3.6 allows remote attackers to inject headers into HTTP responses.",
      "cve": "CVE-2015-7318",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2016-4041",
      "advisory": "Plone 4.0 through 5.1a1 does not have security declarations for Dexterity content-related WebDAV requests, which allows remote attackers to gain webdav access via unspecified vectors.",
      "cve": "CVE-2016-4041",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2016-4042",
      "advisory": "Plone 3.3 through 5.1a1 allows remote attackers to obtain information about the ID of sensitive content via unspecified vectors.",
      "cve": "CVE-2016-4042",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2016-4043",
      "advisory": "Chameleon (five.pt) in Plone 5.0rc1 through 5.1a1 allows remote authenticated users to bypass Restricted Python by leveraging permissions to create or edit templates.",
      "cve": "CVE-2016-4043",
      "specs": [
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2016-7135",
      "advisory": "Directory traversal vulnerability in Plone CMS 5.x through 5.0.6 and 4.2.x through 4.3.11 allows remote administrators to read arbitrary files via a .. (dot dot) in the path parameter in a getFile action to Plone/++theme++barceloneta/@@plone.resourceeditor.filemanager-actions.",
      "cve": "CVE-2016-7135",
      "specs": [
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2016-7136",
      "advisory": "z3c.form in Plone CMS 5.x through 5.0.6 and 4.x through 4.3.11 allows remote attackers to conduct cross-site scripting (XSS) attacks via a crafted GET request.",
      "cve": "CVE-2016-7136",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2016-7137",
      "advisory": "Multiple open redirect vulnerabilities in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allow remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via a URL in the referer parameter to (1) %2b%2bgroupdashboard%2b%2bplone.dashboard1%2bgroup/%2b/portlets.Actions or (2) folder/%2b%2bcontextportlets%2b%2bplone.footerportlets/%2b /portlets.Actions or the (3) came_from parameter to /login_form.",
      "cve": "CVE-2016-7137",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2016-7138",
      "advisory": "Cross-site scripting (XSS) vulnerability in the URL checking infrastructure in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allows remote attackers to inject arbitrary web script or HTML via a crafted URL.",
      "cve": "CVE-2016-7138",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2016-7139",
      "advisory": "Cross-site scripting (XSS) vulnerability in an unspecified page template in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allows remote attackers to inject arbitrary web script or HTML via unknown vectors.",
      "cve": "CVE-2016-7139",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2016-7140",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in the ZMI page in Zope2 in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allow remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2016-7140",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2016-7147",
      "advisory": "Cross-site scripting (XSS) vulnerability in the manage_findResult component in the search feature in Zope ZMI in Plone before 4.3.12 and 5.x before 5.0.7 allows remote attackers to inject arbitrary web script or HTML via vectors involving double quotes, as demonstrated by the obj_ids:tokens parameter. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-7140.",
      "cve": "CVE-2016-7147",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1-a1",
        "==5.1-a2"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2017-1000481",
      "advisory": "When you visit a page where you need to login, Plone 2.5-5.1rc1 sends you to the login form with a 'came_from' parameter set to the previous url. After you login, you get redirected to the page you tried to view before. An attacker might try to abuse this by letting you click on a specially crafted link. You would login, and get redirected to the site of the attacker, letting you think that you are still on the original Plone site. Or some javascript of the attacker could be executed. Most of these types of attacks are already blocked by Plone, using the `isURLInPortal` check to make sure we only redirect to a page on the same Plone site. But a few more ways of tricking Plone into accepting a malicious link were discovered, and fixed with this hotfix.",
      "cve": "CVE-2017-1000481",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2017-1000482",
      "advisory": "A member of the Plone 2.5-5.1rc1 site could set javascript in the home_page property of his profile, and have this executed when a visitor click the home page link on the author page.",
      "cve": "CVE-2017-1000482",
      "specs": [
        "<=5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2017-1000483",
      "advisory": "Accessing private content via str.format in through-the-web templates and scripts in Plone 2.5-5.1rc1. This improves an earlier hotfix. Since the format method was introduced in Python 2.6, this part of the hotfix is only relevant for Plone 4 and 5.",
      "cve": "CVE-2017-1000483",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2017-1000484",
      "advisory": "By linking to a specific url in Plone 2.5-5.1rc1 with a parameter, an attacker could send you to his own website. On its own this is not so bad: the attacker could more easily link directly to his own website instead. But in combination with another attack, you could be sent to the Plone login form and login, then get redirected to the specific url, and then get a second redirect to the attacker website. (The specific url can be seen by inspecting the hotfix code, but we don't want to make it too easy for attackers by spelling it out here.)",
      "cve": "CVE-2017-1000484",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2017-5524",
      "advisory": "Plone 4.x through 4.3.11 and 5.x through 5.0.6 allow remote attackers to bypass a sandbox protection mechanism and obtain sensitive information by leveraging the Python string format method.",
      "cve": "CVE-2017-5524",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1-a1",
        "==5.1-a2"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2020-28734",
      "advisory": "Plone before 5.2.3 allows XXE attacks via a feature that is explicitly only available to the Manager role.",
      "cve": "CVE-2020-28734",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2020-28735",
      "advisory": "Plone before 5.2.3 allows SSRF attacks via the tracebacks feature (only available to the Manager role).",
      "cve": "CVE-2020-28735",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2020-28736",
      "advisory": "Plone before 5.2.3 allows XXE attacks via a feature that is protected by an unapplied permission of plone.schemaeditor.ManageSchemata (therefore, only available to the Manager role).",
      "cve": "CVE-2020-28736",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2020-35190",
      "advisory": "The official plone Docker images before version of 4.3.18-alpine (Alpine specific) contain a blank password for a root user. System using the plone docker container deployed by affected versions of the docker image may allow a remote attacker to achieve root access with a blank password.",
      "cve": "CVE-2020-35190",
      "specs": [
        ">=4.0.0-alpine,<4.3.18-alpine"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2020-7936",
      "advisory": "An open redirect on the login form (and possibly other places) in Plone 4.0 through 5.2.1 allows an attacker to craft a link to a Plone Site that, when followed, and possibly after login, will redirect to an attacker's site.",
      "cve": "CVE-2020-7936",
      "specs": [
        ">=4.0.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2020-7937",
      "advisory": "An XSS issue in the title field in Plone 5.0 through 5.2.1 allows users with a certain privilege level to insert JavaScript that will be executed when other users access the site.",
      "cve": "CVE-2020-7937",
      "specs": [
        ">=5.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2020-7938",
      "advisory": "plone.restapi in Plone 5.2.0 through 5.2.1 allows users with a certain privilege level to escalate their privileges up to the highest level.",
      "cve": "CVE-2020-7938",
      "specs": [
        ">=5.2.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2020-7939",
      "advisory": "SQL Injection in DTML or in connection objects in Plone 4.0 through 5.2.1 allows users to perform unwanted SQL queries. (This is a problem in Zope.)",
      "cve": "CVE-2020-7939",
      "specs": [
        ">=4.0.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2020-7940",
      "advisory": "Missing password strength checks on some forms in Plone 4.3 through 5.2.0 allow users to set weak passwords, leading to easier cracking.",
      "cve": "CVE-2020-7940",
      "specs": [
        ">=4.3.0,<=5.2.0"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2020-7941",
      "advisory": "A privilege escalation issue in plone.app.contenttypes in Plone 4.3 through 5.2.1 allows users to PUT (overwrite) some content without needing write permission.",
      "cve": "CVE-2020-7941",
      "specs": [
        ">=4.3.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2021-29002",
      "advisory": "A stored cross-site scripting (XSS) vulnerability in Plone CMS 5.2.3 exists in site-controlpanel via the \"form.widgets.site_title\" parameter.",
      "cve": "CVE-2021-29002",
      "specs": [
        "==5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2021-32633",
      "advisory": "Zope is an open-source web application server. In Zope versions prior to 4.6 and 5.2, users can access untrusted modules indirectly through Python modules that are available for direct use. By default, only users with the Manager role can add or edit Zope Page Templates through the web, but sites that allow untrusted users to add/edit Zope Page Templates through the web are at risk from this vulnerability. The problem has been fixed in Zope 5.2 and 4.6. As a workaround, a site administrator can restrict adding/editing Zope Page Templates through the web using the standard Zope user/role permission mechanisms. Untrusted users should not be assigned the Zope Manager role and adding/editing Zope Page Templates through the web should be restricted to trusted users only.",
      "cve": "CVE-2021-32633",
      "specs": [
        "<=4.3.20",
        ">=5.0,<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2021-3313",
      "advisory": "Plone CMS until version 5.2.4 has a stored Cross-Site Scripting (XSS) vulnerability in the user fullname property and the file upload functionality. The user's input data is not properly encoded when being echoed back to the user. This data can be interpreted as executable code by the browser and allows an attacker to execute JavaScript in the context of the victim's browser if the victim opens a vulnerable page containing an XSS payload.",
      "cve": "CVE-2021-3313",
      "specs": [
        "<5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2021-33507",
      "advisory": "Zope Products.CMFCore before 2.5.1 and Products.PluggableAuthService before 2.6.2, as used in Plone through 5.2.4 and other products, allow Reflected XSS.",
      "cve": "CVE-2021-33507",
      "specs": [
        "<=4.3.20",
        ">=5.0,<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2021-33508",
      "advisory": "Plone through 5.2.4 allows XSS via a full name that is mishandled during rendering of the ownership tab of a content item.",
      "cve": "CVE-2021-33508",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2021-33509",
      "advisory": "Plone through 5.2.4 allows remote authenticated managers to perform disk I/O via crafted keyword arguments to the ReStructuredText transform in a Python script.",
      "cve": "CVE-2021-33509",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2021-33510",
      "advisory": "Plone through 5.2.4 allows remote authenticated managers to conduct SSRF attacks via an event ical URL, to read one line of a file.",
      "cve": "CVE-2021-33510",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2021-33511",
      "advisory": "Plone though 5.2.4 allows SSRF via the lxml parser. This affects Diazo themes, Dexterity TTW schemas, and modeleditors in plone.app.theming, plone.app.dexterity, and plone.supermodel.",
      "cve": "CVE-2021-33511",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2021-33512",
      "advisory": "Plone through 5.2.4 allows stored XSS attacks (by a Contributor) by uploading an SVG or HTML document.",
      "cve": "CVE-2021-33512",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2021-33513",
      "advisory": "Plone through 5.2.4 allows XSS via the inline_diff methods in Products.CMFDiffTool.",
      "cve": "CVE-2021-33513",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.app.users:CVE-2021-35959",
      "advisory": "In Plone 5.0 through 5.2.4, Editors are vulnerable to XSS in the folder contents view, if a Contributor has created a folder with a SCRIPT tag in the description field.",
      "cve": "CVE-2021-35959",
      "specs": [
        ">=5.0,<=5.2.4"
      ]
    }
  ],
  "plone.supermodel": [
    {
      "id": "pyup.io-plone.supermodel:CVE-2006-1711",
      "advisory": "Plone 2.0.5, 2.1.2, and 2.5-beta1 does not restrict access to the (1) changeMemberPortrait, (2) deletePersonalPortrait, and (3) testCurrentPassword methods, which allows remote attackers to modify portraits.",
      "cve": "CVE-2006-1711",
      "specs": [
        "==2.0.5",
        "==2.1.2",
        "==2.5_beta1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2006-4247",
      "advisory": "Unspecified vulnerability in the Password Reset Tool before 0.4.1 on Plone 2.5 and 2.5.1 Release Candidate allows attackers to reset the passwords of other users, related to \"an erroneous security declaration.\"",
      "cve": "CVE-2006-4247",
      "specs": [
        "==2.5",
        "==2.5.1_rc"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2006-4249",
      "advisory": "Unspecified vulnerability in PlonePAS in Plone 2.5 and 2.5.1, when anonymous member registration is enabled, allows an attacker to \"masquerade as a group.\"",
      "cve": "CVE-2006-4249",
      "specs": [
        "==2.5",
        "==2.5.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2007-5741",
      "advisory": "Plone 2.5 through 2.5.4 and 3.0 through 3.0.2 allows remote attackers to execute arbitrary Python code via network data containing pickled objects for the (1) statusmessages or (2) linkintegrity module, which the module unpickles and executes.",
      "cve": "CVE-2007-5741",
      "specs": [
        "==2.5",
        "==2.5.1",
        "==2.5.1_rc",
        "==2.5.4",
        "==2.5_beta1",
        "==3.0",
        "==3.0.1",
        "==3.0.2"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2008-0164",
      "advisory": "Multiple cross-site request forgery (CSRF) vulnerabilities in Plone CMS 3.0.5 and 3.0.6 allow remote attackers to (1) add arbitrary accounts via the join_form page and (2) change the privileges of arbitrary groups via the prefs_groups_overview page.",
      "cve": "CVE-2008-0164",
      "specs": [
        "==3.0.5",
        "==3.0.6"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2008-1393",
      "advisory": "Plone CMS 3.0.5, and probably other 3.x versions, places a base64 encoded form of the username and password in the __ac cookie for the admin account, which makes it easier for remote attackers to obtain administrative privileges by sniffing the network.",
      "cve": "CVE-2008-1393",
      "specs": [
        "<=3",
        "<=3.0.5"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2008-1394",
      "advisory": "Plone CMS before 3 places a base64 encoded form of the username and password in the __ac cookie for all user accounts, which makes it easier for remote attackers to obtain access by sniffing the network.",
      "cve": "CVE-2008-1394",
      "specs": [
        "<=2.5.1",
        "==2.0.5",
        "==2.1.2",
        "==2.1.3-rc1",
        "==2.5",
        "==2.5-beta1",
        "==2.5-beta2"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2008-4571",
      "advisory": "Cross-site scripting (XSS) vulnerability in the LiveSearch module in Plone before 3.0.4 allows remote attackers to inject arbitrary web script or HTML via the Description field for search results, as demonstrated using the onerror Javascript even in an IMG tag.",
      "cve": "CVE-2008-4571",
      "specs": [
        "<=3.0.3",
        "==2.0.5",
        "==2.1.2",
        "==2.5",
        "==2.5.1",
        "==2.5.1_rc",
        "==2.5.4",
        "==2.5_beta1",
        "==3.0",
        "==3.0.1",
        "==3.0.2"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2010-2422",
      "advisory": "Cross-site scripting (XSS) vulnerability in PortalTransforms in Plone 2.1 through 3.3.4 before hotfix 20100612 allows remote attackers to inject arbitrary web script or HTML via the safe_html transform.",
      "cve": "CVE-2010-2422",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2011-1340",
      "advisory": "Cross-site scripting (XSS) vulnerability in skins/plone_templates/default_error_message.pt in Plone before 2.5.3 allows remote attackers to inject arbitrary web script or HTML via the type_name parameter to Members/ipa/createObject.",
      "cve": "CVE-2011-1340",
      "specs": [
        "<=2.5.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2011-1948",
      "advisory": "Cross-site scripting (XSS) vulnerability in Plone 4.1 and earlier allows remote attackers to inject arbitrary web script or HTML via a crafted URL.",
      "cve": "CVE-2011-1948",
      "specs": [
        "<=4.1",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2011-1949",
      "advisory": "Cross-site scripting (XSS) vulnerability in the safe_html filter in Products.PortalTransforms in Plone 2.1 through 4.1 allows remote authenticated users to inject arbitrary web script or HTML via unspecified vectors, a different vulnerability than CVE-2010-2422.",
      "cve": "CVE-2011-1949",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2011-1950",
      "advisory": "plone.app.users in Plone 4.0 and 4.1 allows remote authenticated users to modify the properties of arbitrary accounts via unspecified vectors, as exploited in the wild in June 2011.",
      "cve": "CVE-2011-1950",
      "specs": [
        "==4.0",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2011-2528",
      "advisory": "Unspecified vulnerability in (1) Zope 2.12.x before 2.12.19 and 2.13.x before 2.13.8, as used in Plone 4.x and other products, and (2) PloneHotfix20110720 for Plone 3.x allows attackers to gain privileges via unspecified vectors, related to a \"highly serious vulnerability.\" NOTE: this vulnerability exists because of an incorrect fix for CVE-2011-0720.",
      "cve": "CVE-2011-2528",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2011-3587",
      "advisory": "Unspecified vulnerability in Zope 2.12.x and 2.13.x, as used in Plone 4.0.x through 4.0.9, 4.1, and 4.2 through 4.2a2, allows remote attackers to execute arbitrary commands via vectors related to the p_ class in OFS/misc_.py and the use of Python modules.",
      "cve": "CVE-2011-3587",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.2",
        "==4.2a1",
        "==4.2a2"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2011-4030",
      "advisory": "The CMFEditions component 2.x in Plone 4.0.x through 4.0.9, 4.1, and 4.2 through 4.2a2 does not prevent the KwAsAttributes classes from being publishable, which allows remote attackers to access sub-objects via unspecified vectors, a different vulnerability than CVE-2011-3587.",
      "cve": "CVE-2011-4030",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.2",
        "==4.2a1",
        "==4.2a2"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2011-4462",
      "advisory": "Plone 4.1.3 and earlier computes hash values for form parameters without restricting the ability to trigger hash collisions predictably, which allows remote attackers to cause a denial of service (CPU consumption) by sending many crafted parameters.",
      "cve": "CVE-2011-4462",
      "specs": [
        "<=4.1.3",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5485",
      "advisory": "registerConfiglet.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via unspecified vectors, related to the admin interface.",
      "cve": "CVE-2012-5485",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5486",
      "advisory": "ZPublisher.HTTPRequest._scrubHeader in Zope 2 before 2.13.19, as used in Plone before 4.3 beta 1, allows remote attackers to inject arbitrary HTTP headers via a linefeed (LF) character.",
      "cve": "CVE-2012-5486",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5487",
      "advisory": "The sandbox whitelisting function (allowmodule.py) in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with certain privileges to bypass the Python sandbox restriction and execute arbitrary Python code via vectors related to importing.",
      "cve": "CVE-2012-5487",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5488",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via a crafted URL, related to createObject.",
      "cve": "CVE-2012-5488",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5489",
      "advisory": "The App.Undo.UndoSupport.get_request_var_or_attr function in Zope before 2.12.21 and 3.13.x before 2.13.11, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote authenticated users to gain access to restricted attributes via unspecified vectors.",
      "cve": "CVE-2012-5489",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5490",
      "advisory": "Cross-site scripting (XSS) vulnerability in kssdevel.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5490",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5491",
      "advisory": "z3c.form, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote attackers to obtain the default form field values by leveraging knowledge of the form location and the element id.",
      "cve": "CVE-2012-5491",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5492",
      "advisory": "uid_catalog.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to obtain metadata about hidden objects via a crafted URL.",
      "cve": "CVE-2012-5492",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5493",
      "advisory": "gtbn.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with certain permissions to bypass the Python sandbox and execute arbitrary Python code via unspecified vectors.",
      "cve": "CVE-2012-5493",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5494",
      "advisory": "Cross-site scripting (XSS) vulnerability in python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors, related to \"{u,}translate.\"",
      "cve": "CVE-2012-5494",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5495",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via a crafted URL, related to \"go_back.\"",
      "cve": "CVE-2012-5495",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5496",
      "advisory": "kupu_spellcheck.py in Kupu in Plone before 4.0 allows remote attackers to cause a denial of service (ZServer thread lock) via a crafted URL.",
      "cve": "CVE-2012-5496",
      "specs": [
        "<=3.3.5",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5497",
      "advisory": "membership_tool.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to enumerate user account names via a crafted URL.",
      "cve": "CVE-2012-5497",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5498",
      "advisory": "queryCatalog.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to bypass caching and cause a denial of service via a crafted request to a collection.",
      "cve": "CVE-2012-5498",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5499",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to cause a denial of service (memory consumption) via a large value, related to formatColumns.",
      "cve": "CVE-2012-5499",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5500",
      "advisory": "The batch id change script (renameObjectsByPaths.py) in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to change the titles of content items by leveraging a valid CSRF token in a crafted request.",
      "cve": "CVE-2012-5500",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5501",
      "advisory": "at_download.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read arbitrary BLOBs (Files and Images) stored on custom content types via a crafted URL.",
      "cve": "CVE-2012-5501",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5502",
      "advisory": "Cross-site scripting (XSS) vulnerability in safe_html.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with permissions to edit content to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5502",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5503",
      "advisory": "ftp.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read hidden folder contents via unspecified vectors.",
      "cve": "CVE-2012-5503",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5504",
      "advisory": "Cross-site scripting (XSS) vulnerability in widget_traversal.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5504",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5505",
      "advisory": "atat.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read private data structures via a request for a view without a name.",
      "cve": "CVE-2012-5505",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5506",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to cause a denial of service (infinite loop) via an RSS feed request for a folder the user does not have permission to access.",
      "cve": "CVE-2012-5506",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5507",
      "advisory": "AccessControl/AuthEncoding.py in Zope before 2.13.19, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote attackers to obtain passwords via vectors involving timing discrepancies in password validation.",
      "cve": "CVE-2012-5507",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-5508",
      "advisory": "The error pages in Plone before 4.2.3 and 4.3 before beta 1 allow remote attackers to obtain random numbers and derive the PRNG state for password resets via unspecified vectors.  NOTE: this identifier was SPLIT per ADT2 due to different vulnerability types. CVE-2012-6661 was assigned for the PRNG reseeding issue in Zope.",
      "cve": "CVE-2012-5508",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2012-6661",
      "advisory": "Zope before 2.13.19, as used in Plone before 4.2.3 and 4.3 before beta 1, does not reseed the pseudo-random number generator (PRNG), which makes it easier for remote attackers to guess the value via unspecified vectors.  NOTE: this issue was SPLIT from CVE-2012-5508 due to different vulnerability types (ADT2).",
      "cve": "CVE-2012-6661",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2013-4188",
      "advisory": "traverser.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote attackers with administrator privileges to cause a denial of service (infinite loop and resource consumption) via unspecified vectors related to \"retrieving information for certain resources.\"",
      "cve": "CVE-2013-4188",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2013-4189",
      "advisory": "Multiple unspecified vulnerabilities in (1) dataitems.py, (2) get.py, and (3) traverseName.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote authenticated users with administrator access to a subtree to access nodes above the subtree via unknown vectors.",
      "cve": "CVE-2013-4189",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2013-4190",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in (1) spamProtect.py, (2) pts.py, and (3) request.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2013-4190",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2013-4191",
      "advisory": "zip.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly enforce access restrictions when including content in a zip archive, which allows remote attackers to obtain sensitive information by reading a generated archive.",
      "cve": "CVE-2013-4191",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2013-4192",
      "advisory": "sendto.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to spoof emails via unspecified vectors.",
      "cve": "CVE-2013-4192",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2013-4193",
      "advisory": "typeswidget.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly enforce the immutable setting on unspecified content edit forms, which allows remote attackers to hide fields on the forms via a crafted URL.",
      "cve": "CVE-2013-4193",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2013-4194",
      "advisory": "The WYSIWYG component (wysiwyg.py) in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote attackers to obtain sensitive information via a crafted URL, which reveals the installation path in an error message.",
      "cve": "CVE-2013-4194",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2013-4195",
      "advisory": "Multiple open redirect vulnerabilities in (1) marmoset_patch.py, (2) publish.py, and (3) principiaredirect.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via unspecified vectors.",
      "cve": "CVE-2013-4195",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2013-4196",
      "advisory": "The object manager implementation (objectmanager.py) in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly restrict access to internal methods, which allows remote attackers to obtain sensitive information via a crafted request.",
      "cve": "CVE-2013-4196",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2013-4197",
      "advisory": "member_portrait.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to modify or delete portraits of other users via unspecified vectors.",
      "cve": "CVE-2013-4197",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2013-4198",
      "advisory": "mail_password.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to bypass the prohibition on password changes via the forgotten password email functionality.",
      "cve": "CVE-2013-4198",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2013-4199",
      "advisory": "(1) cb_decode.py and (2) linkintegrity.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote authenticated users to cause a denial of service (resource consumption) via a large zip archive, which is expanded (decompressed).",
      "cve": "CVE-2013-4199",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2013-4200",
      "advisory": "The isURLInPortal method in the URLTool class in in_portal.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 treats URLs starting with a space as a relative URL, which allows remote attackers to bypass the allow_external_login_sites filtering property,  redirect users to arbitrary web sites, and conduct phishing attacks via a space before a URL in the \"next\" parameter to acl_users/credentials_cookie_auth/require_login.",
      "cve": "CVE-2013-4200",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2013-7060",
      "advisory": "Products/CMFPlone/FactoryTool.py in Plone 3.3 through 4.3.2 allows remote attackers to obtain the installation path via vectors related to a file object for unspecified documentation which is initialized in class scope.",
      "cve": "CVE-2013-7060",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2013-7061",
      "advisory": "Products/CMFPlone/CatalogTool.py in Plone 3.3 through 4.3.2 allows remote administrators to bypass restrictions and obtain sensitive information via an unspecified search API.",
      "cve": "CVE-2013-7061",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2013-7062",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in Zope, as used in Plone 3.3.x through 3.3.6, 4.0.x through 4.0.9, 4.1.x through 4.1.6, 4.2.x through 4.2.7, and 4.3 through 4.3.2, allow remote attackers to inject arbitrary web script or HTML via unspecified input in the (1) browser_id_manager or (2) OFS.Image method.",
      "cve": "CVE-2013-7062",
      "specs": [
        ">=3.3.0,<=3.3.6",
        ">=4.0.0,<=4.0.9",
        ">=4.1.0,<=4.1.6",
        ">=4.2.0,<=4.2.7",
        ">=4.3.0,<=4.3.2"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2015-7293",
      "advisory": "Multiple cross-site request forgery (CSRF) vulnerabilities in Zope Management Interface 4.3.7 and earlier, and Plone before 5.x.",
      "cve": "CVE-2015-7293",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2015-7315",
      "advisory": "Plone 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, 4.2.0 through 4.2.7, 4.3.0 through 4.3.6, and 5.0rc1 allows remote attackers to add a new member to a Plone site with registration enabled, without acknowledgment of site administrator.",
      "cve": "CVE-2015-7315",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==5.0-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2015-7316",
      "advisory": "Cross-site scripting (XSS) vulnerability in Plone 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, 4.2.0 through 4.2.7, 4.3.x before 4.3.7, and 5.0rc1.",
      "cve": "CVE-2015-7316",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==5.0-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2015-7317",
      "advisory": "Kupu 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, and 4.2.0 through 4.2.7 allows remote authenticated users to edit Kupu settings.",
      "cve": "CVE-2015-7317",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2015-7318",
      "advisory": "Plone 3.3.0 through 3.3.6 allows remote attackers to inject headers into HTTP responses.",
      "cve": "CVE-2015-7318",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2016-4041",
      "advisory": "Plone 4.0 through 5.1a1 does not have security declarations for Dexterity content-related WebDAV requests, which allows remote attackers to gain webdav access via unspecified vectors.",
      "cve": "CVE-2016-4041",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2016-4042",
      "advisory": "Plone 3.3 through 5.1a1 allows remote attackers to obtain information about the ID of sensitive content via unspecified vectors.",
      "cve": "CVE-2016-4042",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2016-4043",
      "advisory": "Chameleon (five.pt) in Plone 5.0rc1 through 5.1a1 allows remote authenticated users to bypass Restricted Python by leveraging permissions to create or edit templates.",
      "cve": "CVE-2016-4043",
      "specs": [
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2016-7135",
      "advisory": "Directory traversal vulnerability in Plone CMS 5.x through 5.0.6 and 4.2.x through 4.3.11 allows remote administrators to read arbitrary files via a .. (dot dot) in the path parameter in a getFile action to Plone/++theme++barceloneta/@@plone.resourceeditor.filemanager-actions.",
      "cve": "CVE-2016-7135",
      "specs": [
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2016-7136",
      "advisory": "z3c.form in Plone CMS 5.x through 5.0.6 and 4.x through 4.3.11 allows remote attackers to conduct cross-site scripting (XSS) attacks via a crafted GET request.",
      "cve": "CVE-2016-7136",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2016-7137",
      "advisory": "Multiple open redirect vulnerabilities in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allow remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via a URL in the referer parameter to (1) %2b%2bgroupdashboard%2b%2bplone.dashboard1%2bgroup/%2b/portlets.Actions or (2) folder/%2b%2bcontextportlets%2b%2bplone.footerportlets/%2b /portlets.Actions or the (3) came_from parameter to /login_form.",
      "cve": "CVE-2016-7137",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2016-7138",
      "advisory": "Cross-site scripting (XSS) vulnerability in the URL checking infrastructure in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allows remote attackers to inject arbitrary web script or HTML via a crafted URL.",
      "cve": "CVE-2016-7138",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2016-7139",
      "advisory": "Cross-site scripting (XSS) vulnerability in an unspecified page template in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allows remote attackers to inject arbitrary web script or HTML via unknown vectors.",
      "cve": "CVE-2016-7139",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2016-7140",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in the ZMI page in Zope2 in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allow remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2016-7140",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2016-7147",
      "advisory": "Cross-site scripting (XSS) vulnerability in the manage_findResult component in the search feature in Zope ZMI in Plone before 4.3.12 and 5.x before 5.0.7 allows remote attackers to inject arbitrary web script or HTML via vectors involving double quotes, as demonstrated by the obj_ids:tokens parameter. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-7140.",
      "cve": "CVE-2016-7147",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1-a1",
        "==5.1-a2"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2017-1000481",
      "advisory": "When you visit a page where you need to login, Plone 2.5-5.1rc1 sends you to the login form with a 'came_from' parameter set to the previous url. After you login, you get redirected to the page you tried to view before. An attacker might try to abuse this by letting you click on a specially crafted link. You would login, and get redirected to the site of the attacker, letting you think that you are still on the original Plone site. Or some javascript of the attacker could be executed. Most of these types of attacks are already blocked by Plone, using the `isURLInPortal` check to make sure we only redirect to a page on the same Plone site. But a few more ways of tricking Plone into accepting a malicious link were discovered, and fixed with this hotfix.",
      "cve": "CVE-2017-1000481",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2017-1000482",
      "advisory": "A member of the Plone 2.5-5.1rc1 site could set javascript in the home_page property of his profile, and have this executed when a visitor click the home page link on the author page.",
      "cve": "CVE-2017-1000482",
      "specs": [
        "<=5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2017-1000483",
      "advisory": "Accessing private content via str.format in through-the-web templates and scripts in Plone 2.5-5.1rc1. This improves an earlier hotfix. Since the format method was introduced in Python 2.6, this part of the hotfix is only relevant for Plone 4 and 5.",
      "cve": "CVE-2017-1000483",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2017-1000484",
      "advisory": "By linking to a specific url in Plone 2.5-5.1rc1 with a parameter, an attacker could send you to his own website. On its own this is not so bad: the attacker could more easily link directly to his own website instead. But in combination with another attack, you could be sent to the Plone login form and login, then get redirected to the specific url, and then get a second redirect to the attacker website. (The specific url can be seen by inspecting the hotfix code, but we don't want to make it too easy for attackers by spelling it out here.)",
      "cve": "CVE-2017-1000484",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2017-5524",
      "advisory": "Plone 4.x through 4.3.11 and 5.x through 5.0.6 allow remote attackers to bypass a sandbox protection mechanism and obtain sensitive information by leveraging the Python string format method.",
      "cve": "CVE-2017-5524",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1-a1",
        "==5.1-a2"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2020-28734",
      "advisory": "Plone before 5.2.3 allows XXE attacks via a feature that is explicitly only available to the Manager role.",
      "cve": "CVE-2020-28734",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2020-28735",
      "advisory": "Plone before 5.2.3 allows SSRF attacks via the tracebacks feature (only available to the Manager role).",
      "cve": "CVE-2020-28735",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2020-28736",
      "advisory": "Plone before 5.2.3 allows XXE attacks via a feature that is protected by an unapplied permission of plone.schemaeditor.ManageSchemata (therefore, only available to the Manager role).",
      "cve": "CVE-2020-28736",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2020-35190",
      "advisory": "The official plone Docker images before version of 4.3.18-alpine (Alpine specific) contain a blank password for a root user. System using the plone docker container deployed by affected versions of the docker image may allow a remote attacker to achieve root access with a blank password.",
      "cve": "CVE-2020-35190",
      "specs": [
        ">=4.0.0-alpine,<4.3.18-alpine"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2020-7936",
      "advisory": "An open redirect on the login form (and possibly other places) in Plone 4.0 through 5.2.1 allows an attacker to craft a link to a Plone Site that, when followed, and possibly after login, will redirect to an attacker's site.",
      "cve": "CVE-2020-7936",
      "specs": [
        ">=4.0.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2020-7937",
      "advisory": "An XSS issue in the title field in Plone 5.0 through 5.2.1 allows users with a certain privilege level to insert JavaScript that will be executed when other users access the site.",
      "cve": "CVE-2020-7937",
      "specs": [
        ">=5.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2020-7938",
      "advisory": "plone.restapi in Plone 5.2.0 through 5.2.1 allows users with a certain privilege level to escalate their privileges up to the highest level.",
      "cve": "CVE-2020-7938",
      "specs": [
        ">=5.2.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2020-7939",
      "advisory": "SQL Injection in DTML or in connection objects in Plone 4.0 through 5.2.1 allows users to perform unwanted SQL queries. (This is a problem in Zope.)",
      "cve": "CVE-2020-7939",
      "specs": [
        ">=4.0.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2020-7940",
      "advisory": "Missing password strength checks on some forms in Plone 4.3 through 5.2.0 allow users to set weak passwords, leading to easier cracking.",
      "cve": "CVE-2020-7940",
      "specs": [
        ">=4.3.0,<=5.2.0"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2020-7941",
      "advisory": "A privilege escalation issue in plone.app.contenttypes in Plone 4.3 through 5.2.1 allows users to PUT (overwrite) some content without needing write permission.",
      "cve": "CVE-2020-7941",
      "specs": [
        ">=4.3.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2021-29002",
      "advisory": "A stored cross-site scripting (XSS) vulnerability in Plone CMS 5.2.3 exists in site-controlpanel via the \"form.widgets.site_title\" parameter.",
      "cve": "CVE-2021-29002",
      "specs": [
        "==5.2.3"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2021-32633",
      "advisory": "Zope is an open-source web application server. In Zope versions prior to 4.6 and 5.2, users can access untrusted modules indirectly through Python modules that are available for direct use. By default, only users with the Manager role can add or edit Zope Page Templates through the web, but sites that allow untrusted users to add/edit Zope Page Templates through the web are at risk from this vulnerability. The problem has been fixed in Zope 5.2 and 4.6. As a workaround, a site administrator can restrict adding/editing Zope Page Templates through the web using the standard Zope user/role permission mechanisms. Untrusted users should not be assigned the Zope Manager role and adding/editing Zope Page Templates through the web should be restricted to trusted users only.",
      "cve": "CVE-2021-32633",
      "specs": [
        "<=4.3.20",
        ">=5.0,<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2021-3313",
      "advisory": "Plone CMS until version 5.2.4 has a stored Cross-Site Scripting (XSS) vulnerability in the user fullname property and the file upload functionality. The user's input data is not properly encoded when being echoed back to the user. This data can be interpreted as executable code by the browser and allows an attacker to execute JavaScript in the context of the victim's browser if the victim opens a vulnerable page containing an XSS payload.",
      "cve": "CVE-2021-3313",
      "specs": [
        "<5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2021-33507",
      "advisory": "Zope Products.CMFCore before 2.5.1 and Products.PluggableAuthService before 2.6.2, as used in Plone through 5.2.4 and other products, allow Reflected XSS.",
      "cve": "CVE-2021-33507",
      "specs": [
        "<=4.3.20",
        ">=5.0,<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2021-33508",
      "advisory": "Plone through 5.2.4 allows XSS via a full name that is mishandled during rendering of the ownership tab of a content item.",
      "cve": "CVE-2021-33508",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2021-33509",
      "advisory": "Plone through 5.2.4 allows remote authenticated managers to perform disk I/O via crafted keyword arguments to the ReStructuredText transform in a Python script.",
      "cve": "CVE-2021-33509",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2021-33510",
      "advisory": "Plone through 5.2.4 allows remote authenticated managers to conduct SSRF attacks via an event ical URL, to read one line of a file.",
      "cve": "CVE-2021-33510",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2021-33511",
      "advisory": "Plone though 5.2.4 allows SSRF via the lxml parser. This affects Diazo themes, Dexterity TTW schemas, and modeleditors in plone.app.theming, plone.app.dexterity, and plone.supermodel.",
      "cve": "CVE-2021-33511",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2021-33512",
      "advisory": "Plone through 5.2.4 allows stored XSS attacks (by a Contributor) by uploading an SVG or HTML document.",
      "cve": "CVE-2021-33512",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2021-33513",
      "advisory": "Plone through 5.2.4 allows XSS via the inline_diff methods in Products.CMFDiffTool.",
      "cve": "CVE-2021-33513",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-plone.supermodel:CVE-2021-35959",
      "advisory": "In Plone 5.0 through 5.2.4, Editors are vulnerable to XSS in the folder contents view, if a Contributor has created a folder with a SCRIPT tag in the description field.",
      "cve": "CVE-2021-35959",
      "specs": [
        ">=5.0,<=5.2.4"
      ]
    }
  ],
  "postfix-mta-sts-resolver": [
    {
      "id": "pyup.io-postfix-mta-sts-resolver:CVE-2019-16791",
      "advisory": "In postfix-mta-sts-resolver before 0.5.1, All users can receive incorrect response from daemon under rare conditions, rendering downgrade of effective STS policy.",
      "cve": "CVE-2019-16791",
      "specs": [
        "<0.5.1"
      ]
    }
  ],
  "priority": [
    {
      "id": "pyup.io-priority:CVE-2016-6580",
      "advisory": "A HTTP/2 implementation built using any version of the Python priority library prior to version 1.2.0 could be targeted by a malicious peer by having that peer assign priority information for every possible HTTP/2 stream ID. The priority tree would happily continue to store the priority information for each stream, and would therefore allocate unbounded amounts of memory. Attempting to actually use a tree like this would also cause extremely high CPU usage to maintain the tree.",
      "cve": "CVE-2016-6580",
      "specs": [
        "==1.0.0",
        "==1.1.0",
        "==1.1.1"
      ]
    }
  ],
  "privacyidea": [
    {
      "id": "pyup.io-privacyidea:CVE-2018-1000809",
      "advisory": "privacyIDEA version 2.23.1 and earlier contains a Improper Input Validation vulnerability in token validation api that can result in Denial-of-Service. This attack appear to be exploitable via http request with user=<space>&pass= to /validate/check url. This vulnerability appears to have been fixed in 2.23.2.",
      "cve": "CVE-2018-1000809",
      "specs": [
        "<=2.23.1"
      ]
    }
  ],
  "products.cmfplone": [
    {
      "id": "pyup.io-products.cmfplone:CVE-2006-1711",
      "advisory": "Plone 2.0.5, 2.1.2, and 2.5-beta1 does not restrict access to the (1) changeMemberPortrait, (2) deletePersonalPortrait, and (3) testCurrentPassword methods, which allows remote attackers to modify portraits.",
      "cve": "CVE-2006-1711",
      "specs": [
        "==2.0.5",
        "==2.1.2",
        "==2.5_beta1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2006-4247",
      "advisory": "Unspecified vulnerability in the Password Reset Tool before 0.4.1 on Plone 2.5 and 2.5.1 Release Candidate allows attackers to reset the passwords of other users, related to \"an erroneous security declaration.\"",
      "cve": "CVE-2006-4247",
      "specs": [
        "==2.5",
        "==2.5.1_rc"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2006-4249",
      "advisory": "Unspecified vulnerability in PlonePAS in Plone 2.5 and 2.5.1, when anonymous member registration is enabled, allows an attacker to \"masquerade as a group.\"",
      "cve": "CVE-2006-4249",
      "specs": [
        "==2.5",
        "==2.5.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2007-5741",
      "advisory": "Plone 2.5 through 2.5.4 and 3.0 through 3.0.2 allows remote attackers to execute arbitrary Python code via network data containing pickled objects for the (1) statusmessages or (2) linkintegrity module, which the module unpickles and executes.",
      "cve": "CVE-2007-5741",
      "specs": [
        "==2.5",
        "==2.5.1",
        "==2.5.1_rc",
        "==2.5.4",
        "==2.5_beta1",
        "==3.0",
        "==3.0.1",
        "==3.0.2"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2008-4571",
      "advisory": "Cross-site scripting (XSS) vulnerability in the LiveSearch module in Plone before 3.0.4 allows remote attackers to inject arbitrary web script or HTML via the Description field for search results, as demonstrated using the onerror Javascript even in an IMG tag.",
      "cve": "CVE-2008-4571",
      "specs": [
        "<=3.0.3",
        "==2.0.5",
        "==2.1.2",
        "==2.5",
        "==2.5.1",
        "==2.5.1_rc",
        "==2.5.4",
        "==2.5_beta1",
        "==3.0",
        "==3.0.1",
        "==3.0.2"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2010-2422",
      "advisory": "Cross-site scripting (XSS) vulnerability in PortalTransforms in Plone 2.1 through 3.3.4 before hotfix 20100612 allows remote attackers to inject arbitrary web script or HTML via the safe_html transform.",
      "cve": "CVE-2010-2422",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2011-1340",
      "advisory": "Cross-site scripting (XSS) vulnerability in skins/plone_templates/default_error_message.pt in Plone before 2.5.3 allows remote attackers to inject arbitrary web script or HTML via the type_name parameter to Members/ipa/createObject.",
      "cve": "CVE-2011-1340",
      "specs": [
        "<=2.5.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2011-1948",
      "advisory": "Cross-site scripting (XSS) vulnerability in Plone 4.1 and earlier allows remote attackers to inject arbitrary web script or HTML via a crafted URL.",
      "cve": "CVE-2011-1948",
      "specs": [
        "<=4.1",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2011-1949",
      "advisory": "Cross-site scripting (XSS) vulnerability in the safe_html filter in Products.PortalTransforms in Plone 2.1 through 4.1 allows remote authenticated users to inject arbitrary web script or HTML via unspecified vectors, a different vulnerability than CVE-2010-2422.",
      "cve": "CVE-2011-1949",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2011-1950",
      "advisory": "plone.app.users in Plone 4.0 and 4.1 allows remote authenticated users to modify the properties of arbitrary accounts via unspecified vectors, as exploited in the wild in June 2011.",
      "cve": "CVE-2011-1950",
      "specs": [
        "==4.0",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2011-2528",
      "advisory": "Unspecified vulnerability in (1) Zope 2.12.x before 2.12.19 and 2.13.x before 2.13.8, as used in Plone 4.x and other products, and (2) PloneHotfix20110720 for Plone 3.x allows attackers to gain privileges via unspecified vectors, related to a \"highly serious vulnerability.\" NOTE: this vulnerability exists because of an incorrect fix for CVE-2011-0720.",
      "cve": "CVE-2011-2528",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2011-3587",
      "advisory": "Unspecified vulnerability in Zope 2.12.x and 2.13.x, as used in Plone 4.0.x through 4.0.9, 4.1, and 4.2 through 4.2a2, allows remote attackers to execute arbitrary commands via vectors related to the p_ class in OFS/misc_.py and the use of Python modules.",
      "cve": "CVE-2011-3587",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.2",
        "==4.2a1",
        "==4.2a2"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2011-4030",
      "advisory": "The CMFEditions component 2.x in Plone 4.0.x through 4.0.9, 4.1, and 4.2 through 4.2a2 does not prevent the KwAsAttributes classes from being publishable, which allows remote attackers to access sub-objects via unspecified vectors, a different vulnerability than CVE-2011-3587.",
      "cve": "CVE-2011-4030",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.2",
        "==4.2a1",
        "==4.2a2"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2011-4462",
      "advisory": "Plone 4.1.3 and earlier computes hash values for form parameters without restricting the ability to trigger hash collisions predictably, which allows remote attackers to cause a denial of service (CPU consumption) by sending many crafted parameters.",
      "cve": "CVE-2011-4462",
      "specs": [
        "<=4.1.3",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5485",
      "advisory": "registerConfiglet.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via unspecified vectors, related to the admin interface.",
      "cve": "CVE-2012-5485",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5486",
      "advisory": "ZPublisher.HTTPRequest._scrubHeader in Zope 2 before 2.13.19, as used in Plone before 4.3 beta 1, allows remote attackers to inject arbitrary HTTP headers via a linefeed (LF) character.",
      "cve": "CVE-2012-5486",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5487",
      "advisory": "The sandbox whitelisting function (allowmodule.py) in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with certain privileges to bypass the Python sandbox restriction and execute arbitrary Python code via vectors related to importing.",
      "cve": "CVE-2012-5487",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5488",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via a crafted URL, related to createObject.",
      "cve": "CVE-2012-5488",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5489",
      "advisory": "The App.Undo.UndoSupport.get_request_var_or_attr function in Zope before 2.12.21 and 3.13.x before 2.13.11, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote authenticated users to gain access to restricted attributes via unspecified vectors.",
      "cve": "CVE-2012-5489",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5490",
      "advisory": "Cross-site scripting (XSS) vulnerability in kssdevel.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5490",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5491",
      "advisory": "z3c.form, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote attackers to obtain the default form field values by leveraging knowledge of the form location and the element id.",
      "cve": "CVE-2012-5491",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5492",
      "advisory": "uid_catalog.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to obtain metadata about hidden objects via a crafted URL.",
      "cve": "CVE-2012-5492",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5493",
      "advisory": "gtbn.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with certain permissions to bypass the Python sandbox and execute arbitrary Python code via unspecified vectors.",
      "cve": "CVE-2012-5493",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5494",
      "advisory": "Cross-site scripting (XSS) vulnerability in python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors, related to \"{u,}translate.\"",
      "cve": "CVE-2012-5494",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5495",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via a crafted URL, related to \"go_back.\"",
      "cve": "CVE-2012-5495",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5496",
      "advisory": "kupu_spellcheck.py in Kupu in Plone before 4.0 allows remote attackers to cause a denial of service (ZServer thread lock) via a crafted URL.",
      "cve": "CVE-2012-5496",
      "specs": [
        "<=3.3.5",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5497",
      "advisory": "membership_tool.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to enumerate user account names via a crafted URL.",
      "cve": "CVE-2012-5497",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5498",
      "advisory": "queryCatalog.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to bypass caching and cause a denial of service via a crafted request to a collection.",
      "cve": "CVE-2012-5498",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5499",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to cause a denial of service (memory consumption) via a large value, related to formatColumns.",
      "cve": "CVE-2012-5499",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5500",
      "advisory": "The batch id change script (renameObjectsByPaths.py) in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to change the titles of content items by leveraging a valid CSRF token in a crafted request.",
      "cve": "CVE-2012-5500",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5501",
      "advisory": "at_download.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read arbitrary BLOBs (Files and Images) stored on custom content types via a crafted URL.",
      "cve": "CVE-2012-5501",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5502",
      "advisory": "Cross-site scripting (XSS) vulnerability in safe_html.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with permissions to edit content to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5502",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5503",
      "advisory": "ftp.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read hidden folder contents via unspecified vectors.",
      "cve": "CVE-2012-5503",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5504",
      "advisory": "Cross-site scripting (XSS) vulnerability in widget_traversal.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5504",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5505",
      "advisory": "atat.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read private data structures via a request for a view without a name.",
      "cve": "CVE-2012-5505",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5506",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to cause a denial of service (infinite loop) via an RSS feed request for a folder the user does not have permission to access.",
      "cve": "CVE-2012-5506",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5507",
      "advisory": "AccessControl/AuthEncoding.py in Zope before 2.13.19, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote attackers to obtain passwords via vectors involving timing discrepancies in password validation.",
      "cve": "CVE-2012-5507",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-5508",
      "advisory": "The error pages in Plone before 4.2.3 and 4.3 before beta 1 allow remote attackers to obtain random numbers and derive the PRNG state for password resets via unspecified vectors.  NOTE: this identifier was SPLIT per ADT2 due to different vulnerability types. CVE-2012-6661 was assigned for the PRNG reseeding issue in Zope.",
      "cve": "CVE-2012-5508",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2012-6661",
      "advisory": "Zope before 2.13.19, as used in Plone before 4.2.3 and 4.3 before beta 1, does not reseed the pseudo-random number generator (PRNG), which makes it easier for remote attackers to guess the value via unspecified vectors.  NOTE: this issue was SPLIT from CVE-2012-5508 due to different vulnerability types (ADT2).",
      "cve": "CVE-2012-6661",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2013-4188",
      "advisory": "traverser.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote attackers with administrator privileges to cause a denial of service (infinite loop and resource consumption) via unspecified vectors related to \"retrieving information for certain resources.\"",
      "cve": "CVE-2013-4188",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2013-4189",
      "advisory": "Multiple unspecified vulnerabilities in (1) dataitems.py, (2) get.py, and (3) traverseName.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote authenticated users with administrator access to a subtree to access nodes above the subtree via unknown vectors.",
      "cve": "CVE-2013-4189",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2013-4190",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in (1) spamProtect.py, (2) pts.py, and (3) request.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2013-4190",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2013-4191",
      "advisory": "zip.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly enforce access restrictions when including content in a zip archive, which allows remote attackers to obtain sensitive information by reading a generated archive.",
      "cve": "CVE-2013-4191",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2013-4192",
      "advisory": "sendto.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to spoof emails via unspecified vectors.",
      "cve": "CVE-2013-4192",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2013-4193",
      "advisory": "typeswidget.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly enforce the immutable setting on unspecified content edit forms, which allows remote attackers to hide fields on the forms via a crafted URL.",
      "cve": "CVE-2013-4193",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2013-4194",
      "advisory": "The WYSIWYG component (wysiwyg.py) in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote attackers to obtain sensitive information via a crafted URL, which reveals the installation path in an error message.",
      "cve": "CVE-2013-4194",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2013-4195",
      "advisory": "Multiple open redirect vulnerabilities in (1) marmoset_patch.py, (2) publish.py, and (3) principiaredirect.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via unspecified vectors.",
      "cve": "CVE-2013-4195",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2013-4196",
      "advisory": "The object manager implementation (objectmanager.py) in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly restrict access to internal methods, which allows remote attackers to obtain sensitive information via a crafted request.",
      "cve": "CVE-2013-4196",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2013-4197",
      "advisory": "member_portrait.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to modify or delete portraits of other users via unspecified vectors.",
      "cve": "CVE-2013-4197",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2013-4198",
      "advisory": "mail_password.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to bypass the prohibition on password changes via the forgotten password email functionality.",
      "cve": "CVE-2013-4198",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2013-4199",
      "advisory": "(1) cb_decode.py and (2) linkintegrity.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote authenticated users to cause a denial of service (resource consumption) via a large zip archive, which is expanded (decompressed).",
      "cve": "CVE-2013-4199",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2013-4200",
      "advisory": "The isURLInPortal method in the URLTool class in in_portal.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 treats URLs starting with a space as a relative URL, which allows remote attackers to bypass the allow_external_login_sites filtering property,  redirect users to arbitrary web sites, and conduct phishing attacks via a space before a URL in the \"next\" parameter to acl_users/credentials_cookie_auth/require_login.",
      "cve": "CVE-2013-4200",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2013-7060",
      "advisory": "Products/CMFPlone/FactoryTool.py in Plone 3.3 through 4.3.2 allows remote attackers to obtain the installation path via vectors related to a file object for unspecified documentation which is initialized in class scope.",
      "cve": "CVE-2013-7060",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2013-7061",
      "advisory": "Products/CMFPlone/CatalogTool.py in Plone 3.3 through 4.3.2 allows remote administrators to bypass restrictions and obtain sensitive information via an unspecified search API.",
      "cve": "CVE-2013-7061",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2013-7062",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in Zope, as used in Plone 3.3.x through 3.3.6, 4.0.x through 4.0.9, 4.1.x through 4.1.6, 4.2.x through 4.2.7, and 4.3 through 4.3.2, allow remote attackers to inject arbitrary web script or HTML via unspecified input in the (1) browser_id_manager or (2) OFS.Image method.",
      "cve": "CVE-2013-7062",
      "specs": [
        ">=3.3.0,<=3.3.6",
        ">=4.0.0,<=4.0.9",
        ">=4.1.0,<=4.1.6",
        ">=4.2.0,<=4.2.7",
        ">=4.3.0,<=4.3.2"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2015-7293",
      "advisory": "Multiple cross-site request forgery (CSRF) vulnerabilities in Zope Management Interface 4.3.7 and earlier, and Plone before 5.x.",
      "cve": "CVE-2015-7293",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2015-7315",
      "advisory": "Plone 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, 4.2.0 through 4.2.7, 4.3.0 through 4.3.6, and 5.0rc1 allows remote attackers to add a new member to a Plone site with registration enabled, without acknowledgment of site administrator.",
      "cve": "CVE-2015-7315",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==5.0-rc1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2015-7316",
      "advisory": "Cross-site scripting (XSS) vulnerability in Plone 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, 4.2.0 through 4.2.7, 4.3.x before 4.3.7, and 5.0rc1.",
      "cve": "CVE-2015-7316",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==5.0-rc1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2015-7317",
      "advisory": "Kupu 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, and 4.2.0 through 4.2.7 allows remote authenticated users to edit Kupu settings.",
      "cve": "CVE-2015-7317",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2015-7318",
      "advisory": "Plone 3.3.0 through 3.3.6 allows remote attackers to inject headers into HTTP responses.",
      "cve": "CVE-2015-7318",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2016-4041",
      "advisory": "Plone 4.0 through 5.1a1 does not have security declarations for Dexterity content-related WebDAV requests, which allows remote attackers to gain webdav access via unspecified vectors.",
      "cve": "CVE-2016-4041",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2016-4042",
      "advisory": "Plone 3.3 through 5.1a1 allows remote attackers to obtain information about the ID of sensitive content via unspecified vectors.",
      "cve": "CVE-2016-4042",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2016-4043",
      "advisory": "Chameleon (five.pt) in Plone 5.0rc1 through 5.1a1 allows remote authenticated users to bypass Restricted Python by leveraging permissions to create or edit templates.",
      "cve": "CVE-2016-4043",
      "specs": [
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2016-7135",
      "advisory": "Directory traversal vulnerability in Plone CMS 5.x through 5.0.6 and 4.2.x through 4.3.11 allows remote administrators to read arbitrary files via a .. (dot dot) in the path parameter in a getFile action to Plone/++theme++barceloneta/@@plone.resourceeditor.filemanager-actions.",
      "cve": "CVE-2016-7135",
      "specs": [
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2016-7136",
      "advisory": "z3c.form in Plone CMS 5.x through 5.0.6 and 4.x through 4.3.11 allows remote attackers to conduct cross-site scripting (XSS) attacks via a crafted GET request.",
      "cve": "CVE-2016-7136",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2016-7137",
      "advisory": "Multiple open redirect vulnerabilities in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allow remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via a URL in the referer parameter to (1) %2b%2bgroupdashboard%2b%2bplone.dashboard1%2bgroup/%2b/portlets.Actions or (2) folder/%2b%2bcontextportlets%2b%2bplone.footerportlets/%2b /portlets.Actions or the (3) came_from parameter to /login_form.",
      "cve": "CVE-2016-7137",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2016-7138",
      "advisory": "Cross-site scripting (XSS) vulnerability in the URL checking infrastructure in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allows remote attackers to inject arbitrary web script or HTML via a crafted URL.",
      "cve": "CVE-2016-7138",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2016-7139",
      "advisory": "Cross-site scripting (XSS) vulnerability in an unspecified page template in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allows remote attackers to inject arbitrary web script or HTML via unknown vectors.",
      "cve": "CVE-2016-7139",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2016-7140",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in the ZMI page in Zope2 in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allow remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2016-7140",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2016-7147",
      "advisory": "Cross-site scripting (XSS) vulnerability in the manage_findResult component in the search feature in Zope ZMI in Plone before 4.3.12 and 5.x before 5.0.7 allows remote attackers to inject arbitrary web script or HTML via vectors involving double quotes, as demonstrated by the obj_ids:tokens parameter. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-7140.",
      "cve": "CVE-2016-7147",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1-a1",
        "==5.1-a2"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2017-1000481",
      "advisory": "When you visit a page where you need to login, Plone 2.5-5.1rc1 sends you to the login form with a 'came_from' parameter set to the previous url. After you login, you get redirected to the page you tried to view before. An attacker might try to abuse this by letting you click on a specially crafted link. You would login, and get redirected to the site of the attacker, letting you think that you are still on the original Plone site. Or some javascript of the attacker could be executed. Most of these types of attacks are already blocked by Plone, using the `isURLInPortal` check to make sure we only redirect to a page on the same Plone site. But a few more ways of tricking Plone into accepting a malicious link were discovered, and fixed with this hotfix.",
      "cve": "CVE-2017-1000481",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2017-1000482",
      "advisory": "A member of the Plone 2.5-5.1rc1 site could set javascript in the home_page property of his profile, and have this executed when a visitor click the home page link on the author page.",
      "cve": "CVE-2017-1000482",
      "specs": [
        "<=5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2017-1000483",
      "advisory": "Accessing private content via str.format in through-the-web templates and scripts in Plone 2.5-5.1rc1. This improves an earlier hotfix. Since the format method was introduced in Python 2.6, this part of the hotfix is only relevant for Plone 4 and 5.",
      "cve": "CVE-2017-1000483",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2017-1000484",
      "advisory": "By linking to a specific url in Plone 2.5-5.1rc1 with a parameter, an attacker could send you to his own website. On its own this is not so bad: the attacker could more easily link directly to his own website instead. But in combination with another attack, you could be sent to the Plone login form and login, then get redirected to the specific url, and then get a second redirect to the attacker website. (The specific url can be seen by inspecting the hotfix code, but we don't want to make it too easy for attackers by spelling it out here.)",
      "cve": "CVE-2017-1000484",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2017-5524",
      "advisory": "Plone 4.x through 4.3.11 and 5.x through 5.0.6 allow remote attackers to bypass a sandbox protection mechanism and obtain sensitive information by leveraging the Python string format method.",
      "cve": "CVE-2017-5524",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1-a1",
        "==5.1-a2"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2020-28734",
      "advisory": "Plone before 5.2.3 allows XXE attacks via a feature that is explicitly only available to the Manager role.",
      "cve": "CVE-2020-28734",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2020-28735",
      "advisory": "Plone before 5.2.3 allows SSRF attacks via the tracebacks feature (only available to the Manager role).",
      "cve": "CVE-2020-28735",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2020-28736",
      "advisory": "Plone before 5.2.3 allows XXE attacks via a feature that is protected by an unapplied permission of plone.schemaeditor.ManageSchemata (therefore, only available to the Manager role).",
      "cve": "CVE-2020-28736",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2020-35190",
      "advisory": "The official plone Docker images before version of 4.3.18-alpine (Alpine specific) contain a blank password for a root user. System using the plone docker container deployed by affected versions of the docker image may allow a remote attacker to achieve root access with a blank password.",
      "cve": "CVE-2020-35190",
      "specs": [
        ">=4.0.0-alpine,<4.3.18-alpine"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2020-7936",
      "advisory": "An open redirect on the login form (and possibly other places) in Plone 4.0 through 5.2.1 allows an attacker to craft a link to a Plone Site that, when followed, and possibly after login, will redirect to an attacker's site.",
      "cve": "CVE-2020-7936",
      "specs": [
        ">=4.0.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2020-7937",
      "advisory": "An XSS issue in the title field in Plone 5.0 through 5.2.1 allows users with a certain privilege level to insert JavaScript that will be executed when other users access the site.",
      "cve": "CVE-2020-7937",
      "specs": [
        ">=5.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2020-7938",
      "advisory": "plone.restapi in Plone 5.2.0 through 5.2.1 allows users with a certain privilege level to escalate their privileges up to the highest level.",
      "cve": "CVE-2020-7938",
      "specs": [
        ">=5.2.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2020-7939",
      "advisory": "SQL Injection in DTML or in connection objects in Plone 4.0 through 5.2.1 allows users to perform unwanted SQL queries. (This is a problem in Zope.)",
      "cve": "CVE-2020-7939",
      "specs": [
        ">=4.0.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2020-7940",
      "advisory": "Missing password strength checks on some forms in Plone 4.3 through 5.2.0 allow users to set weak passwords, leading to easier cracking.",
      "cve": "CVE-2020-7940",
      "specs": [
        ">=4.3.0,<=5.2.0"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2020-7941",
      "advisory": "A privilege escalation issue in plone.app.contenttypes in Plone 4.3 through 5.2.1 allows users to PUT (overwrite) some content without needing write permission.",
      "cve": "CVE-2020-7941",
      "specs": [
        ">=4.3.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2021-29002",
      "advisory": "A stored cross-site scripting (XSS) vulnerability in Plone CMS 5.2.3 exists in site-controlpanel via the \"form.widgets.site_title\" parameter.",
      "cve": "CVE-2021-29002",
      "specs": [
        "==5.2.3"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2021-32633",
      "advisory": "Zope is an open-source web application server. In Zope versions prior to 4.6 and 5.2, users can access untrusted modules indirectly through Python modules that are available for direct use. By default, only users with the Manager role can add or edit Zope Page Templates through the web, but sites that allow untrusted users to add/edit Zope Page Templates through the web are at risk from this vulnerability. The problem has been fixed in Zope 5.2 and 4.6. As a workaround, a site administrator can restrict adding/editing Zope Page Templates through the web using the standard Zope user/role permission mechanisms. Untrusted users should not be assigned the Zope Manager role and adding/editing Zope Page Templates through the web should be restricted to trusted users only.",
      "cve": "CVE-2021-32633",
      "specs": [
        "<=4.3.20",
        ">=5.0,<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2021-3313",
      "advisory": "Plone CMS until version 5.2.4 has a stored Cross-Site Scripting (XSS) vulnerability in the user fullname property and the file upload functionality. The user's input data is not properly encoded when being echoed back to the user. This data can be interpreted as executable code by the browser and allows an attacker to execute JavaScript in the context of the victim's browser if the victim opens a vulnerable page containing an XSS payload.",
      "cve": "CVE-2021-3313",
      "specs": [
        "<5.2.4"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2021-33507",
      "advisory": "Zope Products.CMFCore before 2.5.1 and Products.PluggableAuthService before 2.6.2, as used in Plone through 5.2.4 and other products, allow Reflected XSS.",
      "cve": "CVE-2021-33507",
      "specs": [
        "<=4.3.20",
        ">=5.0,<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2021-33508",
      "advisory": "Plone through 5.2.4 allows XSS via a full name that is mishandled during rendering of the ownership tab of a content item.",
      "cve": "CVE-2021-33508",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2021-33509",
      "advisory": "Plone through 5.2.4 allows remote authenticated managers to perform disk I/O via crafted keyword arguments to the ReStructuredText transform in a Python script.",
      "cve": "CVE-2021-33509",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2021-33510",
      "advisory": "Plone through 5.2.4 allows remote authenticated managers to conduct SSRF attacks via an event ical URL, to read one line of a file.",
      "cve": "CVE-2021-33510",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2021-33511",
      "advisory": "Plone though 5.2.4 allows SSRF via the lxml parser. This affects Diazo themes, Dexterity TTW schemas, and modeleditors in plone.app.theming, plone.app.dexterity, and plone.supermodel.",
      "cve": "CVE-2021-33511",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2021-33512",
      "advisory": "Plone through 5.2.4 allows stored XSS attacks (by a Contributor) by uploading an SVG or HTML document.",
      "cve": "CVE-2021-33512",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2021-33513",
      "advisory": "Plone through 5.2.4 allows XSS via the inline_diff methods in Products.CMFDiffTool.",
      "cve": "CVE-2021-33513",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-products.cmfplone:CVE-2021-35959",
      "advisory": "In Plone 5.0 through 5.2.4, Editors are vulnerable to XSS in the folder contents view, if a Contributor has created a folder with a SCRIPT tag in the description field.",
      "cve": "CVE-2021-35959",
      "specs": [
        ">=5.0,<=5.2.4"
      ]
    }
  ],
  "products.genericsetup": [
    {
      "id": "pyup.io-products.genericsetup:CVE-2021-21360",
      "advisory": "Products.GenericSetup is a mini-framework for expressing the configured state of a Zope Site as a set of filesystem artifacts. In Products.GenericSetup before version 2.1.1 there is an information disclosure vulnerability - anonymous visitors may view log and snapshot files generated by the Generic Setup Tool. The problem has been fixed in version 2.1.1. Depending on how you have installed Products.GenericSetup, you should change the buildout version pin to 2.1.1 and re-run the buildout, or if you used pip simply do pip install `\"Products.GenericSetup>=2.1.1\"`.",
      "cve": "CVE-2021-21360",
      "specs": [
        "<2.1.1"
      ]
    }
  ],
  "products.isurlinportal": [
    {
      "id": "pyup.io-products.isurlinportal:CVE-2021-32806",
      "advisory": "Products.isurlinportal is a replacement for isURLInPortal method in Plone. Versions of Products.isurlinportal prior to 1.2.0 have an Open Redirect vulnerability. Various parts of Plone use the 'is url in portal' check for security, mostly to see if it is safe to redirect to a url. A url like `https://example.org` is not in the portal. The url `https:example.org` without slashes is considered to be in the portal. When redirecting, some browsers go to `https://example.org`, others give an error. Attackers may use this to redirect victims to their site, especially as part of a phishing attack. The problem has been patched in Products.isurlinportal 1.2.0.",
      "cve": "CVE-2021-32806",
      "specs": [
        "<1.2.0"
      ]
    }
  ],
  "products.passwordresettool": [
    {
      "id": "pyup.io-products.passwordresettool:CVE-2006-1711",
      "advisory": "Plone 2.0.5, 2.1.2, and 2.5-beta1 does not restrict access to the (1) changeMemberPortrait, (2) deletePersonalPortrait, and (3) testCurrentPassword methods, which allows remote attackers to modify portraits.",
      "cve": "CVE-2006-1711",
      "specs": [
        "==2.0.5",
        "==2.1.2",
        "==2.5_beta1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2006-4247",
      "advisory": "Unspecified vulnerability in the Password Reset Tool before 0.4.1 on Plone 2.5 and 2.5.1 Release Candidate allows attackers to reset the passwords of other users, related to \"an erroneous security declaration.\"",
      "cve": "CVE-2006-4247",
      "specs": [
        "==2.5",
        "==2.5.1_rc"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2006-4249",
      "advisory": "Unspecified vulnerability in PlonePAS in Plone 2.5 and 2.5.1, when anonymous member registration is enabled, allows an attacker to \"masquerade as a group.\"",
      "cve": "CVE-2006-4249",
      "specs": [
        "==2.5",
        "==2.5.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2007-5741",
      "advisory": "Plone 2.5 through 2.5.4 and 3.0 through 3.0.2 allows remote attackers to execute arbitrary Python code via network data containing pickled objects for the (1) statusmessages or (2) linkintegrity module, which the module unpickles and executes.",
      "cve": "CVE-2007-5741",
      "specs": [
        "==2.5",
        "==2.5.1",
        "==2.5.1_rc",
        "==2.5.4",
        "==2.5_beta1",
        "==3.0",
        "==3.0.1",
        "==3.0.2"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2008-4571",
      "advisory": "Cross-site scripting (XSS) vulnerability in the LiveSearch module in Plone before 3.0.4 allows remote attackers to inject arbitrary web script or HTML via the Description field for search results, as demonstrated using the onerror Javascript even in an IMG tag.",
      "cve": "CVE-2008-4571",
      "specs": [
        "<=3.0.3",
        "==2.0.5",
        "==2.1.2",
        "==2.5",
        "==2.5.1",
        "==2.5.1_rc",
        "==2.5.4",
        "==2.5_beta1",
        "==3.0",
        "==3.0.1",
        "==3.0.2"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2010-2422",
      "advisory": "Cross-site scripting (XSS) vulnerability in PortalTransforms in Plone 2.1 through 3.3.4 before hotfix 20100612 allows remote attackers to inject arbitrary web script or HTML via the safe_html transform.",
      "cve": "CVE-2010-2422",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2011-1340",
      "advisory": "Cross-site scripting (XSS) vulnerability in skins/plone_templates/default_error_message.pt in Plone before 2.5.3 allows remote attackers to inject arbitrary web script or HTML via the type_name parameter to Members/ipa/createObject.",
      "cve": "CVE-2011-1340",
      "specs": [
        "<=2.5.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2011-1948",
      "advisory": "Cross-site scripting (XSS) vulnerability in Plone 4.1 and earlier allows remote attackers to inject arbitrary web script or HTML via a crafted URL.",
      "cve": "CVE-2011-1948",
      "specs": [
        "<=4.1",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2011-1949",
      "advisory": "Cross-site scripting (XSS) vulnerability in the safe_html filter in Products.PortalTransforms in Plone 2.1 through 4.1 allows remote authenticated users to inject arbitrary web script or HTML via unspecified vectors, a different vulnerability than CVE-2010-2422.",
      "cve": "CVE-2011-1949",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2011-1950",
      "advisory": "plone.app.users in Plone 4.0 and 4.1 allows remote authenticated users to modify the properties of arbitrary accounts via unspecified vectors, as exploited in the wild in June 2011.",
      "cve": "CVE-2011-1950",
      "specs": [
        "==4.0",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2011-2528",
      "advisory": "Unspecified vulnerability in (1) Zope 2.12.x before 2.12.19 and 2.13.x before 2.13.8, as used in Plone 4.x and other products, and (2) PloneHotfix20110720 for Plone 3.x allows attackers to gain privileges via unspecified vectors, related to a \"highly serious vulnerability.\" NOTE: this vulnerability exists because of an incorrect fix for CVE-2011-0720.",
      "cve": "CVE-2011-2528",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2011-3587",
      "advisory": "Unspecified vulnerability in Zope 2.12.x and 2.13.x, as used in Plone 4.0.x through 4.0.9, 4.1, and 4.2 through 4.2a2, allows remote attackers to execute arbitrary commands via vectors related to the p_ class in OFS/misc_.py and the use of Python modules.",
      "cve": "CVE-2011-3587",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.2",
        "==4.2a1",
        "==4.2a2"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2011-4030",
      "advisory": "The CMFEditions component 2.x in Plone 4.0.x through 4.0.9, 4.1, and 4.2 through 4.2a2 does not prevent the KwAsAttributes classes from being publishable, which allows remote attackers to access sub-objects via unspecified vectors, a different vulnerability than CVE-2011-3587.",
      "cve": "CVE-2011-4030",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.2",
        "==4.2a1",
        "==4.2a2"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2011-4462",
      "advisory": "Plone 4.1.3 and earlier computes hash values for form parameters without restricting the ability to trigger hash collisions predictably, which allows remote attackers to cause a denial of service (CPU consumption) by sending many crafted parameters.",
      "cve": "CVE-2011-4462",
      "specs": [
        "<=4.1.3",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5485",
      "advisory": "registerConfiglet.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via unspecified vectors, related to the admin interface.",
      "cve": "CVE-2012-5485",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5486",
      "advisory": "ZPublisher.HTTPRequest._scrubHeader in Zope 2 before 2.13.19, as used in Plone before 4.3 beta 1, allows remote attackers to inject arbitrary HTTP headers via a linefeed (LF) character.",
      "cve": "CVE-2012-5486",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5487",
      "advisory": "The sandbox whitelisting function (allowmodule.py) in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with certain privileges to bypass the Python sandbox restriction and execute arbitrary Python code via vectors related to importing.",
      "cve": "CVE-2012-5487",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5488",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via a crafted URL, related to createObject.",
      "cve": "CVE-2012-5488",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5489",
      "advisory": "The App.Undo.UndoSupport.get_request_var_or_attr function in Zope before 2.12.21 and 3.13.x before 2.13.11, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote authenticated users to gain access to restricted attributes via unspecified vectors.",
      "cve": "CVE-2012-5489",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5490",
      "advisory": "Cross-site scripting (XSS) vulnerability in kssdevel.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5490",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5491",
      "advisory": "z3c.form, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote attackers to obtain the default form field values by leveraging knowledge of the form location and the element id.",
      "cve": "CVE-2012-5491",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5492",
      "advisory": "uid_catalog.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to obtain metadata about hidden objects via a crafted URL.",
      "cve": "CVE-2012-5492",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5493",
      "advisory": "gtbn.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with certain permissions to bypass the Python sandbox and execute arbitrary Python code via unspecified vectors.",
      "cve": "CVE-2012-5493",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5494",
      "advisory": "Cross-site scripting (XSS) vulnerability in python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors, related to \"{u,}translate.\"",
      "cve": "CVE-2012-5494",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5495",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to execute Python code via a crafted URL, related to \"go_back.\"",
      "cve": "CVE-2012-5495",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5496",
      "advisory": "kupu_spellcheck.py in Kupu in Plone before 4.0 allows remote attackers to cause a denial of service (ZServer thread lock) via a crafted URL.",
      "cve": "CVE-2012-5496",
      "specs": [
        "<=3.3.5",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5497",
      "advisory": "membership_tool.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to enumerate user account names via a crafted URL.",
      "cve": "CVE-2012-5497",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5498",
      "advisory": "queryCatalog.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to bypass caching and cause a denial of service via a crafted request to a collection.",
      "cve": "CVE-2012-5498",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5499",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to cause a denial of service (memory consumption) via a large value, related to formatColumns.",
      "cve": "CVE-2012-5499",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5500",
      "advisory": "The batch id change script (renameObjectsByPaths.py) in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to change the titles of content items by leveraging a valid CSRF token in a crafted request.",
      "cve": "CVE-2012-5500",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5501",
      "advisory": "at_download.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read arbitrary BLOBs (Files and Images) stored on custom content types via a crafted URL.",
      "cve": "CVE-2012-5501",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5502",
      "advisory": "Cross-site scripting (XSS) vulnerability in safe_html.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote authenticated users with permissions to edit content to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5502",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5503",
      "advisory": "ftp.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read hidden folder contents via unspecified vectors.",
      "cve": "CVE-2012-5503",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5504",
      "advisory": "Cross-site scripting (XSS) vulnerability in widget_traversal.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2012-5504",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5505",
      "advisory": "atat.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to read private data structures via a request for a view without a name.",
      "cve": "CVE-2012-5505",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5506",
      "advisory": "python_scripts.py in Plone before 4.2.3 and 4.3 before beta 1 allows remote attackers to cause a denial of service (infinite loop) via an RSS feed request for a folder the user does not have permission to access.",
      "cve": "CVE-2012-5506",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5507",
      "advisory": "AccessControl/AuthEncoding.py in Zope before 2.13.19, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote attackers to obtain passwords via vectors involving timing discrepancies in password validation.",
      "cve": "CVE-2012-5507",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2-a1",
        "==4.2-a2",
        "==4.2-b1",
        "==4.2-b2",
        "==4.2-rc1",
        "==4.2-rc2",
        "==4.2.0.1",
        "==4.2.1",
        "==4.2.1.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-5508",
      "advisory": "The error pages in Plone before 4.2.3 and 4.3 before beta 1 allow remote attackers to obtain random numbers and derive the PRNG state for password resets via unspecified vectors.  NOTE: this identifier was SPLIT per ADT2 due to different vulnerability types. CVE-2012-6661 was assigned for the PRNG reseeding issue in Zope.",
      "cve": "CVE-2012-5508",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2012-6661",
      "advisory": "Zope before 2.13.19, as used in Plone before 4.2.3 and 4.3 before beta 1, does not reseed the pseudo-random number generator (PRNG), which makes it easier for remote attackers to guess the value via unspecified vectors.  NOTE: this issue was SPLIT from CVE-2012-5508 due to different vulnerability types (ADT2).",
      "cve": "CVE-2012-6661",
      "specs": [
        "<=4.2.2",
        "==1.0",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.6",
        "==2.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2013-4188",
      "advisory": "traverser.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote attackers with administrator privileges to cause a denial of service (infinite loop and resource consumption) via unspecified vectors related to \"retrieving information for certain resources.\"",
      "cve": "CVE-2013-4188",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2013-4189",
      "advisory": "Multiple unspecified vulnerabilities in (1) dataitems.py, (2) get.py, and (3) traverseName.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote authenticated users with administrator access to a subtree to access nodes above the subtree via unknown vectors.",
      "cve": "CVE-2013-4189",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2013-4190",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in (1) spamProtect.py, (2) pts.py, and (3) request.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2013-4190",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2013-4191",
      "advisory": "zip.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly enforce access restrictions when including content in a zip archive, which allows remote attackers to obtain sensitive information by reading a generated archive.",
      "cve": "CVE-2013-4191",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2013-4192",
      "advisory": "sendto.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to spoof emails via unspecified vectors.",
      "cve": "CVE-2013-4192",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2013-4193",
      "advisory": "typeswidget.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly enforce the immutable setting on unspecified content edit forms, which allows remote attackers to hide fields on the forms via a crafted URL.",
      "cve": "CVE-2013-4193",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2013-4194",
      "advisory": "The WYSIWYG component (wysiwyg.py) in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote attackers to obtain sensitive information via a crafted URL, which reveals the installation path in an error message.",
      "cve": "CVE-2013-4194",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2013-4195",
      "advisory": "Multiple open redirect vulnerabilities in (1) marmoset_patch.py, (2) publish.py, and (3) principiaredirect.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via unspecified vectors.",
      "cve": "CVE-2013-4195",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2013-4196",
      "advisory": "The object manager implementation (objectmanager.py) in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 does not properly restrict access to internal methods, which allows remote attackers to obtain sensitive information via a crafted request.",
      "cve": "CVE-2013-4196",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2013-4197",
      "advisory": "member_portrait.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to modify or delete portraits of other users via unspecified vectors.",
      "cve": "CVE-2013-4197",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2013-4198",
      "advisory": "mail_password.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allows remote authenticated users to bypass the prohibition on password changes via the forgotten password email functionality.",
      "cve": "CVE-2013-4198",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2013-4199",
      "advisory": "(1) cb_decode.py and (2) linkintegrity.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 allow remote authenticated users to cause a denial of service (resource consumption) via a large zip archive, which is expanded (decompressed).",
      "cve": "CVE-2013-4199",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.5",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3",
        "==2.5.4",
        "==2.5.5",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2013-4200",
      "advisory": "The isURLInPortal method in the URLTool class in in_portal.py in Plone 2.1 through 4.1, 4.2.x through 4.2.5, and 4.3.x through 4.3.1 treats URLs starting with a space as a relative URL, which allows remote attackers to bypass the allow_external_login_sites filtering property,  redirect users to arbitrary web sites, and conduct phishing attacks via a space before a URL in the \"next\" parameter to acl_users/credentials_cookie_auth/require_login.",
      "cve": "CVE-2013-4200",
      "specs": [
        "==2.1",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==3.0",
        "==3.0.1",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.1",
        "==3.1.1",
        "==3.1.2",
        "==3.1.3",
        "==3.1.4",
        "==3.1.5.1",
        "==3.1.6",
        "==3.1.7",
        "==3.2",
        "==3.2.1",
        "==3.2.2",
        "==3.2.3",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.1",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.3",
        "==4.3.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2013-7060",
      "advisory": "Products/CMFPlone/FactoryTool.py in Plone 3.3 through 4.3.2 allows remote attackers to obtain the installation path via vectors related to a file object for unspecified documentation which is initialized in class scope.",
      "cve": "CVE-2013-7060",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2013-7061",
      "advisory": "Products/CMFPlone/CatalogTool.py in Plone 3.3 through 4.3.2 allows remote administrators to bypass restrictions and obtain sensitive information via an unspecified search API.",
      "cve": "CVE-2013-7061",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2013-7062",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in Zope, as used in Plone 3.3.x through 3.3.6, 4.0.x through 4.0.9, 4.1.x through 4.1.6, 4.2.x through 4.2.7, and 4.3 through 4.3.2, allow remote attackers to inject arbitrary web script or HTML via unspecified input in the (1) browser_id_manager or (2) OFS.Image method.",
      "cve": "CVE-2013-7062",
      "specs": [
        ">=3.3.0,<=3.3.6",
        ">=4.0.0,<=4.0.9",
        ">=4.1.0,<=4.1.6",
        ">=4.2.0,<=4.2.7",
        ">=4.3.0,<=4.3.2"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2015-7293",
      "advisory": "Multiple cross-site request forgery (CSRF) vulnerabilities in Zope Management Interface 4.3.7 and earlier, and Plone before 5.x.",
      "cve": "CVE-2015-7293",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2015-7315",
      "advisory": "Plone 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, 4.2.0 through 4.2.7, 4.3.0 through 4.3.6, and 5.0rc1 allows remote attackers to add a new member to a Plone site with registration enabled, without acknowledgment of site administrator.",
      "cve": "CVE-2015-7315",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==5.0-rc1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2015-7316",
      "advisory": "Cross-site scripting (XSS) vulnerability in Plone 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, 4.2.0 through 4.2.7, 4.3.x before 4.3.7, and 5.0rc1.",
      "cve": "CVE-2015-7316",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==5.0-rc1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2015-7317",
      "advisory": "Kupu 3.3.0 through 3.3.6, 4.0.0 through 4.0.10, 4.1.0 through 4.1.6, and 4.2.0 through 4.2.7 allows remote authenticated users to edit Kupu settings.",
      "cve": "CVE-2015-7317",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6.1",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2015-7318",
      "advisory": "Plone 3.3.0 through 3.3.6 allows remote attackers to inject headers into HTTP responses.",
      "cve": "CVE-2015-7318",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2016-4041",
      "advisory": "Plone 4.0 through 5.1a1 does not have security declarations for Dexterity content-related WebDAV requests, which allows remote attackers to gain webdav access via unspecified vectors.",
      "cve": "CVE-2016-4041",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2016-4042",
      "advisory": "Plone 3.3 through 5.1a1 allows remote attackers to obtain information about the ID of sensitive content via unspecified vectors.",
      "cve": "CVE-2016-4042",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2016-4043",
      "advisory": "Chameleon (five.pt) in Plone 5.0rc1 through 5.1a1 allows remote authenticated users to bypass Restricted Python by leveraging permissions to create or edit templates.",
      "cve": "CVE-2016-4043",
      "specs": [
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2016-7135",
      "advisory": "Directory traversal vulnerability in Plone CMS 5.x through 5.0.6 and 4.2.x through 4.3.11 allows remote administrators to read arbitrary files via a .. (dot dot) in the path parameter in a getFile action to Plone/++theme++barceloneta/@@plone.resourceeditor.filemanager-actions.",
      "cve": "CVE-2016-7135",
      "specs": [
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2016-7136",
      "advisory": "z3c.form in Plone CMS 5.x through 5.0.6 and 4.x through 4.3.11 allows remote attackers to conduct cross-site scripting (XSS) attacks via a crafted GET request.",
      "cve": "CVE-2016-7136",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2016-7137",
      "advisory": "Multiple open redirect vulnerabilities in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allow remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via a URL in the referer parameter to (1) %2b%2bgroupdashboard%2b%2bplone.dashboard1%2bgroup/%2b/portlets.Actions or (2) folder/%2b%2bcontextportlets%2b%2bplone.footerportlets/%2b /portlets.Actions or the (3) came_from parameter to /login_form.",
      "cve": "CVE-2016-7137",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2016-7138",
      "advisory": "Cross-site scripting (XSS) vulnerability in the URL checking infrastructure in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allows remote attackers to inject arbitrary web script or HTML via a crafted URL.",
      "cve": "CVE-2016-7138",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2016-7139",
      "advisory": "Cross-site scripting (XSS) vulnerability in an unspecified page template in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allows remote attackers to inject arbitrary web script or HTML via unknown vectors.",
      "cve": "CVE-2016-7139",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2016-7140",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in the ZMI page in Zope2 in Plone CMS 5.x through 5.0.6, 4.x through 4.3.11, and 3.3.x through 3.3.6 allow remote attackers to inject arbitrary web script or HTML via unspecified vectors.",
      "cve": "CVE-2016-7140",
      "specs": [
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-a1",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1a1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2016-7147",
      "advisory": "Cross-site scripting (XSS) vulnerability in the manage_findResult component in the search feature in Zope ZMI in Plone before 4.3.12 and 5.x before 5.0.7 allows remote attackers to inject arbitrary web script or HTML via vectors involving double quotes, as demonstrated by the obj_ids:tokens parameter. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-7140.",
      "cve": "CVE-2016-7147",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1-a1",
        "==5.1-a2"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2017-1000481",
      "advisory": "When you visit a page where you need to login, Plone 2.5-5.1rc1 sends you to the login form with a 'came_from' parameter set to the previous url. After you login, you get redirected to the page you tried to view before. An attacker might try to abuse this by letting you click on a specially crafted link. You would login, and get redirected to the site of the attacker, letting you think that you are still on the original Plone site. Or some javascript of the attacker could be executed. Most of these types of attacks are already blocked by Plone, using the `isURLInPortal` check to make sure we only redirect to a page on the same Plone site. But a few more ways of tricking Plone into accepting a malicious link were discovered, and fixed with this hotfix.",
      "cve": "CVE-2017-1000481",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2017-1000482",
      "advisory": "A member of the Plone 2.5-5.1rc1 site could set javascript in the home_page property of his profile, and have this executed when a visitor click the home page link on the author page.",
      "cve": "CVE-2017-1000482",
      "specs": [
        "<=5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2017-1000483",
      "advisory": "Accessing private content via str.format in through-the-web templates and scripts in Plone 2.5-5.1rc1. This improves an earlier hotfix. Since the format method was introduced in Python 2.6, this part of the hotfix is only relevant for Plone 4 and 5.",
      "cve": "CVE-2017-1000483",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2017-1000484",
      "advisory": "By linking to a specific url in Plone 2.5-5.1rc1 with a parameter, an attacker could send you to his own website. On its own this is not so bad: the attacker could more easily link directly to his own website instead. But in combination with another attack, you could be sent to the Plone login form and login, then get redirected to the specific url, and then get a second redirect to the attacker website. (The specific url can be seen by inspecting the hotfix code, but we don't want to make it too easy for attackers by spelling it out here.)",
      "cve": "CVE-2017-1000484",
      "specs": [
        "==2.5.5",
        "==3.3",
        "==3.3.1",
        "==3.3.2",
        "==3.3.3",
        "==3.3.4",
        "==3.3.5",
        "==3.3.6",
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.12",
        "==4.3.14",
        "==4.3.15",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.0.7",
        "==5.0.8",
        "==5.0.9",
        "==5.1-a1",
        "==5.1-a2",
        "==5.1-b2",
        "==5.1-b3",
        "==5.1-b4",
        "==5.1-rc1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2017-5524",
      "advisory": "Plone 4.x through 4.3.11 and 5.x through 5.0.6 allow remote attackers to bypass a sandbox protection mechanism and obtain sensitive information by leveraging the Python string format method.",
      "cve": "CVE-2017-5524",
      "specs": [
        "==4.0",
        "==4.0.1",
        "==4.0.10",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.1",
        "==4.1.1",
        "==4.1.2",
        "==4.1.3",
        "==4.1.4",
        "==4.1.5",
        "==4.1.6",
        "==4.2",
        "==4.2.1",
        "==4.2.2",
        "==4.2.3",
        "==4.2.4",
        "==4.2.5",
        "==4.2.6",
        "==4.2.7",
        "==4.3",
        "==4.3.1",
        "==4.3.10",
        "==4.3.11",
        "==4.3.2",
        "==4.3.3",
        "==4.3.4",
        "==4.3.5",
        "==4.3.6",
        "==4.3.7",
        "==4.3.8",
        "==4.3.9",
        "==5.0",
        "==5.0-rc1",
        "==5.0-rc2",
        "==5.0-rc3",
        "==5.0.1",
        "==5.0.2",
        "==5.0.3",
        "==5.0.4",
        "==5.0.5",
        "==5.0.6",
        "==5.1-a1",
        "==5.1-a2"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2020-28734",
      "advisory": "Plone before 5.2.3 allows XXE attacks via a feature that is explicitly only available to the Manager role.",
      "cve": "CVE-2020-28734",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2020-28735",
      "advisory": "Plone before 5.2.3 allows SSRF attacks via the tracebacks feature (only available to the Manager role).",
      "cve": "CVE-2020-28735",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2020-28736",
      "advisory": "Plone before 5.2.3 allows XXE attacks via a feature that is protected by an unapplied permission of plone.schemaeditor.ManageSchemata (therefore, only available to the Manager role).",
      "cve": "CVE-2020-28736",
      "specs": [
        "<5.2.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2020-35190",
      "advisory": "The official plone Docker images before version of 4.3.18-alpine (Alpine specific) contain a blank password for a root user. System using the plone docker container deployed by affected versions of the docker image may allow a remote attacker to achieve root access with a blank password.",
      "cve": "CVE-2020-35190",
      "specs": [
        ">=4.0.0-alpine,<4.3.18-alpine"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2020-7936",
      "advisory": "An open redirect on the login form (and possibly other places) in Plone 4.0 through 5.2.1 allows an attacker to craft a link to a Plone Site that, when followed, and possibly after login, will redirect to an attacker's site.",
      "cve": "CVE-2020-7936",
      "specs": [
        ">=4.0.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2020-7937",
      "advisory": "An XSS issue in the title field in Plone 5.0 through 5.2.1 allows users with a certain privilege level to insert JavaScript that will be executed when other users access the site.",
      "cve": "CVE-2020-7937",
      "specs": [
        ">=5.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2020-7938",
      "advisory": "plone.restapi in Plone 5.2.0 through 5.2.1 allows users with a certain privilege level to escalate their privileges up to the highest level.",
      "cve": "CVE-2020-7938",
      "specs": [
        ">=5.2.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2020-7939",
      "advisory": "SQL Injection in DTML or in connection objects in Plone 4.0 through 5.2.1 allows users to perform unwanted SQL queries. (This is a problem in Zope.)",
      "cve": "CVE-2020-7939",
      "specs": [
        ">=4.0.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2020-7940",
      "advisory": "Missing password strength checks on some forms in Plone 4.3 through 5.2.0 allow users to set weak passwords, leading to easier cracking.",
      "cve": "CVE-2020-7940",
      "specs": [
        ">=4.3.0,<=5.2.0"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2020-7941",
      "advisory": "A privilege escalation issue in plone.app.contenttypes in Plone 4.3 through 5.2.1 allows users to PUT (overwrite) some content without needing write permission.",
      "cve": "CVE-2020-7941",
      "specs": [
        ">=4.3.0,<=5.2.1"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2021-29002",
      "advisory": "A stored cross-site scripting (XSS) vulnerability in Plone CMS 5.2.3 exists in site-controlpanel via the \"form.widgets.site_title\" parameter.",
      "cve": "CVE-2021-29002",
      "specs": [
        "==5.2.3"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2021-32633",
      "advisory": "Zope is an open-source web application server. In Zope versions prior to 4.6 and 5.2, users can access untrusted modules indirectly through Python modules that are available for direct use. By default, only users with the Manager role can add or edit Zope Page Templates through the web, but sites that allow untrusted users to add/edit Zope Page Templates through the web are at risk from this vulnerability. The problem has been fixed in Zope 5.2 and 4.6. As a workaround, a site administrator can restrict adding/editing Zope Page Templates through the web using the standard Zope user/role permission mechanisms. Untrusted users should not be assigned the Zope Manager role and adding/editing Zope Page Templates through the web should be restricted to trusted users only.",
      "cve": "CVE-2021-32633",
      "specs": [
        "<=4.3.20",
        ">=5.0,<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2021-3313",
      "advisory": "Plone CMS until version 5.2.4 has a stored Cross-Site Scripting (XSS) vulnerability in the user fullname property and the file upload functionality. The user's input data is not properly encoded when being echoed back to the user. This data can be interpreted as executable code by the browser and allows an attacker to execute JavaScript in the context of the victim's browser if the victim opens a vulnerable page containing an XSS payload.",
      "cve": "CVE-2021-3313",
      "specs": [
        "<5.2.4"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2021-33507",
      "advisory": "Zope Products.CMFCore before 2.5.1 and Products.PluggableAuthService before 2.6.2, as used in Plone through 5.2.4 and other products, allow Reflected XSS.",
      "cve": "CVE-2021-33507",
      "specs": [
        "<=4.3.20",
        ">=5.0,<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2021-33508",
      "advisory": "Plone through 5.2.4 allows XSS via a full name that is mishandled during rendering of the ownership tab of a content item.",
      "cve": "CVE-2021-33508",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2021-33509",
      "advisory": "Plone through 5.2.4 allows remote authenticated managers to perform disk I/O via crafted keyword arguments to the ReStructuredText transform in a Python script.",
      "cve": "CVE-2021-33509",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2021-33510",
      "advisory": "Plone through 5.2.4 allows remote authenticated managers to conduct SSRF attacks via an event ical URL, to read one line of a file.",
      "cve": "CVE-2021-33510",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2021-33511",
      "advisory": "Plone though 5.2.4 allows SSRF via the lxml parser. This affects Diazo themes, Dexterity TTW schemas, and modeleditors in plone.app.theming, plone.app.dexterity, and plone.supermodel.",
      "cve": "CVE-2021-33511",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2021-33512",
      "advisory": "Plone through 5.2.4 allows stored XSS attacks (by a Contributor) by uploading an SVG or HTML document.",
      "cve": "CVE-2021-33512",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2021-33513",
      "advisory": "Plone through 5.2.4 allows XSS via the inline_diff methods in Products.CMFDiffTool.",
      "cve": "CVE-2021-33513",
      "specs": [
        "<=5.2.4"
      ]
    },
    {
      "id": "pyup.io-products.passwordresettool:CVE-2021-35959",
      "advisory": "In Plone 5.0 through 5.2.4, Editors are vulnerable to XSS in the folder contents view, if a Contributor has created a folder with a SCRIPT tag in the description field.",
      "cve": "CVE-2021-35959",
      "specs": [
        ">=5.0,<=5.2.4"
      ]
    }
  ],
  "products.pluggableauthservice": [
    {
      "id": "pyup.io-products.pluggableauthservice:CVE-2021-21336",
      "advisory": "Products.PluggableAuthService is a pluggable Zope authentication and authorization framework. In Products.PluggableAuthService before version 2.6.0 there is an information disclosure vulnerability - everyone can list the names of roles defined in the ZODB Role Manager plugin if the site uses this plugin. The problem has been fixed in version 2.6.0. Depending on how you have installed Products.PluggableAuthService, you should change the buildout version pin to 2.6.0 and re-run the buildout, or if you used pip simply do `pip install \"Products.PluggableAuthService>=2.6.0\"`.",
      "cve": "CVE-2021-21336",
      "specs": [
        "<2.6.0"
      ]
    },
    {
      "id": "pyup.io-products.pluggableauthservice:CVE-2021-21337",
      "advisory": "Products.PluggableAuthService is a pluggable Zope authentication and authorization framework. In Products.PluggableAuthService before version 2.6.0 there is an open redirect vulnerability. A maliciously crafted link to the login form and login functionality could redirect the browser to a different website. The problem has been fixed in version 2.6.1. Depending on how you have installed Products.PluggableAuthService, you should change the buildout version pin to `2.6.1` and re-run the buildout, or if you used `pip` simply do `pip install \"Products.PluggableAuthService>=2.6.1\".",
      "cve": "CVE-2021-21337",
      "specs": [
        "<2.6.1"
      ]
    }
  ],
  "protobuf": [
    {
      "id": "pyup.io-protobuf:CVE-2015-5237",
      "advisory": "protobuf allows remote authenticated attackers to cause a heap-based buffer overflow.",
      "cve": "CVE-2015-5237",
      "specs": [
        "<=3.1.0"
      ]
    }
  ],
  "proxy.py": [
    {
      "id": "pyup.io-proxy.py:CVE-2021-3116",
      "advisory": "before_upstream_connection in AuthPlugin in http/proxy/auth.py in proxy.py before 2.3.1 accepts incorrect Proxy-Authorization header data because of a boolean confusion (and versus or).",
      "cve": "CVE-2021-3116",
      "specs": [
        "<2.3.1"
      ]
    }
  ],
  "psd-tools": [
    {
      "id": "pyup.io-psd-tools:CVE-2020-10571",
      "advisory": "An issue was discovered in psd-tools before 1.9.4. The Cython implementation of RLE decoding did not check for malicious data.",
      "cve": "CVE-2020-10571",
      "specs": [
        "<1.9.4"
      ]
    }
  ],
  "psutil": [
    {
      "id": "pyup.io-psutil:CVE-2019-18874",
      "advisory": "psutil (aka python-psutil) through 5.6.5 can have a double free. This occurs because of refcount mishandling within a while or for loop that converts system data into a Python object.",
      "cve": "CVE-2019-18874",
      "specs": [
        "<=5.6.5"
      ]
    }
  ],
  "pwntools": [
    {
      "id": "pyup.io-pwntools:CVE-2020-28468",
      "advisory": "This affects the package pwntools before 4.3.1. The shellcraft generator for affected versions of this module are vulnerable to Server-Side Template Injection (SSTI), which can lead to remote code execution.",
      "cve": "CVE-2020-28468",
      "specs": [
        "<4.3.1"
      ]
    }
  ],
  "py": [
    {
      "id": "pyup.io-py:CVE-2020-29651",
      "advisory": "A denial of service via regular expression in the py.path.svnwc component of py (aka python-py) through 1.9.0 could be used by attackers to cause a compute-time denial of service attack by supplying malicious input to the blame functionality.",
      "cve": "CVE-2020-29651",
      "specs": [
        "<=1.9.0"
      ]
    }
  ],
  "py-bcrypt": [
    {
      "id": "pyup.io-py-bcrypt:CVE-2013-1895",
      "advisory": "The py-bcrypt module before 0.3 for Python does not properly handle concurrent memory access, which allows attackers to bypass authentication via multiple authentication requests, which trigger the password hash to be overwritten.",
      "cve": "CVE-2013-1895",
      "specs": [
        "<0.3"
      ]
    }
  ],
  "py-evm": [
    {
      "id": "pyup.io-py-evm:CVE-2018-18920",
      "advisory": "Py-EVM v0.2.0-alpha.33 allows attackers to make a vm.execute_bytecode call that triggers computation._stack.values with '\"stack\": [100, 100, 0]' where b'\\x' was expected, resulting in an execution failure because of an invalid opcode. This is reportedly related to \"smart contracts can be executed indefinitely without gas being paid.\"",
      "cve": "CVE-2018-18920",
      "specs": [
        "==0.2.0-alpha.33"
      ]
    }
  ],
  "py-mini-racer": [
    {
      "id": "pyup.io-py-mini-racer:CVE-2020-25489",
      "advisory": "A heap overflow in Sqreen PyMiniRacer (aka Python Mini Racer) before 0.3.0 allows remote attackers to potentially exploit heap corruption.",
      "cve": "CVE-2020-25489",
      "specs": [
        "<0.3.0"
      ]
    }
  ],
  "pyanyapi": [
    {
      "id": "pyup.io-pyanyapi:CVE-2017-16616",
      "advisory": "An exploitable vulnerability exists in the YAML parsing functionality in the YAMLParser method in Interfaces.py in PyAnyAPI before 0.6.1. A YAML parser can execute arbitrary Python commands resulting in command execution because load is used where safe_load should have been used. An attacker can insert Python into loaded YAML to trigger this vulnerability.",
      "cve": "CVE-2017-16616",
      "specs": [
        "<0.6.1"
      ]
    }
  ],
  "pyarrow": [
    {
      "id": "pyup.io-pyarrow:CVE-2019-12408",
      "advisory": "It was discovered that the C++ implementation (which underlies the R, Python and Ruby implementations) of Apache Arrow 0.14.0 to 0.14.1 had a uninitialized memory bug when building arrays with null values in some cases. This can lead to uninitialized memory being unintentionally shared if Arrow Arrays are transmitted over the wire (for instance with Flight) or persisted in the streaming IPC and file formats.",
      "cve": "CVE-2019-12408",
      "specs": [
        ">=0.14.0,<=0.14.1"
      ]
    },
    {
      "id": "pyup.io-pyarrow:CVE-2019-12410",
      "advisory": "While investigating UBSAN errors in https://github.com/apache/arrow/pull/5365 it was discovered Apache Arrow versions 0.12.0 to 0.14.1, left memory Array data uninitialized when reading RLE null data from parquet. This affected the C++, Python, Ruby and R implementations. The uninitialized memory could potentially be shared if are transmitted over the wire (for instance with Flight) or persisted in the streaming IPC and file formats.",
      "cve": "CVE-2019-12410",
      "specs": [
        ">=0.12.0,<=0.14.1"
      ]
    }
  ],
  "pycares": [
    {
      "id": "pyup.io-pycares:CVE-2016-5180",
      "advisory": "Heap-based buffer overflow in the ares_create_query function in c-ares 1.x before 1.12.0 allows remote attackers to cause a denial of service (out-of-bounds write) or possibly execute arbitrary code via a hostname with an escaped trailing dot.",
      "cve": "CVE-2016-5180",
      "specs": [
        "==1.0.0",
        "==1.1.0",
        "==1.10.0",
        "==1.11.0",
        "==1.2.0",
        "==1.2.1",
        "==1.3.0",
        "==1.3.1",
        "==1.3.2",
        "==1.4.0",
        "==1.5.0",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.6.0",
        "==1.7.0",
        "==1.7.1",
        "==1.7.2",
        "==1.7.3",
        "==1.7.4",
        "==1.7.5",
        "==1.8.0",
        "==1.9.0",
        "==1.9.1"
      ]
    },
    {
      "id": "pyup.io-pycares:CVE-2017-1000381",
      "advisory": "The c-ares function `ares_parse_naptr_reply()`, which is used for parsing NAPTR responses, could be triggered to read memory outside of the given input buffer if the passed in DNS response packet was crafted in a particular way.",
      "cve": "CVE-2017-1000381",
      "specs": [
        "==1.10.0",
        "==1.11.0",
        "==1.11.0-rc1",
        "==1.12.0",
        "==1.8.0",
        "==1.9.0",
        "==1.9.1"
      ]
    },
    {
      "id": "pyup.io-pycares:CVE-2020-14354",
      "advisory": "A possible use-after-free and double-free in c-ares lib version 1.16.0 if ares_destroy() is called prior to ares_getaddrinfo() completing. This flaw possibly allows an attacker to crash the service that uses c-ares lib. The highest threat from this vulnerability is to this service availability.",
      "cve": "CVE-2020-14354",
      "specs": [
        "==1.16.0"
      ]
    },
    {
      "id": "pyup.io-pycares:CVE-2020-8277",
      "advisory": "A Node.js application that allows an attacker to trigger a DNS request for a host of their choice could trigger a Denial of Service in versions < 15.2.1, < 14.15.1, and < 12.19.1 by getting the application to resolve a DNS record with a larger number of responses. This is fixed in 15.2.1, 14.15.1, and 12.19.1.",
      "cve": "CVE-2020-8277",
      "specs": [
        "<1.16.0"
      ]
    }
  ],
  "pycrypto": [
    {
      "id": "pyup.io-pycrypto:CVE-2012-2417",
      "advisory": "PyCrypto before 2.6 does not produce appropriate prime numbers when using an ElGamal scheme to generate a key, which reduces the signature space or public key space and makes it easier for attackers to conduct brute force attacks to obtain the private key.",
      "cve": "CVE-2012-2417",
      "specs": [
        "<=2.5",
        "==1.0.0",
        "==1.0.1",
        "==1.0.2",
        "==1.1-alpha2",
        "==1.9-alpha1",
        "==1.9-alpha2",
        "==1.9-alpha3",
        "==1.9-alpha4",
        "==1.9-alpha5",
        "==1.9-alpha6",
        "==2.0",
        "==2.0.1",
        "==2.1.0",
        "==2.1.0-alpha1",
        "==2.1.0-alpha2",
        "==2.1.0-beta1",
        "==2.2",
        "==2.3",
        "==2.4",
        "==2.4.1"
      ]
    },
    {
      "id": "pyup.io-pycrypto:CVE-2013-1445",
      "advisory": "The Crypto.Random.atfork function in PyCrypto before 2.6.1 does not properly reseed the pseudo-random number generator (PRNG) before allowing a child process to access it, which makes it easier for context-dependent attackers to obtain sensitive information by leveraging a race condition in which a child process is created and accesses the PRNG within the same rate-limit period as another process.",
      "cve": "CVE-2013-1445",
      "specs": [
        "<=2.6",
        "==1.0.0",
        "==1.0.1",
        "==1.0.2",
        "==2.0",
        "==2.0.1",
        "==2.1.0",
        "==2.2",
        "==2.3",
        "==2.4",
        "==2.4.1",
        "==2.5"
      ]
    },
    {
      "id": "pyup.io-pycrypto:CVE-2013-7459",
      "advisory": "Heap-based buffer overflow in the ALGnew function in block_templace.c in Python Cryptography Toolkit (aka pycrypto) allows remote attackers to execute arbitrary code as demonstrated by a crafted iv parameter to cryptmsg.py.",
      "cve": "CVE-2013-7459",
      "specs": [
        "<=2.6.1"
      ]
    },
    {
      "id": "pyup.io-pycrypto:CVE-2018-6594",
      "advisory": "lib/Crypto/PublicKey/ElGamal.py in PyCrypto through 2.6.1 generates weak ElGamal key parameters, which allows attackers to obtain sensitive information by reading ciphertext data (i.e., it does not have semantic security in face of a ciphertext-only attack). The Decisional Diffie-Hellman (DDH) assumption does not hold for PyCrypto's ElGamal implementation.",
      "cve": "CVE-2018-6594",
      "specs": [
        "<=2.6.1"
      ]
    }
  ],
  "pycryptodome": [
    {
      "id": "pyup.io-pycryptodome:CVE-2018-15560",
      "advisory": "PyCryptodome before 3.6.6 has an integer overflow in the data_len variable in AESNI.c, related to the AESNI_encrypt and AESNI_decrypt functions, leading to the mishandling of messages shorter than 16 bytes.",
      "cve": "CVE-2018-15560",
      "specs": [
        "<3.6.6"
      ]
    }
  ],
  "pycsw": [
    {
      "id": "pyup.io-pycsw:CVE-2016-8640",
      "advisory": "A SQL injection vulnerability in pycsw all versions before 2.0.2, 1.10.5 and 1.8.6 that leads to read and extract of any data from any table in the pycsw database that the database user has access to. Also on PostgreSQL (at least) it is possible to perform updates/inserts/deletes and database modifications to any table the database user has access to.",
      "cve": "CVE-2016-8640",
      "specs": [
        "<1.8.6",
        ">=1.10.0,<1.10.5",
        ">=2.0.0,<2.0.2"
      ]
    }
  ],
  "pydantic": [
    {
      "id": "pyup.io-pydantic:CVE-2021-29510",
      "advisory": "Pydantic is a data validation and settings management using Python type hinting. In affected versions passing either `'infinity'`, `'inf'` or `float('inf')` (or their negatives) to `datetime` or `date` fields causes validation to run forever with 100% CPU usage (on one CPU). Pydantic has been patched with fixes available in the following versions: v1.8.2, v1.7.4, v1.6.2. All these versions are available on pypi(https://pypi.org/project/pydantic/#history), and will be available on conda-forge(https://anaconda.org/conda-forge/pydantic) soon. See the changelog(https://pydantic-docs.helpmanual.io/) for details. If you absolutely can't upgrade, you can work around this risk using a validator(https://pydantic-docs.helpmanual.io/usage/validators/) to catch these values. This is not an ideal solution (in particular you'll need a slightly different function for datetimes), instead of a hack like this you should upgrade pydantic. If you are not using v1.8.x, v1.7.x or v1.6.x and are unable to upgrade to a fixed version of pydantic, please create an issue at https://github.com/samuelcolvin/pydantic/issues requesting a back-port, and we will endeavour to release a patch for earlier versions of pydantic.",
      "cve": "CVE-2021-29510",
      "specs": [
        "<1.6.2",
        ">=1.7,<1.7.4",
        ">=1.8,<1.8.2"
      ]
    }
  ],
  "pyftpdlib": [
    {
      "id": "pyup.io-pyftpdlib:CVE-2007-6736",
      "advisory": "Multiple directory traversal vulnerabilities in FTPServer.py in pyftpdlib before 0.2.0 allow remote authenticated users to access arbitrary files and directories via a .. (dot dot) in a (1) LIST, (2) STOR, or (3) RETR command.",
      "cve": "CVE-2007-6736",
      "specs": [
        "<=0.1.1",
        "==0.1"
      ]
    },
    {
      "id": "pyup.io-pyftpdlib:CVE-2007-6737",
      "advisory": "FTPServer.py in pyftpdlib before 0.2.0 does not increment the attempted_logins count for a USER command that specifies an invalid username, which makes it easier for remote attackers to obtain access via a brute-force attack.",
      "cve": "CVE-2007-6737",
      "specs": [
        "<=0.1.1",
        "==0.1"
      ]
    },
    {
      "id": "pyup.io-pyftpdlib:CVE-2007-6738",
      "advisory": "pyftpdlib before 0.1.1 does not choose a random value for the port associated with the PASV command, which makes it easier for remote attackers to obtain potentially sensitive information about the number of in-progress data connections by reading the response to this command.",
      "cve": "CVE-2007-6738",
      "specs": [
        "<=0.1"
      ]
    },
    {
      "id": "pyup.io-pyftpdlib:CVE-2007-6739",
      "advisory": "FTPServer.py in pyftpdlib before 0.2.0 allows remote attackers to cause a denial of service via a long command.",
      "cve": "CVE-2007-6739",
      "specs": [
        "<=0.1.1",
        "==0.1"
      ]
    },
    {
      "id": "pyup.io-pyftpdlib:CVE-2007-6740",
      "advisory": "The ftp_STOU function in FTPServer.py in pyftpdlib before 0.2.0 does not limit the number of attempts to discover a unique filename, which might allow remote authenticated users to cause a denial of service via a STOU command.",
      "cve": "CVE-2007-6740",
      "specs": [
        "<=0.1.1",
        "==0.1"
      ]
    },
    {
      "id": "pyup.io-pyftpdlib:CVE-2007-6741",
      "advisory": "The ftp_PORT function in FTPServer.py in pyftpdlib before 0.2.0 does not prevent TCP connections to privileged ports if the destination IP address matches the source IP address of the connection from the FTP client, which might allow remote authenticated users to conduct FTP bounce attacks via crafted FTP data, as demonstrated by an FTP bounce attack against a NAT server, a related issue to CVE-1999-0017.",
      "cve": "CVE-2007-6741",
      "specs": [
        "<=0.1.1",
        "==0.1"
      ]
    },
    {
      "id": "pyup.io-pyftpdlib:CVE-2008-7262",
      "advisory": "Multiple directory traversal vulnerabilities in FTPServer.py in pyftpdlib before 0.3.0 allow remote authenticated users to access arbitrary files and directories via vectors involving a symlink in a pathname to a (1) CWD, (2) DELE, (3) STOR, or (4) RETR command.",
      "cve": "CVE-2008-7262",
      "specs": [
        "<=0.2.0",
        "==0.1",
        "==0.1.1"
      ]
    },
    {
      "id": "pyup.io-pyftpdlib:CVE-2008-7263",
      "advisory": "ftpserver.py in pyftpdlib before 0.5.0 does not delay its response after receiving an invalid login attempt, which makes it easier for remote attackers to obtain access via a brute-force attack.",
      "cve": "CVE-2008-7263",
      "specs": [
        "<=0.4.0",
        "==0.1",
        "==0.1.1",
        "==0.2.0",
        "==0.3.0"
      ]
    },
    {
      "id": "pyup.io-pyftpdlib:CVE-2008-7264",
      "advisory": "The ftp_QUIT function in ftpserver.py in pyftpdlib before 0.5.0 allows remote authenticated users to cause a denial of service (file descriptor exhaustion and daemon outage) by sending a QUIT command during a disallowed data-transfer attempt.",
      "cve": "CVE-2008-7264",
      "specs": [
        "<=0.4.0",
        "==0.1",
        "==0.1.1",
        "==0.2.0",
        "==0.3.0"
      ]
    },
    {
      "id": "pyup.io-pyftpdlib:CVE-2009-5010",
      "advisory": "Race condition in the FTPHandler class in ftpserver.py in pyftpdlib before 0.5.1 allows remote attackers to cause a denial of service (daemon outage) by establishing and then immediately closing a TCP connection, leading to the accept function having an unexpected return value of None, a different vulnerability than CVE-2010-3494.",
      "cve": "CVE-2009-5010",
      "specs": [
        "<=0.5.0",
        "==0.1",
        "==0.1.1",
        "==0.2.0",
        "==0.3.0",
        "==0.4.0"
      ]
    },
    {
      "id": "pyup.io-pyftpdlib:CVE-2009-5011",
      "advisory": "Race condition in the FTPHandler class in ftpserver.py in pyftpdlib before 0.5.2 allows remote attackers to cause a denial of service (daemon outage) by establishing and then immediately closing a TCP connection, leading to the getpeername function having an ENOTCONN error, a different vulnerability than CVE-2010-3494.",
      "cve": "CVE-2009-5011",
      "specs": [
        "<=0.5.1",
        "==0.1",
        "==0.1.1",
        "==0.2.0",
        "==0.3.0",
        "==0.4.0",
        "==0.5.0"
      ]
    },
    {
      "id": "pyup.io-pyftpdlib:CVE-2009-5012",
      "advisory": "ftpserver.py in pyftpdlib before 0.5.2 does not require the l permission for the MLST command, which allows remote authenticated users to bypass intended access restrictions and list the root directory via an FTP session.",
      "cve": "CVE-2009-5012",
      "specs": [
        "<=0.5.1",
        "==0.1",
        "==0.1.1",
        "==0.2.0",
        "==0.3.0",
        "==0.4.0",
        "==0.5.0"
      ]
    },
    {
      "id": "pyup.io-pyftpdlib:CVE-2009-5013",
      "advisory": "Memory leak in the on_dtp_close function in ftpserver.py in pyftpdlib before 0.5.2 allows remote authenticated users to cause a denial of service (memory consumption) by sending a QUIT command during a data transfer.",
      "cve": "CVE-2009-5013",
      "specs": [
        "<=0.5.1",
        "==0.1",
        "==0.1.1",
        "==0.2.0",
        "==0.3.0",
        "==0.4.0",
        "==0.5.0"
      ]
    },
    {
      "id": "pyup.io-pyftpdlib:CVE-2010-3494",
      "advisory": "Race condition in the FTPHandler class in ftpserver.py in pyftpdlib before 0.5.2 allows remote attackers to cause a denial of service (daemon outage) by establishing and then immediately closing a TCP connection, leading to the accept function having an unexpected value of None for the address, or an ECONNABORTED, EAGAIN, or EWOULDBLOCK error, a related issue to CVE-2010-3492.",
      "cve": "CVE-2010-3494",
      "specs": [
        "<=0.5.1",
        "==0.1",
        "==0.1.1",
        "==0.2.0",
        "==0.3.0",
        "==0.4.0",
        "==0.5.0"
      ]
    }
  ],
  "pygments": [
    {
      "id": "pyup.io-pygments:CVE-2015-8557",
      "advisory": "The FontManager._get_nix_font_path function in formatters/img.py in Pygments 1.2.2 through 2.0.2 allows remote attackers to execute arbitrary commands via shell metacharacters in a font name.",
      "cve": "CVE-2015-8557",
      "specs": [
        "==1.2.2",
        "==1.3",
        "==1.3.1",
        "==1.4",
        "==1.5",
        "==1.6",
        "==1.6-rc1",
        "==2.0",
        "==2.0-rc1",
        "==2.0.1"
      ]
    },
    {
      "id": "pyup.io-pygments:CVE-2021-20270",
      "advisory": "An infinite loop in SMLLexer in Pygments versions 1.5 to 2.7.3 may lead to denial of service when performing syntax highlighting of a Standard ML (SML) source file, as demonstrated by input that only contains the \"exception\" keyword.",
      "cve": "CVE-2021-20270",
      "specs": [
        ">=1.5,<=2.7.3"
      ]
    },
    {
      "id": "pyup.io-pygments:CVE-2021-27291",
      "advisory": "In pygments 1.1+, fixed in 2.7.4, the lexers used to parse programming languages rely heavily on regular expressions. Some of the regular expressions have exponential or cubic worst-case complexity and are vulnerable to ReDoS. By crafting malicious input, an attacker can cause a denial of service.",
      "cve": "CVE-2021-27291",
      "specs": [
        ">=1.1,<2.7.4"
      ]
    }
  ],
  "pyjwt": [
    {
      "id": "pyup.io-pyjwt:CVE-2017-11424",
      "advisory": "In PyJWT 1.5.0 and below the `invalid_strings` check in `HMACAlgorithm.prepare_key` does not account for all PEM encoded public keys. Specifically, the PKCS1 PEM encoded format would be allowed because it is prefaced with the string `-----BEGIN RSA PUBLIC KEY-----` which is not accounted for. This enables symmetric/asymmetric key confusion attacks against users using the PKCS1 PEM encoded public keys, which would allow an attacker to craft JWTs from scratch.",
      "cve": "CVE-2017-11424",
      "specs": [
        "<=1.5.0"
      ]
    }
  ],
  "pykmip": [
    {
      "id": "pyup.io-pykmip:CVE-2018-1000872",
      "advisory": "OpenKMIP PyKMIP version All versions before 0.8.0 contains a CWE 399: Resource Management Errors (similar issue to CVE-2015-5262) vulnerability in PyKMIP server that can result in DOS: the server can be made unavailable by one or more clients opening all of the available sockets. This attack appear to be exploitable via A client or clients open sockets with the server and then never close them. This vulnerability appears to have been fixed in 0.8.0.",
      "cve": "CVE-2018-1000872",
      "specs": [
        "<0.8.0"
      ]
    }
  ],
  "pymongo": [
    {
      "id": "pyup.io-pymongo:CVE-2012-6619",
      "advisory": "The default configuration for MongoDB before 2.3.2 does not validate objects, which allows remote authenticated users to cause a denial of service (crash) or read system memory via a crafted BSON object in the column name in an insert command, which triggers a buffer over-read.",
      "cve": "CVE-2012-6619",
      "specs": [
        "<=2.3.1",
        "==1.2.0",
        "==1.4.0",
        "==1.6.0",
        "==1.8.0",
        "==2.0.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.0.6",
        "==2.0.7",
        "==2.0.8",
        "==2.2.0",
        "==2.2.1",
        "==2.2.2",
        "==2.2.3",
        "==2.2.4",
        "==2.2.5",
        "==2.2.6",
        "==2.2.7",
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2013-1892",
      "advisory": "MongoDB before 2.0.9 and 2.2.x before 2.2.4 does not properly validate requests to the nativeHelper function in SpiderMonkey, which allows remote authenticated users to cause a denial of service (invalid memory access and server crash) or execute arbitrary code via a crafted memory address in the first argument.",
      "cve": "CVE-2013-1892",
      "specs": [
        "<=2.0.8",
        "==1.2.0",
        "==1.4.0",
        "==1.6.0",
        "==1.8.0",
        "==2.0.0",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3",
        "==2.0.4",
        "==2.0.5",
        "==2.0.6",
        "==2.0.7",
        "==2.2.0",
        "==2.2.1",
        "==2.2.2",
        "==2.2.3"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2013-2132",
      "advisory": "bson/_cbsonmodule.c in the mongo-python-driver (aka. pymongo) before 2.5.2, as used in MongoDB, allows context-dependent attackers to cause a denial of service (NULL pointer dereference and crash) via vectors related to decoding of an \"invalid DBRef.\"",
      "cve": "CVE-2013-2132",
      "specs": [
        "<=2.5.1",
        "==1.2.0",
        "==1.4.0",
        "==1.6.0",
        "==1.8.0",
        "==2.0.0",
        "==2.2.0",
        "==2.4.0",
        "==2.4.1",
        "==2.4.2",
        "==2.4.3",
        "==2.4.4",
        "==2.4.5",
        "==2.5.0"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2013-3969",
      "advisory": "The find prototype in scripting/engine_v8.h in MongoDB 2.4.0 through 2.4.4 allows remote authenticated users to cause a denial of service (uninitialized pointer dereference and server crash) or possibly execute arbitrary code via an invalid RefDB object.",
      "cve": "CVE-2013-3969",
      "specs": [
        "==2.4.0",
        "==2.4.1",
        "==2.4.2",
        "==2.4.3",
        "==2.4.4"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2013-4650",
      "advisory": "MongoDB 2.4.x before 2.4.5 and 2.5.x before 2.5.1 allows remote authenticated users to obtain internal system privileges by leveraging a username of __system in an arbitrary database.",
      "cve": "CVE-2013-4650",
      "specs": [
        "==2.4.0",
        "==2.4.1",
        "==2.4.2",
        "==2.4.3",
        "==2.4.4",
        "==2.5.0"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2014-3971",
      "advisory": "The CmdAuthenticate::_authenticateX509 function in db/commands/authentication_commands.cpp in mongod in MongoDB 2.6.x before 2.6.2 allows remote attackers to cause a denial of service (daemon crash) by attempting authentication with an invalid X.509 client certificate.",
      "cve": "CVE-2014-3971",
      "specs": [
        "==2.6.0",
        "==2.6.1"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2015-1609",
      "advisory": "MongoDB before 2.4.13 and 2.6.x before 2.6.8 allows remote attackers to cause a denial of service via a crafted UTF-8 string in a BSON request.",
      "cve": "CVE-2015-1609",
      "specs": [
        "<=2.4.12",
        "==2.6.0",
        "==2.6.1",
        "==2.6.2",
        "==2.6.3",
        "==2.6.4",
        "==2.6.5",
        "==2.6.6",
        "==2.6.7"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2015-7882",
      "advisory": "Improper handling of LDAP authentication in MongoDB Server versions 3.0.0 to 3.0.6 allows an unauthenticated client to gain unauthorized access.",
      "cve": "CVE-2015-7882",
      "specs": [
        ">=3.0.0,<=3.0.6"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2016-3104",
      "advisory": "mongod in MongoDB 2.6, when using 2.4-style users, and 2.4 allow remote attackers to cause a denial of service (memory consumption and process termination) by leveraging in-memory database representation when authenticating against a non-existent database.",
      "cve": "CVE-2016-3104",
      "specs": [
        "==2.4.0",
        "==2.6.0"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2016-6494",
      "advisory": "The client in MongoDB uses world-readable permissions on .dbshell history files, which might allow local users to obtain sensitive information by reading these files.",
      "cve": "CVE-2016-6494",
      "specs": [
        "<3.0.15",
        ">=3.2,<3.2.14",
        ">=3.3,<3.3.14"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2017-14227",
      "advisory": "In MongoDB libbson 1.7.0, the bson_iter_codewscope function in bson-iter.c miscalculates a bson_utf8_validate length argument, which allows remote attackers to cause a denial of service (heap-based buffer over-read in the bson_utf8_validate function in bson-utf8.c), as demonstrated by bson-to-json.c.",
      "cve": "CVE-2017-14227",
      "specs": [
        "==1.7.0"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2017-15535",
      "advisory": "MongoDB 3.4.x before 3.4.10, and 3.5.x-development, has a disabled-by-default configuration setting, networkMessageCompressors (aka wire protocol compression), which exposes a vulnerability when enabled that could be exploited by a malicious attacker to deny service or modify memory.",
      "cve": "CVE-2017-15535",
      "specs": [
        ">=3.4.0,<3.4.10"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2018-20802",
      "advisory": "A user authorized to perform database queries may trigger denial of service by issuing specially crafted queries with compound indexes affecting QueryPlanner. This issue affects: MongoDB Inc. MongoDB Server v3.6 versions prior to 3.6.9, v4.0 versions prior to 4.0.3.",
      "cve": "CVE-2018-20802",
      "specs": [
        ">=3.6.0,<3.6.9",
        ">=4.0.0,<4.0.3"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2018-20803",
      "advisory": "A user authorized to perform database queries may trigger denial of service by issuing specially crafted queries, which loop indefinitely in mathematics processing while retaining locks. This issue affects: MongoDB Inc. MongoDB Server v4.0 versions prior to 4.0.5; v3.6 versions prior to 3.6.10; v3.4 versions prior to 3.4.19.",
      "cve": "CVE-2018-20803",
      "specs": [
        ">=3.4.0,<3.4.19",
        ">=3.6.0,<3.6.10",
        ">=4.0.0,<4.0.5"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2018-20804",
      "advisory": "A user authorized to perform database queries may trigger denial of service by issuing specially crafted applyOps invocations. This issue affects: MongoDB Inc. MongoDB Server v4.0 versions prior to 4.0.10; v3.6 versions prior to 3.6.13.",
      "cve": "CVE-2018-20804",
      "specs": [
        ">=3.6.0,<3.6.13",
        ">=4.0.0,<4.0.10"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2018-20805",
      "advisory": "A user authorized to perform database queries may trigger denial of service by issuing specially crafted queries, which perform an $elemMatch This issue affects: MongoDB Inc. MongoDB Server v4.0 versions prior to 4.0.5; v3.6 versions prior to 3.6.10. This issue affects: MongoDB Inc. MongoDB Server 3.6 versions prior to 3.6.10; 4.0 versions prior to 4.0.5.",
      "cve": "CVE-2018-20805",
      "specs": [
        ">=3.6.0,<3.6.10",
        ">=4.0.0,<4.0.5"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2018-25004",
      "advisory": "A user authorized to performing a specific type of query may trigger a denial of service by issuing a generic explain command on a find query. This issue affects: MongoDB Inc. MongoDB Server v4.0 versions prior to 4.0.6; MongoDB Server v3.6 versions prior to 3.6.11.",
      "cve": "CVE-2018-25004",
      "specs": [
        ">=3.6.0,<3.6.11",
        ">=4.0.0,<4.0.6"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2019-20923",
      "advisory": "A user authorized to perform database queries may trigger denial of service by issuing specially crafted queries, which throw unhandled Javascript exceptions containing types intended to be scoped to the Javascript engine's internals. This issue affects: MongoDB Inc. MongoDB Server v4.0 versions prior to 4.0.7.",
      "cve": "CVE-2019-20923",
      "specs": [
        ">=4.0.0,<4.0.7"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2019-20924",
      "advisory": "A user authorized to perform database queries may trigger denial of service by issuing specially crafted queries which trigger an invariant in the IndexBoundsBuilder. This issue affects: MongoDB Inc. MongoDB Server v4.2 versions prior to 4.2.2.",
      "cve": "CVE-2019-20924",
      "specs": [
        ">=4.2.0,<4.2.2"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2019-20925",
      "advisory": "An unauthenticated client can trigger denial of service by issuing specially crafted wire protocol messages, which cause the message decompressor to incorrectly allocate memory. This issue affects: MongoDB Inc. MongoDB Server v4.2 versions prior to 4.2.1; v4.0 versions prior to 4.0.13; v3.6 versions prior to 3.6.15; v3.4 versions prior to 3.4.24.",
      "cve": "CVE-2019-20925",
      "specs": [
        ">=3.4.0,<3.4.24",
        ">=3.6.0,<3.6.15",
        ">=4.0.0,<4.0.13",
        ">=4.2.0,<4.2.1"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2019-2386",
      "advisory": "After user deletion in MongoDB Server the improper invalidation of authorization sessions allows an authenticated user's session to persist and become conflated with new accounts, if those accounts reuse the names of deleted ones. This issue affects: MongoDB Inc. MongoDB Server v4.0 versions prior to 4.0.9; v3.6 versions prior to 3.6.13; v3.4 versions prior to 3.4.22.",
      "cve": "CVE-2019-2386",
      "specs": [
        ">=3.4.0,<3.4.22",
        ">=3.6.0,<3.6.13",
        ">=4.0.0,<4.0.9"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2019-2389",
      "advisory": "Incorrect scoping of kill operations in MongoDB Server's packaged SysV init scripts allow users with write access to the PID file to insert arbitrary PIDs to be killed when the root user stops the MongoDB process via SysV init. This issue affects: MongoDB Inc. MongoDB Server v4.0 versions prior to 4.0.11; v3.6 versions prior to 3.6.14; v3.4 versions prior to 3.4.22.",
      "cve": "CVE-2019-2389",
      "specs": [
        ">=3.4.0,<3.4.22",
        ">=3.6.0,<3.6.14",
        ">=4.0.0,<4.0.11"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2019-2392",
      "advisory": "A user authorized to perform database queries may trigger denial of service by issuing specially crafted queries, which use the $mod operator to overflow negative values. This issue affects: MongoDB Inc. MongoDB Server v4.4 versions prior to 4.4.1; v4.2 versions prior to 4.2.9; v4.0 versions prior to 4.0.20; v3.6 versions prior to 3.6.20.",
      "cve": "CVE-2019-2392",
      "specs": [
        ">=3.6.0,<3.6.20",
        ">=4.0.0,<4.0.20",
        ">=4.2.0,<4.2.9",
        ">=4.4.0,<4.4.1"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2019-2393",
      "advisory": "A user authorized to perform database queries may trigger denial of service by issuing specially crafted queries, which use $lookup and collations. This issue affects: MongoDB Inc. MongoDB Server v4.2 versions prior to 4.2.1; v4.0 versions prior to 4.0.13; v3.6 versions prior to 3.6.15.",
      "cve": "CVE-2019-2393",
      "specs": [
        ">=3.6.0,<3.6.15",
        ">=4.0.0,<4.0.13",
        ">=4.2.0,<4.2.1"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2020-7921",
      "advisory": "Improper serialization of internal state in the authorization subsystem in MongoDB Server's authorization subsystem permits a user with valid credentials to bypass IP whitelisting protection mechanisms following administrative action. This issue affects: MongoDB Inc. MongoDB Server 4.2 versions prior to 4.2.3; 4.0 versions prior to 4.0.15; 4.3 versions prior to 4.3.3; 3.6 versions prior to 3.6.18.",
      "cve": "CVE-2020-7921",
      "specs": [
        ">=3.6.0,<3.6.18",
        ">=4.0.0,<4.0.15",
        ">=4.2.0,<4.2.3",
        ">=4.3.0,<4.3.3"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2020-7923",
      "advisory": "A user authorized to perform database queries may cause denial of service by issuing specially crafted queries, which violate an invariant in the query subsystem's support for geoNear. This issue affects: MongoDB Inc. MongoDB Server v4.4 versions prior to 4.4.0-rc7; v4.2 versions prior to 4.2.8; v4.0 versions prior to 4.0.19.",
      "cve": "CVE-2020-7923",
      "specs": [
        ">=4.0,<4.0.19",
        ">=4.2,<4.2.8",
        ">=4.4,<4.4.0",
        ">=4.5,<4.5.1"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2020-7925",
      "advisory": "Incorrect validation of user input in the role name parser may lead to use of uninitialized memory allowing an unauthenticated attacker to use a specially crafted request to cause a denial of service. This issue affects: MongoDB Inc. MongoDB Server v4.4 versions prior to 4.4.0-rc12; v4.2 versions prior to 4.2.9.",
      "cve": "CVE-2020-7925",
      "specs": [
        "==4.4.0-rc1",
        "==4.4.0-rc10",
        "==4.4.0-rc11",
        "==4.4.0-rc2",
        "==4.4.0-rc3",
        "==4.4.0-rc4",
        "==4.4.0-rc5",
        "==4.4.0-rc6",
        "==4.4.0-rc7",
        "==4.4.0-rc8",
        "==4.4.0-rc9",
        ">=4.2.0,<4.2.9"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2020-7926",
      "advisory": "A user authorized to perform database queries may cause denial of service by issuing a specially crafted query which violates an invariant in the server selection subsystem. This issue affects: MongoDB Server version 4.4 prior to 4.4.1. Versions before 4.4 are not affected.",
      "cve": "CVE-2020-7926",
      "specs": [
        ">=4.4.0,<4.4.1"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2020-7928",
      "advisory": "A user authorized to perform database queries may trigger a read overrun and access arbitrary memory by issuing specially crafted queries. This issue affects: MongoDB Inc. MongoDB Server v4.4 versions prior to 4.4.1; v4.2 versions prior to 4.2.9; v4.0 versions prior to 4.0.20; v3.6 versions prior to 3.6.20.",
      "cve": "CVE-2020-7928",
      "specs": [
        ">=3.6.0,<3.6.20",
        ">=4.0.0,<4.0.20",
        ">=4.2.0,<4.2.9",
        ">=4.4.0,<4.4.1",
        ">=4.5.0,<4.5.1"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2020-7929",
      "advisory": "A user authorized to perform database queries may trigger denial of service by issuing specially crafted query contain a type of regex. This issue affects: MongoDB Inc. MongoDB Server v3.6 versions prior to 3.6.21 and MongoDB Server v4.0 versions prior to 4.0.20.",
      "cve": "CVE-2020-7929",
      "specs": [
        ">=3.6.0,<3.6.21",
        ">=4.0.0,<4.0.20"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2021-20326",
      "advisory": "A user authorized to performing a specific type of find query may trigger a denial of service. This issue affects: MongoDB Inc. MongoDB Server v4.4 versions prior to 4.4.4.",
      "cve": "CVE-2021-20326",
      "specs": [
        ">=4.4.0,<4.4.4"
      ]
    },
    {
      "id": "pyup.io-pymongo:CVE-2021-20333",
      "advisory": "Sending specially crafted commands to a MongoDB Server may result in artificial log entries being generated or for log entries to be split. This issue affects MongoDB Server v3.6 versions prior to 3.6.20; MongoDB Server v4.0 versions prior to 4.0.21; MongoDB Server v4.2 versions prior to 4.2.10;",
      "cve": "CVE-2021-20333",
      "specs": [
        ">=3.6.0,<3.6.20",
        ">=4.0.0,<4.0.21",
        ">=4.2.0,<4.2.10"
      ]
    }
  ],
  "pyopenssl": [
    {
      "id": "pyup.io-pyopenssl:CVE-2013-4314",
      "advisory": "The X509Extension in pyOpenSSL before 0.13.1 does not properly handle a '\\0' character in a domain name in the Subject Alternative Name field of an X.509 certificate, which allows man-in-the-middle attackers to spoof arbitrary SSL servers via a crafted certificate issued by a legitimate Certification Authority.",
      "cve": "CVE-2013-4314",
      "specs": [
        "<=0.13",
        "==0.10",
        "==0.11",
        "==0.11-a1",
        "==0.11-a2",
        "==0.12",
        "==0.7",
        "==0.8-a1",
        "==0.9"
      ]
    },
    {
      "id": "pyup.io-pyopenssl:CVE-2018-1000807",
      "advisory": "Python Cryptographic Authority pyopenssl version prior to version 17.5.0 contains a CWE-416: Use After Free vulnerability in X509 object handling that can result in Use after free can lead to possible denial of service or remote code execution.. This attack appear to be exploitable via Depends on the calling application and if it retains a reference to the memory.. This vulnerability appears to have been fixed in 17.5.0.",
      "cve": "CVE-2018-1000807",
      "specs": [
        "<17.5.0"
      ]
    },
    {
      "id": "pyup.io-pyopenssl:CVE-2018-1000808",
      "advisory": "Python Cryptographic Authority pyopenssl version Before 17.5.0 contains a CWE - 401 : Failure to Release Memory Before Removing Last Reference vulnerability in PKCS #12 Store that can result in Denial of service if memory runs low or is exhausted. This attack appear to be exploitable via Depends upon calling application, however it could be as simple as initiating a TLS connection. Anything that would cause the calling application to reload certificates from a PKCS #12 store.. This vulnerability appears to have been fixed in 17.5.0.",
      "cve": "CVE-2018-1000808",
      "specs": [
        "<17.5.0"
      ]
    }
  ],
  "pypiserver": [
    {
      "id": "pyup.io-pypiserver:CVE-2019-6802",
      "advisory": "CRLF Injection in pypiserver 1.2.5 and below allows attackers to set arbitrary HTTP headers and possibly conduct XSS attacks via a %0d%0a in a URI.",
      "cve": "CVE-2019-6802",
      "specs": [
        "<=1.2.5"
      ]
    }
  ],
  "pyplate": [
    {
      "id": "pyup.io-pyplate:CVE-2014-3851",
      "advisory": "usr/lib/cgi-bin/create_passwd_file.py in Pyplate 0.08 uses world-readable permissions for passwd.db, which allows local users to obtain the administrator password by reading this file.",
      "cve": "CVE-2014-3851",
      "specs": [
        "==0.08"
      ]
    },
    {
      "id": "pyup.io-pyplate:CVE-2014-3852",
      "advisory": "Pyplate 0.08 does not include the HTTPOnly flag in a Set-Cookie header for the id cookie, which makes it easier for remote attackers to obtain potentially sensitive information via script access to this cookie.",
      "cve": "CVE-2014-3852",
      "specs": [
        "==0.08"
      ]
    },
    {
      "id": "pyup.io-pyplate:CVE-2014-3853",
      "advisory": "Pyplate 0.08 does not set the secure flag for the id cookie in an https session, which makes it easier for remote attackers to capture this cookie by intercepting its transmission within an http session.",
      "cve": "CVE-2014-3853",
      "specs": [
        "==0.08"
      ]
    },
    {
      "id": "pyup.io-pyplate:CVE-2014-3854",
      "advisory": "Cross-site request forgery (CSRF) vulnerability in admin/addScript.py in Pyplate 0.08 allows remote attackers to hijack the authentication of administrators for requests that conduct cross-site scripting (XSS) attacks via the title parameter.",
      "cve": "CVE-2014-3854",
      "specs": [
        "==0.08"
      ]
    },
    {
      "id": "pyup.io-pyplate:CVE-2014-3855",
      "advisory": "Directory traversal vulnerability in download.py in Pyplate 0.08 allows remote attackers to read arbitrary files via a .. (dot dot) in the filename parameter.",
      "cve": "CVE-2014-3855",
      "specs": [
        "==0.08"
      ]
    }
  ],
  "pyrad": [
    {
      "id": "pyup.io-pyrad:CVE-2013-0294",
      "advisory": "packet.py in pyrad before 2.1 uses weak random numbers to generate RADIUS authenticators and hash passwords, which makes it easier for remote attackers to obtain sensitive information via a brute force attack.",
      "cve": "CVE-2013-0294",
      "specs": [
        "<2.1"
      ]
    },
    {
      "id": "pyup.io-pyrad:CVE-2013-0342",
      "advisory": "The CreateID function in packet.py in pyrad before 2.1 uses sequential packet IDs, which makes it easier for remote attackers to spoof packets by predicting the next ID, a different vulnerability than CVE-2013-0294.",
      "cve": "CVE-2013-0342",
      "specs": [
        "<2.1"
      ]
    }
  ],
  "pyro": [
    {
      "id": "pyup.io-pyro:CVE-2011-2765",
      "advisory": "pyro before 3.15 unsafely handles pid files in temporary directory locations and opening the pid file as root. An attacker can use this flaw to overwrite arbitrary files via symlinks.",
      "cve": "CVE-2011-2765",
      "specs": [
        "<3.15"
      ]
    }
  ],
  "pyro4": [
    {
      "id": "pyup.io-pyro4:CVE-2011-2765",
      "advisory": "pyro before 3.15 unsafely handles pid files in temporary directory locations and opening the pid file as root. An attacker can use this flaw to overwrite arbitrary files via symlinks.",
      "cve": "CVE-2011-2765",
      "specs": [
        "<3.15"
      ]
    }
  ],
  "pysaml2": [
    {
      "id": "pyup.io-pysaml2:CVE-2016-10149",
      "advisory": "XML External Entity (XXE) vulnerability in PySAML2 4.4.0 and earlier allows remote attackers to read arbitrary files via a crafted SAML XML request or response.",
      "cve": "CVE-2016-10149",
      "specs": [
        "<=4.4.0"
      ]
    },
    {
      "id": "pyup.io-pysaml2:CVE-2017-1000246",
      "advisory": "Python package pysaml2 version 4.4.0 and earlier reuses the initialization vector across encryptions in the IDP server, resulting in weak encryption of data.",
      "cve": "CVE-2017-1000246",
      "specs": [
        "<4.6.0"
      ]
    },
    {
      "id": "pyup.io-pysaml2:CVE-2017-1000433",
      "advisory": "pysaml2 version 4.4.0 and older accept any password when run with python optimizations enabled. This allows attackers to log in as any user without knowing their password.",
      "cve": "CVE-2017-1000433",
      "specs": [
        "<=4.4.0"
      ]
    },
    {
      "id": "pyup.io-pysaml2:CVE-2020-5390",
      "advisory": "PySAML2 before 5.0.0 does not check that the signature in a SAML document is enveloped and thus signature wrapping is effective, i.e., it is affected by XML Signature Wrapping (XSW). The signature information and the node/object that is signed can be in different places and thus the signature verification will succeed, but the wrong data will be used. This specifically affects the verification of assertion that have been signed.",
      "cve": "CVE-2020-5390",
      "specs": [
        "<5.0.0"
      ]
    },
    {
      "id": "pyup.io-pysaml2:CVE-2021-21238",
      "advisory": "PySAML2 is a pure python implementation of SAML Version 2 Standard. PySAML2 before 6.5.0 has an improper verification of cryptographic signature vulnerability. All users of pysaml2 that need to validate signed SAML documents are impacted. The vulnerability is a variant of XML Signature wrapping because it did not validate the SAML document against an XML schema. This allowed invalid XML documents to be processed and such a document can trick pysaml2 with a wrapped signature. This is fixed in PySAML2 6.5.0.",
      "cve": "CVE-2021-21238",
      "specs": [
        "<6.5.0"
      ]
    },
    {
      "id": "pyup.io-pysaml2:CVE-2021-21239",
      "advisory": "PySAML2 is a pure python implementation of SAML Version 2 Standard. PySAML2 before 6.5.0 has an improper verification of cryptographic signature vulnerability. Users of pysaml2 that use the default CryptoBackendXmlSec1 backend and need to verify signed SAML documents are impacted. PySAML2 does not ensure that a signed SAML document is correctly signed. The default CryptoBackendXmlSec1 backend is using the xmlsec1 binary to verify the signature of signed SAML documents, but by default xmlsec1 accepts any type of key found within the given document. xmlsec1 needs to be configured explicitly to only use only _x509 certificates_ for the verification process of the SAML document signature. This is fixed in PySAML2 6.5.0.",
      "cve": "CVE-2021-21239",
      "specs": [
        "<6.5.0"
      ]
    }
  ],
  "pyshop": [
    {
      "id": "pyup.io-pyshop:CVE-2013-1630",
      "advisory": "pyshop before 0.7.1 uses HTTP to retrieve packages from the PyPI repository, and does not perform integrity checks on package contents, which allows man-in-the-middle attackers to execute arbitrary code via a crafted response to a download operation.",
      "cve": "CVE-2013-1630",
      "specs": [
        "<=0.7",
        "==0.1",
        "==0.2",
        "==0.3",
        "==0.4",
        "==0.5",
        "==0.6"
      ]
    }
  ],
  "pyspark": [
    {
      "id": "pyup.io-pyspark:CVE-2017-12612",
      "advisory": "In Apache Spark 1.6.0 until 2.1.1, the launcher API performs unsafe deserialization of data received by its socket. This makes applications launched programmatically using the launcher API potentially vulnerable to arbitrary code execution by an attacker with access to any user account on the local machine. It does not affect apps run by spark-submit or spark-shell. The attacker would be able to execute code as the user that ran the Spark application. Users are encouraged to update to version 2.2.0 or later.",
      "cve": "CVE-2017-12612",
      "specs": [
        "==1.6.0",
        "==1.6.1",
        "==1.6.2",
        "==1.6.3",
        "==2.0.0",
        "==2.0.1",
        "==2.0.2",
        "==2.1.0",
        "==2.1.1"
      ]
    },
    {
      "id": "pyup.io-pyspark:CVE-2017-7678",
      "advisory": "In Apache Spark before 2.2.0, it is possible for an attacker to take advantage of a user's trust in the server to trick them into visiting a link that points to a shared Spark cluster and submits data including MHTML to the Spark master, or history server. This data, which could contain a script, would then be reflected back to the user and could be evaluated and executed by MS Windows-based clients. It is not an attack on Spark itself, but on the user, who may then execute the script inadvertently when viewing elements of the Spark web UIs.",
      "cve": "CVE-2017-7678",
      "specs": [
        "<=2.1.1"
      ]
    },
    {
      "id": "pyup.io-pyspark:CVE-2018-11760",
      "advisory": "When using PySpark , it's possible for a different local user to connect to the Spark application and impersonate the user running the Spark application. This affects versions 1.x, 2.0.x, 2.1.x, 2.2.0 to 2.2.2, and 2.3.0 to 2.3.1.",
      "cve": "CVE-2018-11760",
      "specs": [
        ">=1.0.2,<=1.6.3",
        ">=2.0.0,<=2.0.2",
        ">=2.1.0,<=2.1.3",
        ">=2.2.0,<=2.2.2",
        ">=2.3.0,<=2.3.1"
      ]
    },
    {
      "id": "pyup.io-pyspark:CVE-2018-11770",
      "advisory": "From version 1.3.0 onward, Apache Spark's standalone master exposes a REST API for job submission, in addition to the submission mechanism used by spark-submit. In standalone, the config property 'spark.authenticate.secret' establishes a shared secret for authenticating requests to submit jobs via spark-submit. However, the REST API does not use this or any other authentication mechanism, and this is not adequately documented. In this case, a user would be able to run a driver program without authenticating, but not launch executors, using the REST API. This REST API is also used by Mesos, when set up to run in cluster mode (i.e., when also running MesosClusterDispatcher), for job submission. Future versions of Spark will improve documentation on these points, and prohibit setting 'spark.authenticate.secret' when running the REST APIs, to make this clear. Future versions will also disable the REST API by default in the standalone master by changing the default value of 'spark.master.rest.enabled' to 'false'.",
      "cve": "CVE-2018-11770",
      "specs": [
        ">=1.3.0"
      ]
    },
    {
      "id": "pyup.io-pyspark:CVE-2018-11804",
      "advisory": "Spark's Apache Maven-based build includes a convenience script, 'build/mvn', that downloads and runs a zinc server to speed up compilation. It has been included in release branches since 1.3.x, up to and including master. This server will accept connections from external hosts by default. A specially-crafted request to the zinc server could cause it to reveal information in files readable to the developer account running the build. Note that this issue does not affect end users of Spark, only developers building Spark from source code.",
      "cve": "CVE-2018-11804",
      "specs": [
        ">=1.3.0"
      ]
    },
    {
      "id": "pyup.io-pyspark:CVE-2018-1334",
      "advisory": "In Apache Spark 1.0.0 to 2.1.2, 2.2.0 to 2.2.1, and 2.3.0, when using PySpark or SparkR, it's possible for a different local user to connect to the Spark application and impersonate the user running the Spark application.",
      "cve": "CVE-2018-1334",
      "specs": [
        "<=2.1.2",
        "==2.3.0",
        ">=2.2.0,<=2.2.1"
      ]
    },
    {
      "id": "pyup.io-pyspark:CVE-2018-8024",
      "advisory": "In Apache Spark 2.1.0 to 2.1.2, 2.2.0 to 2.2.1, and 2.3.0, it's possible for a malicious user to construct a URL pointing to a Spark cluster's UI's job and stage info pages, and if a user can be tricked into accessing the URL, can be used to cause script to execute and expose information from the user's view of the Spark UI. While some browsers like recent versions of Chrome and Safari are able to block this type of attack, current versions of Firefox (and possibly others) do not.",
      "cve": "CVE-2018-8024",
      "specs": [
        "==2.3.0",
        ">=2.1.0,<=2.1.2",
        ">=2.2.0,<=2.2.1"
      ]
    },
    {
      "id": "pyup.io-pyspark:CVE-2019-10099",
      "advisory": "Prior to Spark 2.3.3, in certain situations Spark would write user data to local disk unencrypted, even if spark.io.encryption.enabled=true. This includes cached blocks that are fetched to disk (controlled by spark.maxRemoteBlockSizeFetchToMem); in SparkR, using parallelize; in Pyspark, using broadcast and parallelize; and use of python udfs.",
      "cve": "CVE-2019-10099",
      "specs": [
        ">=1.0.2,<=1.6.3",
        ">=2.0.0,<=2.0.2",
        ">=2.1.0,<=2.1.3",
        ">=2.2.0,<=2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-pyspark:CVE-2019-10172",
      "advisory": "A flaw was found in org.codehaus.jackson:jackson-mapper-asl:1.9.x libraries. XML external entity vulnerabilities similar CVE-2016-3720 also affects codehaus jackson-mapper-asl libraries but in different classes.",
      "cve": "CVE-2019-10172",
      "specs": [
        "==3.0.1"
      ]
    },
    {
      "id": "pyup.io-pyspark:CVE-2019-20445",
      "advisory": "HttpObjectDecoder.java in Netty before 4.1.44 allows a Content-Length header to be accompanied by a second Content-Length header, or by a Transfer-Encoding header.",
      "cve": "CVE-2019-20445",
      "specs": [
        "==2.4.7",
        "==2.4.8"
      ]
    },
    {
      "id": "pyup.io-pyspark:CVE-2020-27223",
      "advisory": "In Eclipse Jetty 9.4.6.v20170531 to 9.4.36.v20210114 (inclusive), 10.0.0, and 11.0.0 when Jetty handles a request containing multiple Accept headers with a large number of \u201cquality\u201d (i.e. q) parameters, the server may enter a denial of service (DoS) state due to high CPU usage processing those quality values, resulting in minutes of CPU time exhausted processing those quality values.",
      "cve": "CVE-2020-27223",
      "specs": [
        "==3.1.1"
      ]
    },
    {
      "id": "pyup.io-pyspark:CVE-2020-9480",
      "advisory": "In Apache Spark 2.4.5 and earlier, a standalone resource manager's master may be configured to require authentication (spark.authenticate) via a shared secret. When enabled, however, a specially-crafted RPC to the master can succeed in starting an application's resources on the Spark cluster, even without the shared key. This can be leveraged to execute shell commands on the host machine. This does not affect Spark clusters using other resource managers (YARN, Mesos, etc).",
      "cve": "CVE-2020-9480",
      "specs": [
        "<=2.4.5"
      ]
    }
  ],
  "python-bugzilla": [
    {
      "id": "pyup.io-python-bugzilla:CVE-2013-2191",
      "advisory": "python-bugzilla before 0.9.0 does not validate X.509 certificates, which allows man-in-the-middle attackers to spoof Bugzilla servers via a crafted certificate.",
      "cve": "CVE-2013-2191",
      "specs": [
        "<=0.8.0",
        "==0.6.0",
        "==0.6.1",
        "==0.6.2",
        "==0.7.0"
      ]
    }
  ],
  "python-cjson": [
    {
      "id": "pyup.io-python-cjson:CVE-2009-4924",
      "advisory": "Dan Pascu python-cjson 1.0.5 does not properly handle a ['/'] argument to cjson.encode, which makes it easier for remote attackers to conduct certain cross-site scripting (XSS) attacks involving Firefox and the end tag of a SCRIPT element.",
      "cve": "CVE-2009-4924",
      "specs": [
        "==1.0.5"
      ]
    },
    {
      "id": "pyup.io-python-cjson:CVE-2010-1666",
      "advisory": "Buffer overflow in Dan Pascu python-cjson 1.0.5, when UCS-4 encoding is enabled, allows context-dependent attackers to cause a denial of service (application crash) or possibly have unspecified other impact via vectors involving crafted Unicode input to the cjson.encode function.",
      "cve": "CVE-2010-1666",
      "specs": [
        "==1.0.5"
      ]
    }
  ],
  "python-dbusmock": [
    {
      "id": "pyup.io-python-dbusmock:CVE-2015-1326",
      "advisory": "python-dbusmock before version 0.15.1 AddTemplate() D-Bus method call or DBusTestCase.spawn_server_template() method could be tricked into executing malicious code if an attacker supplies a .pyc file.",
      "cve": "CVE-2015-1326",
      "specs": [
        "<0.15.1"
      ]
    }
  ],
  "python-engineio": [
    {
      "id": "pyup.io-python-engineio:CVE-2019-13611",
      "advisory": "An issue was discovered in python-engineio through 3.8.2. There is a Cross-Site WebSocket Hijacking (CSWSH) vulnerability that allows attackers to make WebSocket connections to a server by using a victim's credentials, because the Origin header is not restricted.",
      "cve": "CVE-2019-13611",
      "specs": [
        "<=3.8.2"
      ]
    }
  ],
  "python-fedora": [
    {
      "id": "pyup.io-python-fedora:CVE-2017-1002150",
      "advisory": "python-fedora 0.8.0 and lower is vulnerable to an open redirect resulting in loss of CSRF protection",
      "cve": "CVE-2017-1002150",
      "specs": [
        "<=0.8.0"
      ]
    }
  ],
  "python-gnupg": [
    {
      "id": "pyup.io-python-gnupg:CVE-2013-7323",
      "advisory": "python-gnupg before 0.3.5 allows context-dependent attackers to execute arbitrary commands via shell metacharacters in unspecified vectors.",
      "cve": "CVE-2013-7323",
      "specs": [
        "<=0.3.4",
        "==0.3.0",
        "==0.3.1",
        "==0.3.2",
        "==0.3.3"
      ]
    },
    {
      "id": "pyup.io-python-gnupg:CVE-2014-1927",
      "advisory": "The shell_quote function in python-gnupg 0.3.5 does not properly quote strings, which allows context-dependent attackers to execute arbitrary code via shell metacharacters in unspecified vectors, as demonstrated using \"$(\" command-substitution sequences, a different vulnerability than CVE-2014-1928.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2013-7323.",
      "cve": "CVE-2014-1927",
      "specs": [
        "==0.3.5"
      ]
    },
    {
      "id": "pyup.io-python-gnupg:CVE-2014-1928",
      "advisory": "The shell_quote function in python-gnupg 0.3.5 does not properly escape characters, which allows context-dependent attackers to execute arbitrary code via shell metacharacters in unspecified vectors, as demonstrated using \"\\\" (backslash) characters to form multi-command sequences, a different vulnerability than CVE-2014-1927.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2013-7323.",
      "cve": "CVE-2014-1928",
      "specs": [
        "<=0.3.5"
      ]
    },
    {
      "id": "pyup.io-python-gnupg:CVE-2014-1929",
      "advisory": "python-gnupg 0.3.5 and 0.3.6 allows context-dependent attackers to have an unspecified impact via vectors related to \"option injection through positional arguments.\" NOTE: this vulnerability exists because of an incomplete fix for CVE-2013-7323.",
      "cve": "CVE-2014-1929",
      "specs": [
        "==0.3.5",
        "==0.3.6"
      ]
    },
    {
      "id": "pyup.io-python-gnupg:CVE-2019-6690",
      "advisory": "python-gnupg 0.4.3 allows context-dependent attackers to trick gnupg to decrypt other ciphertext than intended. To perform the attack, the passphrase to gnupg must be controlled by the adversary and the ciphertext should be trusted. Related to a \"CWE-20: Improper Input Validation\" issue affecting the affect functionality component.",
      "cve": "CVE-2019-6690",
      "specs": [
        "==0.4.3"
      ]
    }
  ],
  "python-jose": [
    {
      "id": "pyup.io-python-jose:CVE-2016-7036",
      "advisory": "python-jose before 1.3.2 allows attackers to have unspecified impact by leveraging failure to use a constant time comparison for HMAC keys.",
      "cve": "CVE-2016-7036",
      "specs": [
        "<=1.3.1"
      ]
    }
  ],
  "python-keystoneclient": [
    {
      "id": "pyup.io-python-keystoneclient:CVE-2013-2013",
      "advisory": "The user-password-update command in python-keystoneclient before 0.2.4 accepts the new password in the --password argument, which allows local users to obtain sensitive information by listing the process.",
      "cve": "CVE-2013-2013",
      "specs": [
        "<=0.2.3",
        "==0.2.2"
      ]
    },
    {
      "id": "pyup.io-python-keystoneclient:CVE-2013-2104",
      "advisory": "python-keystoneclient before 0.2.4, as used in OpenStack Keystone (Folsom), does not properly check expiry for PKI tokens, which allows remote authenticated users to (1) retain use of a token after it has expired, or (2) use a revoked token once it expires.",
      "cve": "CVE-2013-2104",
      "specs": [
        "<=0.2.3",
        "==0.2.2"
      ]
    },
    {
      "id": "pyup.io-python-keystoneclient:CVE-2013-2166",
      "advisory": "python-keystoneclient version 0.2.3 to 0.2.5 has middleware memcache encryption bypass",
      "cve": "CVE-2013-2166",
      "specs": [
        ">=0.2.3,<=0.2.5"
      ]
    },
    {
      "id": "pyup.io-python-keystoneclient:CVE-2013-2167",
      "advisory": "python-keystoneclient version 0.2.3 to 0.2.5 has middleware memcache signing bypass",
      "cve": "CVE-2013-2167",
      "specs": [
        ">=0.2.3,<=0.2.5"
      ]
    },
    {
      "id": "pyup.io-python-keystoneclient:CVE-2014-0105",
      "advisory": "The auth_token middleware in the OpenStack Python client library for Keystone (aka python-keystoneclient) before 0.7.0 does not properly retrieve user tokens from memcache, which allows remote authenticated users to gain privileges in opportunistic circumstances via a large number of requests, related to an \"interaction between eventlet and python-memcached.\"",
      "cve": "CVE-2014-0105",
      "specs": [
        "<=0.4.2",
        "==0.2.2",
        "==0.2.3",
        "==0.2.4",
        "==0.3.0",
        "==0.3.1",
        "==0.3.2"
      ]
    },
    {
      "id": "pyup.io-python-keystoneclient:CVE-2014-7144",
      "advisory": "OpenStack keystonemiddleware (formerly python-keystoneclient) 0.x before 0.11.0 and 1.x before 1.2.0 disables certification verification when the \"insecure\" option is set in a paste configuration (paste.ini) file regardless of the value, which allows remote attackers to conduct man-in-the-middle attacks via a crafted certificate.",
      "cve": "CVE-2014-7144",
      "specs": [
        "<=0.10.1"
      ]
    },
    {
      "id": "pyup.io-python-keystoneclient:CVE-2015-1852",
      "advisory": "The s3_token middleware in OpenStack keystonemiddleware before 1.6.0 and python-keystoneclient before 1.4.0 disables certification verification when the \"insecure\" option is set in a paste configuration (paste.ini) file regardless of the value, which allows remote attackers to conduct man-in-the-middle attacks via a crafted certificate, a different vulnerability than CVE-2014-7144.",
      "cve": "CVE-2015-1852",
      "specs": [
        "<=1.3.0"
      ]
    }
  ],
  "python-libnmap": [
    {
      "id": "pyup.io-python-libnmap:CVE-2019-1010017",
      "advisory": "libnmap < v0.6.3 is affected by: XML Injection. The impact is: Denial of service (DoS) by consuming resources. The component is: XML Parsing. The attack vector is: Specially crafted XML payload.",
      "cve": "CVE-2019-1010017",
      "specs": [
        "<0.6.3"
      ]
    }
  ],
  "python-muranoclient": [
    {
      "id": "pyup.io-python-muranoclient:CVE-2016-4972",
      "advisory": "OpenStack Murano before 1.0.3 (liberty) and 2.x before 2.0.1 (mitaka), Murano-dashboard before 1.0.3 (liberty) and 2.x before 2.0.1 (mitaka), and python-muranoclient before 0.7.3 (liberty) and 0.8.x before 0.8.5 (mitaka) improperly use loaders inherited from yaml.Loader when parsing MuranoPL and UI files, which allows remote attackers to create arbitrary Python objects and execute arbitrary code via crafted extended YAML tags in UI definitions in packages.",
      "cve": "CVE-2016-4972",
      "specs": [
        "<=0.7.2"
      ]
    }
  ],
  "python-saml": [
    {
      "id": "pyup.io-python-saml:CVE-2017-11427",
      "advisory": "OneLogin PythonSAML 2.3.0 and earlier may incorrectly utilize the results of XML DOM traversal and canonicalization APIs in such a way that an attacker may be able to manipulate the SAML data without invalidating the cryptographic signature, allowing the attack to potentially bypass authentication to SAML service providers.",
      "cve": "CVE-2017-11427",
      "specs": [
        "<=2.3.0"
      ]
    }
  ],
  "python-swiftclient": [
    {
      "id": "pyup.io-python-swiftclient:CVE-2012-4406",
      "advisory": "OpenStack Object Storage (swift) before 1.7.0 uses the loads function in the pickle Python module unsafely when storing and loading metadata in memcached, which allows remote attackers to execute arbitrary code via a crafted pickle object.",
      "cve": "CVE-2012-4406",
      "specs": [
        "<=1.6.0",
        "==1.0.0",
        "==1.0.1",
        "==1.0.2",
        "==1.1.0",
        "==1.1.0-rc1",
        "==1.1.0-rc2",
        "==1.2.0",
        "==1.2.0-gamma1",
        "==1.2.0-rc1",
        "==1.3.0",
        "==1.3.0-gamma1",
        "==1.3.0-rc1",
        "==1.4.0",
        "==1.4.1",
        "==1.4.2",
        "==1.4.3",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8",
        "==1.5.0"
      ]
    },
    {
      "id": "pyup.io-python-swiftclient:CVE-2013-4155",
      "advisory": "OpenStack Swift before 1.9.1 in Folsom, Grizzly, and Havana allows authenticated users to cause a denial of service (\"superfluous\" tombstone consumption and Swift cluster slowdown) via a DELETE request with a timestamp that is older than expected.",
      "cve": "CVE-2013-4155",
      "specs": [
        "<=1.9.0",
        "==1.0.0",
        "==1.0.1",
        "==1.0.2",
        "==1.1.0",
        "==1.1.0-rc1",
        "==1.1.0-rc2",
        "==1.2.0",
        "==1.2.0-gamma1",
        "==1.2.0-rc1",
        "==1.3.0",
        "==1.3.0-gamma1",
        "==1.3.0-rc1",
        "==1.4.0",
        "==1.4.1",
        "==1.4.2",
        "==1.4.3",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8",
        "==1.5.0",
        "==1.6.0",
        "==1.7.0",
        "==1.7.2",
        "==1.7.4",
        "==1.7.5",
        "==1.7.6",
        "==1.8.0",
        "==1.8.0-rc1",
        "==1.8.0-rc2"
      ]
    },
    {
      "id": "pyup.io-python-swiftclient:CVE-2013-6396",
      "advisory": "The OpenStack Python client library for Swift (python-swiftclient) 1.0 through 1.9.0 does not verify X.509 certificates from SSL servers, which allows man-in-the-middle attackers to spoof servers and obtain sensitive information via a crafted certificate.",
      "cve": "CVE-2013-6396",
      "specs": [
        "==1.0.0",
        "==1.0.1",
        "==1.0.2",
        "==1.1.0",
        "==1.1.0-rc1",
        "==1.1.0-rc2",
        "==1.10.0",
        "==1.11.0",
        "==1.2.0",
        "==1.2.0-gamma1",
        "==1.2.0-rc1",
        "==1.3.0",
        "==1.3.0-gamma1",
        "==1.3.0-rc1",
        "==1.4.0",
        "==1.4.1",
        "==1.4.2",
        "==1.4.3",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8",
        "==1.5.0",
        "==1.6.0",
        "==1.7.0",
        "==1.7.2",
        "==1.7.4",
        "==1.7.5",
        "==1.7.6",
        "==1.8.0",
        "==1.8.0-rc1",
        "==1.8.0-rc2",
        "==1.9.0"
      ]
    },
    {
      "id": "pyup.io-python-swiftclient:CVE-2013-7109",
      "advisory": "OpenStack Swift as of 2013-12-15 mishandles PYTHON_EGG_CACHE",
      "cve": "CVE-2013-7109",
      "specs": [
        "<=2013-12-15"
      ]
    },
    {
      "id": "pyup.io-python-swiftclient:CVE-2014-0006",
      "advisory": "The TempURL middleware in OpenStack Object Storage (Swift) 1.4.6 through 1.8.0, 1.9.0 through 1.10.0, and 1.11.0 allows remote attackers to obtain secret URLs by leveraging an object name and a timing side-channel attack.",
      "cve": "CVE-2014-0006",
      "specs": [
        "==1.10.0",
        "==1.11.0",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8",
        "==1.5.0",
        "==1.6.0",
        "==1.7.0",
        "==1.7.2",
        "==1.7.4",
        "==1.7.5",
        "==1.7.6",
        "==1.8.0",
        "==1.9.0",
        "==1.9.1",
        "==1.9.2"
      ]
    },
    {
      "id": "pyup.io-python-swiftclient:CVE-2014-3497",
      "advisory": "Cross-site scripting (XSS) vulnerability in OpenStack Swift 1.11.0 through 1.13.1 allows remote attackers to inject arbitrary web script or HTML via the WWW-Authenticate header.",
      "cve": "CVE-2014-3497",
      "specs": [
        "==1.11.0",
        "==1.12.0",
        "==1.13.0",
        "==1.13.1",
        "==1.13.1-rc1",
        "==1.13.1-rc2"
      ]
    },
    {
      "id": "pyup.io-python-swiftclient:CVE-2014-7960",
      "advisory": "OpenStack Object Storage (Swift) before 2.2.0 allows remote authenticated users to bypass the max_meta_count and other metadata constraints via multiple crafted requests which exceed the limit when combined.",
      "cve": "CVE-2014-7960",
      "specs": [
        "<=2.1.0"
      ]
    },
    {
      "id": "pyup.io-python-swiftclient:CVE-2015-1856",
      "advisory": "OpenStack Object Storage (Swift) before 2.3.0, when allow_version is configured, allows remote authenticated users to delete the latest version of an object by leveraging listing access to the x-versions-location container.",
      "cve": "CVE-2015-1856",
      "specs": [
        "<=2.2.2"
      ]
    },
    {
      "id": "pyup.io-python-swiftclient:CVE-2015-5223",
      "advisory": "OpenStack Object Storage (Swift) before 2.4.0 allows attackers to obtain sensitive information via a PUT tempurl and a DLO object manifest that references an object in another container.",
      "cve": "CVE-2015-5223",
      "specs": [
        "<=2.3.0"
      ]
    },
    {
      "id": "pyup.io-python-swiftclient:CVE-2016-0737",
      "advisory": "OpenStack Object Storage (Swift) before 2.4.0 does not properly close client connections, which allows remote attackers to cause a denial of service (proxy-server resource consumption) via a series of interrupted requests to a Large Object URL.",
      "cve": "CVE-2016-0737",
      "specs": [
        "<=2.3.0"
      ]
    },
    {
      "id": "pyup.io-python-swiftclient:CVE-2016-0738",
      "advisory": "OpenStack Object Storage (Swift) before 2.3.1 (Kilo), 2.4.x, and 2.5.x before 2.5.1 (Liberty) do not properly close server connections, which allows remote attackers to cause a denial of service (proxy-server resource consumption) via a series of interrupted requests to a Large Object URL.",
      "cve": "CVE-2016-0738",
      "specs": [
        "<=2.3.0",
        "==2.4.0",
        "==2.5.0"
      ]
    },
    {
      "id": "pyup.io-python-swiftclient:CVE-2017-16613",
      "advisory": "An issue was discovered in middleware.py in OpenStack Swauth through 1.2.0 when used with OpenStack Swift through 2.15.1. The Swift object store and proxy server are saving (unhashed) tokens retrieved from the Swauth middleware authentication mechanism to a log file as part of a GET URI. This allows attackers to bypass authentication by inserting a token into an X-Auth-Token header of a new request. NOTE: github.com/openstack/swauth URLs do not mean that Swauth is maintained by an official OpenStack project team.",
      "cve": "CVE-2017-16613",
      "specs": [
        "<=2.15.1"
      ]
    },
    {
      "id": "pyup.io-python-swiftclient:CVE-2017-8761",
      "advisory": "In OpenStack Swift through 2.10.1, 2.11.0 through 2.13.0, and 2.14.0, the proxy-server logs full tempurl paths, potentially leaking reusable tempurl signatures to anyone with read access to these logs. All Swift deployments using the tempurl middleware are affected.",
      "cve": "CVE-2017-8761",
      "specs": [
        "<=2.10.1",
        "==2.14.0",
        ">=2.11.0,<=2.13.0"
      ]
    }
  ],
  "python3-saml": [
    {
      "id": "pyup.io-python3-saml:CVE-2017-11427",
      "advisory": "OneLogin PythonSAML 2.3.0 and earlier may incorrectly utilize the results of XML DOM traversal and canonicalization APIs in such a way that an attacker may be able to manipulate the SAML data without invalidating the cryptographic signature, allowing the attack to potentially bypass authentication to SAML service providers.",
      "cve": "CVE-2017-11427",
      "specs": [
        "<=2.3.0"
      ]
    }
  ],
  "pywb": [
    {
      "id": "pyup.io-pywb:CVE-2021-39286",
      "advisory": "Webrecorder pywb before 2.6.0 allows XSS because it does not ensure that Jinja2 templates are autoescaped.",
      "cve": "CVE-2021-39286",
      "specs": [
        "<2.6.0"
      ]
    }
  ],
  "pywbem": [
    {
      "id": "pyup.io-pywbem:CVE-2013-6418",
      "advisory": "PyWBEM 0.7 and earlier uses a separate connection to validate X.509 certificates, which allows man-in-the-middle attackers to spoof a peer via an arbitrary certificate.",
      "cve": "CVE-2013-6418",
      "specs": [
        "<=0.7"
      ]
    },
    {
      "id": "pyup.io-pywbem:CVE-2013-6444",
      "advisory": "PyWBEM 0.7 and earlier does not verify that the server hostname matches a domain name in the subject's Common Name (CN) or subjectAltName field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
      "cve": "CVE-2013-6444",
      "specs": [
        "<=0.7"
      ]
    }
  ],
  "pywin32": [
    {
      "id": "pyup.io-pywin32:CVE-2021-32559",
      "advisory": "An integer overflow exists in pywin32 prior to version b301 when adding an access control entry (ACE) to an access control list (ACL) that would cause the size to be greater than 65535 bytes. An attacker who successfully exploited this vulnerability could crash the vulnerable process.",
      "cve": "CVE-2021-32559",
      "specs": [
        "<b301"
      ]
    }
  ],
  "pywps": [
    {
      "id": "pyup.io-pywps:CVE-2021-39371",
      "advisory": "An XML external entity (XXE) injection in PyWPS before 4.4.5 allows an attacker to view files on the application server filesystem by assigning a path to the entity. OWSLib 0.24.1 may also be affected.",
      "cve": "CVE-2021-39371",
      "specs": [
        "<4.4.5",
        "==0.24.1"
      ]
    }
  ],
  "pyxdg": [
    {
      "id": "pyup.io-pyxdg:CVE-2014-1624",
      "advisory": "Race condition in the xdg.BaseDirectory.get_runtime_dir function in python-xdg 0.25 allows local users to overwrite arbitrary files by pre-creating /tmp/pyxdg-runtime-dir-fallback-victim to point to a victim-owned location, then replacing it with a symlink to an attacker-controlled location once the get_runtime_dir function is called.",
      "cve": "CVE-2014-1624",
      "specs": [
        "==0.25"
      ]
    },
    {
      "id": "pyup.io-pyxdg:CVE-2019-12761",
      "advisory": "A code injection issue was discovered in PyXDG before 0.26 via crafted Python code in a Category element of a Menu XML document in a .menu file. XDG_CONFIG_DIRS must be set up to trigger xdg.Menu.parse parsing within the directory containing this file. This is due to a lack of sanitization in xdg/Menu.py before an eval call.",
      "cve": "CVE-2019-12761",
      "specs": [
        "<0.26"
      ]
    }
  ],
  "pyyaml": [
    {
      "id": "pyup.io-pyyaml:CVE-2017-18342",
      "advisory": "In PyYAML before 5.1, the yaml.load() API could execute arbitrary code if used with untrusted data. The load() function has been deprecated in version 5.1 and the 'UnsafeLoader' has been introduced for backward compatibility with the function.",
      "cve": "CVE-2017-18342",
      "specs": [
        "<5.1"
      ]
    },
    {
      "id": "pyup.io-pyyaml:CVE-2019-20477",
      "advisory": "PyYAML 5.1 through 5.1.2 has insufficient restrictions on the load and load_all functions because of a class deserialization issue, e.g., Popen is a class in the subprocess module. NOTE: this issue exists because of an incomplete fix for CVE-2017-18342.",
      "cve": "CVE-2019-20477",
      "specs": [
        ">=5.1,<=5.1.2"
      ]
    },
    {
      "id": "pyup.io-pyyaml:CVE-2020-14343",
      "advisory": "A vulnerability was discovered in the PyYAML library in versions before 5.4, where it is susceptible to arbitrary code execution when it processes untrusted YAML files through the full_load method or with the FullLoader loader. Applications that use the library to process untrusted input may be vulnerable to this flaw. This flaw allows an attacker to execute arbitrary code on the system by abusing the python/object/new constructor. This flaw is due to an incomplete fix for CVE-2020-1747.",
      "cve": "CVE-2020-14343",
      "specs": [
        ">=5.1,<5.4"
      ]
    },
    {
      "id": "pyup.io-pyyaml:CVE-2020-1747",
      "advisory": "A vulnerability was discovered in the PyYAML library in versions before 5.3.1, where it is susceptible to arbitrary code execution when it processes untrusted YAML files through the full_load method or with the FullLoader loader. Applications that use the library to process untrusted input may be vulnerable to this flaw. An attacker could use this flaw to execute arbitrary code on the system by abusing the python/object/new constructor.",
      "cve": "CVE-2020-1747",
      "specs": [
        ">=5.1,<5.3.1"
      ]
    }
  ],
  "quokka": [
    {
      "id": "pyup.io-quokka:CVE-2020-18702",
      "advisory": "Cross Site Scripting (XSS) in Quokka v0.4.0 allows remote attackers to execute arbitrary code via the 'Username' parameter in the component 'quokka/admin/actions.py'.",
      "cve": "CVE-2020-18702",
      "specs": [
        "==0.4.0"
      ]
    },
    {
      "id": "pyup.io-quokka:CVE-2020-18703",
      "advisory": "XML External Entities (XXE) in Quokka v0.4.0 allows remote attackers to execute arbitrary code via the component 'quokka/utils/atom.py'.",
      "cve": "CVE-2020-18703",
      "specs": [
        "==0.4.0"
      ]
    },
    {
      "id": "pyup.io-quokka:CVE-2020-18705",
      "advisory": "XML External Entities (XXE) in Quokka v0.4.0 allows remote attackers to execute arbitrary code via the component 'quokka/core/content/views.py'.",
      "cve": "CVE-2020-18705",
      "specs": [
        "==0.4.0"
      ]
    }
  ],
  "qutebrowser": [
    {
      "id": "pyup.io-qutebrowser:CVE-2018-1000559",
      "advisory": "qutebrowser version introduced in v0.11.0 (1179ee7a937fb31414d77d9970bac21095358449) contains a Cross Site Scripting (XSS) vulnerability in history command, qute://history page that can result in Via injected JavaScript code, a website can steal the user's browsing history. This attack appear to be exploitable via the victim must open a page with a specially crafted <title> attribute, and then open the qute://history site via the :history command. This vulnerability appears to have been fixed in fixed in v1.3.3 (4c9360237f186681b1e3f2a0f30c45161cf405c7, to be released today) and v1.4.0 (5a7869f2feaa346853d2a85413d6527c87ef0d9f, released later this week).",
      "cve": "CVE-2018-1000559",
      "specs": [
        ">=0.11.0,<1.3.3"
      ]
    },
    {
      "id": "pyup.io-qutebrowser:CVE-2018-10895",
      "advisory": "qutebrowser before version 1.4.1 is vulnerable to a cross-site request forgery flaw that allows websites to access 'qute://*' URLs. A malicious website could exploit this to load a 'qute://settings/set' URL, which then sets 'editor.command' to a bash script, resulting in arbitrary code execution.",
      "cve": "CVE-2018-10895",
      "specs": [
        "<1.4.1"
      ]
    },
    {
      "id": "pyup.io-qutebrowser:CVE-2020-11054",
      "advisory": "In qutebrowser versions less than 1.11.1, reloading a page with certificate errors shows a green URL. After a certificate error was overridden by the user, qutebrowser displays the URL as yellow (colors.statusbar.url.warn.fg). However, when the affected website was subsequently loaded again, the URL was mistakenly displayed as green (colors.statusbar.url.success_https). While the user already has seen a certificate error prompt at this point (or set content.ssl_strict to false, which is not recommended), this could still provide a false sense of security. This has been fixed in 1.11.1 and 1.12.0. All versions of qutebrowser are believed to be affected, though versions before v0.11.x couldn't be tested. Backported patches for older versions (greater than or equal to 1.4.0 and less than or equal to 1.10.2) are available, but no further releases are planned.",
      "cve": "CVE-2020-11054",
      "specs": [
        "<1.11.0"
      ]
    },
    {
      "id": "pyup.io-qutebrowser:CVE-2021-41146",
      "advisory": "qutebrowser is an open source keyboard-focused browser with a minimal GUI. Starting with qutebrowser v1.7.0, the Windows installer for qutebrowser registers a `qutebrowserurl:` URL handler. With certain applications, opening a specially crafted `qutebrowserurl:...` URL can lead to execution of qutebrowser commands, which in turn allows arbitrary code execution via commands such as `:spawn` or `:debug-pyeval`. Only Windows installs where qutebrowser is registered as URL handler are affected. The issue has been fixed in qutebrowser v2.4.0. The fix also adds additional hardening for potential similar issues on Linux (by adding the new --untrusted-args flag to the .desktop file), though no such vulnerabilities are known.",
      "cve": "CVE-2021-41146",
      "specs": [
        "<=1.7.0",
        ">=2.0.0,<2.4.0"
      ]
    }
  ],
  "rasa": [
    {
      "id": "pyup.io-rasa:CVE-2021-41127",
      "advisory": "Rasa is an open source machine learning framework to automate text-and voice-based conversations. In affected versions a vulnerability exists in the functionality that loads a trained model `tar.gz` file which allows a malicious actor to craft a `model.tar.gz` file which can overwrite or replace bot files in the bot directory. The vulnerability is fixed in Rasa 2.8.10. For users unable to update ensure that users do not upload untrusted model files, and restrict CLI or API endpoint access where a malicious actor could target a deployed Rasa instance.",
      "cve": "CVE-2021-41127",
      "specs": [
        "<2.8.10"
      ]
    }
  ],
  "recommender-xblock": [
    {
      "id": "pyup.io-recommender-xblock:CVE-2018-20858",
      "advisory": "Recommender before 2018-07-18 allows XSS.",
      "cve": "CVE-2018-20858",
      "specs": [
        "<1.3.1"
      ]
    }
  ],
  "recurly": [
    {
      "id": "pyup.io-recurly:CVE-2017-0906",
      "advisory": "The Recurly Client Python Library before 2.0.5, 2.1.16, 2.2.22, 2.3.1, 2.4.5, 2.5.1, 2.6.2 is vulnerable to a Server-Side Request Forgery vulnerability in the \"Resource.get\" method that could result in compromise of API keys or other critical resources.",
      "cve": "CVE-2017-0906",
      "specs": [
        "==2.3.0",
        "==2.5.0",
        "==2.6.0",
        "==2.6.1",
        ">=2.0.0,<=2.0.4",
        ">=2.1.0,<=2.1.15",
        ">=2.2.0,<=2.2.21",
        ">=2.4.0,<=2.4.4"
      ]
    }
  ],
  "red-dashboard": [
    {
      "id": "pyup.io-red-dashboard:CVE-2020-26249",
      "advisory": "Red Discord Bot Dashboard is an easy-to-use interactive web dashboard to control your Redbot. In Red Discord Bot before version 0.1.7a an RCE exploit has been discovered. This exploit allows Discord users with specially crafted Server names and Usernames/Nicknames to inject code into the webserver front-end code. By abusing this exploit, it's possible to perform destructive actions and/or access sensitive information. This high severity exploit has been fixed on version 0.1.7a. There are no workarounds, bot owners must upgrade their relevant packages (Dashboard module and Dashboard webserver) in order to patch this issue.",
      "cve": "CVE-2020-26249",
      "specs": [
        "==0.1.2-alpha0",
        "==0.1.3-alpha0",
        "==0.1.4-alpha0",
        "==0.1.5-alpha0",
        "==0.1.6-alpha0"
      ]
    }
  ],
  "red-discordbot": [
    {
      "id": "pyup.io-red-discordbot:CVE-2020-15140",
      "advisory": "In Red Discord Bot before version 3.3.11, a RCE exploit has been discovered in the Trivia module: this exploit allows Discord users with specifically crafted usernames to inject code into the Trivia module's leaderboard command. By abusing this exploit, it's possible to perform destructive actions and/or access sensitive information. This critical exploit has been fixed on version 3.3.11.",
      "cve": "CVE-2020-15140",
      "specs": [
        "<3.3.11"
      ]
    },
    {
      "id": "pyup.io-red-discordbot:CVE-2020-15147",
      "advisory": "Red Discord Bot before versions 3.3.12 and 3.4 has a Remote Code Execution vulnerability in the Streams module. This exploit allows Discord users with specifically crafted \"going live\" messages to inject code into the Streams module's going live message. By abusing this exploit, it's possible to perform destructive actions and/or access sensitive information. As a workaround, unloading the Trivia module with `unload streams` can render this exploit not accessible. It is highly recommended updating to 3.3.12 or 3.4 to completely patch this issue.",
      "cve": "CVE-2020-15147",
      "specs": [
        "<=3.3.11"
      ]
    },
    {
      "id": "pyup.io-red-discordbot:CVE-2020-15278",
      "advisory": "Red Discord Bot before version 3.4.1 has an unauthorized privilege escalation exploit in the Mod module. This exploit allows Discord users with a high privilege level within the guild to bypass hierarchy checks when the application is in a specific condition that is beyond that user's control. By abusing this exploit, it is possible to perform destructive actions within the guild the user has high privileges in. This exploit has been fixed in version 3.4.1. As a workaround, unloading the Mod module with unload mod or, disabling the massban command with command disable global massban can render this exploit not accessible. We still highly recommend updating to 3.4.1 to completely patch this issue.",
      "cve": "CVE-2020-15278",
      "specs": [
        "<3.4.1"
      ]
    }
  ],
  "rediswrapper": [
    {
      "id": "pyup.io-rediswrapper:CVE-2019-17206",
      "advisory": "Uncontrolled deserialization of a pickled object in models.py in Frost Ming rediswrapper (aka Redis Wrapper) before 0.3.0 allows attackers to execute arbitrary scripts.",
      "cve": "CVE-2019-17206",
      "specs": [
        "<0.3.0"
      ]
    }
  ],
  "rencode": [
    {
      "id": "pyup.io-rencode:CVE-2021-40839",
      "advisory": "The rencode package through 1.0.6 for Python allows an infinite loop in typecode decoding (such as via ;\\x2f\\x7f), enabling a remote attack that consumes CPU and memory.",
      "cve": "CVE-2021-40839",
      "specs": [
        "<=1.0.6"
      ]
    }
  ],
  "reportlab": [
    {
      "id": "pyup.io-reportlab:CVE-2019-17626",
      "advisory": "ReportLab through 3.5.26 allows remote code execution because of toColor(eval(arg)) in colors.py, as demonstrated by a crafted XML document with '<span color=\"' followed by arbitrary Python code.",
      "cve": "CVE-2019-17626",
      "specs": [
        "<=3.5.26"
      ]
    }
  ],
  "requests": [
    {
      "id": "pyup.io-requests:CVE-2014-1829",
      "advisory": "Requests (aka python-requests) before 2.3.0 allows remote servers to obtain a netrc password by reading the Authorization header in a redirected request.",
      "cve": "CVE-2014-1829",
      "specs": [
        "<=2.2.1"
      ]
    },
    {
      "id": "pyup.io-requests:CVE-2014-1830",
      "advisory": "Requests (aka python-requests) before 2.3.0 allows remote servers to obtain sensitive information by reading the Proxy-Authorization header in a redirected request.",
      "cve": "CVE-2014-1830",
      "specs": [
        "<=2.2.1"
      ]
    },
    {
      "id": "pyup.io-requests:CVE-2015-2296",
      "advisory": "The resolve_redirects function in sessions.py in requests 2.1.0 through 2.5.3 allows remote attackers to conduct session fixation attacks via a cookie without a host value in a redirect.",
      "cve": "CVE-2015-2296",
      "specs": [
        "==2.1.0",
        "==2.2.1",
        "==2.3.0",
        "==2.4.0",
        "==2.4.1",
        "==2.4.2",
        "==2.4.3",
        "==2.5.0",
        "==2.5.1",
        "==2.5.2",
        "==2.5.3"
      ]
    },
    {
      "id": "pyup.io-requests:CVE-2018-18074",
      "advisory": "The Requests package before 2.20.0 for Python sends an HTTP Authorization header to an http URI upon receiving a same-hostname https-to-http redirect, which makes it easier for remote attackers to discover credentials by sniffing the network.",
      "cve": "CVE-2018-18074",
      "specs": [
        "<2.20.0"
      ]
    }
  ],
  "requests-kerberos": [
    {
      "id": "pyup.io-requests-kerberos:CVE-2014-8650",
      "advisory": "python-requests-Kerberos through 0.5 does not handle mutual authentication",
      "cve": "CVE-2014-8650",
      "specs": [
        "<=0.5"
      ]
    }
  ],
  "reviewboard": [
    {
      "id": "pyup.io-reviewboard:CVE-2011-4312",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in the commenting system in Review Board before 1.5.7 and 1.6.x before 1.6.3 allow remote attackers to inject arbitrary web script or HTML via vectors involving the (1) diff viewer or (2) screenshot component.",
      "cve": "CVE-2011-4312",
      "specs": [
        "<=1.5.6",
        "==1.0",
        "==1.0-alpha1",
        "==1.0-alpha2",
        "==1.0-alpha3",
        "==1.0-alpha4",
        "==1.0-beta1",
        "==1.0-beta2",
        "==1.0-rc1",
        "==1.0-rc2",
        "==1.0-rc3",
        "==1.0.1",
        "==1.0.2",
        "==1.0.3",
        "==1.0.4",
        "==1.0.5",
        "==1.0.5.1",
        "==1.0.6",
        "==1.0.7",
        "==1.0.8",
        "==1.0.9",
        "==1.1-alpha1",
        "==1.1-alpha2",
        "==1.5",
        "==1.5-beta1",
        "==1.5-beta2",
        "==1.5-rc1",
        "==1.5-rc2",
        "==1.5.1",
        "==1.5.2",
        "==1.5.3",
        "==1.5.4",
        "==1.5.5",
        "==1.6",
        "==1.6-beta1",
        "==1.6-beta2",
        "==1.6-rc1",
        "==1.6-rc2",
        "==1.6.1",
        "==1.6.2"
      ]
    },
    {
      "id": "pyup.io-reviewboard:CVE-2013-2209",
      "advisory": "Cross-site scripting (XSS) vulnerability in the auto-complete widget in htdocs/media/rb/js/reviews.js in Review Board 1.6.x before 1.6.17 and 1.7.x before 1.7.10 allows remote attackers to inject arbitrary web script or HTML via a full name.",
      "cve": "CVE-2013-2209",
      "specs": [
        "==1.6",
        "==1.6-beta1",
        "==1.6-beta2",
        "==1.6-rc1",
        "==1.6-rc2",
        "==1.6.1",
        "==1.6.10",
        "==1.6.11",
        "==1.6.12",
        "==1.6.13",
        "==1.6.14",
        "==1.6.15",
        "==1.6.16",
        "==1.6.2",
        "==1.6.3",
        "==1.6.4",
        "==1.6.5",
        "==1.6.6",
        "==1.6.7",
        "==1.6.8",
        "==1.6.9",
        "==1.7.0",
        "==1.7.0.1",
        "==1.7.1",
        "==1.7.2",
        "==1.7.3",
        "==1.7.4",
        "==1.7.5",
        "==1.7.6",
        "==1.7.7",
        "==1.7.8",
        "==1.7.9"
      ]
    },
    {
      "id": "pyup.io-reviewboard:CVE-2013-4409",
      "advisory": "An eval() vulnerability exists in Python Software Foundation Djblets 0.7.21 and Beanbag Review Board before 1.7.15 when parsing JSON requests.",
      "cve": "CVE-2013-4409",
      "specs": [
        "<1.7.15"
      ]
    },
    {
      "id": "pyup.io-reviewboard:CVE-2013-4410",
      "advisory": "ReviewBoard: has an access-control problem in REST API",
      "cve": "CVE-2013-4410",
      "specs": [
        ">=1.6,<1.6.19",
        ">=1.7,<1.7.15"
      ]
    },
    {
      "id": "pyup.io-reviewboard:CVE-2013-4411",
      "advisory": "Review Board: URL processing gives unauthorized users access to review lists",
      "cve": "CVE-2013-4411",
      "specs": [
        ">=1.6,<1.6.19",
        ">=1.7,<1.7.15"
      ]
    },
    {
      "id": "pyup.io-reviewboard:CVE-2013-4519",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in Review Board 1.6.x before 1.6.21 and 1.7.x before 1.7.17 allow remote attackers to inject arbitrary web script or HTML via the (1) Branch field or (2) caption of an uploaded file.",
      "cve": "CVE-2013-4519",
      "specs": [
        "==1.6",
        "==1.6-beta1",
        "==1.6-beta2",
        "==1.6-rc1",
        "==1.6-rc2",
        "==1.6.1",
        "==1.6.10",
        "==1.6.11",
        "==1.6.12",
        "==1.6.13",
        "==1.6.14",
        "==1.6.15",
        "==1.6.16",
        "==1.6.17",
        "==1.6.18",
        "==1.6.19",
        "==1.6.2",
        "==1.6.20",
        "==1.6.3",
        "==1.6.4",
        "==1.6.5",
        "==1.6.6",
        "==1.6.7",
        "==1.6.8",
        "==1.6.9",
        "==1.7.0",
        "==1.7.0.1",
        "==1.7.1",
        "==1.7.10",
        "==1.7.11",
        "==1.7.12",
        "==1.7.13",
        "==1.7.14",
        "==1.7.15",
        "==1.7.16",
        "==1.7.2",
        "==1.7.3",
        "==1.7.4",
        "==1.7.5",
        "==1.7.6",
        "==1.7.7",
        "==1.7.8",
        "==1.7.9"
      ]
    },
    {
      "id": "pyup.io-reviewboard:CVE-2013-4795",
      "advisory": "Cross-site scripting (XSS) vulnerability in the Submitters list in Review Board 1.6.x before 1.6.18 and 1.7.x before 1.7.12 allows remote attackers to inject arbitrary web script or HTML via a user full name.",
      "cve": "CVE-2013-4795",
      "specs": [
        "==1.6",
        "==1.6-beta1",
        "==1.6-beta2",
        "==1.6-rc1",
        "==1.6-rc2",
        "==1.6.1",
        "==1.6.10",
        "==1.6.11",
        "==1.6.12",
        "==1.6.13",
        "==1.6.14",
        "==1.6.15",
        "==1.6.16",
        "==1.6.17",
        "==1.6.2",
        "==1.6.3",
        "==1.7.0",
        "==1.7.0.1",
        "==1.7.1",
        "==1.7.10",
        "==1.7.11",
        "==1.7.2",
        "==1.7.3",
        "==1.7.4",
        "==1.7.5",
        "==1.7.6",
        "==1.7.7",
        "==1.7.8",
        "==1.7.9"
      ]
    },
    {
      "id": "pyup.io-reviewboard:CVE-2013-4796",
      "advisory": "ReviewBoard 1.6.17 allows code execution by attaching PHP scripts to review request",
      "cve": "CVE-2013-4796",
      "specs": [
        "==1.6.17"
      ]
    },
    {
      "id": "pyup.io-reviewboard:CVE-2014-5027",
      "advisory": "Cross-site scripting (XSS) vulnerability in Review Board 1.7.x before 1.7.27 and 2.0.x before 2.0.4 allows remote attackers to inject arbitrary web script or HTML via a query parameter to a diff fragment page.",
      "cve": "CVE-2014-5027",
      "specs": [
        "==1.7.0",
        "==1.7.0.1",
        "==1.7.1",
        "==1.7.10",
        "==1.7.11",
        "==1.7.12",
        "==1.7.13",
        "==1.7.14",
        "==1.7.15",
        "==1.7.16",
        "==1.7.17",
        "==1.7.18",
        "==1.7.19",
        "==1.7.2",
        "==1.7.20",
        "==1.7.21",
        "==1.7.22",
        "==1.7.23",
        "==1.7.24",
        "==1.7.25",
        "==1.7.26",
        "==1.7.3",
        "==1.7.4",
        "==1.7.5",
        "==1.7.6",
        "==1.7.7",
        "==1.7.8",
        "==1.7.9",
        "==2.0",
        "==2.0-beta1",
        "==2.0-beta2",
        "==2.0-beta3",
        "==2.0-rc1",
        "==2.0-rc2",
        "==2.0-rc3",
        "==2.0.1",
        "==2.0.2",
        "==2.0.3"
      ]
    },
    {
      "id": "pyup.io-reviewboard:CVE-2014-5028",
      "advisory": "The Original File and Patched File resources in Review Board 1.7.x before 1.7.27 and 2.0.x before 2.0.4 allow remote authenticated users to bypass intended access restrictions and obtain sensitive information from repository files by leveraging knowledge of database ids.",
      "cve": "CVE-2014-5028",
      "specs": [
        ">1.7.0,<1.7.27",
        ">=2.0,<2.0.4"
      ]
    }
  ],
  "rope": [
    {
      "id": "pyup.io-rope:CVE-2014-3539",
      "advisory": "base/oi/doa.py in the Rope library in CPython (aka Python) allows remote attackers to execute arbitrary code by leveraging an unsafe call to pickle.load.",
      "cve": "CVE-2014-3539",
      "specs": [
        "<0.11.0"
      ]
    }
  ],
  "roundup": [
    {
      "id": "pyup.io-roundup:CVE-2004-1444",
      "advisory": "Directory traversal vulnerability in Roundup 0.6.4 and earlier allows remote attackers to view arbitrary files via .. (dot dot) sequences in an @@ command in an HTTP GET request.",
      "cve": "CVE-2004-1444",
      "specs": [
        "<=0.6.4",
        "==0.1.0",
        "==0.1.1",
        "==0.1.2",
        "==0.1.3",
        "==0.2.0",
        "==0.2.1",
        "==0.2.2",
        "==0.2.3",
        "==0.2.4",
        "==0.2.5",
        "==0.2.6",
        "==0.2.7",
        "==0.2.8",
        "==0.3.0",
        "==0.3.0-pre1",
        "==0.3.0-pre2",
        "==0.3.0-pre3",
        "==0.4.0",
        "==0.4.0-b1",
        "==0.4.0-b2",
        "==0.4.1",
        "==0.4.2",
        "==0.4.2-pr1",
        "==0.5",
        "==0.5.0",
        "==0.5.0-beta1",
        "==0.5.0-beta2",
        "==0.5.0-pr1",
        "==0.5.1",
        "==0.5.2",
        "==0.5.3",
        "==0.5.4",
        "==0.5.5",
        "==0.5.6",
        "==0.5.7",
        "==0.5.8-stable",
        "==0.5.9",
        "==0.6.0",
        "==0.6.0-b1",
        "==0.6.0-b2",
        "==0.6.0-b3",
        "==0.6.0-b4",
        "==0.6.1",
        "==0.6.2",
        "==0.6.3"
      ]
    },
    {
      "id": "pyup.io-roundup:CVE-2008-1474",
      "advisory": "Multiple unspecified vulnerabilities in Roundup before 1.4.4 have unknown impact and attack vectors, some of which may be related to cross-site scripting (XSS).",
      "cve": "CVE-2008-1474",
      "specs": [
        "<=1.4.3",
        "==0.1.0",
        "==0.1.1",
        "==0.1.2",
        "==0.1.3",
        "==0.2.0",
        "==0.2.1",
        "==0.2.2",
        "==0.2.3",
        "==0.2.4",
        "==0.2.5",
        "==0.2.6",
        "==0.2.7",
        "==0.2.8",
        "==0.3.0",
        "==0.3.0-pre1",
        "==0.3.0-pre2",
        "==0.3.0-pre3",
        "==0.4.0",
        "==0.4.0-b1",
        "==0.4.0-b2",
        "==0.4.1",
        "==0.4.2",
        "==0.4.2-pr1",
        "==0.5",
        "==0.5.0",
        "==0.5.0-beta1",
        "==0.5.0-beta2",
        "==0.5.0-pr1",
        "==0.5.1",
        "==0.5.2",
        "==0.5.3",
        "==0.5.4",
        "==0.5.5",
        "==0.5.6",
        "==0.5.7",
        "==0.5.8-stable",
        "==0.5.9",
        "==0.6.0",
        "==0.6.0-b1",
        "==0.6.0-b2",
        "==0.6.0-b3",
        "==0.6.0-b4",
        "==0.6.1",
        "==0.6.10",
        "==0.6.11",
        "==0.6.2",
        "==0.6.3",
        "==0.6.4",
        "==0.6.5",
        "==0.6.6",
        "==0.6.7",
        "==0.6.8",
        "==0.6.9",
        "==0.7.0",
        "==0.7.0-b1",
        "==0.7.0-b2",
        "==0.7.0-b3",
        "==0.7.1",
        "==0.7.10",
        "==0.7.11",
        "==0.7.12",
        "==0.7.2",
        "==0.7.3",
        "==0.7.4",
        "==0.7.5",
        "==0.7.6",
        "==0.7.7",
        "==0.7.8",
        "==0.7.9",
        "==0.8.0",
        "==0.8.0-b1",
        "==0.8.0-b2",
        "==0.8.1",
        "==0.8.2",
        "==0.8.3",
        "==0.8.4",
        "==0.8.5",
        "==0.8.6",
        "==0.9.0-b1",
        "==1.0",
        "==1.0.1",
        "==1.1.0",
        "==1.1.1",
        "==1.1.2",
        "==1.2.0",
        "==1.2.1",
        "==1.3.0",
        "==1.3.1",
        "==1.3.2",
        "==1.3.3",
        "==1.4.0",
        "==1.4.1",
        "==1.4.2"
      ]
    },
    {
      "id": "pyup.io-roundup:CVE-2008-1475",
      "advisory": "The xml-rpc server in Roundup 1.4.4 does not check property permissions, which allows attackers to bypass restrictions and edit or read restricted properties via the (1) list, (2) display, and (3) set methods.",
      "cve": "CVE-2008-1475",
      "specs": [
        "<=1.4.3",
        "==0.1.0",
        "==0.1.1",
        "==0.1.2",
        "==0.1.3",
        "==0.2.0",
        "==0.2.1",
        "==0.2.2",
        "==0.2.3",
        "==0.2.4",
        "==0.2.5",
        "==0.2.6",
        "==0.2.7",
        "==0.2.8",
        "==0.3.0",
        "==0.3.0-pre1",
        "==0.3.0-pre2",
        "==0.3.0-pre3",
        "==0.4.0",
        "==0.4.0-b1",
        "==0.4.0-b2",
        "==0.4.1",
        "==0.4.2",
        "==0.4.2-pr1",
        "==0.5",
        "==0.5.0",
        "==0.5.0-beta1",
        "==0.5.0-beta2",
        "==0.5.0-pr1",
        "==0.5.1",
        "==0.5.2",
        "==0.5.3",
        "==0.5.4",
        "==0.5.5",
        "==0.5.6",
        "==0.5.7",
        "==0.5.8-stable",
        "==0.5.9",
        "==0.6.0",
        "==0.6.0-b1",
        "==0.6.0-b2",
        "==0.6.0-b3",
        "==0.6.0-b4",
        "==0.6.1",
        "==0.6.10",
        "==0.6.11",
        "==0.6.2",
        "==0.6.3",
        "==0.6.4",
        "==0.6.5",
        "==0.6.6",
        "==0.6.7",
        "==0.6.8",
        "==0.6.9",
        "==0.7.0",
        "==0.7.0-b1",
        "==0.7.0-b2",
        "==0.7.0-b3",
        "==0.7.1",
        "==0.7.10",
        "==0.7.11",
        "==0.7.12",
        "==0.7.2",
        "==0.7.3",
        "==0.7.4",
        "==0.7.5",
        "==0.7.6",
        "==0.7.7",
        "==0.7.8",
        "==0.7.9",
        "==0.8.0",
        "==0.8.0-b1",
        "==0.8.0-b2",
        "==0.8.1",
        "==0.8.2",
        "==0.8.3",
        "==0.8.4",
        "==0.8.5",
        "==0.8.6",
        "==0.9.0-b1",
        "==1.0",
        "==1.0.1",
        "==1.1.0",
        "==1.1.1",
        "==1.1.2",
        "==1.2.0",
        "==1.2.1",
        "==1.3.0",
        "==1.3.1",
        "==1.3.2",
        "==1.3.3",
        "==1.4.0",
        "==1.4.1",
        "==1.4.2"
      ]
    },
    {
      "id": "pyup.io-roundup:CVE-2010-2491",
      "advisory": "Cross-site scripting (XSS) vulnerability in cgi/client.py in Roundup before 1.4.14 allows remote attackers to inject arbitrary web script or HTML via the template argument to the /issue program.",
      "cve": "CVE-2010-2491",
      "specs": [
        "<=1.4.13",
        "==0.1.0",
        "==0.1.1",
        "==0.1.2",
        "==0.1.3",
        "==0.2.0",
        "==0.2.1",
        "==0.2.2",
        "==0.2.3",
        "==0.2.4",
        "==0.2.5",
        "==0.2.6",
        "==0.2.7",
        "==0.2.8",
        "==0.3.0",
        "==0.3.0-pre1",
        "==0.3.0-pre2",
        "==0.3.0-pre3",
        "==0.4.0",
        "==0.4.0-b1",
        "==0.4.0-b2",
        "==0.4.1",
        "==0.4.2",
        "==0.4.2-pr1",
        "==0.5",
        "==0.5.0",
        "==0.5.0-beta1",
        "==0.5.0-beta2",
        "==0.5.0-pr1",
        "==0.5.1",
        "==0.5.2",
        "==0.5.3",
        "==0.5.4",
        "==0.5.5",
        "==0.5.6",
        "==0.5.7",
        "==0.5.8-stable",
        "==0.5.9",
        "==0.6.0",
        "==0.6.0-b1",
        "==0.6.0-b2",
        "==0.6.0-b3",
        "==0.6.0-b4",
        "==0.6.1",
        "==0.6.10",
        "==0.6.11",
        "==0.6.2",
        "==0.6.3",
        "==0.6.4",
        "==0.6.5",
        "==0.6.6",
        "==0.6.7",
        "==0.6.8",
        "==0.6.9",
        "==0.7.0",
        "==0.7.0-b1",
        "==0.7.0-b2",
        "==0.7.0-b3",
        "==0.7.1",
        "==0.7.10",
        "==0.7.11",
        "==0.7.12",
        "==0.7.2",
        "==0.7.3",
        "==0.7.4",
        "==0.7.5",
        "==0.7.6",
        "==0.7.7",
        "==0.7.8",
        "==0.7.9",
        "==0.8.0",
        "==0.8.0-b1",
        "==0.8.0-b2",
        "==0.8.1",
        "==0.8.2",
        "==0.8.3",
        "==0.8.4",
        "==0.8.5",
        "==0.8.6",
        "==0.9.0-b1",
        "==1.0",
        "==1.0.1",
        "==1.1.0",
        "==1.1.1",
        "==1.1.2",
        "==1.2.0",
        "==1.2.1",
        "==1.3.0",
        "==1.3.1",
        "==1.3.2",
        "==1.3.3",
        "==1.4.0",
        "==1.4.1",
        "==1.4.10",
        "==1.4.11",
        "==1.4.12",
        "==1.4.2",
        "==1.4.3",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8",
        "==1.4.9"
      ]
    },
    {
      "id": "pyup.io-roundup:CVE-2012-6130",
      "advisory": "Cross-site scripting (XSS) vulnerability in the history display in Roundup before 1.4.20 allows remote attackers to inject arbitrary web script or HTML via a username, related to generating a link.",
      "cve": "CVE-2012-6130",
      "specs": [
        "<=1.4.19",
        "==1.4.0",
        "==1.4.1",
        "==1.4.10",
        "==1.4.11",
        "==1.4.12",
        "==1.4.13",
        "==1.4.14",
        "==1.4.15",
        "==1.4.16",
        "==1.4.17",
        "==1.4.18",
        "==1.4.2",
        "==1.4.3",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8",
        "==1.4.9"
      ]
    },
    {
      "id": "pyup.io-roundup:CVE-2012-6131",
      "advisory": "Cross-site scripting (XSS) vulnerability in cgi/client.py in Roundup before 1.4.20 allows remote attackers to inject arbitrary web script or HTML via the @action parameter to support/issue1.",
      "cve": "CVE-2012-6131",
      "specs": [
        "<=1.4.19",
        "==1.4.0",
        "==1.4.1",
        "==1.4.10",
        "==1.4.11",
        "==1.4.12",
        "==1.4.13",
        "==1.4.14",
        "==1.4.15",
        "==1.4.16",
        "==1.4.17",
        "==1.4.18",
        "==1.4.2",
        "==1.4.3",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8",
        "==1.4.9"
      ]
    },
    {
      "id": "pyup.io-roundup:CVE-2012-6132",
      "advisory": "Cross-site scripting (XSS) vulnerability in Roundup before 1.4.20 allows remote attackers to inject arbitrary web script or HTML via the otk parameter.",
      "cve": "CVE-2012-6132",
      "specs": [
        "<=1.4.19",
        "==1.4.0",
        "==1.4.1",
        "==1.4.10",
        "==1.4.11",
        "==1.4.12",
        "==1.4.13",
        "==1.4.14",
        "==1.4.15",
        "==1.4.16",
        "==1.4.17",
        "==1.4.18",
        "==1.4.2",
        "==1.4.3",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8",
        "==1.4.9"
      ]
    },
    {
      "id": "pyup.io-roundup:CVE-2012-6133",
      "advisory": "Multiple cross-site scripting (XSS) vulnerabilities in Roundup before 1.4.20 allow remote attackers to inject arbitrary web script or HTML via the (1) @ok_message or (2) @error_message parameter to issue*.",
      "cve": "CVE-2012-6133",
      "specs": [
        "<1.4.20"
      ]
    },
    {
      "id": "pyup.io-roundup:CVE-2014-6276",
      "advisory": "schema.py in Roundup before 1.5.1 does not properly limit attributes included in default user permissions, which might allow remote authenticated users to obtain sensitive user information by viewing user details.",
      "cve": "CVE-2014-6276",
      "specs": [
        "<=1.5.0"
      ]
    },
    {
      "id": "pyup.io-roundup:CVE-2019-10904",
      "advisory": "Roundup 1.6 allows XSS via the URI because frontends/roundup.cgi and roundup/cgi/wsgi_handler.py mishandle 404 errors.",
      "cve": "CVE-2019-10904",
      "specs": [
        "==1.6"
      ]
    }
  ],
  "rply": [
    {
      "id": "pyup.io-rply:CVE-2014-1604",
      "advisory": "The parser cache functionality in parsergenerator.py in RPLY (aka python-rply) before 0.7.1 allows local users to spoof cache data by pre-creating a temporary rply-*.json file with a predictable name.",
      "cve": "CVE-2014-1604",
      "specs": [
        "<=0.7.0"
      ]
    },
    {
      "id": "pyup.io-rply:CVE-2014-1938",
      "advisory": "python-rply before 0.7.4 insecurely creates temporary files.",
      "cve": "CVE-2014-1938",
      "specs": [
        "<0.7.4"
      ]
    }
  ],
  "rpyc": [
    {
      "id": "pyup.io-rpyc:CVE-2019-16328",
      "advisory": "In RPyC 4.1.x through 4.1.1, a remote attacker can dynamically modify object attributes to construct a remote procedure call that executes code for an RPyC service with default configuration settings.",
      "cve": "CVE-2019-16328",
      "specs": [
        ">=4.1.0,<=4.1.1"
      ]
    }
  ],
  "rsa": [
    {
      "id": "pyup.io-rsa:CVE-2016-1494",
      "advisory": "The verify function in the RSA package for Python (Python-RSA) before 3.3 allows attackers to spoof signatures with a small public exponent via crafted signature padding, aka a BERserk attack.",
      "cve": "CVE-2016-1494",
      "specs": [
        "<3.3"
      ]
    },
    {
      "id": "pyup.io-rsa:CVE-2020-13757",
      "advisory": "Python-RSA before 4.1 ignores leading '\\0' bytes during decryption of ciphertext. This could conceivably have a security-relevant impact, e.g., by helping an attacker to infer that an application uses Python-RSA, or if the length of accepted ciphertext affects application behavior (such as by causing excessive memory allocation).",
      "cve": "CVE-2020-13757",
      "specs": [
        "==4.0"
      ]
    },
    {
      "id": "pyup.io-rsa:CVE-2020-25658",
      "advisory": "It was found that python-rsa is vulnerable to Bleichenbacher timing attacks. An attacker can use this flaw via the RSA decryption API to decrypt parts of the cipher text encrypted with RSA.",
      "cve": "CVE-2020-25658",
      "specs": [
        ">=2.1,<4.7"
      ]
    }
  ],
  "rtslib-fb": [
    {
      "id": "pyup.io-rtslib-fb:CVE-2020-14019",
      "advisory": "Open-iSCSI rtslib-fb through 2.1.72 has weak permissions for /etc/target/saveconfig.json because shutil.copyfile (instead of shutil.copy) is used, and thus permissions are not preserved.",
      "cve": "CVE-2020-14019",
      "specs": [
        "<=2.1.72"
      ]
    }
  ],
  "safety": [
    {
      "id": "pyup.io-safety:CVE-2020-5252",
      "advisory": "The command-line \"safety\" package for Python has a potential security issue. There are two Python characteristics that allow malicious code to \u201cpoison-pill\u201d command-line Safety package detection routines by disguising, or obfuscating, other malicious or non-secure packages. This vulnerability is considered to be of low severity because the attack makes use of an existing Python condition, not the Safety tool itself. This can happen if: You are running Safety in a Python environment that you don\u2019t trust. You are running Safety from the same Python environment where you have your dependencies installed. Dependency packages are being installed arbitrarily or without proper verification. Users can mitigate this issue by doing any of the following: Perform a static analysis by installing Docker and running the Safety Docker image: $ docker run --rm -it pyupio/safety check -r requirements.txt Run Safety against a static dependencies list, such as the requirements.txt file, in a separate, clean Python environment. Run Safety from a Continuous Integration pipeline. Use PyUp.io, which runs Safety in a controlled environment and checks Python for dependencies without any need to install them. Use PyUp's Online Requirements Checker.",
      "cve": "CVE-2020-5252",
      "specs": [
        "<=1.8.6"
      ]
    }
  ],
  "saleor": [
    {
      "id": "pyup.io-saleor:CVE-2019-1010304",
      "advisory": "Saleor Issue was introduced by merge commit: e1b01bad0703afd08d297ed3f1f472248312cc9c. This commit was released as part of 2.0.0 release is affected by: Incorrect Access Control. The impact is: Important. The component is: ProductVariant type in GraphQL API. The attack vector is: Unauthenticated user can access the GraphQL API (which is by default publicly exposed under `/graphql/` URL) and fetch products data which may include admin-restricted shop's revenue data. The fixed version is: 2.3.1.",
      "cve": "CVE-2019-1010304",
      "specs": [
        ">=2.0.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-saleor:CVE-2019-13594",
      "advisory": "In Mirumee Saleor 2.7.0 (fixed in 2.8.0), CSRF protection middleware was accidentally disabled, which allowed attackers to send a POST request without a valid CSRF token and be accepted by the server.",
      "cve": "CVE-2019-13594",
      "specs": [
        "==2.7.0"
      ]
    },
    {
      "id": "pyup.io-saleor:CVE-2020-15085",
      "advisory": "In Saleor Storefront before version 2.10.3, request data used to authenticate customers was inadvertently cached in the browser's local storage mechanism, including credentials. A malicious user with direct access to the browser could extract the email and password. In versions prior to 2.10.0 persisted the cache even after the user logged out. This is fixed in version 2.10.3. A workaround is to manually clear application data (browser's local storage) after logging into Saleor Storefront.",
      "cve": "CVE-2020-15085",
      "specs": [
        "<2.10.3"
      ]
    },
    {
      "id": "pyup.io-saleor:CVE-2020-7964",
      "advisory": "An issue was discovered in Mirumee Saleor 2.x before 2.9.1. Incorrect access control in the checkoutCustomerAttach mutations allows attackers to attach their checkouts to any user ID and consequently leak user data (e.g., name, address, and previous orders of any other customer).",
      "cve": "CVE-2020-7964",
      "specs": [
        ">=2.0.0,<2.9.1"
      ]
    }
  ],
  "salt": [
    {
      "id": "pyup.io-salt:CVE-2013-4435",
      "advisory": "Salt (aka SaltStack) 0.15.0 through 0.17.0 allows remote authenticated users who are using external authentication or client ACL to execute restricted routines by embedding the routine in another routine.",
      "cve": "CVE-2013-4435",
      "specs": [
        "==0.15.0",
        "==0.15.1",
        "==0.16.0",
        "==0.16.2",
        "==0.16.3",
        "==0.16.4",
        "==0.17.0"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2013-4436",
      "advisory": "The default configuration for salt-ssh in Salt (aka SaltStack) 0.17.0 does not validate the SSH host key of requests, which allows remote attackers to have unspecified impact via a man-in-the-middle (MITM) attack.",
      "cve": "CVE-2013-4436",
      "specs": [
        "==0.17.0"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2013-4437",
      "advisory": "Unspecified vulnerability in salt-ssh in Salt (aka SaltStack) 0.17.0 has unspecified impact and vectors related to \"insecure Usage of /tmp.\"",
      "cve": "CVE-2013-4437",
      "specs": [
        "==0.17.0"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2013-4438",
      "advisory": "Salt (aka SaltStack) before 0.17.1 allows remote attackers to execute arbitrary YAML code via unspecified vectors.  NOTE: the vendor states that this might not be a vulnerability because the YAML to be loaded has already been determined to be safe.",
      "cve": "CVE-2013-4438",
      "specs": [
        "<=0.17.0",
        "==0.10.0",
        "==0.10.2",
        "==0.10.3",
        "==0.10.4",
        "==0.10.5",
        "==0.11.0",
        "==0.12.0",
        "==0.13.0",
        "==0.14.0",
        "==0.15.0",
        "==0.15.1",
        "==0.16.0",
        "==0.16.2",
        "==0.16.3",
        "==0.16.4",
        "==0.6.0",
        "==0.7.0",
        "==0.8.0",
        "==0.8.7",
        "==0.8.8",
        "==0.8.9",
        "==0.9.0",
        "==0.9.2",
        "==0.9.3",
        "==0.9.4",
        "==0.9.5",
        "==0.9.6",
        "==0.9.7",
        "==0.9.8",
        "==0.9.9"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2013-4439",
      "advisory": "Salt (aka SaltStack) before 0.15.0 through 0.17.0 allows remote authenticated minions to impersonate arbitrary minions via a crafted minion with a valid key.",
      "cve": "CVE-2013-4439",
      "specs": [
        "==0.15.0",
        "==0.15.1",
        "==0.16.0",
        "==0.16.2",
        "==0.16.3",
        "==0.16.4",
        "==0.17.0"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2013-6617",
      "advisory": "The salt master in Salt (aka SaltStack) 0.11.0 through 0.17.0 does not properly drop group privileges, which makes it easier for remote attackers to gain privileges.",
      "cve": "CVE-2013-6617",
      "specs": [
        "==0.11.0",
        "==0.12.0",
        "==0.13.0",
        "==0.14.0",
        "==0.15.0",
        "==0.15.1",
        "==0.16.0",
        "==0.16.2",
        "==0.16.3",
        "==0.16.4",
        "==0.17.0"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2014-3563",
      "advisory": "Multiple unspecified vulnerabilities in Salt (aka SaltStack) before 2014.1.10 allow local users to have an unspecified impact via vectors related to temporary file creation in (1) seed.py, (2) salt-ssh, or (3) salt-cloud.",
      "cve": "CVE-2014-3563",
      "specs": [
        "<=2014.1.9"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2015-1838",
      "advisory": "modules/serverdensity_device.py in SaltStack before 2014.7.4 does not properly handle files in /tmp.",
      "cve": "CVE-2015-1838",
      "specs": [
        "<=2014.7.3"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2015-1839",
      "advisory": "modules/chef.py in SaltStack before 2014.7.4 does not properly handle files in /tmp.",
      "cve": "CVE-2015-1839",
      "specs": [
        "<=2014.7.3"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2015-4017",
      "advisory": "Salt before 2014.7.6 does not verify certificates when connecting via the aliyun, proxmox, and splunk modules.",
      "cve": "CVE-2015-4017",
      "specs": [
        "==2014.7.5"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2015-8034",
      "advisory": "The state.sls function in Salt before 2015.8.3 uses weak permissions on the cache data, which allows local users to obtain sensitive information by reading the file.",
      "cve": "CVE-2015-8034",
      "specs": [
        "<=2015.8.2"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2016-1866",
      "advisory": "Salt 2015.8.x before 2015.8.4 does not properly handle clear messages on the minion, which allows man-in-the-middle attackers to execute arbitrary code by inserting packets into the minion-master data stream.",
      "cve": "CVE-2016-1866",
      "specs": [
        "==2015.8.0",
        "==2015.8.1",
        "==2015.8.2",
        "==2015.8.3"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2016-3176",
      "advisory": "Salt before 2015.5.10 and 2015.8.x before 2015.8.8, when PAM external authentication is enabled, allows attackers to bypass the configured authentication service by passing an alternate service with a command sent to LocalClient.",
      "cve": "CVE-2016-3176",
      "specs": [
        "<=2015.5.9",
        "==2015.8.0",
        "==2015.8.1",
        "==2015.8.2",
        "==2015.8.3",
        "==2015.8.4",
        "==2015.8.5",
        "==2015.8.7"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2016-9639",
      "advisory": "Salt before 2015.8.11 allows deleted minions to read or write to minions with the same id, related to caching.",
      "cve": "CVE-2016-9639",
      "specs": [
        "<=2015.8.10"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2017-12791",
      "advisory": "Directory traversal vulnerability in minion id validation in SaltStack Salt before 2016.11.7 and 2017.7.x before 2017.7.1 allows remote minions with incorrect credentials to authenticate to a master via a crafted minion ID.",
      "cve": "CVE-2017-12791",
      "specs": [
        "<=2016.11.6",
        "==2017.7.0"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2017-14695",
      "advisory": "Directory traversal vulnerability in minion id validation in SaltStack Salt before 2016.3.8, 2016.11.x before 2016.11.8, and 2017.7.x before 2017.7.2 allows remote minions with incorrect credentials to authenticate to a master via a crafted minion ID.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-12791.",
      "cve": "CVE-2017-14695",
      "specs": [
        "<=2016.3.7",
        "==2016.11",
        "==2016.11.0",
        "==2016.11.1",
        "==2016.11.1-rc1",
        "==2016.11.1-rc2",
        "==2016.11.2",
        "==2016.11.3",
        "==2016.11.4",
        "==2016.11.5",
        "==2016.11.6",
        "==2016.11.7",
        "==2017.7.0",
        "==2017.7.0-rc1",
        "==2017.7.1"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2017-14696",
      "advisory": "SaltStack Salt before 2016.3.8, 2016.11.x before 2016.11.8, and 2017.7.x before 2017.7.2 allows remote attackers to cause a denial of service via a crafted authentication request.",
      "cve": "CVE-2017-14696",
      "specs": [
        "<=2016.3.7",
        "==2016.11",
        "==2016.11.0",
        "==2016.11.1",
        "==2016.11.1-rc1",
        "==2016.11.1-rc2",
        "==2016.11.2",
        "==2016.11.3",
        "==2016.11.4",
        "==2016.11.5",
        "==2016.11.6",
        "==2016.11.7",
        "==2017.7.0",
        "==2017.7.0-rc1",
        "==2017.7.1"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2017-5192",
      "advisory": "When using the local_batch client from salt-api in SaltStack Salt before 2015.8.13, 2016.3.x before 2016.3.5, and 2016.11.x before 2016.11.2, external authentication is not respected, enabling all authentication to be bypassed.",
      "cve": "CVE-2017-5192",
      "specs": [
        "<=2015.8.12",
        "==2016.11.0",
        "==2016.11.1",
        "==2016.11.2",
        "==2016.3.0",
        "==2016.3.1",
        "==2016.3.2",
        "==2016.3.3",
        "==2016.3.4"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2017-5200",
      "advisory": "Salt-api in SaltStack Salt before 2015.8.13, 2016.3.x before 2016.3.5, and 2016.11.x before 2016.11.2 allows arbitrary command execution on a salt-master via Salt's ssh_client.",
      "cve": "CVE-2017-5200",
      "specs": [
        "<=2015.8.12",
        "==2016.11.0",
        "==2016.11.1",
        "==2016.11.2",
        "==2016.3.0",
        "==2016.3.1",
        "==2016.3.2",
        "==2016.3.3",
        "==2016.3.4"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2017-7893",
      "advisory": "In SaltStack Salt before 2016.3.6, compromised salt-minions can impersonate the salt-master.",
      "cve": "CVE-2017-7893",
      "specs": [
        "<2016.3.6"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2017-8109",
      "advisory": "The salt-ssh minion code in SaltStack Salt 2016.11 before 2016.11.4 copied over configuration from the Salt Master without adjusting permissions, which might leak credentials to local attackers on configured minions (clients).",
      "cve": "CVE-2017-8109",
      "specs": [
        "==2016.11",
        "==2016.11.0",
        "==2016.11.0-rc1",
        "==2016.11.0-rc2",
        "==2016.11.1",
        "==2016.11.2",
        "==2016.11.3"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2018-15750",
      "advisory": "Directory Traversal vulnerability in salt-api in SaltStack Salt before 2017.7.8 and 2018.3.x before 2018.3.3 allows remote attackers to determine which files exist on the server.",
      "cve": "CVE-2018-15750",
      "specs": [
        "<2017.7.8",
        ">=2018.3.0,<2018.3.3"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2018-15751",
      "advisory": "SaltStack Salt before 2017.7.8 and 2018.3.x before 2018.3.3 allow remote attackers to bypass authentication and execute arbitrary commands via salt-api(netapi).",
      "cve": "CVE-2018-15751",
      "specs": [
        "<2017.7.8",
        ">=2018.3.0,<2018.3.3"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2019-17361",
      "advisory": "In SaltStack Salt through 2019.2.0, the salt-api NET API with the ssh client enabled is vulnerable to command injection. This allows an unauthenticated attacker with network access to the API endpoint to execute arbitrary code on the salt-api host.",
      "cve": "CVE-2019-17361",
      "specs": [
        "<=2019.2.0"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2020-11651",
      "advisory": "An issue was discovered in SaltStack Salt before 2019.2.4 and 3000 before 3000.2. The salt-master process ClearFuncs class does not properly validate method calls. This allows a remote user to access some methods without authentication. These methods can be used to retrieve user tokens from the salt master and/or run arbitrary commands on salt minions.",
      "cve": "CVE-2020-11651",
      "specs": [
        "<2019.2.4",
        ">=3000,<3000.2"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2020-11652",
      "advisory": "An issue was discovered in SaltStack Salt before 2019.2.4 and 3000 before 3000.2. The salt-master process ClearFuncs class allows access to some methods that improperly sanitize paths. These methods allow arbitrary directory access to authenticated users.",
      "cve": "CVE-2020-11652",
      "specs": [
        "<2019.2.4",
        ">=3000,<3000.2"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2020-16846",
      "advisory": "An issue was discovered in SaltStack Salt through 3002. Sending crafted web requests to the Salt API, with the SSH client enabled, can result in shell injection.",
      "cve": "CVE-2020-16846",
      "specs": [
        "<2015.8.10",
        "==3001",
        ">=2015.8.11,<2015.8.13",
        ">=2016.11.0,<2016.11.3",
        ">=2016.11.4,<2016.11.6",
        ">=2016.11.7,<2016.11.10",
        ">=2016.3.0,<2016.3.4",
        ">=2016.3.5,<2016.3.6",
        ">=2016.3.7,<2016.3.8",
        ">=2017.5.0,<2017.7.4",
        ">=2017.7.5,<2017.7.8",
        ">=2018.2.0,<2018.3.5",
        ">=2019.2.0,<2019.2.5",
        ">=3000.0,<3000.3"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2020-17490",
      "advisory": "The TLS module within SaltStack Salt through 3002 creates certificates with weak file permissions.",
      "cve": "CVE-2020-17490",
      "specs": [
        "<2015.8.10",
        "==3001",
        ">=2015.8.11,<2015.8.13",
        ">=2016.11.0,<2016.11.3",
        ">=2016.11.4,<2016.11.6",
        ">=2016.11.7,<2016.11.10",
        ">=2016.3.0,<2016.3.4",
        ">=2016.3.5,<2016.3.6",
        ">=2016.3.7,<2016.3.8",
        ">=2017.5.0,<2017.7.4",
        ">=2017.7.5,<2017.7.8",
        ">=2018.2.0,<2018.3.5",
        ">=2019.2.0,<2019.2.5",
        ">=3000.0,<3000.3"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2020-25592",
      "advisory": "In SaltStack Salt through 3002, salt-netapi improperly validates eauth credentials and tokens. A user can bypass authentication and invoke Salt SSH.",
      "cve": "CVE-2020-25592",
      "specs": [
        "<2015.8.10",
        "==3001",
        ">=2015.8.11,<2015.8.13",
        ">=2016.11.0,<2016.11.3",
        ">=2016.11.4,<2016.11.6",
        ">=2016.11.7,<2016.11.10",
        ">=2016.3.0,<2016.3.4",
        ">=2016.3.5,<2016.3.6",
        ">=2016.3.7,<2016.3.8",
        ">=2017.5.0,<2017.7.4",
        ">=2017.7.5,<2017.7.8",
        ">=2018.2.0,<2018.3.5",
        ">=2019.2.0,<2019.2.5",
        ">=3000.0,<3000.3"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2020-28243",
      "advisory": "An issue was discovered in SaltStack Salt before 3002.5. The minion's restartcheck is vulnerable to command injection via a crafted process name. This allows for a local privilege escalation by any user able to create a files on the minion in a non-blacklisted directory.",
      "cve": "CVE-2020-28243",
      "specs": [
        "<2015.8.10",
        ">=2015.8.11,<2015.8.13",
        ">=2016.11.4,<2016.11.5",
        ">=2016.11.7,<2016.11.10",
        ">=2016.3.0,<2016.3.4",
        ">=2016.3.5,<2016.3.6",
        ">=2016.3.7,<2016.3.8",
        ">=2016.3.9,<2016.11.3",
        ">=2017.5.0,<2017.7.8",
        ">=2018.2.0,<=2018.3.5",
        ">=2019.2.0,<2019.2.5",
        ">=2019.2.6,<2019.2.8",
        ">=3000,<3000.6",
        ">=3001,<3001.4",
        ">=3002,<3002.5"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2020-28972",
      "advisory": "In SaltStack Salt before 3002.5, authentication to VMware vcenter, vsphere, and esxi servers (in the vmware.py files) does not always validate the SSL/TLS certificate.",
      "cve": "CVE-2020-28972",
      "specs": [
        "<2015.8.10",
        ">=2015.8.11,<2015.8.13",
        ">=2016.11.4,<2016.11.5",
        ">=2016.11.7,<2016.11.10",
        ">=2016.3.0,<2016.3.4",
        ">=2016.3.5,<2016.3.6",
        ">=2016.3.7,<2016.3.8",
        ">=2016.3.9,<2016.11.3",
        ">=2017.5.0,<2017.7.8",
        ">=2018.2.0,<=2018.3.5",
        ">=2019.2.0,<2019.2.5",
        ">=2019.2.6,<2019.2.8",
        ">=3000,<3000.6",
        ">=3001,<3001.4",
        ">=3002,<3002.5"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2020-35662",
      "advisory": "In SaltStack Salt before 3002.5, when authenticating to services using certain modules, the SSL certificate is not always validated.",
      "cve": "CVE-2020-35662",
      "specs": [
        "<2015.8.10",
        ">=2015.8.11,<2015.8.13",
        ">=2016.11.4,<2016.11.5",
        ">=2016.11.7,<2016.11.10",
        ">=2016.3.0,<2016.3.4",
        ">=2016.3.5,<2016.3.6",
        ">=2016.3.7,<2016.3.8",
        ">=2016.3.9,<2016.11.3",
        ">=2017.5.0,<2017.7.8",
        ">=2018.2.0,<=2018.3.5",
        ">=2019.2.0,<2019.2.5",
        ">=2019.2.6,<2019.2.8",
        ">=3000,<3000.6",
        ">=3001,<3001.4",
        ">=3002,<3002.5"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2021-21996",
      "advisory": "An issue was discovered in SaltStack Salt before 3003.3. A user who has control of the source, and source_hash URLs can gain full file system access as root on a salt minion.",
      "cve": "CVE-2021-21996",
      "specs": [
        "<3000.3"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2021-25281",
      "advisory": "An issue was discovered in through SaltStack Salt before 3002.5. salt-api does not honor eauth credentials for the wheel_async client. Thus, an attacker can remotely run any wheel modules on the master.",
      "cve": "CVE-2021-25281",
      "specs": [
        "<2015.8.10",
        ">=2015.8.11,<2015.8.13",
        ">=2016.11.4,<2016.11.5",
        ">=2016.11.7,<2016.11.10",
        ">=2016.3.0,<2016.3.4",
        ">=2016.3.5,<2016.3.6",
        ">=2016.3.7,<2016.3.8",
        ">=2016.3.9,<2016.11.3",
        ">=2017.5.0,<2017.7.8",
        ">=2018.2.0,<=2018.3.5",
        ">=2019.2.0,<2019.2.5",
        ">=2019.2.6,<2019.2.8",
        ">=3000,<3000.6",
        ">=3001,<3001.4",
        ">=3002,<3002.5"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2021-25282",
      "advisory": "An issue was discovered in through SaltStack Salt before 3002.5. The salt.wheel.pillar_roots.write method is vulnerable to directory traversal.",
      "cve": "CVE-2021-25282",
      "specs": [
        "<2015.8.10",
        ">=2015.8.11,<2015.8.13",
        ">=2016.11.4,<2016.11.5",
        ">=2016.11.7,<2016.11.10",
        ">=2016.3.0,<2016.3.4",
        ">=2016.3.5,<2016.3.6",
        ">=2016.3.7,<2016.3.8",
        ">=2016.3.9,<2016.11.3",
        ">=2017.5.0,<2017.7.8",
        ">=2018.2.0,<=2018.3.5",
        ">=2019.2.0,<2019.2.5",
        ">=2019.2.6,<2019.2.8",
        ">=3000,<3000.6",
        ">=3001,<3001.4",
        ">=3002,<3002.5"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2021-25283",
      "advisory": "An issue was discovered in through SaltStack Salt before 3002.5. The jinja renderer does not protect against server side template injection attacks.",
      "cve": "CVE-2021-25283",
      "specs": [
        "<2015.8.10",
        ">=2015.8.11,<2015.8.13",
        ">=2016.11.4,<2016.11.5",
        ">=2016.11.7,<2016.11.10",
        ">=2016.3.0,<2016.3.4",
        ">=2016.3.5,<2016.3.6",
        ">=2016.3.7,<2016.3.8",
        ">=2016.3.9,<2016.11.3",
        ">=2017.5.0,<2017.7.8",
        ">=2018.2.0,<=2018.3.5",
        ">=2019.2.0,<2019.2.5",
        ">=2019.2.6,<2019.2.8",
        ">=3000,<3000.6",
        ">=3001,<3001.4",
        ">=3002,<3002.5"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2021-25284",
      "advisory": "An issue was discovered in through SaltStack Salt before 3002.5. salt.modules.cmdmod can log credentials to the info or error log level.",
      "cve": "CVE-2021-25284",
      "specs": [
        "<2015.8.10",
        ">=2015.8.11,<2015.8.13",
        ">=2016.11.4,<2016.11.5",
        ">=2016.11.7,<2016.11.10",
        ">=2016.3.0,<2016.3.4",
        ">=2016.3.5,<2016.3.6",
        ">=2016.3.7,<2016.3.8",
        ">=2016.3.9,<2016.11.3",
        ">=2017.5.0,<2017.7.8",
        ">=2018.2.0,<=2018.3.5",
        ">=2019.2.0,<2019.2.5",
        ">=2019.2.6,<2019.2.8",
        ">=3000,<3000.6",
        ">=3001,<3001.4",
        ">=3002,<3002.5"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2021-3144",
      "advisory": "In SaltStack Salt before 3002.5, eauth tokens can be used once after expiration. (They might be used to run command against the salt master or minions.)",
      "cve": "CVE-2021-3144",
      "specs": [
        "<2015.8.10",
        ">=2015.8.11,<2015.8.13",
        ">=2016.11.4,<2016.11.5",
        ">=2016.11.7,<2016.11.10",
        ">=2016.3.0,<2016.3.4",
        ">=2016.3.5,<2016.3.6",
        ">=2016.3.7,<2016.3.8",
        ">=2016.3.9,<2016.11.3",
        ">=2017.5.0,<2017.7.8",
        ">=2018.2.0,<=2018.3.5",
        ">=2019.2.0,<2019.2.5",
        ">=2019.2.6,<2019.2.8",
        ">=3000,<3000.6",
        ">=3001,<3001.4",
        ">=3002,<3002.5"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2021-3148",
      "advisory": "An issue was discovered in SaltStack Salt before 3002.5. Sending crafted web requests to the Salt API can result in salt.utils.thin.gen_thin() command injection because of different handling of single versus double quotes. This is related to salt/utils/thin.py.",
      "cve": "CVE-2021-3148",
      "specs": [
        "<2015.8.10",
        ">=2015.8.11,<2015.8.13",
        ">=2016.11.4,<2016.11.5",
        ">=2016.11.7,<2016.11.10",
        ">=2016.3.0,<2016.3.4",
        ">=2016.3.5,<2016.3.6",
        ">=2016.3.7,<2016.3.8",
        ">=2016.3.9,<2016.11.3",
        ">=2017.5.0,<2017.7.8",
        ">=2018.2.0,<=2018.3.5",
        ">=2019.2.0,<2019.2.5",
        ">=2019.2.6,<2019.2.8",
        ">=3000,<3000.6",
        ">=3001,<3001.4",
        ">=3002,<3002.5"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2021-31607",
      "advisory": "In SaltStack Salt 2016.9 through 3002.6, a command injection vulnerability exists in the snapper module that allows for local privilege escalation on a minion. The attack requires that a file is created with a pathname that is backed up by snapper, and that the master calls the snapper.diff function (which executes popen unsafely).",
      "cve": "CVE-2021-31607",
      "specs": [
        ">=2016.9,<=3002.6"
      ]
    },
    {
      "id": "pyup.io-salt:CVE-2021-3197",
      "advisory": "An issue was discovered in SaltStack Salt before 3002.5. The salt-api's ssh client is vulnerable to a shell injection by including ProxyCommand in an argument, or via ssh_options provided in an API request.",
      "cve": "CVE-2021-3197",
      "specs": [
        "<2015.8.10",
        ">=2015.8.11,<2015.8.13",
        ">=2016.11.4,<2016.11.5",
        ">=2016.11.7,<2016.11.10",
        ">=2016.3.0,<2016.3.4",
        ">=2016.3.5,<2016.3.6",
        ">=2016.3.7,<2016.3.8",
        ">=2016.3.9,<2016.11.3",
        ">=2017.5.0,<2017.7.8",
        ">=2018.2.0,<=2018.3.5",
        ">=2019.2.0,<2019.2.5",
        ">=2019.2.6,<2019.2.8",
        ">=3000,<3000.6",
        ">=3001,<3001.4",
        ">=3002,<3002.5"
      ]
    }
  ],
  "scalyr-agent-2": [
    {
      "id": "pyup.io-scalyr-agent-2:CVE-2020-24714",
      "advisory": "The Scalyr Agent before 2.1.10 has Missing SSL Certificate Validation because, in some circumstances, the openssl binary is called without the -verify_hostname option.",
      "cve": "CVE-2020-24714",
      "specs": [
        "<2.1.10"
      ]
    },
    {
      "id": "pyup.io-scalyr-agent-2:CVE-2020-24715",
      "advisory": "The Scalyr Agent before 2.1.10 has Missing SSL Certificate Validation because, in some circumstances, native Python code is used that lacks a comparison of the hostname to commonName and subjectAltName.",
      "cve": "CVE-2020-24715",
      "specs": [
        "<2.1.10"
      ]
    }
  ],
  "scapy": [
    {
      "id": "pyup.io-scapy:CVE-2019-1010142",
      "advisory": "scapy 2.4.0 is affected by: Denial of Service. The impact is: infinite loop, resource consumption and program unresponsive. The component is: _RADIUSAttrPacketListField.getfield(self..). The attack vector is: over the network or in a pcap. both work.",
      "cve": "CVE-2019-1010142",
      "specs": [
        "==2.4.0"
      ]
    }
  ],
  "scikit-learn": [
    {
      "id": "pyup.io-scikit-learn:CVE-2020-13092",
      "advisory": "** DISPUTED ** scikit-learn (aka sklearn) through 0.23.0 can unserialize and execute commands from an untrusted file that is passed to the joblib.load() function, if __reduce__ makes an os.system call. NOTE: third parties dispute this issue because the joblib.load() function is documented as unsafe and it is the user's responsibility to use the function in a secure manner.",
      "cve": "CVE-2020-13092",
      "specs": [
        "<=0.23.0"
      ]
    },
    {
      "id": "pyup.io-scikit-learn:CVE-2020-28975",
      "advisory": "** DISPUTED ** svm_predict_values in svm.cpp in Libsvm v324, as used in scikit-learn 0.23.2 and other products, allows attackers to cause a denial of service (segmentation fault) via a crafted model SVM (introduced via pickle, json, or any other model permanence standard) with a large value in the _n_support array. NOTE: the scikit-learn vendor's position is that the behavior can only occur if the library's API is violated by an application that changes a private attribute.",
      "cve": "CVE-2020-28975",
      "specs": [
        "==0.23.2"
      ]
    }
  ],
  "scipy": [
    {
      "id": "pyup.io-scipy:CVE-2013-4251",
      "advisory": "The scipy.weave component in SciPy before 0.12.1 creates insecure temporary directories.",
      "cve": "CVE-2013-4251",
      "specs": [
        "<0.12.1"
      ]
    }
  ],
  "scrapy": [
    {
      "id": "pyup.io-scrapy:CVE-2017-14158",
      "advisory": "Scrapy 1.4 allows remote attackers to cause a denial of service (memory consumption) via large files because arbitrarily many files are read into memory, which is especially problematic if the files are then individually written in a separate thread to a slow storage resource, as demonstrated by interaction between dataReceived (in core/downloader/handlers/http11.py) and S3FilesStore.",
      "cve": "CVE-2017-14158",
      "specs": [
        "==1.4"
      ]
    },
    {
      "id": "pyup.io-scrapy:CVE-2021-41125",
      "advisory": "Scrapy is a high-level web crawling and scraping framework for Python. If you use `HttpAuthMiddleware` (i.e. the `http_user` and `http_pass` spider attributes) for HTTP authentication, all requests will expose your credentials to the request target. This includes requests generated by Scrapy components, such as `robots.txt` requests sent by Scrapy when the `ROBOTSTXT_OBEY` setting is set to `True`, or as requests reached through redirects. Upgrade to Scrapy 2.5.1 and use the new `http_auth_domain` spider attribute to control which domains are allowed to receive the configured HTTP authentication credentials. If you are using Scrapy 1.8 or a lower version, and upgrading to Scrapy 2.5.1 is not an option, you may upgrade to Scrapy 1.8.1 instead. If you cannot upgrade, set your HTTP authentication credentials on a per-request basis, using for example the `w3lib.http.basic_auth_header` function to convert your credentials into a value that you can assign to the `Authorization` header of your request, instead of defining your credentials globally using `HttpAuthMiddleware`.",
      "cve": "CVE-2021-41125",
      "specs": [
        "<1.8.1",
        ">=2.0.0,<2.5.1"
      ]
    }
  ],
  "scrapy-splash": [
    {
      "id": "pyup.io-scrapy-splash:CVE-2021-41124",
      "advisory": "Scrapy-splash is a library which provides Scrapy and JavaScript integration. In affected versions users who use [`HttpAuthMiddleware`](http://doc.scrapy.org/en/latest/topics/downloader-middleware.html#module-scrapy.downloadermiddlewares.httpauth) (i.e. the `http_user` and `http_pass` spider attributes) for Splash authentication will have any non-Splash request expose your credentials to the request target. This includes `robots.txt` requests sent by Scrapy when the `ROBOTSTXT_OBEY` setting is set to `True`. Upgrade to scrapy-splash 0.8.0 and use the new `SPLASH_USER` and `SPLASH_PASS` settings instead to set your Splash authentication credentials safely. If you cannot upgrade, set your Splash request credentials on a per-request basis, [using the `splash_headers` request parameter](https://github.com/scrapy-plugins/scrapy-splash/tree/0.8.x#http-basic-auth), instead of defining them globally using the [`HttpAuthMiddleware`](http://doc.scrapy.org/en/latest/topics/downloader-middleware.html#module-scrapy.downloadermiddlewares.httpauth). Alternatively, make sure all your requests go through Splash. That includes disabling the [robots.txt middleware](https://docs.scrapy.org/en/latest/topics/downloader-middleware.html#topics-dlmw-robots).",
      "cve": "CVE-2021-41124",
      "specs": [
        "<0.8.0"
      ]
    }
  ],
  "setuptools": [
    {
      "id": "pyup.io-setuptools:CVE-2013-1633",
      "advisory": "easy_install in setuptools before 0.7 uses HTTP to retrieve packages from the PyPI repository, and does not perform integrity checks on package contents, which allows man-in-the-middle attackers to execute arbitrary code via a crafted response to the default use of the product.",
      "cve": "CVE-2013-1633",
      "specs": [
        "<=0.7b4",
        "==0.6.40",
        "==0.6.41",
        "==0.6.42",
        "==0.6.43",
        "==0.6.44",
        "==0.6.45",
        "==0.6.46",
        "==0.6.47",
        "==0.6.48",
        "==0.6.49"
      ]
    }
  ],
  "shuup": [
    {
      "id": "pyup.io-shuup:CVE-2021-25962",
      "advisory": "\u201cShuup\u201d application in versions 0.4.2 to 2.10.8 is affected by the \u201cFormula Injection\u201d vulnerability. A customer can inject payloads in the name input field in the billing address while buying a product. When a store administrator accesses the reports page to export the data as an Excel file and opens it, the payload gets executed.",
      "cve": "CVE-2021-25962",
      "specs": [
        ">=0.4.2,<2.11.0"
      ]
    },
    {
      "id": "pyup.io-shuup:CVE-2021-25963",
      "advisory": "In Shuup, versions 1.6.0 through 2.10.8 are vulnerable to reflected Cross-Site Scripting (XSS) that allows execution of arbitrary javascript code on a victim browser. This vulnerability exists due to the error page contents not escaped.",
      "cve": "CVE-2021-25963",
      "specs": [
        ">=1.6.0,<=2.10.8"
      ]
    }
  ],
  "sickrage": [
    {
      "id": "pyup.io-sickrage:CVE-2018-9160",
      "advisory": "SickRage before v2018.03.09-1 includes cleartext credentials in HTTP responses.",
      "cve": "CVE-2018-9160",
      "specs": [
        "<=9.2.101"
      ]
    },
    {
      "id": "pyup.io-sickrage:CVE-2021-25925",
      "advisory": "in SiCKRAGE, versions 4.2.0 to 10.0.11.dev1 are vulnerable to Stored Cross-Site-Scripting (XSS) due to user input not being validated properly when processed by the server. Therefore, an attacker can inject arbitrary JavaScript code inside the application, and possibly steal a user\u2019s sensitive information.",
      "cve": "CVE-2021-25925",
      "specs": [
        "==10.0.11",
        "==10.0.11-dev1",
        ">=4.2.0,<=10.0.11"
      ]
    },
    {
      "id": "pyup.io-sickrage:CVE-2021-25926",
      "advisory": "In SiCKRAGE, versions 9.3.54.dev1 to 10.0.11.dev1 are vulnerable to Reflected Cross-Site-Scripting (XSS) due to user input not being validated properly in the `quicksearch` feature. Therefore, an attacker can steal a user's sessionID to masquerade as a victim user, to carry out any actions in the context of the user.",
      "cve": "CVE-2021-25926",
      "specs": [
        "==10.0.11-dev1",
        "==9.3.54-dev1",
        ">=9.3.55,<=10.0.11"
      ]
    }
  ],
  "simiki": [
    {
      "id": "pyup.io-simiki:CVE-2020-19000",
      "advisory": "Cross Site Scripting (XSS) in Simiki v1.6.2.1 and prior allows remote attackers to execute arbitrary code via line 54 of the component 'simiki/blob/master/simiki/generators.py'.",
      "cve": "CVE-2020-19000",
      "specs": [
        "==1.6.2.1"
      ]
    },
    {
      "id": "pyup.io-simiki:CVE-2020-19001",
      "advisory": "Command Injection in Simiki v1.6.2.1 and prior allows remote attackers to execute arbitrary system commands via line 64 of the component 'simiki/blob/master/simiki/config.py'.",
      "cve": "CVE-2020-19001",
      "specs": [
        "==1.6.2.1"
      ]
    }
  ],
  "simplejson": [
    {
      "id": "pyup.io-simplejson:CVE-2014-4616",
      "advisory": "Array index error in the scanstring function in the _json module in Python 2.7 through 3.5 and simplejson before 2.6.1 allows context-dependent attackers to read arbitrary process memory via a negative index value in the idx argument to the raw_decode function.",
      "cve": "CVE-2014-4616",
      "specs": [
        "<2.6.1"
      ]
    }
  ],
  "slo-generator": [
    {
      "id": "pyup.io-slo-generator:CVE-2021-22557",
      "advisory": "SLO generator allows for loading of YAML files that if crafted in a specific format can allow for code execution within the context of the SLO Generator. We recommend upgrading SLO Generator past https://github.com/google/slo-generator/pull/173",
      "cve": "CVE-2021-22557",
      "specs": [
        "<2.0.1"
      ]
    }
  ],
  "splunk-sdk": [
    {
      "id": "pyup.io-splunk-sdk:CVE-2019-5729",
      "advisory": "Splunk-SDK-Python before 1.6.6 does not properly verify untrusted TLS server certificates, which could result in man-in-the-middle attacks.",
      "cve": "CVE-2019-5729",
      "specs": [
        "<1.6.6"
      ]
    }
  ],
  "sqla-yaml-fixtures": [
    {
      "id": "pyup.io-sqla-yaml-fixtures:CVE-2019-3575",
      "advisory": "Sqla_yaml_fixtures 0.9.1 allows local users to execute arbitrary python code via the fixture_text argument in sqla_yaml_fixtures.load.",
      "cve": "CVE-2019-3575",
      "specs": [
        "==0.9.1"
      ]
    }
  ],
  "sqlalchemy": [
    {
      "id": "pyup.io-sqlalchemy:CVE-2012-0805",
      "advisory": "Multiple SQL injection vulnerabilities in SQLAlchemy before 0.7.0b4, as used in Keystone, allow remote attackers to execute arbitrary SQL commands via the (1) limit or (2) offset keyword to the select function, or unspecified vectors to the (3) select.limit or (4) select.offset function.",
      "cve": "CVE-2012-0805",
      "specs": [
        "<=0.7.0",
        "==0.6.0",
        "==0.6.0-beta1",
        "==0.6.0-beta2",
        "==0.6.0-beta3",
        "==0.6.1",
        "==0.6.2",
        "==0.6.3",
        "==0.6.4",
        "==0.6.5",
        "==0.6.6",
        "==0.6.7",
        "==0.7.0-b1",
        "==0.7.0-b2"
      ]
    },
    {
      "id": "pyup.io-sqlalchemy:CVE-2019-7164",
      "advisory": "SQLAlchemy through 1.2.17 and 1.3.x through 1.3.0b2 allows SQL Injection via the order_by parameter.",
      "cve": "CVE-2019-7164",
      "specs": [
        "<=1.2.17",
        "==1.3.0-b1",
        "==1.3.0-b2"
      ]
    },
    {
      "id": "pyup.io-sqlalchemy:CVE-2019-7548",
      "advisory": "SQLAlchemy 1.2.17 has SQL Injection when the group_by parameter can be controlled.",
      "cve": "CVE-2019-7548",
      "specs": [
        "==1.2.17"
      ]
    }
  ],
  "sqlparse": [
    {
      "id": "pyup.io-sqlparse:CVE-2021-32839",
      "advisory": "sqlparse is a non-validating SQL parser module for Python. In sqlparse versions 0.4.0 and 0.4.1 there is a regular Expression Denial of Service in sqlparse vulnerability. The regular expression may cause exponential backtracking on strings containing many repetitions of '\\r\\n' in SQL comments. Only the formatting feature that removes comments from SQL statements is affected by this regular expression. As a workaround don't use the sqlformat.format function with keyword strip_comments=True or the --strip-comments command line flag when using the sqlformat command line tool. The issues has been fixed in sqlparse 0.4.2.",
      "cve": "CVE-2021-32839",
      "specs": [
        ">=0.4.0,<0.4.2"
      ]
    }
  ],
  "suds": [
    {
      "id": "pyup.io-suds:CVE-2013-2217",
      "advisory": "cache.py in Suds 0.4, when tempdir is set to None, allows local users to redirect SOAP queries and possibly have other unspecified impact via a symlink attack on a cache file with a predictable name in /tmp/suds/.",
      "cve": "CVE-2013-2217",
      "specs": [
        "==0.4"
      ]
    }
  ],
  "suds-community": [
    {
      "id": "pyup.io-suds-community:CVE-2013-2217",
      "advisory": "cache.py in Suds 0.4, when tempdir is set to None, allows local users to redirect SOAP queries and possibly have other unspecified impact via a symlink attack on a cache file with a predictable name in /tmp/suds/.",
      "cve": "CVE-2013-2217",
      "specs": [
        "==0.4"
      ]
    }
  ],
  "superset": [
    {
      "id": "pyup.io-superset:CVE-2018-8021",
      "advisory": "Versions of Superset prior to 0.23 used an unsafe load method from the pickle library to deserialize data leading to possible remote code execution. Note Superset 0.23 was released prior to any Superset release under the Apache Software Foundation.",
      "cve": "CVE-2018-8021",
      "specs": [
        "<0.23"
      ]
    },
    {
      "id": "pyup.io-superset:CVE-2020-13948",
      "advisory": "While investigating a bug report on Apache Superset, it was determined that an authenticated user could craft requests via a number of templated text fields in the product that would allow arbitrary access to Python\u2019s `os` package in the web application process in versions < 0.37.1. It was thus possible for an authenticated user to list and access files, environment variables, and process information. Additionally it was possible to set environment variables for the current process, create and update files in folders writable by the web process, and execute arbitrary programs accessible by the web process. All other operations available to the `os` package in Python were also available, even if not explicitly enumerated in this CVE.",
      "cve": "CVE-2020-13948",
      "specs": [
        "<0.37.1"
      ]
    },
    {
      "id": "pyup.io-superset:CVE-2020-13952",
      "advisory": "In the course of work on the open source project it was discovered that authenticated users running queries against Hive and Presto database engines could access information via a number of templated fields including the contents of query description metadata database, the hashed version of the authenticated users\u2019 password, and access to connection information including the plaintext password for the current connection. It would also be possible to run arbitrary methods on the database connection object for the Presto or Hive connection, allowing the user to bypass security controls internal to Superset. This vulnerability is present in every Apache Superset version < 0.37.2.",
      "cve": "CVE-2020-13952",
      "specs": [
        "<0.37.2"
      ]
    },
    {
      "id": "pyup.io-superset:CVE-2020-1932",
      "advisory": "An information disclosure issue was found in Apache Superset 0.34.0, 0.34.1, 0.35.0, and 0.35.1. Authenticated Apache Superset users are able to retrieve other users' information, including hashed passwords, by accessing an unused and undocumented API endpoint on Apache Superset.",
      "cve": "CVE-2020-1932",
      "specs": [
        "==0.34.0",
        "==0.34.1",
        "==0.35.0",
        "==0.35.1"
      ]
    },
    {
      "id": "pyup.io-superset:CVE-2021-27907",
      "advisory": "Apache Superset up to and including 0.38.0 allowed the creation of a Markdown component on a Dashboard page for describing chart's related information. Abusing this functionality, a malicious user could inject javascript code executing unwanted action in the context of the user's browser. The javascript code will be automatically executed (Stored XSS) when a legitimate user surfs on the dashboard page. The vulnerability is exploitable creating a \u201cdiv\u201d section and embedding in it a \u201csvg\u201d element with javascript code.",
      "cve": "CVE-2021-27907",
      "specs": [
        "<=0.38.0"
      ]
    },
    {
      "id": "pyup.io-superset:CVE-2021-28125",
      "advisory": "Apache Superset up to and including 1.0.1 allowed for the creation of an external URL that could be malicious. By not checking user input for open redirects the URL shortener functionality would allow for a malicious user to create a short URL for a dashboard that could convince the user to click the link.",
      "cve": "CVE-2021-28125",
      "specs": [
        "<=1.0.1"
      ]
    },
    {
      "id": "pyup.io-superset:CVE-2021-32609",
      "advisory": "Apache Superset up to and including 1.1 does not sanitize titles correctly on the Explore page. This allows an attacker with Explore access to save a chart with a malicious title, injecting html (including scripts) into the page.",
      "cve": "CVE-2021-32609",
      "specs": [
        "<=1.1"
      ]
    },
    {
      "id": "pyup.io-superset:CVE-2021-41971",
      "advisory": "Apache Superset up to and including 1.3.0 when configured with ENABLE_TEMPLATE_PROCESSING on (disabled by default) allowed SQL injection when a malicious authenticated user sends an http request with a custom URL.",
      "cve": "CVE-2021-41971",
      "specs": [
        "<=1.3.0"
      ]
    }
  ],
  "svglib": [
    {
      "id": "pyup.io-svglib:CVE-2020-10799",
      "advisory": "The svglib package through 0.9.3 for Python allows XXE attacks via an svg2rlg call.",
      "cve": "CVE-2020-10799",
      "specs": [
        "<=0.9.3"
      ]
    }
  ],
  "swift": [
    {
      "id": "pyup.io-swift:CVE-2012-4406",
      "advisory": "OpenStack Object Storage (swift) before 1.7.0 uses the loads function in the pickle Python module unsafely when storing and loading metadata in memcached, which allows remote attackers to execute arbitrary code via a crafted pickle object.",
      "cve": "CVE-2012-4406",
      "specs": [
        "<=1.6.0",
        "==1.0.0",
        "==1.0.1",
        "==1.0.2",
        "==1.1.0",
        "==1.1.0-rc1",
        "==1.1.0-rc2",
        "==1.2.0",
        "==1.2.0-gamma1",
        "==1.2.0-rc1",
        "==1.3.0",
        "==1.3.0-gamma1",
        "==1.3.0-rc1",
        "==1.4.0",
        "==1.4.1",
        "==1.4.2",
        "==1.4.3",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8",
        "==1.5.0"
      ]
    },
    {
      "id": "pyup.io-swift:CVE-2013-4155",
      "advisory": "OpenStack Swift before 1.9.1 in Folsom, Grizzly, and Havana allows authenticated users to cause a denial of service (\"superfluous\" tombstone consumption and Swift cluster slowdown) via a DELETE request with a timestamp that is older than expected.",
      "cve": "CVE-2013-4155",
      "specs": [
        "<=1.9.0",
        "==1.0.0",
        "==1.0.1",
        "==1.0.2",
        "==1.1.0",
        "==1.1.0-rc1",
        "==1.1.0-rc2",
        "==1.2.0",
        "==1.2.0-gamma1",
        "==1.2.0-rc1",
        "==1.3.0",
        "==1.3.0-gamma1",
        "==1.3.0-rc1",
        "==1.4.0",
        "==1.4.1",
        "==1.4.2",
        "==1.4.3",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8",
        "==1.5.0",
        "==1.6.0",
        "==1.7.0",
        "==1.7.2",
        "==1.7.4",
        "==1.7.5",
        "==1.7.6",
        "==1.8.0",
        "==1.8.0-rc1",
        "==1.8.0-rc2"
      ]
    },
    {
      "id": "pyup.io-swift:CVE-2013-6396",
      "advisory": "The OpenStack Python client library for Swift (python-swiftclient) 1.0 through 1.9.0 does not verify X.509 certificates from SSL servers, which allows man-in-the-middle attackers to spoof servers and obtain sensitive information via a crafted certificate.",
      "cve": "CVE-2013-6396",
      "specs": [
        "==1.0.0",
        "==1.0.1",
        "==1.0.2",
        "==1.1.0",
        "==1.1.0-rc1",
        "==1.1.0-rc2",
        "==1.10.0",
        "==1.11.0",
        "==1.2.0",
        "==1.2.0-gamma1",
        "==1.2.0-rc1",
        "==1.3.0",
        "==1.3.0-gamma1",
        "==1.3.0-rc1",
        "==1.4.0",
        "==1.4.1",
        "==1.4.2",
        "==1.4.3",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8",
        "==1.5.0",
        "==1.6.0",
        "==1.7.0",
        "==1.7.2",
        "==1.7.4",
        "==1.7.5",
        "==1.7.6",
        "==1.8.0",
        "==1.8.0-rc1",
        "==1.8.0-rc2",
        "==1.9.0"
      ]
    },
    {
      "id": "pyup.io-swift:CVE-2013-7109",
      "advisory": "OpenStack Swift as of 2013-12-15 mishandles PYTHON_EGG_CACHE",
      "cve": "CVE-2013-7109",
      "specs": [
        "<=2013-12-15"
      ]
    },
    {
      "id": "pyup.io-swift:CVE-2014-0006",
      "advisory": "The TempURL middleware in OpenStack Object Storage (Swift) 1.4.6 through 1.8.0, 1.9.0 through 1.10.0, and 1.11.0 allows remote attackers to obtain secret URLs by leveraging an object name and a timing side-channel attack.",
      "cve": "CVE-2014-0006",
      "specs": [
        "==1.10.0",
        "==1.11.0",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8",
        "==1.5.0",
        "==1.6.0",
        "==1.7.0",
        "==1.7.2",
        "==1.7.4",
        "==1.7.5",
        "==1.7.6",
        "==1.8.0",
        "==1.9.0",
        "==1.9.1",
        "==1.9.2"
      ]
    },
    {
      "id": "pyup.io-swift:CVE-2014-3497",
      "advisory": "Cross-site scripting (XSS) vulnerability in OpenStack Swift 1.11.0 through 1.13.1 allows remote attackers to inject arbitrary web script or HTML via the WWW-Authenticate header.",
      "cve": "CVE-2014-3497",
      "specs": [
        "==1.11.0",
        "==1.12.0",
        "==1.13.0",
        "==1.13.1",
        "==1.13.1-rc1",
        "==1.13.1-rc2"
      ]
    },
    {
      "id": "pyup.io-swift:CVE-2014-7960",
      "advisory": "OpenStack Object Storage (Swift) before 2.2.0 allows remote authenticated users to bypass the max_meta_count and other metadata constraints via multiple crafted requests which exceed the limit when combined.",
      "cve": "CVE-2014-7960",
      "specs": [
        "<=2.1.0"
      ]
    },
    {
      "id": "pyup.io-swift:CVE-2015-1856",
      "advisory": "OpenStack Object Storage (Swift) before 2.3.0, when allow_version is configured, allows remote authenticated users to delete the latest version of an object by leveraging listing access to the x-versions-location container.",
      "cve": "CVE-2015-1856",
      "specs": [
        "<=2.2.2"
      ]
    },
    {
      "id": "pyup.io-swift:CVE-2015-5223",
      "advisory": "OpenStack Object Storage (Swift) before 2.4.0 allows attackers to obtain sensitive information via a PUT tempurl and a DLO object manifest that references an object in another container.",
      "cve": "CVE-2015-5223",
      "specs": [
        "<=2.3.0"
      ]
    },
    {
      "id": "pyup.io-swift:CVE-2016-0737",
      "advisory": "OpenStack Object Storage (Swift) before 2.4.0 does not properly close client connections, which allows remote attackers to cause a denial of service (proxy-server resource consumption) via a series of interrupted requests to a Large Object URL.",
      "cve": "CVE-2016-0737",
      "specs": [
        "<=2.3.0"
      ]
    },
    {
      "id": "pyup.io-swift:CVE-2016-0738",
      "advisory": "OpenStack Object Storage (Swift) before 2.3.1 (Kilo), 2.4.x, and 2.5.x before 2.5.1 (Liberty) do not properly close server connections, which allows remote attackers to cause a denial of service (proxy-server resource consumption) via a series of interrupted requests to a Large Object URL.",
      "cve": "CVE-2016-0738",
      "specs": [
        "<=2.3.0",
        "==2.4.0",
        "==2.5.0"
      ]
    },
    {
      "id": "pyup.io-swift:CVE-2017-16613",
      "advisory": "An issue was discovered in middleware.py in OpenStack Swauth through 1.2.0 when used with OpenStack Swift through 2.15.1. The Swift object store and proxy server are saving (unhashed) tokens retrieved from the Swauth middleware authentication mechanism to a log file as part of a GET URI. This allows attackers to bypass authentication by inserting a token into an X-Auth-Token header of a new request. NOTE: github.com/openstack/swauth URLs do not mean that Swauth is maintained by an official OpenStack project team.",
      "cve": "CVE-2017-16613",
      "specs": [
        "<=2.15.1"
      ]
    },
    {
      "id": "pyup.io-swift:CVE-2017-8761",
      "advisory": "In OpenStack Swift through 2.10.1, 2.11.0 through 2.13.0, and 2.14.0, the proxy-server logs full tempurl paths, potentially leaking reusable tempurl signatures to anyone with read access to these logs. All Swift deployments using the tempurl middleware are affected.",
      "cve": "CVE-2017-8761",
      "specs": [
        "<=2.10.1",
        "==2.14.0",
        ">=2.11.0,<=2.13.0"
      ]
    }
  ],
  "tablib": [
    {
      "id": "pyup.io-tablib:CVE-2017-2810",
      "advisory": "An exploitable vulnerability exists in the Databook loading functionality of Tablib 0.11.4. A yaml loaded Databook can execute arbitrary python commands resulting in command execution. An attacker can insert python into loaded yaml to trigger this vulnerability.",
      "cve": "CVE-2017-2810",
      "specs": [
        "==0.11.4"
      ]
    }
  ],
  "tenable-jira-cloud": [
    {
      "id": "pyup.io-tenable-jira-cloud:CVE-2021-21371",
      "advisory": "Tenable for Jira Cloud is an open source project designed to pull Tenable.io vulnerability data, then generate Jira Tasks and sub-tasks based on the vulnerabilities' current state. It published in pypi as \"tenable-jira-cloud\". In tenable-jira-cloud before version 1.1.21, it is possible to run arbitrary commands through the yaml.load() method. This could allow an attacker with local access to the host to run arbitrary code by running the application with a specially crafted YAML configuration file. This is fixed in version 1.1.21 by using yaml.safe_load() instead of yaml.load().",
      "cve": "CVE-2021-21371",
      "specs": [
        "<1.1.21"
      ]
    }
  ],
  "tendenci": [
    {
      "id": "pyup.io-tendenci:CVE-2020-14942",
      "advisory": "Tendenci 12.0.10 allows unrestricted deserialization in apps\\helpdesk\\views\\staff.py.",
      "cve": "CVE-2020-14942",
      "specs": [
        "==12.0.10"
      ]
    }
  ],
  "tensorflow": [
    {
      "id": "pyup.io-tensorflow:CVE-2018-10055",
      "advisory": "Invalid memory access and/or a heap buffer overflow in the TensorFlow XLA compiler in Google TensorFlow before 1.7.1 could cause a crash or read from other parts of process memory via a crafted configuration file.",
      "cve": "CVE-2018-10055",
      "specs": [
        "<1.7.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2018-21233",
      "advisory": "TensorFlow before 1.7.0 has an integer overflow that causes an out-of-bounds read, possibly causing disclosure of the contents of process memory. This occurs in the DecodeBmp feature of the BMP decoder in core/kernels/decode_bmp_op.cc.",
      "cve": "CVE-2018-21233",
      "specs": [
        "<1.7.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2018-7575",
      "advisory": "Google TensorFlow 1.7.x and earlier is affected by a Buffer Overflow vulnerability. The type of exploitation is context-dependent.",
      "cve": "CVE-2018-7575",
      "specs": [
        "<=1.7.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2018-7576",
      "advisory": "Google TensorFlow 1.6.x and earlier is affected by: Null Pointer Dereference. The type of exploitation is: context-dependent.",
      "cve": "CVE-2018-7576",
      "specs": [
        "<=1.6.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2018-7577",
      "advisory": "Memcpy parameter overlap in Google Snappy library 1.1.4, as used in Google TensorFlow before 1.7.1, could result in a crash or read from other parts of process memory.",
      "cve": "CVE-2018-7577",
      "specs": [
        "<1.7.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2018-8825",
      "advisory": "Google TensorFlow 1.7 and below is affected by: Buffer Overflow. The impact is: execute arbitrary code (local).",
      "cve": "CVE-2018-8825",
      "specs": [
        "<=1.7.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2019-16778",
      "advisory": "In TensorFlow before 1.15, a heap buffer overflow in UnsortedSegmentSum can be produced when the Index template argument is int32. In this case data_size and num_segments fields are truncated from int64 to int32 and can produce negative numbers, resulting in accessing out of bounds heap memory. This is unlikely to be exploitable and was detected and fixed internally in TensorFlow 1.15 and 2.0.",
      "cve": "CVE-2019-16778",
      "specs": [
        ">=1.0.0,<1.15.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2019-9635",
      "advisory": "NULL pointer dereference in Google TensorFlow before 1.12.2 could cause a denial of service via an invalid GIF file.",
      "cve": "CVE-2019-9635",
      "specs": [
        "<1.12.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15190",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `tf.raw_ops.Switch` operation takes as input a tensor and a boolean and outputs two tensors. Depending on the boolean value, one of the tensors is exactly the input tensor whereas the other one should be an empty tensor. However, the eager runtime traverses all tensors in the output. Since only one of the tensors is defined, the other one is `nullptr`, hence we are binding a reference to `nullptr`. This is undefined behavior and reported as an error if compiling with `-fsanitize=null`. In this case, this results in a segmentation fault The issue is patched in commit da8558533d925694483d2c136a9220d6d49d843c, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15190",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15191",
      "advisory": "In Tensorflow before versions 2.2.1 and 2.3.1, if a user passes an invalid argument to `dlpack.to_dlpack` the expected validations will cause variables to bind to `nullptr` while setting a `status` variable to the error condition. However, this `status` argument is not properly checked. Hence, code following these methods will bind references to null pointers. This is undefined behavior and reported as an error if compiling with `-fsanitize=null`. The issue is patched in commit 22e07fb204386768e5bcbea563641ea11f96ceb8 and is released in TensorFlow versions 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15191",
      "specs": [
        "==2.2.0",
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15192",
      "advisory": "In Tensorflow before versions 2.2.1 and 2.3.1, if a user passes a list of strings to `dlpack.to_dlpack` there is a memory leak following an expected validation failure. The issue occurs because the `status` argument during validation failures is not properly checked. Since each of the above methods can return an error status, the `status` value must be checked before continuing. The issue is patched in commit 22e07fb204386768e5bcbea563641ea11f96ceb8 and is released in TensorFlow versions 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15192",
      "specs": [
        "==2.2.0",
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15193",
      "advisory": "In Tensorflow before versions 2.2.1 and 2.3.1, the implementation of `dlpack.to_dlpack` can be made to use uninitialized memory resulting in further memory corruption. This is because the pybind11 glue code assumes that the argument is a tensor. However, there is nothing stopping users from passing in a Python object instead of a tensor. The uninitialized memory address is due to a `reinterpret_cast` Since the `PyObject` is a Python object, not a TensorFlow Tensor, the cast to `EagerTensor` fails. The issue is patched in commit 22e07fb204386768e5bcbea563641ea11f96ceb8 and is released in TensorFlow versions 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15193",
      "specs": [
        "==2.2.0",
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15194",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `SparseFillEmptyRowsGrad` implementation has incomplete validation of the shapes of its arguments. Although `reverse_index_map_t` and `grad_values_t` are accessed in a similar pattern, only `reverse_index_map_t` is validated to be of proper shape. Hence, malicious users can pass a bad `grad_values_t` to trigger an assertion failure in `vec`, causing denial of service in serving installations. The issue is patched in commit 390611e0d45c5793c7066110af37c8514e6a6c54, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.\"",
      "cve": "CVE-2020-15194",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15195",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the implementation of `SparseFillEmptyRowsGrad` uses a double indexing pattern. It is possible for `reverse_index_map(i)` to be an index outside of bounds of `grad_values`, thus resulting in a heap buffer overflow. The issue is patched in commit 390611e0d45c5793c7066110af37c8514e6a6c54, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15195",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15196",
      "advisory": "In Tensorflow version 2.3.0, the `SparseCountSparseOutput` and `RaggedCountSparseOutput` implementations don't validate that the `weights` tensor has the same shape as the data. The check exists for `DenseCountSparseOutput`, where both tensors are fully specified. In the sparse and ragged count weights are still accessed in parallel with the data. But, since there is no validation, a user passing fewer weights than the values for the tensors can generate a read from outside the bounds of the heap buffer allocated for the weights. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15196",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15197",
      "advisory": "In Tensorflow before version 2.3.1, the `SparseCountSparseOutput` implementation does not validate that the input arguments form a valid sparse tensor. In particular, there is no validation that the `indices` tensor has rank 2. This tensor must be a matrix because code assumes its elements are accessed as elements of a matrix. However, malicious users can pass in tensors of different rank, resulting in a `CHECK` assertion failure and a crash. This can be used to cause denial of service in serving installations, if users are allowed to control the components of the input sparse tensor. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15197",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15198",
      "advisory": "In Tensorflow before version 2.3.1, the `SparseCountSparseOutput` implementation does not validate that the input arguments form a valid sparse tensor. In particular, there is no validation that the `indices` tensor has the same shape as the `values` one. The values in these tensors are always accessed in parallel. Thus, a shape mismatch can result in accesses outside the bounds of heap allocated buffers. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15198",
      "specs": [
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15199",
      "advisory": "In Tensorflow before version 2.3.1, the `RaggedCountSparseOutput` does not validate that the input arguments form a valid ragged tensor. In particular, there is no validation that the `splits` tensor has the minimum required number of elements. Code uses this quantity to initialize a different data structure. Since `BatchedMap` is equivalent to a vector, it needs to have at least one element to not be `nullptr`. If user passes a `splits` tensor that is empty or has exactly one element, we get a `SIGABRT` signal raised by the operating system. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15199",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15200",
      "advisory": "In Tensorflow before version 2.3.1, the `RaggedCountSparseOutput` implementation does not validate that the input arguments form a valid ragged tensor. In particular, there is no validation that the values in the `splits` tensor generate a valid partitioning of the `values` tensor. Thus, the code sets up conditions to cause a heap buffer overflow. A `BatchedMap` is equivalent to a vector where each element is a hashmap. However, if the first element of `splits_values` is not 0, `batch_idx` will never be 1, hence there will be no hashmap at index 0 in `per_batch_counts`. Trying to access that in the user code results in a segmentation fault. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15200",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15201",
      "advisory": "In Tensorflow before version 2.3.1, the `RaggedCountSparseOutput` implementation does not validate that the input arguments form a valid ragged tensor. In particular, there is no validation that the values in the `splits` tensor generate a valid partitioning of the `values` tensor. Hence, the code is prone to heap buffer overflow. If `split_values` does not end with a value at least `num_values` then the `while` loop condition will trigger a read outside of the bounds of `split_values` once `batch_idx` grows too large. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15201",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15202",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `Shard` API in TensorFlow expects the last argument to be a function taking two `int64` (i.e., `long long`) arguments. However, there are several places in TensorFlow where a lambda taking `int` or `int32` arguments is being used. In these cases, if the amount of work to be parallelized is large enough, integer truncation occurs. Depending on how the two arguments of the lambda are used, this can result in segfaults, read/write outside of heap allocated arrays, stack overflows, or data corruption. The issue is patched in commits 27b417360cbd671ef55915e4bb6bb06af8b8a832 and ca8c013b5e97b1373b3bb1c97ea655e69f31a575, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15202",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15203",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, by controlling the `fill` argument of tf.strings.as_string, a malicious attacker is able to trigger a format string vulnerability due to the way the internal format use in a `printf` call is constructed. This may result in segmentation fault. The issue is patched in commit 33be22c65d86256e6826666662e40dbdfe70ee83, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15203",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15204",
      "advisory": "In eager mode, TensorFlow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1 does not set the session state. Hence, calling `tf.raw_ops.GetSessionHandle` or `tf.raw_ops.GetSessionHandleV2` results in a null pointer dereference In linked snippet, in eager mode, `ctx->session_state()` returns `nullptr`. Since code immediately dereferences this, we get a segmentation fault. The issue is patched in commit 9a133d73ae4b4664d22bd1aa6d654fec13c52ee1, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15204",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15205",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `data_splits` argument of `tf.raw_ops.StringNGrams` lacks validation. This allows a user to pass values that can cause heap overflow errors and even leak contents of memory In the linked code snippet, all the binary strings after `ee ff` are contents from the memory stack. Since these can contain return addresses, this data leak can be used to defeat ASLR. The issue is patched in commit 0462de5b544ed4731aa2fb23946ac22c01856b80, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15205",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15206",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, changing the TensorFlow's `SavedModel` protocol buffer and altering the name of required keys results in segfaults and data corruption while loading the model. This can cause a denial of service in products using `tensorflow-serving` or other inference-as-a-service installments. Fixed were added in commits f760f88b4267d981e13f4b302c437ae800445968 and fcfef195637c6e365577829c4d67681695956e7d (both going into TensorFlow 2.2.0 and 2.3.0 but not yet backported to earlier versions). However, this was not enough, as #41097 reports a different failure mode. The issue is patched in commit adf095206f25471e864a8e63a0f1caef53a0e3a6, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15206",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15207",
      "advisory": "In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, to mimic Python's indexing with negative values, TFLite uses `ResolveAxis` to convert negative values to positive indices. However, the only check that the converted index is now valid is only present in debug builds. If the `DCHECK` does not trigger, then code execution moves ahead with a negative index. This, in turn, results in accessing data out of bounds which results in segfaults and/or data corruption. The issue is patched in commit 2d88f470dea2671b430884260f3626b1fe99830a, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15207",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15208",
      "advisory": "In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, when determining the common dimension size of two tensors, TFLite uses a `DCHECK` which is no-op outside of debug compilation modes. Since the function always returns the dimension of the first tensor, malicious attackers can craft cases where this is larger than that of the second tensor. In turn, this would result in reads/writes outside of bounds since the interpreter will wrongly assume that there is enough data in both tensors. The issue is patched in commit 8ee24e7949a203d234489f9da2c5bf45a7d5157d, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15208",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15209",
      "advisory": "In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, a crafted TFLite model can force a node to have as input a tensor backed by a `nullptr` buffer. This can be achieved by changing a buffer index in the flatbuffer serialization to convert a read-only tensor to a read-write one. The runtime assumes that these buffers are written to before a possible read, hence they are initialized with `nullptr`. However, by changing the buffer index for a tensor and implicitly converting that tensor to be a read-write one, as there is nothing in the model that writes to it, we get a null pointer dereference. The issue is patched in commit 0b5662bc, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15209",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15210",
      "advisory": "In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, if a TFLite saved model uses the same tensor as both input and output of an operator, then, depending on the operator, we can observe a segmentation fault or just memory corruption. We have patched the issue in d58c96946b and will release patch releases for all versions between 1.15 and 2.3. We recommend users to upgrade to TensorFlow 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15210",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15211",
      "advisory": "In TensorFlow Lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, saved models in the flatbuffer format use a double indexing scheme: a model has a set of subgraphs, each subgraph has a set of operators and each operator has a set of input/output tensors. The flatbuffer format uses indices for the tensors, indexing into an array of tensors that is owned by the subgraph. This results in a pattern of double array indexing when trying to get the data of each tensor. However, some operators can have some tensors be optional. To handle this scenario, the flatbuffer model uses a negative `-1` value as index for these tensors. This results in special casing during validation at model loading time. Unfortunately, this means that the `-1` index is a valid tensor index for any operator, including those that don't expect optional inputs and including for output tensors. Thus, this allows writing and reading from outside the bounds of heap allocated arrays, although only at a specific offset from the start of these arrays. This results in both read and write gadgets, albeit very limited in scope. The issue is patched in several commits (46d5b0852, 00302787b7, e11f5558, cd31fd0ce, 1970c21, and fff2c83), and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to the model loading code to ensure that only operators which accept optional inputs use the `-1` special value and only for the tensors that they expect to be optional. Since this allow-list type approach is erro-prone, we advise upgrading to the patched code.",
      "cve": "CVE-2020-15211",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15212",
      "advisory": "In TensorFlow Lite before versions 2.2.1 and 2.3.1, models using segment sum can trigger writes outside of bounds of heap allocated buffers by inserting negative elements in the segment ids tensor. Users having access to `segment_ids_data` can alter `output_index` and then write to outside of `output_data` buffer. This might result in a segmentation fault but it can also be used to further corrupt the memory and can be chained with other vulnerabilities to create more advanced exploits. The issue is patched in commit 204945b19e44b57906c9344c0d00120eeeae178a and is released in TensorFlow versions 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to the model loading code to ensure that the segment ids are all positive, although this only handles the case when the segment ids are stored statically in the model. A similar validation could be done if the segment ids are generated at runtime between inference steps. If the segment ids are generated as outputs of a tensor during inference steps, then there are no possible workaround and users are advised to upgrade to patched code.",
      "cve": "CVE-2020-15212",
      "specs": [
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15213",
      "advisory": "In TensorFlow Lite before versions 2.2.1 and 2.3.1, models using segment sum can trigger a denial of service by causing an out of memory allocation in the implementation of segment sum. Since code uses the last element of the tensor holding them to determine the dimensionality of output tensor, attackers can use a very large value to trigger a large allocation. The issue is patched in commit 204945b19e44b57906c9344c0d00120eeeae178a and is released in TensorFlow versions 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to limit the maximum value in the segment ids tensor. This only handles the case when the segment ids are stored statically in the model, but a similar validation could be done if the segment ids are generated at runtime, between inference steps. However, if the segment ids are generated as outputs of a tensor during inference steps, then there are no possible workaround and users are advised to upgrade to patched code.",
      "cve": "CVE-2020-15213",
      "specs": [
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15214",
      "advisory": "In TensorFlow Lite before versions 2.2.1 and 2.3.1, models using segment sum can trigger a write out bounds / segmentation fault if the segment ids are not sorted. Code assumes that the segment ids are in increasing order, using the last element of the tensor holding them to determine the dimensionality of output tensor. This results in allocating insufficient memory for the output tensor and in a write outside the bounds of the output array. This usually results in a segmentation fault, but depending on runtime conditions it can provide for a write gadget to be used in future memory corruption-based exploits. The issue is patched in commit 204945b19e44b57906c9344c0d00120eeeae178a and is released in TensorFlow versions 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to the model loading code to ensure that the segment ids are sorted, although this only handles the case when the segment ids are stored statically in the model. A similar validation could be done if the segment ids are generated at runtime between inference steps. If the segment ids are generated as outputs of a tensor during inference steps, then there are no possible workaround and users are advised to upgrade to patched code.",
      "cve": "CVE-2020-15214",
      "specs": [
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15265",
      "advisory": "In Tensorflow before version 2.4.0, an attacker can pass an invalid `axis` value to `tf.quantization.quantize_and_dequantize`. This results in accessing a dimension outside the rank of the input tensor in the C++ kernel implementation. However, dim_size only does a DCHECK to validate the argument and then uses it to access the corresponding element of an array. Since in normal builds, `DCHECK`-like macros are no-ops, this results in segfault and access out of bounds of the array. The issue is patched in eccb7ec454e6617738554a255d77f08e60ee0808 and TensorFlow 2.4.0 will be released containing the patch. TensorFlow nightly packages after this commit will also have the issue resolved.",
      "cve": "CVE-2020-15265",
      "specs": [
        "<2.4.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-15266",
      "advisory": "In Tensorflow before version 2.4.0, when the `boxes` argument of `tf.image.crop_and_resize` has a very large value, the CPU kernel implementation receives it as a C++ `nan` floating point value. Attempting to operate on this is undefined behavior which later produces a segmentation fault. The issue is patched in eccb7ec454e6617738554a255d77f08e60ee0808 and TensorFlow 2.4.0 will be released containing the patch. TensorFlow nightly packages after this commit will also have the issue resolved.",
      "cve": "CVE-2020-15266",
      "specs": [
        "<2.4.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-26266",
      "advisory": "In affected versions of TensorFlow under certain cases a saved model can trigger use of uninitialized values during code execution. This is caused by having tensor buffers be filled with the default value of the type but forgetting to default initialize the quantized floating point types in Eigen. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26266",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-26267",
      "advisory": "In affected versions of TensorFlow the tf.raw_ops.DataFormatVecPermute API does not validate the src_format and dst_format attributes. The code assumes that these two arguments define a permutation of NHWC. This can result in uninitialized memory accesses, read outside of bounds and even crashes. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26267",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-26268",
      "advisory": "In affected versions of TensorFlow the tf.raw_ops.ImmutableConst operation returns a constant tensor created from a memory mapped file which is assumed immutable. However, if the type of the tensor is not an integral type, the operation crashes the Python interpreter as it tries to write to the memory area. If the file is too small, TensorFlow properly returns an error as the memory area has fewer bytes than what is needed for the tensor it creates. However, as soon as there are enough bytes, the above snippet causes a segmentation fault. This is because the allocator used to return the buffer data is not marked as returning an opaque handle since the needed virtual method is not overridden. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26268",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-26269",
      "advisory": "In TensorFlow release candidate versions 2.4.0rc*, the general implementation for matching filesystem paths to globbing pattern is vulnerable to an access out of bounds of the array holding the directories. There are multiple invariants and preconditions that are assumed by the parallel implementation of GetMatchingPaths but are not verified by the PRs introducing it (#40861 and #44310). Thus, we are completely rewriting the implementation to fully specify and validate these. This is patched in version 2.4.0. This issue only impacts master branch and the release candidates for TF version 2.4. The final release of the 2.4 release will be patched.",
      "cve": "CVE-2020-26269",
      "specs": [
        "==2.4.0-rc0",
        "==2.4.0-rc1",
        "==2.4.0-rc2",
        "==2.4.0-rc3",
        "==2.4.0-rc4"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-26270",
      "advisory": "In affected versions of TensorFlow running an LSTM/GRU model where the LSTM/GRU layer receives an input with zero-length results in a CHECK failure when using the CUDA backend. This can result in a query-of-death vulnerability, via denial of service, if users can control the input to the layer. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26270",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-26271",
      "advisory": "In affected versions of TensorFlow under certain cases, loading a saved model can result in accessing uninitialized memory while building the computation graph. The MakeEdge function creates an edge between one output tensor of the src node (given by output_index) and the input slot of the dst node (given by input_index). This is only possible if the types of the tensors on both sides coincide, so the function begins by obtaining the corresponding DataType values and comparing these for equality. However, there is no check that the indices point to inside of the arrays they index into. Thus, this can result in accessing data out of bounds of the corresponding heap allocated arrays. In most scenarios, this can manifest as unitialized data access, but if the index points far away from the boundaries of the arrays this can be used to leak addresses from the library. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26271",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2020-5215",
      "advisory": "In TensorFlow before 1.15.2 and 2.0.1, converting a string (from Python) to a tf.float16 value results in a segmentation fault in eager mode as the format checks for this use case are only in the graph mode. This issue can lead to denial of service in inference/training where a malicious attacker can send a data point which contains a string instead of a tf.float16 value. Similar effects can be obtained by manipulating saved models and checkpoints whereby replacing a scalar tf.float16 value with a scalar string will trigger this issue due to automatic conversions. This can be easily reproduced by tf.constant(\"hello\", tf.float16), if eager execution is enabled. This issue is patched in TensorFlow 1.15.1 and 2.0.1 with this vulnerability patched. TensorFlow 2.1.0 was released after we fixed the issue, thus it is not affected. Users are encouraged to switch to TensorFlow 1.15.1, 2.0.1 or 2.1.0.",
      "cve": "CVE-2020-5215",
      "specs": [
        "<1.15.2",
        ">=2.0.0,<2.0.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29512",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. If the `splits` argument of `RaggedBincount` does not specify a valid `SparseTensor`(https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor), then an attacker can trigger a heap buffer overflow. This will cause a read from outside the bounds of the `splits` tensor buffer in the implementation of the `RaggedBincount` op(https://github.com/tensorflow/tensorflow/blob/8b677d79167799f71c42fd3fa074476e0295413a/tensorflow/core/kernels/bincount_op.cc#L430-L433). Before the `for` loop, `batch_idx` is set to 0. The user controls the `splits` array, making it contain only one element, 0. Thus, the code in the `while` loop would increment `batch_idx` and then try to read `splits(1)`, which is outside of bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3, as these are also affected.",
      "cve": "CVE-2021-29512",
      "specs": [
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29513",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Calling TF operations with tensors of non-numeric types when the operations expect numeric tensors result in null pointer dereferences. The conversion from Python array to C++ array(https://github.com/tensorflow/tensorflow/blob/ff70c47a396ef1e3cb73c90513da4f5cb71bebba/tensorflow/python/lib/core/ndarray_tensor.cc#L113-L169) is vulnerable to a type confusion. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29513",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29514",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. If the `splits` argument of `RaggedBincount` does not specify a valid `SparseTensor`(https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor), then an attacker can trigger a heap buffer overflow. This will cause a read from outside the bounds of the `splits` tensor buffer in the implementation of the `RaggedBincount` op(https://github.com/tensorflow/tensorflow/blob/8b677d79167799f71c42fd3fa074476e0295413a/tensorflow/core/kernels/bincount_op.cc#L430-L446). Before the `for` loop, `batch_idx` is set to 0. The attacker sets `splits(0)` to be 7, hence the `while` loop does not execute and `batch_idx` remains 0. This then results in writing to `out(-1, bin)`, which is before the heap allocated buffer for the output tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3, as these are also affected.",
      "cve": "CVE-2021-29514",
      "specs": [
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29515",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `MatrixDiag*` operations(https://github.com/tensorflow/tensorflow/blob/4c4f420e68f1cfaf8f4b6e8e3eb857e9e4c3ff33/tensorflow/core/kernels/linalg/matrix_diag_op.cc#L195-L197) does not validate that the tensor arguments are non-empty. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29515",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29516",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Calling `tf.raw_ops.RaggedTensorToVariant` with arguments specifying an invalid ragged tensor results in a null pointer dereference. The implementation of `RaggedTensorToVariant` operations(https://github.com/tensorflow/tensorflow/blob/904b3926ed1c6c70380d5313d282d248a776baa1/tensorflow/core/kernels/ragged_tensor_to_variant_op.cc#L39-L40) does not validate that the ragged tensor argument is non-empty. Since `batched_ragged` contains no elements, `batched_ragged.splits` is a null vector, thus `batched_ragged.splits(0)` will result in dereferencing `nullptr`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29516",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29517",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. A malicious user could trigger a division by 0 in `Conv3D` implementation. The implementation(https://github.com/tensorflow/tensorflow/blob/42033603003965bffac51ae171b51801565e002d/tensorflow/core/kernels/conv_ops_3d.cc#L143-L145) does a modulo operation based on user controlled input. Thus, when `filter` has a 0 as the fifth element, this results in a division by 0. Additionally, if the shape of the two tensors is not valid, an Eigen assertion can be triggered, resulting in a program crash. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29517",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29518",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In eager mode (default in TF 2.0 and later), session operations are invalid. However, users could still call the raw ops associated with them and trigger a null pointer dereference. The implementation(https://github.com/tensorflow/tensorflow/blob/eebb96c2830d48597d055d247c0e9aebaea94cd5/tensorflow/core/kernels/session_ops.cc#L104) dereferences the session state pointer without checking if it is valid. Thus, in eager mode, `ctx->session_state()` is nullptr and the call of the member function is undefined behavior. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29518",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29519",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The API of `tf.raw_ops.SparseCross` allows combinations which would result in a `CHECK`-failure and denial of service. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/3d782b7d47b1bf2ed32bd4a246d6d6cadc4c903d/tensorflow/core/kernels/sparse_cross_op.cc#L114-L116) is tricked to consider a tensor of type `tstring` which in fact contains integral elements. Fixing the type confusion by preventing mixing `DT_STRING` and `DT_INT64` types solves this issue. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29519",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29520",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Missing validation between arguments to `tf.raw_ops.Conv3DBackprop*` operations can result in heap buffer overflows. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/4814fafb0ca6b5ab58a09411523b2193fed23fed/tensorflow/core/kernels/conv_grad_shape_utils.cc#L94-L153) assumes that the `input`, `filter_sizes` and `out_backprop` tensors have the same shape, as they are accessed in parallel. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29520",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29521",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Specifying a negative dense shape in `tf.raw_ops.SparseCountSparseOutput` results in a segmentation fault being thrown out from the standard library as `std::vector` invariants are broken. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/8f7b60ee8c0206a2c99802e3a4d1bb55d2bc0624/tensorflow/core/kernels/count_ops.cc#L199-L213) assumes the first element of the dense shape is always positive and uses it to initialize a `BatchedMap<T>` (i.e., `std::vector<absl::flat_hash_map<int64,T>>`(https://github.com/tensorflow/tensorflow/blob/8f7b60ee8c0206a2c99802e3a4d1bb55d2bc0624/tensorflow/core/kernels/count_ops.cc#L27)) data structure. If the `shape` tensor has more than one element, `num_batches` is the first value in `shape`. Ensuring that the `dense_shape` argument is a valid tensor shape (that is, all elements are non-negative) solves this issue. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3.",
      "cve": "CVE-2021-29521",
      "specs": [
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29522",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The `tf.raw_ops.Conv3DBackprop*` operations fail to validate that the input tensors are not empty. In turn, this would result in a division by 0. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a91bb59769f19146d5a0c20060244378e878f140/tensorflow/core/kernels/conv_grad_ops_3d.cc#L430-L450) does not check that the divisor used in computing the shard size is not zero. Thus, if attacker controls the input sizes, they can trigger a denial of service via a division by zero error. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29522",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29523",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.AddManySparseToTensorsMap`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/kernels/sparse_tensors_map_ops.cc#L257) takes the values specified in `sparse_shape` as dimensions for the output shape. The `TensorShape` constructor(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L183-L188) uses a `CHECK` operation which triggers when `InitDims`(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L212-L296) returns a non-OK status. This is a legacy implementation of the constructor and operations should use `BuildTensorShapeBase` or `AddDimWithStatus` to prevent `CHECK`-failures in the presence of overflows. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29523",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29524",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/496c2630e51c1a478f095b084329acedb253db6b/tensorflow/core/kernels/conv_grad_shape_utils.cc#L130) does a modulus operation where the divisor is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29524",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29525",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2DBackpropInput`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/b40060c9f697b044e3107917c797ba052f4506ab/tensorflow/core/kernels/conv_grad_input_ops.h#L625-L655) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29525",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29526",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2D`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/988087bd83f144af14087fe4fecee2d250d93737/tensorflow/core/kernels/conv_ops.cc#L261-L263) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29526",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29527",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.QuantizedConv2D`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/00e9a4d67d76703fa1aee33dac582acf317e0e81/tensorflow/core/kernels/quantized_conv_ops.cc#L257-L259) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29527",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29528",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.QuantizedMul`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/55900e961ed4a23b438392024912154a2c2f5e85/tensorflow/core/kernels/quantized_mul_op.cc#L188-L198) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29528",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29529",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a heap buffer overflow in `tf.raw_ops.QuantizedResizeBilinear` by manipulating input values so that float rounding results in off-by-one error in accessing image elements. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/44b7f486c0143f68b56c34e2d01e146ee445134a/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L62-L66) computes two integers (representing the upper and lower bounds for interpolation) by ceiling and flooring a floating point value. For some values of `in`, `interpolation->upper[i]` might be smaller than `interpolation->lower[i]`. This is an issue if `interpolation->upper[i]` is capped at `in_size-1` as it means that `interpolation->lower[i]` points outside of the image. Then, in the interpolation code(https://github.com/tensorflow/tensorflow/blob/44b7f486c0143f68b56c34e2d01e146ee445134a/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L245-L264), this would result in heap buffer overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29529",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29530",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a null pointer dereference by providing an invalid `permutation` to `tf.raw_ops.SparseMatrixSparseCholesky`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/080f1d9e257589f78b3ffb75debf584168aa6062/tensorflow/core/kernels/sparse/sparse_cholesky_op.cc#L85-L86) fails to properly validate the input arguments. Although `ValidateInputs` is called and there are checks in the body of this function, the code proceeds to the next line in `ValidateInputs` since `OP_REQUIRES`(https://github.com/tensorflow/tensorflow/blob/080f1d9e257589f78b3ffb75debf584168aa6062/tensorflow/core/framework/op_requires.h#L41-L48) is a macro that only exits the current function. Thus, the first validation condition that fails in `ValidateInputs` will cause an early return from that function. However, the caller will continue execution from the next line. The fix is to either explicitly check `context->status()` or to convert `ValidateInputs` to return a `Status`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29530",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29531",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a `CHECK` fail in PNG encoding by providing an empty input tensor as the pixel data. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/e312e0791ce486a80c9d23110841525c6f7c3289/tensorflow/core/kernels/image/encode_png_op.cc#L57-L60) only validates that the total number of pixels in the image does not overflow. Thus, an attacker can send an empty matrix for encoding. However, if the tensor is empty, then the associated buffer is `nullptr`. Hence, when calling `png::WriteImageToBuffer`(https://github.com/tensorflow/tensorflow/blob/e312e0791ce486a80c9d23110841525c6f7c3289/tensorflow/core/kernels/image/encode_png_op.cc#L79-L93), the first argument (i.e., `image.flat<T>().data()`) is `NULL`. This then triggers the `CHECK_NOTNULL` in the first line of `png::WriteImageToBuffer`(https://github.com/tensorflow/tensorflow/blob/e312e0791ce486a80c9d23110841525c6f7c3289/tensorflow/core/lib/png/png_io.cc#L345-L349). Since `image` is null, this results in `abort` being called after printing the stacktrace. Effectively, this allows an attacker to mount a denial of service attack. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29531",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29532",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can force accesses outside the bounds of heap allocated arrays by passing in invalid tensor values to `tf.raw_ops.RaggedCross`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/efea03b38fb8d3b81762237dc85e579cc5fc6e87/tensorflow/core/kernels/ragged_cross_op.cc#L456-L487) lacks validation for the user supplied arguments. Each of the above branches call a helper function after accessing array elements via a `*_list[next_*]` pattern, followed by incrementing the `next_*` index. However, as there is no validation that the `next_*` values are in the valid range for the corresponding `*_list` arrays, this results in heap OOB reads. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29532",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29533",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK` failure by passing an empty image to `tf.raw_ops.DrawBoundingBoxes`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/ea34a18dc3f5c8d80a40ccca1404f343b5d55f91/tensorflow/core/kernels/image/draw_bounding_box_op.cc#L148-L165) uses `CHECK_*` assertions instead of `OP_REQUIRES` to validate user controlled inputs. Whereas `OP_REQUIRES` allows returning an error condition back to the user, the `CHECK_*` macros result in a crash if the condition is false, similar to `assert`. In this case, `height` is 0 from the `images` input. This results in `max_box_row_clamp` being negative and the assertion being falsified, followed by aborting program execution. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29533",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29534",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.SparseConcat`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/b432a38fe0e1b4b904a6c222cbce794c39703e87/tensorflow/core/kernels/sparse_concat_op.cc#L76) takes the values specified in `shapes[0]` as dimensions for the output shape. The `TensorShape` constructor(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L183-L188) uses a `CHECK` operation which triggers when `InitDims`(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L212-L296) returns a non-OK status. This is a legacy implementation of the constructor and operations should use `BuildTensorShapeBase` or `AddDimWithStatus` to prevent `CHECK`-failures in the presence of overflows. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29534",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29535",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedMul` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/87cf4d3ea9949051e50ca3f071fc909538a51cd0/tensorflow/core/kernels/quantized_mul_op.cc#L287-L290) assumes that the 4 arguments are always valid scalars and tries to access the numeric value directly. However, if any of these tensors is empty, then `.flat<T>()` is an empty buffer and accessing the element at position 0 results in overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29535",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29536",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedReshape` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a324ac84e573fba362a5e53d4e74d5de6729933e/tensorflow/core/kernels/quantized_reshape_op.cc#L38-L55) assumes that the 2 arguments are always valid scalars and tries to access the numeric value directly. However, if any of these tensors is empty, then `.flat<T>()` is an empty buffer and accessing the element at position 0 results in overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29536",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29537",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedResizeBilinear` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/50711818d2e61ccce012591eeb4fdf93a8496726/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L705-L706) assumes that the 2 arguments are always valid scalars and tries to access the numeric value directly. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29537",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29538",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a division by zero to occur in `Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1b0296c3b8dd9bd948f924aa8cd62f87dbb7c3da/tensorflow/core/kernels/conv_grad_filter_ops.cc#L513-L522) computes a divisor based on user provided data (i.e., the shape of the tensors given as arguments). If all shapes are empty then `work_unit_size` is 0. Since there is no check for this case before division, this results in a runtime exception, with potential to be abused for a denial of service. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29538",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29539",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Calling `tf.raw_ops.ImmutableConst`(https://www.tensorflow.org/api_docs/python/tf/raw_ops/ImmutableConst) with a `dtype` of `tf.resource` or `tf.variant` results in a segfault in the implementation as code assumes that the tensor contents are pure scalars. We have patched the issue in 4f663d4b8f0bec1b48da6fa091a7d29609980fa4 and will release TensorFlow 2.5.0 containing the patch. TensorFlow nightly packages after this commit will also have the issue resolved. If using `tf.raw_ops.ImmutableConst` in code, you can prevent the segfault by inserting a filter for the `dtype` argument.",
      "cve": "CVE-2021-29539",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29540",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow to occur in `Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1b0296c3b8dd9bd948f924aa8cd62f87dbb7c3da/tensorflow/core/kernels/conv_grad_filter_ops.cc#L495-L497) computes the size of the filter tensor but does not validate that it matches the number of elements in `filter_sizes`. Later, when reading/writing to this buffer, code uses the value computed here, instead of the number of elements in the tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29540",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29541",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a dereference of a null pointer in `tf.raw_ops.StringNGrams`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1cdd4da14282210cc759e468d9781741ac7d01bf/tensorflow/core/kernels/string_ngrams_op.cc#L67-L74) does not fully validate the `data_splits` argument. This would result in `ngrams_data`(https://github.com/tensorflow/tensorflow/blob/1cdd4da14282210cc759e468d9781741ac7d01bf/tensorflow/core/kernels/string_ngrams_op.cc#L106-L110) to be a null pointer when the output would be computed to have 0 or negative size. Later writes to the output tensor would then cause a null pointer dereference. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29541",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29542",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow by passing crafted inputs to `tf.raw_ops.StringNGrams`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1cdd4da14282210cc759e468d9781741ac7d01bf/tensorflow/core/kernels/string_ngrams_op.cc#L171-L185) fails to consider corner cases where input would be split in such a way that the generated tokens should only contain padding elements. If input is such that `num_tokens` is 0, then, for `data_start_index=0` (when left padding is present), the marked line would result in reading `data[-1]`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29542",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29543",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.CTCGreedyDecoder`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1615440b17b364b875eb06f43d087381f1460a65/tensorflow/core/kernels/ctc_decoder_ops.cc#L37-L50) has a `CHECK_LT` inserted to validate some invariants. When this condition is false, the program aborts, instead of returning a valid error to the user. This abnormal termination can be weaponized in denial of service attacks. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29543",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29544",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.QuantizeAndDequantizeV4Grad`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/95078c145b5a7a43ee046144005f733092756ab5/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L162-L163) does not validate the rank of the `input_*` tensors. In turn, this results in the tensors being passes as they are to `QuantizeAndDequantizePerChannelGradientImpl`(https://github.com/tensorflow/tensorflow/blob/95078c145b5a7a43ee046144005f733092756ab5/tensorflow/core/kernels/quantize_and_dequantize_op.h#L295-L306). However, the `vec<T>` method, requires the rank to 1 and triggers a `CHECK` failure otherwise. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 as this is the only other affected version.",
      "cve": "CVE-2021-29544",
      "specs": [
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29545",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in converting sparse tensors to CSR Sparse matrices. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/800346f2c03a27e182dd4fba48295f65e7790739/tensorflow/core/kernels/sparse/kernels.cc#L66) does a double redirection to access an element of an array allocated on the heap. If the value at `indices(i, 0)` is such that `indices(i, 0) + 1` is outside the bounds of `csr_row_ptr`, this results in writing outside of bounds of heap allocated data. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29545",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29546",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger an integer division by zero undefined behavior in `tf.raw_ops.QuantizedBiasAdd`. This is because the implementation of the Eigen kernel(https://github.com/tensorflow/tensorflow/blob/61bca8bd5ba8a68b2d97435ddfafcdf2b85672cd/tensorflow/core/kernels/quantization_utils.h#L812-L849) does a division by the number of elements of the smaller input (based on shape) without checking that this is not zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29546",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29547",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a segfault and denial of service via accessing data outside of bounds in `tf.raw_ops.QuantizedBatchNormWithGlobalNormalization`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/55a97caa9e99c7f37a0bbbeb414dc55553d3ae7f/tensorflow/core/kernels/quantized_batch_norm_op.cc#L176-L189) assumes the inputs are not empty. If any of these inputs is empty, `.flat<T>()` is an empty buffer, so accessing the element at index 0 is accessing data outside of bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29547",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29548",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a runtime division by zero error and denial of service in `tf.raw_ops.QuantizedBatchNormWithGlobalNormalization`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/55a97caa9e99c7f37a0bbbeb414dc55553d3ae7f/tensorflow/core/kernels/quantized_batch_norm_op.cc) does not validate all constraints specified in the op's contract(https://www.tensorflow.org/api_docs/python/tf/raw_ops/QuantizedBatchNormWithGlobalNormalization). The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29548",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29549",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a runtime division by zero error and denial of service in `tf.raw_ops.QuantizedBatchNormWithGlobalNormalization`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/6f26b3f3418201479c264f2a02000880d8df151c/tensorflow/core/kernels/quantized_add_op.cc#L289-L295) computes a modulo operation without validating that the divisor is not zero. Since `vector_num_elements` is determined based on input shapes(https://github.com/tensorflow/tensorflow/blob/6f26b3f3418201479c264f2a02000880d8df151c/tensorflow/core/kernels/quantized_add_op.cc#L522-L544), a user can trigger scenarios where this quantity is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29549",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29550",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a runtime division by zero error and denial of service in `tf.raw_ops.FractionalAvgPool`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/acc8ee69f5f46f92a3f1f11230f49c6ac266f10c/tensorflow/core/kernels/fractional_avg_pool_op.cc#L85-L89) computes a divisor quantity by dividing two user controlled values. The user controls the values of `input_size[i]` and `pooling_ratio_[i]` (via the `value.shape()` and `pooling_ratio` arguments). If the value in `input_size[i]` is smaller than the `pooling_ratio_[i]`, then the floor operation results in `output_size[i]` being 0. The `DCHECK_GT` line is a no-op outside of debug mode, so in released versions of TF this does not trigger. Later, these computed values are used as arguments(https://github.com/tensorflow/tensorflow/blob/acc8ee69f5f46f92a3f1f11230f49c6ac266f10c/tensorflow/core/kernels/fractional_avg_pool_op.cc#L96-L99) to `GeneratePoolingSequence`(https://github.com/tensorflow/tensorflow/blob/acc8ee69f5f46f92a3f1f11230f49c6ac266f10c/tensorflow/core/kernels/fractional_pool_common.cc#L100-L108). There, the first computation is a division in a modulo operation. Since `output_length` can be 0, this results in runtime crashing. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29550",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29551",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `MatrixTriangularSolve`(https://github.com/tensorflow/tensorflow/blob/8cae746d8449c7dda5298327353d68613f16e798/tensorflow/core/kernels/linalg/matrix_triangular_solve_op_impl.h#L160-L240) fails to terminate kernel execution if one validation condition fails. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29551",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29552",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by controlling the values of `num_segments` tensor argument for `UnsortedSegmentJoin`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a2a607db15c7cd01d754d37e5448d72a13491bdb/tensorflow/core/kernels/unsorted_segment_join_op.cc#L92-L93) assumes that the `num_segments` tensor is a valid scalar. Since the tensor is empty the `CHECK` involved in `.scalar<T>()()` that checks that the number of elements is exactly 1 will be invalidated and this would result in process termination. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29552",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29553",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can read data outside of bounds of heap allocated buffer in `tf.raw_ops.QuantizeAndDequantizeV3`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/11ff7f80667e6490d7b5174aa6bf5e01886e770f/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L237) does not validate the value of user supplied `axis` attribute before using it to index in the array backing the `input` argument. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29553",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29554",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.DenseCountSparseOutput`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/efff014f3b2d8ef6141da30c806faf141297eca1/tensorflow/core/kernels/count_ops.cc#L123-L127) computes a divisor value from user data but does not check that the result is 0 before doing the division. Since `data` is given by the `values` argument, `num_batch_elements` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, and TensorFlow 2.3.3, as these are also affected.",
      "cve": "CVE-2021-29554",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29555",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.FusedBatchNorm`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/828f346274841fa7505f7020e88ca36c22e557ab/tensorflow/core/kernels/fused_batch_norm_op.cc#L295-L297) performs a division based on the last dimension of the `x` tensor. Since this is controlled by the user, an attacker can trigger a denial of service. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29555",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29556",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.Reverse`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/36229ea9e9451dac14a8b1f4711c435a1d84a594/tensorflow/core/kernels/reverse_op.cc#L75-L76) performs a division based on the first dimension of the tensor argument. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29556",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29557",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.SparseMatMul`. The division by 0 occurs deep in Eigen code because the `b` tensor is empty. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29557",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29558",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `tf.raw_ops.SparseSplit`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/699bff5d961f0abfde8fa3f876e6d241681fbef8/tensorflow/core/util/sparse/sparse_tensor.h#L528-L530) accesses an array element based on a user controlled offset. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29558",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29559",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can access data outside of bounds of heap allocated array in `tf.raw_ops.UnicodeEncode`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/472c1f12ad9063405737679d4f6bd43094e1d36d/tensorflow/core/kernels/unicode_ops.cc) assumes that the `input_value`/`input_splits` pair specify a valid sparse tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29559",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29560",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `tf.raw_ops.RaggedTensorToTensor`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/d94227d43aa125ad8b54115c03cece54f6a1977b/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L219-L222) uses the same index to access two arrays in parallel. Since the user controls the shape of the input arguments, an attacker could trigger a heap OOB access when `parent_output_index` is shorter than `row_split`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29560",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29561",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by exploiting a `CHECK`-failure coming from `tf.raw_ops.LoadAndRemapMatrix`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/d94227d43aa125ad8b54115c03cece54f6a1977b/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L219-L222) assumes that the `ckpt_path` is always a valid scalar. However, an attacker can send any other tensor as the first argument of `LoadAndRemapMatrix`. This would cause the rank `CHECK` in `scalar<T>()()` to trigger and terminate the process. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29561",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29562",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by exploiting a `CHECK`-failure coming from the implementation of `tf.raw_ops.IRFFT`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29562",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29563",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by exploiting a `CHECK`-failure coming from the implementation of `tf.raw_ops.RFFT`. Eigen code operating on an empty matrix can trigger on an assertion and will cause program termination. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29563",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29564",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a null pointer dereference in the implementation of `tf.raw_ops.EditDistance`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/79865b542f9ffdc9caeb255631f7c56f1d4b6517/tensorflow/core/kernels/edit_distance_op.cc#L103-L159) has incomplete validation of the input parameters. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29564",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29565",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a null pointer dereference in the implementation of `tf.raw_ops.SparseFillEmptyRows`. This is because of missing validation(https://github.com/tensorflow/tensorflow/blob/fdc82089d206e281c628a93771336bf87863d5e8/tensorflow/core/kernels/sparse_fill_empty_rows_op.cc#L230-L231) that was covered under a `TODO`. If the `dense_shape` tensor is empty, then `dense_shape_t.vec<>()` would cause a null pointer dereference in the implementation of the op. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29565",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29566",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can write outside the bounds of heap allocated arrays by passing invalid arguments to `tf.raw_ops.Dilation2DBackpropInput`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/afd954e65f15aea4d438d0a219136fc4a63a573d/tensorflow/core/kernels/dilation_ops.cc#L321-L322) does not validate before writing to the output array. The values for `h_out` and `w_out` are guaranteed to be in range for `out_backprop` (as they are loop indices bounded by the size of the array). However, there are no similar guarantees relating `h_in_max`/`w_in_max` and `in_backprop`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29566",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29567",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.SparseDenseCwiseMul`, an attacker can trigger denial of service via `CHECK`-fails or accesses to outside the bounds of heap allocated data. Since the implementation(https://github.com/tensorflow/tensorflow/blob/38178a2f7a681a7835bb0912702a134bfe3b4d84/tensorflow/core/kernels/sparse_dense_binary_op_shared.cc#L68-L80) only validates the rank of the input arguments but no constraints between dimensions(https://www.tensorflow.org/api_docs/python/tf/raw_ops/SparseDenseCwiseMul), an attacker can abuse them to trigger internal `CHECK` assertions (and cause program termination, denial of service) or to write to memory outside of bounds of heap allocated tensor buffers. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29567",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29568",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger undefined behavior by binding to null pointer in `tf.raw_ops.ParameterizedTruncatedNormal`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/3f6fe4dfef6f57e768260b48166c27d148f3015f/tensorflow/core/kernels/parameterized_truncated_normal_op.cc#L630) does not validate input arguments before accessing the first element of `shape`. If `shape` argument is empty, then `shape_tensor.flat<T>()` is an empty array. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29568",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29569",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` can cause reads outside of bounds of heap allocated data if attacker supplies specially crafted inputs. The implementation(https://github.com/tensorflow/tensorflow/blob/ac328eaa3870491ababc147822cd04e91a790643/tensorflow/core/kernels/requantization_range_op.cc#L49-L50) assumes that the `input_min` and `input_max` tensors have at least one element, as it accesses the first element in two arrays. If the tensors are empty, `.flat<T>()` is an empty object, backed by an empty array. Hence, accesing even the 0th element is a read outside the bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29569",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29570",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` can cause reads outside of bounds of heap allocated data if attacker supplies specially crafted inputs. The implementation(https://github.com/tensorflow/tensorflow/blob/ef0c008ee84bad91ec6725ddc42091e19a30cf0e/tensorflow/core/kernels/maxpooling_op.cc#L1016-L1017) uses the same value to index in two different arrays but there is no guarantee that the sizes are identical. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29570",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29571",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` can cause reads outside of bounds of heap allocated data if attacker supplies specially crafted inputs. The implementation(https://github.com/tensorflow/tensorflow/blob/31bd5026304677faa8a0b77602c6154171b9aec1/tensorflow/core/kernels/image/draw_bounding_box_op.cc#L116-L130) assumes that the last element of `boxes` input is 4, as required by [the op](https://www.tensorflow.org/api_docs/python/tf/raw_ops/DrawBoundingBoxesV2). Since this is not checked attackers passing values less than 4 can write outside of bounds of heap allocated objects and cause memory corruption. If the last dimension in `boxes` is less than 4, accesses similar to `tboxes(b, bb, 3)` will access data outside of bounds. Further during code execution there are also writes to these indices. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29571",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29572",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.SdcaOptimizer` triggers undefined behavior due to dereferencing a null pointer. The implementation(https://github.com/tensorflow/tensorflow/blob/60a45c8b6192a4699f2e2709a2645a751d435cc3/tensorflow/core/kernels/sdca_internal.cc) does not validate that the user supplied arguments satisfy all constraints expected by the op(https://www.tensorflow.org/api_docs/python/tf/raw_ops/SdcaOptimizer). The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29572",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29573",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` is vulnerable to a division by 0. The implementation(https://github.com/tensorflow/tensorflow/blob/279bab6efa22752a2827621b7edb56a730233bd8/tensorflow/core/kernels/maxpooling_op.cc#L1033-L1034) fails to validate that the batch dimension of the tensor is non-zero, before dividing by this quantity. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29573",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29574",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPool3DGradGrad` exhibits undefined behavior by dereferencing null pointers backing attacker-supplied empty tensors. The implementation(https://github.com/tensorflow/tensorflow/blob/72fe792967e7fd25234342068806707bbc116618/tensorflow/core/kernels/pooling_ops_3d.cc#L679-L703) fails to validate that the 3 tensor inputs are not empty. If any of them is empty, then accessing the elements in the tensor results in dereferencing a null pointer. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29574",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29575",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.ReverseSequence` allows for stack overflow and/or `CHECK`-fail based denial of service. The implementation(https://github.com/tensorflow/tensorflow/blob/5b3b071975e01f0d250c928b2a8f901cd53b90a7/tensorflow/core/kernels/reverse_sequence_op.cc#L114-L118) fails to validate that `seq_dim` and `batch_dim` arguments are valid. Negative values for `seq_dim` can result in stack overflow or `CHECK`-failure, depending on the version of Eigen code used to implement the operation. Similar behavior can be exhibited by invalid values of `batch_dim`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29575",
      "specs": [
        "<=2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29576",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPool3DGradGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/596c05a159b6fbb9e39ca10b3f7753b7244fa1e9/tensorflow/core/kernels/pooling_ops_3d.cc#L694-L696) does not check that the initialization of `Pool3dParameters` completes successfully. Since the constructor(https://github.com/tensorflow/tensorflow/blob/596c05a159b6fbb9e39ca10b3f7753b7244fa1e9/tensorflow/core/kernels/pooling_ops_3d.cc#L48-L88) uses `OP_REQUIRES` to validate conditions, the first assertion that fails interrupts the initialization of `params`, making it contain invalid data. In turn, this might cause a heap buffer overflow, depending on default initialized values. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29576",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29577",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.AvgPool3DGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/d80ffba9702dc19d1fac74fc4b766b3fa1ee976b/tensorflow/core/kernels/pooling_ops_3d.cc#L376-L450) assumes that the `orig_input_shape` and `grad` tensors have similar first and last dimensions but does not check that this assumption is validated. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29577",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29578",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.FractionalAvgPoolGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/dcba796a28364d6d7f003f6fe733d82726dda713/tensorflow/core/kernels/fractional_avg_pool_op.cc#L216) fails to validate that the pooling sequence arguments have enough elements as required by the `out_backprop` tensor shape. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29578",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29579",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/ab1e644b48c82cb71493f4362b4dd38f4577a1cf/tensorflow/core/kernels/maxpooling_op.cc#L194-L203) fails to validate that indices used to access elements of input/output arrays are valid. Whereas accesses to `input_backprop_flat` are guarded by `FastBoundsCheck`, the indexing in `out_backprop_flat` can result in OOB access. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29579",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29580",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.FractionalMaxPoolGrad` triggers an undefined behavior if one of the input tensors is empty. The code is also vulnerable to a denial of service attack as a `CHECK` condition becomes false and aborts the process. The implementation(https://github.com/tensorflow/tensorflow/blob/169054888d50ce488dfde9ca55d91d6325efbd5b/tensorflow/core/kernels/fractional_max_pool_op.cc#L215) fails to validate that input and output tensors are not empty and are of the same rank. Each of these unchecked assumptions is responsible for the above issues. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29580",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29581",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.CTCBeamSearchDecoder`, an attacker can trigger denial of service via segmentation faults. The implementation(https://github.com/tensorflow/tensorflow/blob/a74768f8e4efbda4def9f16ee7e13cf3922ac5f7/tensorflow/core/kernels/ctc_decoder_ops.cc#L68-L79) fails to detect cases when the input tensor is empty and proceeds to read data from a null buffer. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29581",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29582",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.Dequantize`, an attacker can trigger a read from outside of bounds of heap allocated data. The implementation(https://github.com/tensorflow/tensorflow/blob/26003593aa94b1742f34dc22ce88a1e17776a67d/tensorflow/core/kernels/dequantize_op.cc#L106-L131) accesses the `min_range` and `max_range` tensors in parallel but fails to check that they have the same shape. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29582",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29583",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.FusedBatchNorm` is vulnerable to a heap buffer overflow. If the tensors are empty, the same implementation can trigger undefined behavior by dereferencing null pointers. The implementation(https://github.com/tensorflow/tensorflow/blob/57d86e0db5d1365f19adcce848dfc1bf89fdd4c7/tensorflow/core/kernels/fused_batch_norm_op.cc) fails to validate that `scale`, `offset`, `mean` and `variance` (the last two only when required) all have the same number of elements as the number of channels of `x`. This results in heap out of bounds reads when the buffers backing these tensors are indexed past their boundary. If the tensors are empty, the validation mentioned in the above paragraph would also trigger and prevent the undefined behavior. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29583",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29584",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in caused by an integer overflow in constructing a new tensor shape. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/0908c2f2397c099338b901b067f6495a5b96760b/tensorflow/core/kernels/sparse_split_op.cc#L66-L70) builds a dense shape without checking that the dimensions would not result in overflow. The `TensorShape` constructor(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L183-L188) uses a `CHECK` operation which triggers when `InitDims`(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L212-L296) returns a non-OK status. This is a legacy implementation of the constructor and operations should use `BuildTensorShapeBase` or `AddDimWithStatus` to prevent `CHECK`-failures in the presence of overflows. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29584",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29585",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The TFLite computation for size of output after padding, `ComputeOutSize`(https://github.com/tensorflow/tensorflow/blob/0c9692ae7b1671c983569e5d3de5565843d500cf/tensorflow/lite/kernels/padding.h#L43-L55), does not check that the `stride` argument is not 0 before doing the division. Users can craft special models such that `ComputeOutSize` is called with `stride` set to 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29585",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29586",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Optimized pooling implementations in TFLite fail to check that the stride arguments are not 0 before calling `ComputePaddingHeightWidth`(https://github.com/tensorflow/tensorflow/blob/3f24ccd932546416ec906a02ddd183b48a1d2c83/tensorflow/lite/kernels/pooling.cc#L90). Since users can craft special models which will have `params->stride_{height,width}` be zero, this will result in a division by zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29586",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29587",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The `Prepare` step of the `SpaceToDepth` TFLite operator does not check for 0 before division(https://github.com/tensorflow/tensorflow/blob/5f7975d09eac0f10ed8a17dbb6f5964977725adc/tensorflow/lite/kernels/space_to_depth.cc#L63-L67). An attacker can craft a model such that `params->block_size` would be zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29587",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29588",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The optimized implementation of the `TransposeConv` TFLite operator is [vulnerable to a division by zero error](https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/internal/optimized/optimized_ops.h#L5221-L5222). An attacker can craft a model such that `stride_{h,w}` values are 0. Code calling this function must validate these arguments. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29588",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29589",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The reference implementation of the `GatherNd` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/internal/reference/reference_ops.h#L966). An attacker can craft a model such that `params` input would be an empty tensor. In turn, `params_shape.Dims(.)` would be zero, in at least one dimension. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29589",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29590",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementations of the `Minimum` and `Maximum` TFLite operators can be used to read data outside of bounds of heap allocated objects, if any of the two input tensor arguments are empty. This is because the broadcasting implementation(https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/internal/reference/maximum_minimum.h#L52-L56) indexes in both tensors with the same index but does not validate that the index is within bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29590",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29591",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. TFlite graphs must not have loops between nodes. However, this condition was not checked and an attacker could craft models that would result in infinite loop during evaluation. In certain cases, the infinite loop would be replaced by stack overflow due to too many recursive calls. For example, the `While` implementation(https://github.com/tensorflow/tensorflow/blob/106d8f4fb89335a2c52d7c895b7a7485465ca8d9/tensorflow/lite/kernels/while.cc) could be tricked into a scneario where both the body and the loop subgraphs are the same. Evaluating one of the subgraphs means calling the `Eval` function for the other and this quickly exhaust all stack space. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range. Please consult our security guide(https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.",
      "cve": "CVE-2021-29591",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29592",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The fix for CVE-2020-15209(https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-15209) missed the case when the target shape of `Reshape` operator is given by the elements of a 1-D tensor. As such, the fix for the vulnerability(https://github.com/tensorflow/tensorflow/blob/9c1dc920d8ffb4893d6c9d27d1f039607b326743/tensorflow/lite/core/subgraph.cc#L1062-L1074) allowed passing a null-buffer-backed tensor with a 1D shape. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29592",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29593",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `BatchToSpaceNd` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/b5ed552fe55895aee8bd8b191f744a069957d18d/tensorflow/lite/kernels/batch_to_space_nd.cc#L81-L82). An attacker can craft a model such that one dimension of the `block` input is 0. Hence, the corresponding value in `block_shape` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29593",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29594",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. TFLite's convolution code(https://github.com/tensorflow/tensorflow/blob/09c73bca7d648e961dd05898292d91a8322a9d45/tensorflow/lite/kernels/conv.cc) has multiple division where the divisor is controlled by the user and not checked to be non-zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29594",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29595",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `DepthToSpace` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/depth_to_space.cc#L63-L69). An attacker can craft a model such that `params->block_size` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29595",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29596",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `EmbeddingLookup` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/e4b29809543b250bc9b19678ec4776299dd569ba/tensorflow/lite/kernels/embedding_lookup.cc#L73-L74). An attacker can craft a model such that the first dimension of the `value` input is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29596",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29597",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `SpaceToBatchNd` TFLite operator is [vulnerable to a division by zero error](https://github.com/tensorflow/tensorflow/blob/412c7d9bb8f8a762c5b266c9e73bfa165f29aac8/tensorflow/lite/kernels/space_to_batch_nd.cc#L82-L83). An attacker can craft a model such that one dimension of the `block` input is 0. Hence, the corresponding value in `block_shape` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29597",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29598",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `SVDF` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/7f283ff806b2031f407db64c4d3edcda8fb9f9f5/tensorflow/lite/kernels/svdf.cc#L99-L102). An attacker can craft a model such that `params->rank` would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29598",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29599",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `Split` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/e2752089ef7ce9bcf3db0ec618ebd23ea119d0c7/tensorflow/lite/kernels/split.cc#L63-L65). An attacker can craft a model such that `num_splits` would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29599",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29600",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `OneHot` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/f61c57bd425878be108ec787f4d96390579fb83e/tensorflow/lite/kernels/one_hot.cc#L68-L72). An attacker can craft a model such that at least one of the dimensions of `indices` would be 0. In turn, the `prefix_dim_size` value would become 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29600",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29601",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The TFLite implementation of concatenation is vulnerable to an integer overflow issue(https://github.com/tensorflow/tensorflow/blob/7b7352a724b690b11bfaae2cd54bc3907daf6285/tensorflow/lite/kernels/concatenation.cc#L70-L76). An attacker can craft a model such that the dimensions of one of the concatenation input overflow the values of `int`. TFLite uses `int` to represent tensor dimensions, whereas TF uses `int64`. Hence, valid TF models can trigger an integer overflow when converted to TFLite format. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29601",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29602",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `DepthwiseConv` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/1a8e885b864c818198a5b2c0cbbeca5a1e833bc8/tensorflow/lite/kernels/depthwise_conv.cc#L287-L288). An attacker can craft a model such that `input`'s fourth dimension would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29602",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29603",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. A specially crafted TFLite model could trigger an OOB write on heap in the TFLite implementation of `ArgMin`/`ArgMax`(https://github.com/tensorflow/tensorflow/blob/102b211d892f3abc14f845a72047809b39cc65ab/tensorflow/lite/kernels/arg_min_max.cc#L52-L59). If `axis_value` is not a value between 0 and `NumDimensions(input)`, then the condition in the `if` is never true, so code writes past the last valid element of `output_dims->data`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29603",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29604",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The TFLite implementation of hashtable lookup is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/1a8e885b864c818198a5b2c0cbbeca5a1e833bc8/tensorflow/lite/kernels/hashtable_lookup.cc#L114-L115) An attacker can craft a model such that `values`'s first dimension would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29604",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29605",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The TFLite code for allocating `TFLiteIntArray`s is vulnerable to an integer overflow issue(https://github.com/tensorflow/tensorflow/blob/4ceffae632721e52bf3501b736e4fe9d1221cdfa/tensorflow/lite/c/common.c#L24-L27). An attacker can craft a model such that the `size` multiplier is so large that the return value overflows the `int` datatype and becomes negative. In turn, this results in invalid value being given to `malloc`(https://github.com/tensorflow/tensorflow/blob/4ceffae632721e52bf3501b736e4fe9d1221cdfa/tensorflow/lite/c/common.c#L47-L52). In this case, `ret->size` would dereference an invalid pointer. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29605",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29606",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. A specially crafted TFLite model could trigger an OOB read on heap in the TFLite implementation of `Split_V`(https://github.com/tensorflow/tensorflow/blob/c59c37e7b2d563967da813fa50fe20b21f4da683/tensorflow/lite/kernels/split_v.cc#L99). If `axis_value` is not a value between 0 and `NumDimensions(input)`, then the `SizeOfDimension` function(https://github.com/tensorflow/tensorflow/blob/102b211d892f3abc14f845a72047809b39cc65ab/tensorflow/lite/kernels/kernel_util.h#L148-L150) will access data outside the bounds of the tensor shape array. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29606",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29607",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `SparseAdd` results in allowing attackers to exploit undefined behavior (dereferencing null pointers) as well as write outside of bounds of heap allocated data. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/sparse_sparse_binary_op_shared.cc) has a large set of validation for the two sparse tensor inputs (6 tensors in total), but does not validate that the tensors are not empty or that the second dimension of `*_indices` matches the size of corresponding `*_shape`. This allows attackers to send tensor triples that represent invalid sparse tensors to abuse code assumptions that are not protected by validation. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29607",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29608",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.RaggedTensorToTensor`, an attacker can exploit an undefined behavior if input arguments are empty. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L356-L360) only checks that one of the tensors is not empty, but does not check for the other ones. There are multiple `DCHECK` validations to prevent heap OOB, but these are no-op in release builds, hence they don't prevent anything. The fix will be included in TensorFlow 2.5.0. We will also cherrypick these commits on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29608",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29609",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `SparseAdd` results in allowing attackers to exploit undefined behavior (dereferencing null pointers) as well as write outside of bounds of heap allocated data. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/sparse_add_op.cc) has a large set of validation for the two sparse tensor inputs (6 tensors in total), but does not validate that the tensors are not empty or that the second dimension of `*_indices` matches the size of corresponding `*_shape`. This allows attackers to send tensor triples that represent invalid sparse tensors to abuse code assumptions that are not protected by validation. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29609",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29610",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The validation in `tf.raw_ops.QuantizeAndDequantizeV2` allows invalid values for `axis` argument:. The validation(https://github.com/tensorflow/tensorflow/blob/eccb7ec454e6617738554a255d77f08e60ee0808/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L74-L77) uses `||` to mix two different conditions. If `axis_ < -1` the condition in `OP_REQUIRES` will still be true, but this value of `axis_` results in heap underflow. This allows attackers to read/write to other data on the heap. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29610",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29611",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `SparseReshape` results in a denial of service based on a `CHECK`-failure. The implementation(https://github.com/tensorflow/tensorflow/blob/e87b51ce05c3eb172065a6ea5f48415854223285/tensorflow/core/kernels/sparse_reshape_op.cc#L40) has no validation that the input arguments specify a valid sparse tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3, as these are the only affected versions.",
      "cve": "CVE-2021-29611",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29612",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a heap buffer overflow in Eigen implementation of `tf.raw_ops.BandedTriangularSolve`. The implementation(https://github.com/tensorflow/tensorflow/blob/eccb7ec454e6617738554a255d77f08e60ee0808/tensorflow/core/kernels/linalg/banded_triangular_solve_op.cc#L269-L278) calls `ValidateInputTensors` for input validation but fails to validate that the two tensors are not empty. Furthermore, since `OP_REQUIRES` macro only stops execution of current function after setting `ctx->status()` to a non-OK value, callers of helper functions that use `OP_REQUIRES` must check value of `ctx->status()` before continuing. This doesn't happen in this op's implementation(https://github.com/tensorflow/tensorflow/blob/eccb7ec454e6617738554a255d77f08e60ee0808/tensorflow/core/kernels/linalg/banded_triangular_solve_op.cc#L219), hence the validation that is present is also not effective. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29612",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29613",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `tf.raw_ops.CTCLoss` allows an attacker to trigger an OOB read from heap. The fix will be included in TensorFlow 2.5.0. We will also cherrypick these commits on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29613",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29614",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.io.decode_raw` produces incorrect results and crashes the Python interpreter when combining `fixed_length` and wider datatypes. The implementation of the padded version(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc) is buggy due to a confusion about pointer arithmetic rules. First, the code computes(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L61) the width of each output element by dividing the `fixed_length` value to the size of the type argument. The `fixed_length` argument is also used to determine the size needed for the output tensor(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L63-L79). This is followed by reencoding code(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L85-L94). The erroneous code is the last line above: it is moving the `out_data` pointer by `fixed_length * sizeof(T)` bytes whereas it only copied at most `fixed_length` bytes from the input. This results in parts of the input not being decoded into the output. Furthermore, because the pointer advance is far wider than desired, this quickly leads to writing to outside the bounds of the backing data. This OOB write leads to interpreter crash in the reproducer mentioned here, but more severe attacks can be mounted too, given that this gadget allows writing to periodically placed locations in memory. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29614",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29615",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `ParseAttrValue`(https://github.com/tensorflow/tensorflow/blob/c22d88d6ff33031aa113e48aa3fc9aa74ed79595/tensorflow/core/framework/attr_value_util.cc#L397-L453) can be tricked into stack overflow due to recursion by giving in a specially crafted input. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29615",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29616",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of TrySimplify(https://github.com/tensorflow/tensorflow/blob/c22d88d6ff33031aa113e48aa3fc9aa74ed79595/tensorflow/core/grappler/optimizers/arithmetic_optimizer.cc#L390-L401) has undefined behavior due to dereferencing a null pointer in corner cases that result in optimizing a node with no inputs. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29616",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29617",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via `CHECK`-fail in `tf.strings.substr` with invalid arguments. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29617",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29618",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Passing a complex argument to `tf.transpose` at the same time as passing `conjugate=True` argument results in a crash. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29618",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-29619",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Passing invalid arguments (e.g., discovered via fuzzing) to `tf.raw_ops.SparseCountSparseOutput` results in segfault. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29619",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-35958",
      "advisory": "** DISPUTED ** TensorFlow through 2.5.0 allows attackers to overwrite arbitrary files via a crafted archive when tf.keras.utils.get_file is used with extract=True. NOTE: the vendor's position is that tf.keras.utils.get_file is not intended for untrusted archives.",
      "cve": "CVE-2021-35958",
      "specs": [
        "<=2.5.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37635",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of sparse reduction operations in TensorFlow can trigger accesses outside of bounds of heap allocated data. The [implementation](https://github.com/tensorflow/tensorflow/blob/a1bc56203f21a5a4995311825ffaba7a670d7747/tensorflow/core/kernels/sparse_reduce_op.cc#L217-L228) fails to validate that each reduction group does not overflow and that each corresponding index does not point to outside the bounds of the input tensor. We have patched the issue in GitHub commit 87158f43f05f2720a374f3e6d22a7aaa3a33f750. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37635",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37636",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.SparseDenseCwiseDiv` is vulnerable to a division by 0 error. The [implementation](https://github.com/tensorflow/tensorflow/blob/a1bc56203f21a5a4995311825ffaba7a670d7747/tensorflow/core/kernels/sparse_dense_binary_op_shared.cc#L56) uses a common class for all binary operations but fails to treat the division by 0 case separately. We have patched the issue in GitHub commit d9204be9f49520cdaaeb2541d1dc5187b23f31d9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37636",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37637",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. It is possible to trigger a null pointer dereference in TensorFlow by passing an invalid input to `tf.raw_ops.CompressElement`. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/data/compression_utils.cc#L34) was accessing the size of a buffer obtained from the return of a separate function call before validating that said buffer is valid. We have patched the issue in GitHub commit 5dc7f6981fdaf74c8c5be41f393df705841fb7c5. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37637",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37638",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Sending invalid argument for `row_partition_types` of `tf.raw_ops.RaggedTensorToTensor` API results in a null pointer dereference and undefined behavior. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L328) accesses the first element of a user supplied list of values without validating that the provided list is not empty. We have patched the issue in GitHub commit 301ae88b331d37a2a16159b65b255f4f9eb39314. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37638",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37639",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. When restoring tensors via raw APIs, if the tensor name is not provided, TensorFlow can be tricked into dereferencing a null pointer. Alternatively, attackers can read memory outside the bounds of heap allocated data by providing some tensor names but not enough for a successful restoration. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/kernels/save_restore_tensor.cc#L158-L159) retrieves the tensor list corresponding to the `tensor_name` user controlled input and immediately retrieves the tensor at the restoration index (controlled via `preferred_shard` argument). This occurs without validating that the provided list has enough values. If the list is empty this results in dereferencing a null pointer (undefined behavior). If, however, the list has some elements, if the restoration index is outside the bounds this results in heap OOB read. We have patched the issue in GitHub commit 9e82dce6e6bd1f36a57e08fa85af213e2b2f2622. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37639",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37640",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.SparseReshape` can be made to trigger an integral division by 0 exception. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/reshape_util.cc#L176-L181) calls the reshaping functor whenever there is at least an index in the input but does not check that shape of the input or the target shape have both a non-zero number of elements. The [reshape functor](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/reshape_util.cc#L40-L78) blindly divides by the dimensions of the target shape. Hence, if this is not checked, code will result in a division by 0. We have patched the issue in GitHub commit 4923de56ec94fff7770df259ab7f2288a74feb41. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1 as this is the other affected version.",
      "cve": "CVE-2021-37640",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37641",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions if the arguments to `tf.raw_ops.RaggedGather` don't determine a valid ragged tensor code can trigger a read from outside of bounds of heap allocated buffers. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/ragged_gather_op.cc#L70) directly reads the first dimension of a tensor shape before checking that said tensor has rank of at least 1 (i.e., it is not a scalar). Furthermore, the implementation does not check that the list given by `params_nested_splits` is not an empty list of tensors. We have patched the issue in GitHub commit a2b743f6017d7b97af1fe49087ae15f0ac634373. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37641",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37642",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.ResourceScatterDiv` is vulnerable to a division by 0 error. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/resource_variable_ops.cc#L865) uses a common class for all binary operations but fails to treat the division by 0 case separately. We have patched the issue in GitHub commit 4aacb30888638da75023e6601149415b39763d76. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37642",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37643",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. If a user does not provide a valid padding value to `tf.raw_ops.MatrixDiagPartOp`, then the code triggers a null pointer dereference (if input is empty) or produces invalid behavior, ignoring all values after the first. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/linalg/matrix_diag_op.cc#L89) reads the first value from a tensor buffer without first checking that the tensor has values to read from. We have patched the issue in GitHub commit 482da92095c4d48f8784b1f00dda4f81c28d2988. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37643",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37644",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions providing a negative element to `num_elements` list argument of `tf.raw_ops.TensorListReserve` causes the runtime to abort the process due to reallocating a `std::vector` to have a negative number of elements. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/list_kernels.cc#L312) calls `std::vector.resize()` with the new size controlled by input given by the user, without checking that this input is valid. We have patched the issue in GitHub commit 8a6e874437670045e6c7dc6154c7412b4a2135e2. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37644",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37645",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.QuantizeAndDequantizeV4Grad` is vulnerable to an integer overflow issue caused by converting a signed integer value to an unsigned one and then allocating memory based on this value. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L126) uses the `axis` value as the size argument to `absl::InlinedVector` constructor. But, the constructor uses an unsigned type for the argument, so the implicit conversion transforms the negative value to a large integer. We have patched the issue in GitHub commit 96f364a1ca3009f98980021c4b32be5fdcca33a1. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, and TensorFlow 2.4.3, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37645",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37646",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.StringNGrams` is vulnerable to an integer overflow issue caused by converting a signed integer value to an unsigned one and then allocating memory based on this value. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/string_ngrams_op.cc#L184) calls `reserve` on a `tstring` with a value that sometimes can be negative if user supplies negative `ngram_widths`. The `reserve` method calls `TF_TString_Reserve` which has an `unsigned long` argument for the size of the buffer. Hence, the implicit conversion transforms the negative value to a large integer. We have patched the issue in GitHub commit c283e542a3f422420cfdb332414543b62fc4e4a5. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37646",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37647",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. When a user does not supply arguments that determine a valid sparse tensor, `tf.raw_ops.SparseTensorSliceDataset` implementation can be made to dereference a null pointer. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc#L240-L251) has some argument validation but fails to consider the case when either `indices` or `values` are provided for an empty sparse tensor when the other is not. If `indices` is empty, then [code that performs validation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc#L260-L261) (i.e., checking that the indices are monotonically increasing) results in a null pointer dereference. If `indices` as provided by the user is empty, then `indices` in the C++ code above is backed by an empty `std::vector`, hence calling `indices->dim_size(0)` results in null pointer dereferencing (same as calling `std::vector::at()` on an empty vector). We have patched the issue in GitHub commit 02cc160e29d20631de3859c6653184e3f876b9d7. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37647",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37648",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the code for `tf.raw_ops.SaveV2` does not properly validate the inputs and an attacker can trigger a null pointer dereference. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/save_restore_v2_ops.cc) uses `ValidateInputs` to check that the input arguments are valid. This validation would have caught the illegal state represented by the reproducer above. However, the validation uses `OP_REQUIRES` which translates to setting the `Status` object of the current `OpKernelContext` to an error status, followed by an empty `return` statement which just terminates the execution of the function it is present in. However, this does not mean that the kernel execution is finalized: instead, execution continues from the next line in `Compute` that follows the call to `ValidateInputs`. This is equivalent to lacking the validation. We have patched the issue in GitHub commit 9728c60e136912a12d99ca56e106b7cce7af5986. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37648",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37649",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The code for `tf.raw_ops.UncompressElement` can be made to trigger a null pointer dereference. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/data/experimental/compression_ops.cc#L50-L53) obtains a pointer to a `CompressedElement` from a `Variant` tensor and then proceeds to dereference it for decompressing. There is no check that the `Variant` tensor contained a `CompressedElement`, so the pointer is actually `nullptr`. We have patched the issue in GitHub commit 7bdf50bb4f5c54a4997c379092888546c97c3ebd. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37649",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37650",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.ExperimentalDatasetToTFRecord` and `tf.raw_ops.DatasetToTFRecord` can trigger heap buffer overflow and segmentation fault. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/data/experimental/to_tf_record_op.cc#L93-L102) assumes that all records in the dataset are of string type. However, there is no check for that, and the example given above uses numeric types. We have patched the issue in GitHub commit e0b6e58c328059829c3eb968136f17aa72b6c876. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37650",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37651",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.FractionalAvgPoolGrad` can be tricked into accessing data outside of bounds of heap allocated buffers. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/fractional_avg_pool_op.cc#L205) does not validate that the input tensor is non-empty. Thus, code constructs an empty `EigenDoubleMatrixMap` and then accesses this buffer with indices that are outside of the empty area. We have patched the issue in GitHub commit 0f931751fb20f565c4e94aa6df58d54a003cdb30. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37651",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37652",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.BoostedTreesCreateEnsemble` can result in a use after free error if an attacker supplies specially crafted arguments. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/boosted_trees/resource_ops.cc#L55) uses a reference counted resource and decrements the refcount if the initialization fails, as it should. However, when the code was written, the resource was represented as a naked pointer but later refactoring has changed it to be a smart pointer. Thus, when the pointer leaves the scope, a subsequent `free`-ing of the resource occurs, but this fails to take into account that the refcount has already reached 0, thus the resource has been already freed. During this double-free process, members of the resource object are accessed for cleanup but they are invalid as the entire resource has been freed. We have patched the issue in GitHub commit 5ecec9c6fbdbc6be03295685190a45e7eee726ab. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37652",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37653",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a crash via a floating point exception in `tf.raw_ops.ResourceGather`. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/resource_variable_ops.cc#L725-L731) computes the value of a value, `batch_size`, and then divides by it without checking that this value is not 0. We have patched the issue in GitHub commit ac117ee8a8ea57b73d34665cdf00ef3303bc0b11. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37653",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37654",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a crash via a `CHECK`-fail in debug builds of TensorFlow using `tf.raw_ops.ResourceGather` or a read from outside the bounds of heap allocated data in the same API in a release build. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/resource_variable_ops.cc#L660-L668) does not check that the `batch_dims` value that the user supplies is less than the rank of the input tensor. Since the implementation uses several for loops over the dimensions of `tensor`, this results in reading data from outside the bounds of heap allocated buffer backing the tensor. We have patched the issue in GitHub commit bc9c546ce7015c57c2f15c168b3d9201de679a1d. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37654",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37655",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a read from outside of bounds of heap allocated data by sending invalid arguments to `tf.raw_ops.ResourceScatterUpdate`. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/resource_variable_ops.cc#L919-L923) has an incomplete validation of the relationship between the shapes of `indices` and `updates`: instead of checking that the shape of `indices` is a prefix of the shape of `updates` (so that broadcasting can happen), code only checks that the number of elements in these two tensors are in a divisibility relationship. We have patched the issue in GitHub commit 01cff3f986259d661103412a20745928c727326f. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37655",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37656",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.RaggedTensorToSparse`. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/ragged_tensor_to_sparse_kernel.cc#L30) has an incomplete validation of the splits values: it does not check that they are in increasing order. We have patched the issue in GitHub commit 1071f554dbd09f7e101324d366eec5f4fe5a3ece. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37656",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37657",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in all operations of type `tf.raw_ops.MatrixDiagV*`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/linalg/matrix_diag_op.cc) has incomplete validation that the value of `k` is a valid tensor. We have check that this value is either a scalar or a vector, but there is no check for the number of elements. If this is an empty tensor, then code that accesses the first element of the tensor is wrong. We have patched the issue in GitHub commit f2a673bd34f0d64b8e40a551ac78989d16daad09. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37657",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37658",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in all operations of type `tf.raw_ops.MatrixSetDiagV*`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/linalg/matrix_diag_op.cc) has incomplete validation that the value of `k` is a valid tensor. We have check that this value is either a scalar or a vector, but there is no check for the number of elements. If this is an empty tensor, then code that accesses the first element of the tensor is wrong. We have patched the issue in GitHub commit ff8894044dfae5568ecbf2ed514c1a37dc394f1b. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37658",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37659",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in all binary cwise operations that don't require broadcasting (e.g., gradients of binary cwise operations). The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/cwise_ops_common.h#L264) assumes that the two inputs have exactly the same number of elements but does not check that. Hence, when the eigen functor executes it triggers heap OOB reads and undefined behavior due to binding to nullptr. We have patched the issue in GitHub commit 93f428fd1768df147171ed674fee1fc5ab8309ec. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37659",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37660",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause a floating point exception by calling inplace operations with crafted arguments that would result in a division by 0. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/inplace_ops.cc#L283) has a logic error: it should skip processing if `x` and `v` are empty but the code uses `||` instead of `&&`. We have patched the issue in GitHub commit e86605c0a336c088b638da02135ea6f9f6753618. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37660",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37661",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause a denial of service in `boosted_trees_create_quantile_stream_resource` by using negative arguments. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/quantile_ops.cc#L96) does not validate that `num_streams` only contains non-negative numbers. In turn, [this results in using this value to allocate memory](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/quantiles/quantile_stream_resource.h#L31-L40). However, `reserve` receives an unsigned integer so there is an implicit conversion from a negative value to a large positive unsigned. This results in a crash from the standard library. We have patched the issue in GitHub commit 8a84f7a2b5a2b27ecf88d25bad9ac777cd2f7992. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37661",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37662",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can generate undefined behavior via a reference binding to nullptr in `BoostedTreesCalculateBestGainsPerFeature` and similar attack can occur in `BoostedTreesCalculateBestFeatureSplitV2`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/stats_ops.cc) does not validate the input values. We have patched the issue in GitHub commit 9c87c32c710d0b5b53dc6fd3bfde4046e1f7a5ad and in commit 429f009d2b2c09028647dd4bb7b3f6f414bbaad7. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37662",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37663",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions due to incomplete validation in `tf.raw_ops.QuantizeV2`, an attacker can trigger undefined behavior via binding a reference to a null pointer or can access data outside the bounds of heap allocated arrays. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/quantize_op.cc#L59) has some validation but does not check that `min_range` and `max_range` both have the same non-zero number of elements. If `axis` is provided (i.e., not `-1`), then validation should check that it is a value in range for the rank of `input` tensor and then the lengths of `min_range` and `max_range` inputs match the `axis` dimension of the `input` tensor. We have patched the issue in GitHub commit 6da6620efad397c85493b8f8667b821403516708. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37663",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37664",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can read from outside of bounds of heap allocated data by sending specially crafted illegal arguments to `BoostedTreesSparseCalculateBestFeatureSplit`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/stats_ops.cc) needs to validate that each value in `stats_summary_indices` is in range. We have patched the issue in GitHub commit e84c975313e8e8e38bb2ea118196369c45c51378. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37664",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37665",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions due to incomplete validation in MKL implementation of requantization, an attacker can trigger undefined behavior via binding a reference to a null pointer or can access data outside the bounds of heap allocated arrays. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/mkl/mkl_requantization_range_per_channel_op.cc) does not validate the dimensions of the `input` tensor. A similar issue occurs in `MklRequantizePerChannelOp`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/mkl/mkl_requantize_per_channel_op.cc) does not perform full validation for all the input arguments. We have patched the issue in GitHub commit 9e62869465573cb2d9b5053f1fa02a81fce21d69 and in the Github commit 203214568f5bc237603dbab6e1fd389f1572f5c9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37665",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37666",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.RaggedTensorToVariant`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/ragged_tensor_to_variant_op.cc#L129) has an incomplete validation of the splits values, missing the case when the argument would be empty. We have patched the issue in GitHub commit be7a4de6adfbd303ce08be4332554dff70362612. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37666",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37667",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.UnicodeEncode`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/unicode_ops.cc#L533-L539) reads the first dimension of the `input_splits` tensor before validating that this tensor is not empty. We have patched the issue in GitHub commit 2e0ee46f1a47675152d3d865797a18358881d7a6. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37667",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37668",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause denial of service in applications serving models using `tf.raw_ops.UnravelIndex` by triggering a division by 0. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/unravel_index_op.cc#L36) does not check that the tensor subsumed by `dims` is not empty. Hence, if one element of `dims` is 0, the implementation does a division by 0. We have patched the issue in GitHub commit a776040a5e7ebf76eeb7eb923bf1ae417dd4d233. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37668",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37669",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause denial of service in applications serving models using `tf.raw_ops.NonMaxSuppressionV5` by triggering a division by 0. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/image/non_max_suppression_op.cc#L170-L271) uses a user controlled argument to resize a `std::vector`. However, as `std::vector::resize` takes the size argument as a `size_t` and `output_size` is an `int`, there is an implicit conversion to unsigned. If the attacker supplies a negative value, this conversion results in a crash. A similar issue occurs in `CombinedNonMaxSuppression`. We have patched the issue in GitHub commit 3a7362750d5c372420aa8f0caf7bf5b5c3d0f52d and commit [b5cdbf12ffcaaffecf98f22a6be5a64bb96e4f58. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37669",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37670",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can read from outside of bounds of heap allocated data by sending specially crafted illegal arguments to `tf.raw_ops.UpperBound`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/searchsorted_op.cc#L85-L104) does not validate the rank of `sorted_input` argument. A similar issue occurs in `tf.raw_ops.LowerBound`. We have patched the issue in GitHub commit 42459e4273c2e47a3232cc16c4f4fff3b3a35c38. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37670",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37671",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.Map*` and `tf.raw_ops.OrderedMap*` operations. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/map_stage_op.cc#L222-L248) has a check in place to ensure that `indices` is in ascending order, but does not check that `indices` is not empty. We have patched the issue in GitHub commit 532f5c5a547126c634fefd43bbad1dc6417678ac. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37671",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37672",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can read from outside of bounds of heap allocated data by sending specially crafted illegal arguments to `tf.raw_ops.SdcaOptimizerV2`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/sdca_internal.cc#L320-L353) does not check that the length of `example_labels` is the same as the number of examples. We have patched the issue in GitHub commit a4e138660270e7599793fa438cd7b2fc2ce215a6. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37672",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37673",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.MapStage`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/map_stage_op.cc#L513) does not check that the `key` input is a valid non-empty tensor. We have patched the issue in GitHub commit d7de67733925de196ec8863a33445b73f9562d1d. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37673",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37674",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a denial of service via a segmentation fault in `tf.raw_ops.MaxPoolGrad` caused by missing validation. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/maxpooling_op.cc) misses some validation for the `orig_input` and `orig_output` tensors. The fixes for CVE-2021-29579 were incomplete. We have patched the issue in GitHub commit 136b51f10903e044308cf77117c0ed9871350475. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37674",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37675",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions most implementations of convolution operators in TensorFlow are affected by a division by 0 vulnerability where an attacker can trigger a denial of service via a crash. The shape inference [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/framework/common_shape_fns.cc#L577) is missing several validations before doing divisions and modulo operations. We have patched the issue in GitHub commit 8a793b5d7f59e37ac7f3cd0954a750a2fe76bad4. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37675",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37676",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.SparseFillEmptyRows`. The shape inference [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/ops/sparse_ops.cc#L608-L634) does not validate that the input arguments are not empty tensors. We have patched the issue in GitHub commit 578e634b4f1c1c684d4b4294f9e5281b2133b3ed. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37676",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37677",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the shape inference code for `tf.raw_ops.Dequantize` has a vulnerability that could trigger a denial of service via a segfault if an attacker provides invalid arguments. The shape inference [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/ops/array_ops.cc#L2999-L3014) uses `axis` to select between two different values for `minmax_rank` which is then used to retrieve tensor dimensions. However, code assumes that `axis` can be either `-1` or a value greater than `-1`, with no validation for the other values. We have patched the issue in GitHub commit da857cfa0fde8f79ad0afdbc94e88b5d4bbec764. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37677",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37678",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions TensorFlow and Keras can be tricked to perform arbitrary code execution when deserializing a Keras model from YAML format. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/python/keras/saving/model_config.py#L66-L104) uses `yaml.unsafe_load` which can perform arbitrary code execution on the input. Given that YAML format support requires a significant amount of work, we have removed it for now. We have patched the issue in GitHub commit 23d6383eb6c14084a8fc3bdf164043b974818012. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37678",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37679",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions it is possible to nest a `tf.map_fn` within another `tf.map_fn` call. However, if the input tensor is a `RaggedTensor` and there is no function signature provided, code assumes the output is a fully specified tensor and fills output buffer with uninitialized contents from the heap. The `t` and `z` outputs should be identical, however this is not the case. The last row of `t` contains data from the heap which can be used to leak other memory information. The bug lies in the conversion from a `Variant` tensor to a `RaggedTensor`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/ragged_tensor_from_variant_op.cc#L177-L190) does not check that all inner shapes match and this results in the additional dimensions. The same implementation can result in data loss, if input tensor is tweaked. We have patched the issue in GitHub commit 4e2565483d0ffcadc719bd44893fb7f609bb5f12. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37679",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37680",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of fully connected layers in TFLite is [vulnerable to a division by zero error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/fully_connected.cc#L226). We have patched the issue in GitHub commit 718721986aa137691ee23f03638867151f74935f. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37680",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37681",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of SVDF in TFLite is [vulnerable to a null pointer error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/svdf.cc#L300-L313). The [`GetVariableInput` function](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/kernel_util.cc#L115-L119) can return a null pointer but `GetTensorData` assumes that the argument is always a valid tensor. Furthermore, because `GetVariableInput` calls [`GetMutableInput`](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/kernel_util.cc#L82-L90) which might return `nullptr`, the `tensor->is_variable` expression can also trigger a null pointer exception. We have patched the issue in GitHub commit 5b048e87e4e55990dae6b547add4dae59f4e1c76. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37681",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37682",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions all TFLite operations that use quantization can be made to use unitialized values. [For example](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/depthwise_conv.cc#L198-L200). The issue stems from the fact that `quantization.params` is only valid if `quantization.type` is different that `kTfLiteNoQuantization`. However, these checks are missing in large parts of the code. We have patched the issue in GitHub commits 537bc7c723439b9194a358f64d871dd326c18887, 4a91f2069f7145aab6ba2d8cfe41be8a110c18a5 and 8933b8a21280696ab119b63263babdb54c298538. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37682",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37683",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of division in TFLite is [vulnerable to a division by 0 error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/div.cc). There is no check that the divisor tensor does not contain zero elements. We have patched the issue in GitHub commit 1e206baedf8bef0334cca3eb92bab134ef525a28. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37683",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37684",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementations of pooling in TFLite are vulnerable to division by 0 errors as there are no checks for divisors not being 0. We have patched the issue in GitHub commit [dfa22b348b70bb89d6d6ec0ff53973bacb4f4695](https://github.com/tensorflow/tensorflow/commit/dfa22b348b70bb89d6d6ec0ff53973bacb4f4695). The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37684",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37685",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions TFLite's [`expand_dims.cc`](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/expand_dims.cc#L36-L50) contains a vulnerability which allows reading one element outside of bounds of heap allocated data. If `axis` is a large negative value (e.g., `-100000`), then after the first `if` it would still be negative. The check following the `if` statement will pass and the `for` loop would read one element before the start of `input_dims.data` (when `i = 0`). We have patched the issue in GitHub commit d94ffe08a65400f898241c0374e9edc6fa8ed257. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37685",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37686",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the strided slice implementation in TFLite has a logic bug which can allow an attacker to trigger an infinite loop. This arises from newly introduced support for [ellipsis in axis definition](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/strided_slice.cc#L103-L122). An attacker can craft a model such that `ellipsis_end_idx` is smaller than `i` (e.g., always negative). In this case, the inner loop does not increase `i` and the `continue` statement causes execution to skip over the preincrement at the end of the outer loop. We have patched the issue in GitHub commit dfa22b348b70bb89d6d6ec0ff53973bacb4f4695. TensorFlow 2.6.0 is the only affected version.",
      "cve": "CVE-2021-37686",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37687",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions TFLite's [`GatherNd` implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/gather_nd.cc#L124) does not support negative indices but there are no checks for this situation. Hence, an attacker can read arbitrary data from the heap by carefully crafting a model with negative values in `indices`. Similar issue exists in [`Gather` implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/gather.cc). We have patched the issue in GitHub commits bb6a0383ed553c286f87ca88c207f6774d5c4a8f and eb921122119a6b6e470ee98b89e65d721663179d. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37687",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37688",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can craft a TFLite model that would trigger a null pointer dereference, which would result in a crash and denial of service. The [implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/internal/optimized/optimized_ops.h#L268-L285) unconditionally dereferences a pointer. We have patched the issue in GitHub commit 15691e456c7dc9bd6be203b09765b063bf4a380c. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37688",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37689",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can craft a TFLite model that would trigger a null pointer dereference, which would result in a crash and denial of service. This is caused by the MLIR optimization of `L2NormalizeReduceAxis` operator. The [implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/compiler/mlir/lite/transforms/optimize.cc#L67-L70) unconditionally dereferences a pointer to an iterator to a vector without checking that the vector has elements. We have patched the issue in GitHub commit d6b57f461b39fd1aa8c1b870f1b974aac3554955. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37689",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37690",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions when running shape functions, some functions (such as `MutableHashTableShape`) produce extra output information in the form of a `ShapeAndType` struct. The shapes embedded in this struct are owned by an inference context that is cleaned up almost immediately; if the upstream code attempts to access this shape information, it can trigger a segfault. `ShapeRefiner` is mitigating this for normal output shapes by cloning them (and thus putting the newly created shape under ownership of an inference context that will not die), but we were not doing the same for shapes and types. This commit fixes that by doing similar logic on output shapes and types. We have patched the issue in GitHub commit ee119d4a498979525046fba1c3dd3f13a039fbb1. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37690",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37691",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can craft a TFLite model that would trigger a division by zero error in LSH [implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/lsh_projection.cc#L118). We have patched the issue in GitHub commit 0575b640091680cfb70f4dd93e70658de43b94f9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick thiscommit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37691",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-37692",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions under certain conditions, Go code can trigger a segfault in string deallocation. For string tensors, `C.TF_TString_Dealloc` is called during garbage collection within a finalizer function. However, tensor structure isn't checked until encoding to avoid a performance penalty. The current method for dealloc assumes that encoding succeeded, but segfaults when a string tensor is garbage collected whose encoding failed (e.g., due to mismatched dimensions). To fix this, the call to set the finalizer function is deferred until `NewTensor` returns and, if encoding failed for a string tensor, deallocs are determined based on bytes written. We have patched the issue in GitHub commit 8721ba96e5760c229217b594f6d2ba332beedf22. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, which is the other affected version.",
      "cve": "CVE-2021-37692",
      "specs": [
        ">=2.5.0,<2.6.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41195",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `tf.math.segment_*` operations results in a `CHECK`-fail related abort (and denial of service) if a segment id in `segment_ids` is large. This is similar to CVE-2021-29584 (and similar other reported vulnerabilities in TensorFlow, localized to specific APIs): the implementation (both on CPU and GPU) computes the output shape using `AddDim`. However, if the number of elements in the tensor overflows an `int64_t` value, `AddDim` results in a `CHECK` failure which provokes a `std::abort`. Instead, code should use `AddDimWithStatus`. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41195",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41196",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the Keras pooling layers can trigger a segfault if the size of the pool is 0 or if a dimension is negative. This is due to the TensorFlow's implementation of pooling operations where the values in the sliding window are not checked to be strictly positive. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41196",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41197",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions TensorFlow allows tensor to have a large number of dimensions and each dimension can be as large as desired. However, the total number of elements in a tensor must fit within an `int64_t`. If an overflow occurs, `MultiplyWithoutOverflow` would return a negative result. In the majority of TensorFlow codebase this then results in a `CHECK`-failure. Newer constructs exist which return a `Status` instead of crashing the binary. This is similar to CVE-2021-29584. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41197",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41198",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions if `tf.tile` is called with a large input argument then the TensorFlow process will crash due to a `CHECK`-failure caused by an overflow. The number of elements in the output tensor is too much for the `int64_t` type and the overflow is detected via a `CHECK` statement. This aborts the process. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41198",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41199",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions if `tf.image.resize` is called with a large input argument then the TensorFlow process will crash due to a `CHECK`-failure caused by an overflow. The number of elements in the output tensor is too much for the `int64_t` type and the overflow is detected via a `CHECK` statement. This aborts the process. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41199",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41200",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions if `tf.summary.create_file_writer` is called with non-scalar arguments code crashes due to a `CHECK`-fail. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41200",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41201",
      "advisory": "TensorFlow is an open source platform for machine learning. In affeced versions during execution, `EinsumHelper::ParseEquation()` is supposed to set the flags in `input_has_ellipsis` vector and `*output_has_ellipsis` boolean to indicate whether there is ellipsis in the corresponding inputs and output. However, the code only changes these flags to `true` and never assigns `false`. This results in unitialized variable access if callers assume that `EinsumHelper::ParseEquation()` always sets these flags. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41201",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41202",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions while calculating the size of the output within the `tf.range` kernel, there is a conditional statement of type `int64 = condition ? int64 : double`. Due to C++ implicit conversion rules, both branches of the condition will be cast to `double` and the result would be truncated before the assignment. This result in overflows. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41202",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41203",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions an attacker can trigger undefined behavior, integer overflows, segfaults and `CHECK`-fail crashes if they can change saved checkpoints from outside of TensorFlow. This is because the checkpoints loading infrastructure is missing validation for invalid file formats. The fixes will be included in TensorFlow 2.7.0. We will also cherrypick these commits on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41203",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41204",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions during TensorFlow's Grappler optimizer phase, constant folding might attempt to deep copy a resource tensor. This results in a segfault, as these tensors are supposed to not change. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41204",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41205",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference functions for the `QuantizeAndDequantizeV*` operations can trigger a read outside of bounds of heap allocated array. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41205",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41206",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions several TensorFlow operations are missing validation for the shapes of the tensor arguments involved in the call. Depending on the API, this can result in undefined behavior and segfault or `CHECK`-fail related crashes but in some scenarios writes and reads from heap populated arrays are also possible. We have discovered these issues internally via tooling while working on improving/testing GPU op determinism. As such, we don't have reproducers and there will be multiple fixes for these issues. These fixes will be included in TensorFlow 2.7.0. We will also cherrypick these commits on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41206",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41207",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `ParallelConcat` misses some input validation and can produce a division by 0. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41207",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41208",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the code for boosted trees in TensorFlow is still missing validation. As a result, attackers can trigger denial of service (via dereferencing `nullptr`s or via `CHECK`-failures) as well as abuse undefined behavior (binding references to `nullptr`s). An attacker can also read and write from heap buffers, depending on the API that gets used and the arguments that are passed to the call. Given that the boosted trees implementation in TensorFlow is unmaintained, it is recommend to no longer use these APIs. We will deprecate TensorFlow's boosted trees APIs in subsequent releases. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41208",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41209",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementations for convolution operators trigger a division by 0 if passed empty filter tensor arguments. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41209",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41210",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference functions for `SparseCountSparseOutput` can trigger a read outside of bounds of heap allocated array. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41210",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41211",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `QuantizeV2` can trigger a read outside of bounds of heap allocated array. This occurs whenever `axis` is a negative value less than `-1`. In this case, we are accessing data before the start of a heap buffer. The code allows `axis` to be an optional argument (`s` would contain an `error::NOT_FOUND` error code). Otherwise, it assumes that `axis` is a valid index into the dimensions of the `input` tensor. If `axis` is less than `-1` then this results in a heap OOB read. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, as this version is the only one that is also affected.",
      "cve": "CVE-2021-41211",
      "specs": [
        "==2.6.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41212",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `tf.ragged.cross` can trigger a read outside of bounds of heap allocated array. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41212",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41213",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the code behind `tf.function` API can be made to deadlock when two `tf.function` decorated Python functions are mutually recursive. This occurs due to using a non-reentrant `Lock` Python object. Loading any model which contains mutually recursive functions is vulnerable. An attacker can cause denial of service by causing users to load such models and calling a recursive `tf.function`, although this is not a frequent scenario. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41213",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41214",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `tf.ragged.cross` has an undefined behavior due to binding a reference to `nullptr`. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41214",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41215",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `DeserializeSparse` can trigger a null pointer dereference. This is because the shape inference function assumes that the `serialize_sparse` tensor is a tensor with positive rank (and having `3` as the last dimension). The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41215",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41216",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference function for `Transpose` is vulnerable to a heap buffer overflow. This occurs whenever `perm` contains negative elements. The shape inference function does not validate that the indices in `perm` are all valid. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41216",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41217",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the process of building the control flow graph for a TensorFlow model is vulnerable to a null pointer exception when nodes that should be paired are not. This occurs because the code assumes that the first node in the pairing (e.g., an `Enter` node) always exists when encountering the second node (e.g., an `Exit` node). When this is not the case, `parent` is `nullptr` so dereferencing it causes a crash. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41217",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41218",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `AllToAll` can be made to execute a division by 0. This occurs whenever the `split_count` argument is 0. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41218",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41219",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the code for sparse matrix multiplication is vulnerable to undefined behavior via binding a reference to `nullptr`. This occurs whenever the dimensions of `a` or `b` are 0 or less. In the case on one of these is 0, an empty output tensor should be allocated (to conserve the invariant that output tensors are always allocated when the operation is successful) but nothing should be written to it (that is, we should return early from the kernel implementation). Otherwise, attempts to write to this empty tensor would result in heap OOB access. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41219",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41220",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the async implementation of `CollectiveReduceV2` suffers from a memory leak and a use after free. This occurs due to the asynchronous computation and the fact that objects that have been `std::move()`d from are still accessed. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, as this version is the only one that is also affected.",
      "cve": "CVE-2021-41220",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41221",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for the `Cudnn*` operations in TensorFlow can be tricked into accessing invalid memory, via a heap buffer overflow. This occurs because the ranks of the `input`, `input_h` and `input_c` parameters are not validated, but code assumes they have certain values. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41221",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41222",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `SplitV` can trigger a segfault is an attacker supplies negative arguments. This occurs whenever `size_splits` contains more than one value and at least one value is negative. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41222",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41223",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `FusedBatchNorm` kernels is vulnerable to a heap OOB access. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41223",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41224",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `SparseFillEmptyRows` can be made to trigger a heap OOB access. This occurs whenever the size of `indices` does not match the size of `values`. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41224",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41225",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions TensorFlow's Grappler optimizer has a use of unitialized variable. If the `train_nodes` vector (obtained from the saved model that gets optimized) does not contain a `Dequeue` node, then `dequeue_node` is left unitialized. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41225",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41226",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `SparseBinCount` is vulnerable to a heap OOB access. This is because of missing validation between the elements of the `values` argument and the shape of the sparse output. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41226",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41227",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the `ImmutableConst` operation in TensorFlow can be tricked into reading arbitrary memory contents. This is because the `tstring` TensorFlow string class has a special case for memory mapped strings but the operation itself does not offer any support for this datatype. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41227",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow:CVE-2021-41228",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions TensorFlow's `saved_model_cli` tool is vulnerable to a code injection as it calls `eval` on user supplied strings. This can be used by attackers to run arbitrary code on the plaform where the CLI tool runs. However, given that the tool is always run manually, the impact of this is not severe. We have patched this by adding a `safe` flag which defaults to `True` and an explicit warning for users. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41228",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    }
  ],
  "tensorflow-cpu": [
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2018-10055",
      "advisory": "Invalid memory access and/or a heap buffer overflow in the TensorFlow XLA compiler in Google TensorFlow before 1.7.1 could cause a crash or read from other parts of process memory via a crafted configuration file.",
      "cve": "CVE-2018-10055",
      "specs": [
        "<1.7.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2018-21233",
      "advisory": "TensorFlow before 1.7.0 has an integer overflow that causes an out-of-bounds read, possibly causing disclosure of the contents of process memory. This occurs in the DecodeBmp feature of the BMP decoder in core/kernels/decode_bmp_op.cc.",
      "cve": "CVE-2018-21233",
      "specs": [
        "<1.7.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2018-7575",
      "advisory": "Google TensorFlow 1.7.x and earlier is affected by a Buffer Overflow vulnerability. The type of exploitation is context-dependent.",
      "cve": "CVE-2018-7575",
      "specs": [
        "<=1.7.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2018-7576",
      "advisory": "Google TensorFlow 1.6.x and earlier is affected by: Null Pointer Dereference. The type of exploitation is: context-dependent.",
      "cve": "CVE-2018-7576",
      "specs": [
        "<=1.6.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2018-7577",
      "advisory": "Memcpy parameter overlap in Google Snappy library 1.1.4, as used in Google TensorFlow before 1.7.1, could result in a crash or read from other parts of process memory.",
      "cve": "CVE-2018-7577",
      "specs": [
        "<1.7.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2018-8825",
      "advisory": "Google TensorFlow 1.7 and below is affected by: Buffer Overflow. The impact is: execute arbitrary code (local).",
      "cve": "CVE-2018-8825",
      "specs": [
        "<=1.7.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2019-16778",
      "advisory": "In TensorFlow before 1.15, a heap buffer overflow in UnsortedSegmentSum can be produced when the Index template argument is int32. In this case data_size and num_segments fields are truncated from int64 to int32 and can produce negative numbers, resulting in accessing out of bounds heap memory. This is unlikely to be exploitable and was detected and fixed internally in TensorFlow 1.15 and 2.0.",
      "cve": "CVE-2019-16778",
      "specs": [
        ">=1.0.0,<1.15.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2019-9635",
      "advisory": "NULL pointer dereference in Google TensorFlow before 1.12.2 could cause a denial of service via an invalid GIF file.",
      "cve": "CVE-2019-9635",
      "specs": [
        "<1.12.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15190",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `tf.raw_ops.Switch` operation takes as input a tensor and a boolean and outputs two tensors. Depending on the boolean value, one of the tensors is exactly the input tensor whereas the other one should be an empty tensor. However, the eager runtime traverses all tensors in the output. Since only one of the tensors is defined, the other one is `nullptr`, hence we are binding a reference to `nullptr`. This is undefined behavior and reported as an error if compiling with `-fsanitize=null`. In this case, this results in a segmentation fault The issue is patched in commit da8558533d925694483d2c136a9220d6d49d843c, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15190",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15191",
      "advisory": "In Tensorflow before versions 2.2.1 and 2.3.1, if a user passes an invalid argument to `dlpack.to_dlpack` the expected validations will cause variables to bind to `nullptr` while setting a `status` variable to the error condition. However, this `status` argument is not properly checked. Hence, code following these methods will bind references to null pointers. This is undefined behavior and reported as an error if compiling with `-fsanitize=null`. The issue is patched in commit 22e07fb204386768e5bcbea563641ea11f96ceb8 and is released in TensorFlow versions 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15191",
      "specs": [
        "==2.2.0",
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15192",
      "advisory": "In Tensorflow before versions 2.2.1 and 2.3.1, if a user passes a list of strings to `dlpack.to_dlpack` there is a memory leak following an expected validation failure. The issue occurs because the `status` argument during validation failures is not properly checked. Since each of the above methods can return an error status, the `status` value must be checked before continuing. The issue is patched in commit 22e07fb204386768e5bcbea563641ea11f96ceb8 and is released in TensorFlow versions 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15192",
      "specs": [
        "==2.2.0",
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15193",
      "advisory": "In Tensorflow before versions 2.2.1 and 2.3.1, the implementation of `dlpack.to_dlpack` can be made to use uninitialized memory resulting in further memory corruption. This is because the pybind11 glue code assumes that the argument is a tensor. However, there is nothing stopping users from passing in a Python object instead of a tensor. The uninitialized memory address is due to a `reinterpret_cast` Since the `PyObject` is a Python object, not a TensorFlow Tensor, the cast to `EagerTensor` fails. The issue is patched in commit 22e07fb204386768e5bcbea563641ea11f96ceb8 and is released in TensorFlow versions 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15193",
      "specs": [
        "==2.2.0",
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15194",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `SparseFillEmptyRowsGrad` implementation has incomplete validation of the shapes of its arguments. Although `reverse_index_map_t` and `grad_values_t` are accessed in a similar pattern, only `reverse_index_map_t` is validated to be of proper shape. Hence, malicious users can pass a bad `grad_values_t` to trigger an assertion failure in `vec`, causing denial of service in serving installations. The issue is patched in commit 390611e0d45c5793c7066110af37c8514e6a6c54, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.\"",
      "cve": "CVE-2020-15194",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15195",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the implementation of `SparseFillEmptyRowsGrad` uses a double indexing pattern. It is possible for `reverse_index_map(i)` to be an index outside of bounds of `grad_values`, thus resulting in a heap buffer overflow. The issue is patched in commit 390611e0d45c5793c7066110af37c8514e6a6c54, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15195",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15196",
      "advisory": "In Tensorflow version 2.3.0, the `SparseCountSparseOutput` and `RaggedCountSparseOutput` implementations don't validate that the `weights` tensor has the same shape as the data. The check exists for `DenseCountSparseOutput`, where both tensors are fully specified. In the sparse and ragged count weights are still accessed in parallel with the data. But, since there is no validation, a user passing fewer weights than the values for the tensors can generate a read from outside the bounds of the heap buffer allocated for the weights. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15196",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15197",
      "advisory": "In Tensorflow before version 2.3.1, the `SparseCountSparseOutput` implementation does not validate that the input arguments form a valid sparse tensor. In particular, there is no validation that the `indices` tensor has rank 2. This tensor must be a matrix because code assumes its elements are accessed as elements of a matrix. However, malicious users can pass in tensors of different rank, resulting in a `CHECK` assertion failure and a crash. This can be used to cause denial of service in serving installations, if users are allowed to control the components of the input sparse tensor. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15197",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15198",
      "advisory": "In Tensorflow before version 2.3.1, the `SparseCountSparseOutput` implementation does not validate that the input arguments form a valid sparse tensor. In particular, there is no validation that the `indices` tensor has the same shape as the `values` one. The values in these tensors are always accessed in parallel. Thus, a shape mismatch can result in accesses outside the bounds of heap allocated buffers. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15198",
      "specs": [
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15199",
      "advisory": "In Tensorflow before version 2.3.1, the `RaggedCountSparseOutput` does not validate that the input arguments form a valid ragged tensor. In particular, there is no validation that the `splits` tensor has the minimum required number of elements. Code uses this quantity to initialize a different data structure. Since `BatchedMap` is equivalent to a vector, it needs to have at least one element to not be `nullptr`. If user passes a `splits` tensor that is empty or has exactly one element, we get a `SIGABRT` signal raised by the operating system. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15199",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15200",
      "advisory": "In Tensorflow before version 2.3.1, the `RaggedCountSparseOutput` implementation does not validate that the input arguments form a valid ragged tensor. In particular, there is no validation that the values in the `splits` tensor generate a valid partitioning of the `values` tensor. Thus, the code sets up conditions to cause a heap buffer overflow. A `BatchedMap` is equivalent to a vector where each element is a hashmap. However, if the first element of `splits_values` is not 0, `batch_idx` will never be 1, hence there will be no hashmap at index 0 in `per_batch_counts`. Trying to access that in the user code results in a segmentation fault. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15200",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15201",
      "advisory": "In Tensorflow before version 2.3.1, the `RaggedCountSparseOutput` implementation does not validate that the input arguments form a valid ragged tensor. In particular, there is no validation that the values in the `splits` tensor generate a valid partitioning of the `values` tensor. Hence, the code is prone to heap buffer overflow. If `split_values` does not end with a value at least `num_values` then the `while` loop condition will trigger a read outside of the bounds of `split_values` once `batch_idx` grows too large. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15201",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15202",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `Shard` API in TensorFlow expects the last argument to be a function taking two `int64` (i.e., `long long`) arguments. However, there are several places in TensorFlow where a lambda taking `int` or `int32` arguments is being used. In these cases, if the amount of work to be parallelized is large enough, integer truncation occurs. Depending on how the two arguments of the lambda are used, this can result in segfaults, read/write outside of heap allocated arrays, stack overflows, or data corruption. The issue is patched in commits 27b417360cbd671ef55915e4bb6bb06af8b8a832 and ca8c013b5e97b1373b3bb1c97ea655e69f31a575, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15202",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15203",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, by controlling the `fill` argument of tf.strings.as_string, a malicious attacker is able to trigger a format string vulnerability due to the way the internal format use in a `printf` call is constructed. This may result in segmentation fault. The issue is patched in commit 33be22c65d86256e6826666662e40dbdfe70ee83, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15203",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15204",
      "advisory": "In eager mode, TensorFlow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1 does not set the session state. Hence, calling `tf.raw_ops.GetSessionHandle` or `tf.raw_ops.GetSessionHandleV2` results in a null pointer dereference In linked snippet, in eager mode, `ctx->session_state()` returns `nullptr`. Since code immediately dereferences this, we get a segmentation fault. The issue is patched in commit 9a133d73ae4b4664d22bd1aa6d654fec13c52ee1, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15204",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15205",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `data_splits` argument of `tf.raw_ops.StringNGrams` lacks validation. This allows a user to pass values that can cause heap overflow errors and even leak contents of memory In the linked code snippet, all the binary strings after `ee ff` are contents from the memory stack. Since these can contain return addresses, this data leak can be used to defeat ASLR. The issue is patched in commit 0462de5b544ed4731aa2fb23946ac22c01856b80, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15205",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15206",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, changing the TensorFlow's `SavedModel` protocol buffer and altering the name of required keys results in segfaults and data corruption while loading the model. This can cause a denial of service in products using `tensorflow-serving` or other inference-as-a-service installments. Fixed were added in commits f760f88b4267d981e13f4b302c437ae800445968 and fcfef195637c6e365577829c4d67681695956e7d (both going into TensorFlow 2.2.0 and 2.3.0 but not yet backported to earlier versions). However, this was not enough, as #41097 reports a different failure mode. The issue is patched in commit adf095206f25471e864a8e63a0f1caef53a0e3a6, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15206",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15207",
      "advisory": "In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, to mimic Python's indexing with negative values, TFLite uses `ResolveAxis` to convert negative values to positive indices. However, the only check that the converted index is now valid is only present in debug builds. If the `DCHECK` does not trigger, then code execution moves ahead with a negative index. This, in turn, results in accessing data out of bounds which results in segfaults and/or data corruption. The issue is patched in commit 2d88f470dea2671b430884260f3626b1fe99830a, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15207",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15208",
      "advisory": "In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, when determining the common dimension size of two tensors, TFLite uses a `DCHECK` which is no-op outside of debug compilation modes. Since the function always returns the dimension of the first tensor, malicious attackers can craft cases where this is larger than that of the second tensor. In turn, this would result in reads/writes outside of bounds since the interpreter will wrongly assume that there is enough data in both tensors. The issue is patched in commit 8ee24e7949a203d234489f9da2c5bf45a7d5157d, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15208",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15209",
      "advisory": "In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, a crafted TFLite model can force a node to have as input a tensor backed by a `nullptr` buffer. This can be achieved by changing a buffer index in the flatbuffer serialization to convert a read-only tensor to a read-write one. The runtime assumes that these buffers are written to before a possible read, hence they are initialized with `nullptr`. However, by changing the buffer index for a tensor and implicitly converting that tensor to be a read-write one, as there is nothing in the model that writes to it, we get a null pointer dereference. The issue is patched in commit 0b5662bc, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15209",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15210",
      "advisory": "In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, if a TFLite saved model uses the same tensor as both input and output of an operator, then, depending on the operator, we can observe a segmentation fault or just memory corruption. We have patched the issue in d58c96946b and will release patch releases for all versions between 1.15 and 2.3. We recommend users to upgrade to TensorFlow 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15210",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15211",
      "advisory": "In TensorFlow Lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, saved models in the flatbuffer format use a double indexing scheme: a model has a set of subgraphs, each subgraph has a set of operators and each operator has a set of input/output tensors. The flatbuffer format uses indices for the tensors, indexing into an array of tensors that is owned by the subgraph. This results in a pattern of double array indexing when trying to get the data of each tensor. However, some operators can have some tensors be optional. To handle this scenario, the flatbuffer model uses a negative `-1` value as index for these tensors. This results in special casing during validation at model loading time. Unfortunately, this means that the `-1` index is a valid tensor index for any operator, including those that don't expect optional inputs and including for output tensors. Thus, this allows writing and reading from outside the bounds of heap allocated arrays, although only at a specific offset from the start of these arrays. This results in both read and write gadgets, albeit very limited in scope. The issue is patched in several commits (46d5b0852, 00302787b7, e11f5558, cd31fd0ce, 1970c21, and fff2c83), and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to the model loading code to ensure that only operators which accept optional inputs use the `-1` special value and only for the tensors that they expect to be optional. Since this allow-list type approach is erro-prone, we advise upgrading to the patched code.",
      "cve": "CVE-2020-15211",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15212",
      "advisory": "In TensorFlow Lite before versions 2.2.1 and 2.3.1, models using segment sum can trigger writes outside of bounds of heap allocated buffers by inserting negative elements in the segment ids tensor. Users having access to `segment_ids_data` can alter `output_index` and then write to outside of `output_data` buffer. This might result in a segmentation fault but it can also be used to further corrupt the memory and can be chained with other vulnerabilities to create more advanced exploits. The issue is patched in commit 204945b19e44b57906c9344c0d00120eeeae178a and is released in TensorFlow versions 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to the model loading code to ensure that the segment ids are all positive, although this only handles the case when the segment ids are stored statically in the model. A similar validation could be done if the segment ids are generated at runtime between inference steps. If the segment ids are generated as outputs of a tensor during inference steps, then there are no possible workaround and users are advised to upgrade to patched code.",
      "cve": "CVE-2020-15212",
      "specs": [
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15213",
      "advisory": "In TensorFlow Lite before versions 2.2.1 and 2.3.1, models using segment sum can trigger a denial of service by causing an out of memory allocation in the implementation of segment sum. Since code uses the last element of the tensor holding them to determine the dimensionality of output tensor, attackers can use a very large value to trigger a large allocation. The issue is patched in commit 204945b19e44b57906c9344c0d00120eeeae178a and is released in TensorFlow versions 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to limit the maximum value in the segment ids tensor. This only handles the case when the segment ids are stored statically in the model, but a similar validation could be done if the segment ids are generated at runtime, between inference steps. However, if the segment ids are generated as outputs of a tensor during inference steps, then there are no possible workaround and users are advised to upgrade to patched code.",
      "cve": "CVE-2020-15213",
      "specs": [
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15214",
      "advisory": "In TensorFlow Lite before versions 2.2.1 and 2.3.1, models using segment sum can trigger a write out bounds / segmentation fault if the segment ids are not sorted. Code assumes that the segment ids are in increasing order, using the last element of the tensor holding them to determine the dimensionality of output tensor. This results in allocating insufficient memory for the output tensor and in a write outside the bounds of the output array. This usually results in a segmentation fault, but depending on runtime conditions it can provide for a write gadget to be used in future memory corruption-based exploits. The issue is patched in commit 204945b19e44b57906c9344c0d00120eeeae178a and is released in TensorFlow versions 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to the model loading code to ensure that the segment ids are sorted, although this only handles the case when the segment ids are stored statically in the model. A similar validation could be done if the segment ids are generated at runtime between inference steps. If the segment ids are generated as outputs of a tensor during inference steps, then there are no possible workaround and users are advised to upgrade to patched code.",
      "cve": "CVE-2020-15214",
      "specs": [
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15265",
      "advisory": "In Tensorflow before version 2.4.0, an attacker can pass an invalid `axis` value to `tf.quantization.quantize_and_dequantize`. This results in accessing a dimension outside the rank of the input tensor in the C++ kernel implementation. However, dim_size only does a DCHECK to validate the argument and then uses it to access the corresponding element of an array. Since in normal builds, `DCHECK`-like macros are no-ops, this results in segfault and access out of bounds of the array. The issue is patched in eccb7ec454e6617738554a255d77f08e60ee0808 and TensorFlow 2.4.0 will be released containing the patch. TensorFlow nightly packages after this commit will also have the issue resolved.",
      "cve": "CVE-2020-15265",
      "specs": [
        "<2.4.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-15266",
      "advisory": "In Tensorflow before version 2.4.0, when the `boxes` argument of `tf.image.crop_and_resize` has a very large value, the CPU kernel implementation receives it as a C++ `nan` floating point value. Attempting to operate on this is undefined behavior which later produces a segmentation fault. The issue is patched in eccb7ec454e6617738554a255d77f08e60ee0808 and TensorFlow 2.4.0 will be released containing the patch. TensorFlow nightly packages after this commit will also have the issue resolved.",
      "cve": "CVE-2020-15266",
      "specs": [
        "<2.4.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-26266",
      "advisory": "In affected versions of TensorFlow under certain cases a saved model can trigger use of uninitialized values during code execution. This is caused by having tensor buffers be filled with the default value of the type but forgetting to default initialize the quantized floating point types in Eigen. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26266",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-26267",
      "advisory": "In affected versions of TensorFlow the tf.raw_ops.DataFormatVecPermute API does not validate the src_format and dst_format attributes. The code assumes that these two arguments define a permutation of NHWC. This can result in uninitialized memory accesses, read outside of bounds and even crashes. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26267",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-26268",
      "advisory": "In affected versions of TensorFlow the tf.raw_ops.ImmutableConst operation returns a constant tensor created from a memory mapped file which is assumed immutable. However, if the type of the tensor is not an integral type, the operation crashes the Python interpreter as it tries to write to the memory area. If the file is too small, TensorFlow properly returns an error as the memory area has fewer bytes than what is needed for the tensor it creates. However, as soon as there are enough bytes, the above snippet causes a segmentation fault. This is because the allocator used to return the buffer data is not marked as returning an opaque handle since the needed virtual method is not overridden. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26268",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-26269",
      "advisory": "In TensorFlow release candidate versions 2.4.0rc*, the general implementation for matching filesystem paths to globbing pattern is vulnerable to an access out of bounds of the array holding the directories. There are multiple invariants and preconditions that are assumed by the parallel implementation of GetMatchingPaths but are not verified by the PRs introducing it (#40861 and #44310). Thus, we are completely rewriting the implementation to fully specify and validate these. This is patched in version 2.4.0. This issue only impacts master branch and the release candidates for TF version 2.4. The final release of the 2.4 release will be patched.",
      "cve": "CVE-2020-26269",
      "specs": [
        "==2.4.0-rc0",
        "==2.4.0-rc1",
        "==2.4.0-rc2",
        "==2.4.0-rc3",
        "==2.4.0-rc4"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-26270",
      "advisory": "In affected versions of TensorFlow running an LSTM/GRU model where the LSTM/GRU layer receives an input with zero-length results in a CHECK failure when using the CUDA backend. This can result in a query-of-death vulnerability, via denial of service, if users can control the input to the layer. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26270",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-26271",
      "advisory": "In affected versions of TensorFlow under certain cases, loading a saved model can result in accessing uninitialized memory while building the computation graph. The MakeEdge function creates an edge between one output tensor of the src node (given by output_index) and the input slot of the dst node (given by input_index). This is only possible if the types of the tensors on both sides coincide, so the function begins by obtaining the corresponding DataType values and comparing these for equality. However, there is no check that the indices point to inside of the arrays they index into. Thus, this can result in accessing data out of bounds of the corresponding heap allocated arrays. In most scenarios, this can manifest as unitialized data access, but if the index points far away from the boundaries of the arrays this can be used to leak addresses from the library. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26271",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2020-5215",
      "advisory": "In TensorFlow before 1.15.2 and 2.0.1, converting a string (from Python) to a tf.float16 value results in a segmentation fault in eager mode as the format checks for this use case are only in the graph mode. This issue can lead to denial of service in inference/training where a malicious attacker can send a data point which contains a string instead of a tf.float16 value. Similar effects can be obtained by manipulating saved models and checkpoints whereby replacing a scalar tf.float16 value with a scalar string will trigger this issue due to automatic conversions. This can be easily reproduced by tf.constant(\"hello\", tf.float16), if eager execution is enabled. This issue is patched in TensorFlow 1.15.1 and 2.0.1 with this vulnerability patched. TensorFlow 2.1.0 was released after we fixed the issue, thus it is not affected. Users are encouraged to switch to TensorFlow 1.15.1, 2.0.1 or 2.1.0.",
      "cve": "CVE-2020-5215",
      "specs": [
        "<1.15.2",
        ">=2.0.0,<2.0.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29512",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. If the `splits` argument of `RaggedBincount` does not specify a valid `SparseTensor`(https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor), then an attacker can trigger a heap buffer overflow. This will cause a read from outside the bounds of the `splits` tensor buffer in the implementation of the `RaggedBincount` op(https://github.com/tensorflow/tensorflow/blob/8b677d79167799f71c42fd3fa074476e0295413a/tensorflow/core/kernels/bincount_op.cc#L430-L433). Before the `for` loop, `batch_idx` is set to 0. The user controls the `splits` array, making it contain only one element, 0. Thus, the code in the `while` loop would increment `batch_idx` and then try to read `splits(1)`, which is outside of bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3, as these are also affected.",
      "cve": "CVE-2021-29512",
      "specs": [
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29513",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Calling TF operations with tensors of non-numeric types when the operations expect numeric tensors result in null pointer dereferences. The conversion from Python array to C++ array(https://github.com/tensorflow/tensorflow/blob/ff70c47a396ef1e3cb73c90513da4f5cb71bebba/tensorflow/python/lib/core/ndarray_tensor.cc#L113-L169) is vulnerable to a type confusion. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29513",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29514",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. If the `splits` argument of `RaggedBincount` does not specify a valid `SparseTensor`(https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor), then an attacker can trigger a heap buffer overflow. This will cause a read from outside the bounds of the `splits` tensor buffer in the implementation of the `RaggedBincount` op(https://github.com/tensorflow/tensorflow/blob/8b677d79167799f71c42fd3fa074476e0295413a/tensorflow/core/kernels/bincount_op.cc#L430-L446). Before the `for` loop, `batch_idx` is set to 0. The attacker sets `splits(0)` to be 7, hence the `while` loop does not execute and `batch_idx` remains 0. This then results in writing to `out(-1, bin)`, which is before the heap allocated buffer for the output tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3, as these are also affected.",
      "cve": "CVE-2021-29514",
      "specs": [
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29515",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `MatrixDiag*` operations(https://github.com/tensorflow/tensorflow/blob/4c4f420e68f1cfaf8f4b6e8e3eb857e9e4c3ff33/tensorflow/core/kernels/linalg/matrix_diag_op.cc#L195-L197) does not validate that the tensor arguments are non-empty. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29515",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29516",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Calling `tf.raw_ops.RaggedTensorToVariant` with arguments specifying an invalid ragged tensor results in a null pointer dereference. The implementation of `RaggedTensorToVariant` operations(https://github.com/tensorflow/tensorflow/blob/904b3926ed1c6c70380d5313d282d248a776baa1/tensorflow/core/kernels/ragged_tensor_to_variant_op.cc#L39-L40) does not validate that the ragged tensor argument is non-empty. Since `batched_ragged` contains no elements, `batched_ragged.splits` is a null vector, thus `batched_ragged.splits(0)` will result in dereferencing `nullptr`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29516",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29517",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. A malicious user could trigger a division by 0 in `Conv3D` implementation. The implementation(https://github.com/tensorflow/tensorflow/blob/42033603003965bffac51ae171b51801565e002d/tensorflow/core/kernels/conv_ops_3d.cc#L143-L145) does a modulo operation based on user controlled input. Thus, when `filter` has a 0 as the fifth element, this results in a division by 0. Additionally, if the shape of the two tensors is not valid, an Eigen assertion can be triggered, resulting in a program crash. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29517",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29518",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In eager mode (default in TF 2.0 and later), session operations are invalid. However, users could still call the raw ops associated with them and trigger a null pointer dereference. The implementation(https://github.com/tensorflow/tensorflow/blob/eebb96c2830d48597d055d247c0e9aebaea94cd5/tensorflow/core/kernels/session_ops.cc#L104) dereferences the session state pointer without checking if it is valid. Thus, in eager mode, `ctx->session_state()` is nullptr and the call of the member function is undefined behavior. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29518",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29519",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The API of `tf.raw_ops.SparseCross` allows combinations which would result in a `CHECK`-failure and denial of service. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/3d782b7d47b1bf2ed32bd4a246d6d6cadc4c903d/tensorflow/core/kernels/sparse_cross_op.cc#L114-L116) is tricked to consider a tensor of type `tstring` which in fact contains integral elements. Fixing the type confusion by preventing mixing `DT_STRING` and `DT_INT64` types solves this issue. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29519",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29520",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Missing validation between arguments to `tf.raw_ops.Conv3DBackprop*` operations can result in heap buffer overflows. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/4814fafb0ca6b5ab58a09411523b2193fed23fed/tensorflow/core/kernels/conv_grad_shape_utils.cc#L94-L153) assumes that the `input`, `filter_sizes` and `out_backprop` tensors have the same shape, as they are accessed in parallel. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29520",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29521",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Specifying a negative dense shape in `tf.raw_ops.SparseCountSparseOutput` results in a segmentation fault being thrown out from the standard library as `std::vector` invariants are broken. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/8f7b60ee8c0206a2c99802e3a4d1bb55d2bc0624/tensorflow/core/kernels/count_ops.cc#L199-L213) assumes the first element of the dense shape is always positive and uses it to initialize a `BatchedMap<T>` (i.e., `std::vector<absl::flat_hash_map<int64,T>>`(https://github.com/tensorflow/tensorflow/blob/8f7b60ee8c0206a2c99802e3a4d1bb55d2bc0624/tensorflow/core/kernels/count_ops.cc#L27)) data structure. If the `shape` tensor has more than one element, `num_batches` is the first value in `shape`. Ensuring that the `dense_shape` argument is a valid tensor shape (that is, all elements are non-negative) solves this issue. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3.",
      "cve": "CVE-2021-29521",
      "specs": [
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29522",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The `tf.raw_ops.Conv3DBackprop*` operations fail to validate that the input tensors are not empty. In turn, this would result in a division by 0. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a91bb59769f19146d5a0c20060244378e878f140/tensorflow/core/kernels/conv_grad_ops_3d.cc#L430-L450) does not check that the divisor used in computing the shard size is not zero. Thus, if attacker controls the input sizes, they can trigger a denial of service via a division by zero error. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29522",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29523",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.AddManySparseToTensorsMap`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/kernels/sparse_tensors_map_ops.cc#L257) takes the values specified in `sparse_shape` as dimensions for the output shape. The `TensorShape` constructor(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L183-L188) uses a `CHECK` operation which triggers when `InitDims`(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L212-L296) returns a non-OK status. This is a legacy implementation of the constructor and operations should use `BuildTensorShapeBase` or `AddDimWithStatus` to prevent `CHECK`-failures in the presence of overflows. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29523",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29524",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/496c2630e51c1a478f095b084329acedb253db6b/tensorflow/core/kernels/conv_grad_shape_utils.cc#L130) does a modulus operation where the divisor is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29524",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29525",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2DBackpropInput`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/b40060c9f697b044e3107917c797ba052f4506ab/tensorflow/core/kernels/conv_grad_input_ops.h#L625-L655) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29525",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29526",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2D`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/988087bd83f144af14087fe4fecee2d250d93737/tensorflow/core/kernels/conv_ops.cc#L261-L263) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29526",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29527",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.QuantizedConv2D`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/00e9a4d67d76703fa1aee33dac582acf317e0e81/tensorflow/core/kernels/quantized_conv_ops.cc#L257-L259) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29527",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29528",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.QuantizedMul`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/55900e961ed4a23b438392024912154a2c2f5e85/tensorflow/core/kernels/quantized_mul_op.cc#L188-L198) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29528",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29529",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a heap buffer overflow in `tf.raw_ops.QuantizedResizeBilinear` by manipulating input values so that float rounding results in off-by-one error in accessing image elements. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/44b7f486c0143f68b56c34e2d01e146ee445134a/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L62-L66) computes two integers (representing the upper and lower bounds for interpolation) by ceiling and flooring a floating point value. For some values of `in`, `interpolation->upper[i]` might be smaller than `interpolation->lower[i]`. This is an issue if `interpolation->upper[i]` is capped at `in_size-1` as it means that `interpolation->lower[i]` points outside of the image. Then, in the interpolation code(https://github.com/tensorflow/tensorflow/blob/44b7f486c0143f68b56c34e2d01e146ee445134a/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L245-L264), this would result in heap buffer overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29529",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29530",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a null pointer dereference by providing an invalid `permutation` to `tf.raw_ops.SparseMatrixSparseCholesky`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/080f1d9e257589f78b3ffb75debf584168aa6062/tensorflow/core/kernels/sparse/sparse_cholesky_op.cc#L85-L86) fails to properly validate the input arguments. Although `ValidateInputs` is called and there are checks in the body of this function, the code proceeds to the next line in `ValidateInputs` since `OP_REQUIRES`(https://github.com/tensorflow/tensorflow/blob/080f1d9e257589f78b3ffb75debf584168aa6062/tensorflow/core/framework/op_requires.h#L41-L48) is a macro that only exits the current function. Thus, the first validation condition that fails in `ValidateInputs` will cause an early return from that function. However, the caller will continue execution from the next line. The fix is to either explicitly check `context->status()` or to convert `ValidateInputs` to return a `Status`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29530",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29531",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a `CHECK` fail in PNG encoding by providing an empty input tensor as the pixel data. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/e312e0791ce486a80c9d23110841525c6f7c3289/tensorflow/core/kernels/image/encode_png_op.cc#L57-L60) only validates that the total number of pixels in the image does not overflow. Thus, an attacker can send an empty matrix for encoding. However, if the tensor is empty, then the associated buffer is `nullptr`. Hence, when calling `png::WriteImageToBuffer`(https://github.com/tensorflow/tensorflow/blob/e312e0791ce486a80c9d23110841525c6f7c3289/tensorflow/core/kernels/image/encode_png_op.cc#L79-L93), the first argument (i.e., `image.flat<T>().data()`) is `NULL`. This then triggers the `CHECK_NOTNULL` in the first line of `png::WriteImageToBuffer`(https://github.com/tensorflow/tensorflow/blob/e312e0791ce486a80c9d23110841525c6f7c3289/tensorflow/core/lib/png/png_io.cc#L345-L349). Since `image` is null, this results in `abort` being called after printing the stacktrace. Effectively, this allows an attacker to mount a denial of service attack. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29531",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29532",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can force accesses outside the bounds of heap allocated arrays by passing in invalid tensor values to `tf.raw_ops.RaggedCross`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/efea03b38fb8d3b81762237dc85e579cc5fc6e87/tensorflow/core/kernels/ragged_cross_op.cc#L456-L487) lacks validation for the user supplied arguments. Each of the above branches call a helper function after accessing array elements via a `*_list[next_*]` pattern, followed by incrementing the `next_*` index. However, as there is no validation that the `next_*` values are in the valid range for the corresponding `*_list` arrays, this results in heap OOB reads. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29532",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29533",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK` failure by passing an empty image to `tf.raw_ops.DrawBoundingBoxes`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/ea34a18dc3f5c8d80a40ccca1404f343b5d55f91/tensorflow/core/kernels/image/draw_bounding_box_op.cc#L148-L165) uses `CHECK_*` assertions instead of `OP_REQUIRES` to validate user controlled inputs. Whereas `OP_REQUIRES` allows returning an error condition back to the user, the `CHECK_*` macros result in a crash if the condition is false, similar to `assert`. In this case, `height` is 0 from the `images` input. This results in `max_box_row_clamp` being negative and the assertion being falsified, followed by aborting program execution. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29533",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29534",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.SparseConcat`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/b432a38fe0e1b4b904a6c222cbce794c39703e87/tensorflow/core/kernels/sparse_concat_op.cc#L76) takes the values specified in `shapes[0]` as dimensions for the output shape. The `TensorShape` constructor(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L183-L188) uses a `CHECK` operation which triggers when `InitDims`(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L212-L296) returns a non-OK status. This is a legacy implementation of the constructor and operations should use `BuildTensorShapeBase` or `AddDimWithStatus` to prevent `CHECK`-failures in the presence of overflows. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29534",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29535",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedMul` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/87cf4d3ea9949051e50ca3f071fc909538a51cd0/tensorflow/core/kernels/quantized_mul_op.cc#L287-L290) assumes that the 4 arguments are always valid scalars and tries to access the numeric value directly. However, if any of these tensors is empty, then `.flat<T>()` is an empty buffer and accessing the element at position 0 results in overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29535",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29536",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedReshape` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a324ac84e573fba362a5e53d4e74d5de6729933e/tensorflow/core/kernels/quantized_reshape_op.cc#L38-L55) assumes that the 2 arguments are always valid scalars and tries to access the numeric value directly. However, if any of these tensors is empty, then `.flat<T>()` is an empty buffer and accessing the element at position 0 results in overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29536",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29537",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedResizeBilinear` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/50711818d2e61ccce012591eeb4fdf93a8496726/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L705-L706) assumes that the 2 arguments are always valid scalars and tries to access the numeric value directly. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29537",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29538",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a division by zero to occur in `Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1b0296c3b8dd9bd948f924aa8cd62f87dbb7c3da/tensorflow/core/kernels/conv_grad_filter_ops.cc#L513-L522) computes a divisor based on user provided data (i.e., the shape of the tensors given as arguments). If all shapes are empty then `work_unit_size` is 0. Since there is no check for this case before division, this results in a runtime exception, with potential to be abused for a denial of service. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29538",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29539",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Calling `tf.raw_ops.ImmutableConst`(https://www.tensorflow.org/api_docs/python/tf/raw_ops/ImmutableConst) with a `dtype` of `tf.resource` or `tf.variant` results in a segfault in the implementation as code assumes that the tensor contents are pure scalars. We have patched the issue in 4f663d4b8f0bec1b48da6fa091a7d29609980fa4 and will release TensorFlow 2.5.0 containing the patch. TensorFlow nightly packages after this commit will also have the issue resolved. If using `tf.raw_ops.ImmutableConst` in code, you can prevent the segfault by inserting a filter for the `dtype` argument.",
      "cve": "CVE-2021-29539",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29540",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow to occur in `Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1b0296c3b8dd9bd948f924aa8cd62f87dbb7c3da/tensorflow/core/kernels/conv_grad_filter_ops.cc#L495-L497) computes the size of the filter tensor but does not validate that it matches the number of elements in `filter_sizes`. Later, when reading/writing to this buffer, code uses the value computed here, instead of the number of elements in the tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29540",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29541",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a dereference of a null pointer in `tf.raw_ops.StringNGrams`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1cdd4da14282210cc759e468d9781741ac7d01bf/tensorflow/core/kernels/string_ngrams_op.cc#L67-L74) does not fully validate the `data_splits` argument. This would result in `ngrams_data`(https://github.com/tensorflow/tensorflow/blob/1cdd4da14282210cc759e468d9781741ac7d01bf/tensorflow/core/kernels/string_ngrams_op.cc#L106-L110) to be a null pointer when the output would be computed to have 0 or negative size. Later writes to the output tensor would then cause a null pointer dereference. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29541",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29542",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow by passing crafted inputs to `tf.raw_ops.StringNGrams`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1cdd4da14282210cc759e468d9781741ac7d01bf/tensorflow/core/kernels/string_ngrams_op.cc#L171-L185) fails to consider corner cases where input would be split in such a way that the generated tokens should only contain padding elements. If input is such that `num_tokens` is 0, then, for `data_start_index=0` (when left padding is present), the marked line would result in reading `data[-1]`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29542",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29543",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.CTCGreedyDecoder`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1615440b17b364b875eb06f43d087381f1460a65/tensorflow/core/kernels/ctc_decoder_ops.cc#L37-L50) has a `CHECK_LT` inserted to validate some invariants. When this condition is false, the program aborts, instead of returning a valid error to the user. This abnormal termination can be weaponized in denial of service attacks. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29543",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29544",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.QuantizeAndDequantizeV4Grad`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/95078c145b5a7a43ee046144005f733092756ab5/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L162-L163) does not validate the rank of the `input_*` tensors. In turn, this results in the tensors being passes as they are to `QuantizeAndDequantizePerChannelGradientImpl`(https://github.com/tensorflow/tensorflow/blob/95078c145b5a7a43ee046144005f733092756ab5/tensorflow/core/kernels/quantize_and_dequantize_op.h#L295-L306). However, the `vec<T>` method, requires the rank to 1 and triggers a `CHECK` failure otherwise. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 as this is the only other affected version.",
      "cve": "CVE-2021-29544",
      "specs": [
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29545",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in converting sparse tensors to CSR Sparse matrices. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/800346f2c03a27e182dd4fba48295f65e7790739/tensorflow/core/kernels/sparse/kernels.cc#L66) does a double redirection to access an element of an array allocated on the heap. If the value at `indices(i, 0)` is such that `indices(i, 0) + 1` is outside the bounds of `csr_row_ptr`, this results in writing outside of bounds of heap allocated data. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29545",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29546",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger an integer division by zero undefined behavior in `tf.raw_ops.QuantizedBiasAdd`. This is because the implementation of the Eigen kernel(https://github.com/tensorflow/tensorflow/blob/61bca8bd5ba8a68b2d97435ddfafcdf2b85672cd/tensorflow/core/kernels/quantization_utils.h#L812-L849) does a division by the number of elements of the smaller input (based on shape) without checking that this is not zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29546",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29547",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a segfault and denial of service via accessing data outside of bounds in `tf.raw_ops.QuantizedBatchNormWithGlobalNormalization`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/55a97caa9e99c7f37a0bbbeb414dc55553d3ae7f/tensorflow/core/kernels/quantized_batch_norm_op.cc#L176-L189) assumes the inputs are not empty. If any of these inputs is empty, `.flat<T>()` is an empty buffer, so accessing the element at index 0 is accessing data outside of bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29547",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29548",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a runtime division by zero error and denial of service in `tf.raw_ops.QuantizedBatchNormWithGlobalNormalization`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/55a97caa9e99c7f37a0bbbeb414dc55553d3ae7f/tensorflow/core/kernels/quantized_batch_norm_op.cc) does not validate all constraints specified in the op's contract(https://www.tensorflow.org/api_docs/python/tf/raw_ops/QuantizedBatchNormWithGlobalNormalization). The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29548",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29549",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a runtime division by zero error and denial of service in `tf.raw_ops.QuantizedBatchNormWithGlobalNormalization`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/6f26b3f3418201479c264f2a02000880d8df151c/tensorflow/core/kernels/quantized_add_op.cc#L289-L295) computes a modulo operation without validating that the divisor is not zero. Since `vector_num_elements` is determined based on input shapes(https://github.com/tensorflow/tensorflow/blob/6f26b3f3418201479c264f2a02000880d8df151c/tensorflow/core/kernels/quantized_add_op.cc#L522-L544), a user can trigger scenarios where this quantity is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29549",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29550",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a runtime division by zero error and denial of service in `tf.raw_ops.FractionalAvgPool`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/acc8ee69f5f46f92a3f1f11230f49c6ac266f10c/tensorflow/core/kernels/fractional_avg_pool_op.cc#L85-L89) computes a divisor quantity by dividing two user controlled values. The user controls the values of `input_size[i]` and `pooling_ratio_[i]` (via the `value.shape()` and `pooling_ratio` arguments). If the value in `input_size[i]` is smaller than the `pooling_ratio_[i]`, then the floor operation results in `output_size[i]` being 0. The `DCHECK_GT` line is a no-op outside of debug mode, so in released versions of TF this does not trigger. Later, these computed values are used as arguments(https://github.com/tensorflow/tensorflow/blob/acc8ee69f5f46f92a3f1f11230f49c6ac266f10c/tensorflow/core/kernels/fractional_avg_pool_op.cc#L96-L99) to `GeneratePoolingSequence`(https://github.com/tensorflow/tensorflow/blob/acc8ee69f5f46f92a3f1f11230f49c6ac266f10c/tensorflow/core/kernels/fractional_pool_common.cc#L100-L108). There, the first computation is a division in a modulo operation. Since `output_length` can be 0, this results in runtime crashing. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29550",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29551",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `MatrixTriangularSolve`(https://github.com/tensorflow/tensorflow/blob/8cae746d8449c7dda5298327353d68613f16e798/tensorflow/core/kernels/linalg/matrix_triangular_solve_op_impl.h#L160-L240) fails to terminate kernel execution if one validation condition fails. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29551",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29552",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by controlling the values of `num_segments` tensor argument for `UnsortedSegmentJoin`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a2a607db15c7cd01d754d37e5448d72a13491bdb/tensorflow/core/kernels/unsorted_segment_join_op.cc#L92-L93) assumes that the `num_segments` tensor is a valid scalar. Since the tensor is empty the `CHECK` involved in `.scalar<T>()()` that checks that the number of elements is exactly 1 will be invalidated and this would result in process termination. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29552",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29553",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can read data outside of bounds of heap allocated buffer in `tf.raw_ops.QuantizeAndDequantizeV3`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/11ff7f80667e6490d7b5174aa6bf5e01886e770f/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L237) does not validate the value of user supplied `axis` attribute before using it to index in the array backing the `input` argument. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29553",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29554",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.DenseCountSparseOutput`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/efff014f3b2d8ef6141da30c806faf141297eca1/tensorflow/core/kernels/count_ops.cc#L123-L127) computes a divisor value from user data but does not check that the result is 0 before doing the division. Since `data` is given by the `values` argument, `num_batch_elements` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, and TensorFlow 2.3.3, as these are also affected.",
      "cve": "CVE-2021-29554",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29555",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.FusedBatchNorm`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/828f346274841fa7505f7020e88ca36c22e557ab/tensorflow/core/kernels/fused_batch_norm_op.cc#L295-L297) performs a division based on the last dimension of the `x` tensor. Since this is controlled by the user, an attacker can trigger a denial of service. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29555",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29556",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.Reverse`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/36229ea9e9451dac14a8b1f4711c435a1d84a594/tensorflow/core/kernels/reverse_op.cc#L75-L76) performs a division based on the first dimension of the tensor argument. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29556",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29557",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.SparseMatMul`. The division by 0 occurs deep in Eigen code because the `b` tensor is empty. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29557",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29558",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `tf.raw_ops.SparseSplit`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/699bff5d961f0abfde8fa3f876e6d241681fbef8/tensorflow/core/util/sparse/sparse_tensor.h#L528-L530) accesses an array element based on a user controlled offset. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29558",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29559",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can access data outside of bounds of heap allocated array in `tf.raw_ops.UnicodeEncode`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/472c1f12ad9063405737679d4f6bd43094e1d36d/tensorflow/core/kernels/unicode_ops.cc) assumes that the `input_value`/`input_splits` pair specify a valid sparse tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29559",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29560",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `tf.raw_ops.RaggedTensorToTensor`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/d94227d43aa125ad8b54115c03cece54f6a1977b/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L219-L222) uses the same index to access two arrays in parallel. Since the user controls the shape of the input arguments, an attacker could trigger a heap OOB access when `parent_output_index` is shorter than `row_split`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29560",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29561",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by exploiting a `CHECK`-failure coming from `tf.raw_ops.LoadAndRemapMatrix`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/d94227d43aa125ad8b54115c03cece54f6a1977b/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L219-L222) assumes that the `ckpt_path` is always a valid scalar. However, an attacker can send any other tensor as the first argument of `LoadAndRemapMatrix`. This would cause the rank `CHECK` in `scalar<T>()()` to trigger and terminate the process. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29561",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29562",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by exploiting a `CHECK`-failure coming from the implementation of `tf.raw_ops.IRFFT`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29562",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29563",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by exploiting a `CHECK`-failure coming from the implementation of `tf.raw_ops.RFFT`. Eigen code operating on an empty matrix can trigger on an assertion and will cause program termination. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29563",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29564",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a null pointer dereference in the implementation of `tf.raw_ops.EditDistance`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/79865b542f9ffdc9caeb255631f7c56f1d4b6517/tensorflow/core/kernels/edit_distance_op.cc#L103-L159) has incomplete validation of the input parameters. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29564",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29565",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a null pointer dereference in the implementation of `tf.raw_ops.SparseFillEmptyRows`. This is because of missing validation(https://github.com/tensorflow/tensorflow/blob/fdc82089d206e281c628a93771336bf87863d5e8/tensorflow/core/kernels/sparse_fill_empty_rows_op.cc#L230-L231) that was covered under a `TODO`. If the `dense_shape` tensor is empty, then `dense_shape_t.vec<>()` would cause a null pointer dereference in the implementation of the op. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29565",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29566",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can write outside the bounds of heap allocated arrays by passing invalid arguments to `tf.raw_ops.Dilation2DBackpropInput`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/afd954e65f15aea4d438d0a219136fc4a63a573d/tensorflow/core/kernels/dilation_ops.cc#L321-L322) does not validate before writing to the output array. The values for `h_out` and `w_out` are guaranteed to be in range for `out_backprop` (as they are loop indices bounded by the size of the array). However, there are no similar guarantees relating `h_in_max`/`w_in_max` and `in_backprop`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29566",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29567",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.SparseDenseCwiseMul`, an attacker can trigger denial of service via `CHECK`-fails or accesses to outside the bounds of heap allocated data. Since the implementation(https://github.com/tensorflow/tensorflow/blob/38178a2f7a681a7835bb0912702a134bfe3b4d84/tensorflow/core/kernels/sparse_dense_binary_op_shared.cc#L68-L80) only validates the rank of the input arguments but no constraints between dimensions(https://www.tensorflow.org/api_docs/python/tf/raw_ops/SparseDenseCwiseMul), an attacker can abuse them to trigger internal `CHECK` assertions (and cause program termination, denial of service) or to write to memory outside of bounds of heap allocated tensor buffers. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29567",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29568",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger undefined behavior by binding to null pointer in `tf.raw_ops.ParameterizedTruncatedNormal`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/3f6fe4dfef6f57e768260b48166c27d148f3015f/tensorflow/core/kernels/parameterized_truncated_normal_op.cc#L630) does not validate input arguments before accessing the first element of `shape`. If `shape` argument is empty, then `shape_tensor.flat<T>()` is an empty array. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29568",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29569",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` can cause reads outside of bounds of heap allocated data if attacker supplies specially crafted inputs. The implementation(https://github.com/tensorflow/tensorflow/blob/ac328eaa3870491ababc147822cd04e91a790643/tensorflow/core/kernels/requantization_range_op.cc#L49-L50) assumes that the `input_min` and `input_max` tensors have at least one element, as it accesses the first element in two arrays. If the tensors are empty, `.flat<T>()` is an empty object, backed by an empty array. Hence, accesing even the 0th element is a read outside the bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29569",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29570",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` can cause reads outside of bounds of heap allocated data if attacker supplies specially crafted inputs. The implementation(https://github.com/tensorflow/tensorflow/blob/ef0c008ee84bad91ec6725ddc42091e19a30cf0e/tensorflow/core/kernels/maxpooling_op.cc#L1016-L1017) uses the same value to index in two different arrays but there is no guarantee that the sizes are identical. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29570",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29571",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` can cause reads outside of bounds of heap allocated data if attacker supplies specially crafted inputs. The implementation(https://github.com/tensorflow/tensorflow/blob/31bd5026304677faa8a0b77602c6154171b9aec1/tensorflow/core/kernels/image/draw_bounding_box_op.cc#L116-L130) assumes that the last element of `boxes` input is 4, as required by [the op](https://www.tensorflow.org/api_docs/python/tf/raw_ops/DrawBoundingBoxesV2). Since this is not checked attackers passing values less than 4 can write outside of bounds of heap allocated objects and cause memory corruption. If the last dimension in `boxes` is less than 4, accesses similar to `tboxes(b, bb, 3)` will access data outside of bounds. Further during code execution there are also writes to these indices. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29571",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29572",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.SdcaOptimizer` triggers undefined behavior due to dereferencing a null pointer. The implementation(https://github.com/tensorflow/tensorflow/blob/60a45c8b6192a4699f2e2709a2645a751d435cc3/tensorflow/core/kernels/sdca_internal.cc) does not validate that the user supplied arguments satisfy all constraints expected by the op(https://www.tensorflow.org/api_docs/python/tf/raw_ops/SdcaOptimizer). The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29572",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29573",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` is vulnerable to a division by 0. The implementation(https://github.com/tensorflow/tensorflow/blob/279bab6efa22752a2827621b7edb56a730233bd8/tensorflow/core/kernels/maxpooling_op.cc#L1033-L1034) fails to validate that the batch dimension of the tensor is non-zero, before dividing by this quantity. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29573",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29574",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPool3DGradGrad` exhibits undefined behavior by dereferencing null pointers backing attacker-supplied empty tensors. The implementation(https://github.com/tensorflow/tensorflow/blob/72fe792967e7fd25234342068806707bbc116618/tensorflow/core/kernels/pooling_ops_3d.cc#L679-L703) fails to validate that the 3 tensor inputs are not empty. If any of them is empty, then accessing the elements in the tensor results in dereferencing a null pointer. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29574",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29575",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.ReverseSequence` allows for stack overflow and/or `CHECK`-fail based denial of service. The implementation(https://github.com/tensorflow/tensorflow/blob/5b3b071975e01f0d250c928b2a8f901cd53b90a7/tensorflow/core/kernels/reverse_sequence_op.cc#L114-L118) fails to validate that `seq_dim` and `batch_dim` arguments are valid. Negative values for `seq_dim` can result in stack overflow or `CHECK`-failure, depending on the version of Eigen code used to implement the operation. Similar behavior can be exhibited by invalid values of `batch_dim`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29575",
      "specs": [
        "<=2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29576",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPool3DGradGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/596c05a159b6fbb9e39ca10b3f7753b7244fa1e9/tensorflow/core/kernels/pooling_ops_3d.cc#L694-L696) does not check that the initialization of `Pool3dParameters` completes successfully. Since the constructor(https://github.com/tensorflow/tensorflow/blob/596c05a159b6fbb9e39ca10b3f7753b7244fa1e9/tensorflow/core/kernels/pooling_ops_3d.cc#L48-L88) uses `OP_REQUIRES` to validate conditions, the first assertion that fails interrupts the initialization of `params`, making it contain invalid data. In turn, this might cause a heap buffer overflow, depending on default initialized values. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29576",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29577",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.AvgPool3DGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/d80ffba9702dc19d1fac74fc4b766b3fa1ee976b/tensorflow/core/kernels/pooling_ops_3d.cc#L376-L450) assumes that the `orig_input_shape` and `grad` tensors have similar first and last dimensions but does not check that this assumption is validated. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29577",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29578",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.FractionalAvgPoolGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/dcba796a28364d6d7f003f6fe733d82726dda713/tensorflow/core/kernels/fractional_avg_pool_op.cc#L216) fails to validate that the pooling sequence arguments have enough elements as required by the `out_backprop` tensor shape. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29578",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29579",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/ab1e644b48c82cb71493f4362b4dd38f4577a1cf/tensorflow/core/kernels/maxpooling_op.cc#L194-L203) fails to validate that indices used to access elements of input/output arrays are valid. Whereas accesses to `input_backprop_flat` are guarded by `FastBoundsCheck`, the indexing in `out_backprop_flat` can result in OOB access. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29579",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29580",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.FractionalMaxPoolGrad` triggers an undefined behavior if one of the input tensors is empty. The code is also vulnerable to a denial of service attack as a `CHECK` condition becomes false and aborts the process. The implementation(https://github.com/tensorflow/tensorflow/blob/169054888d50ce488dfde9ca55d91d6325efbd5b/tensorflow/core/kernels/fractional_max_pool_op.cc#L215) fails to validate that input and output tensors are not empty and are of the same rank. Each of these unchecked assumptions is responsible for the above issues. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29580",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29581",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.CTCBeamSearchDecoder`, an attacker can trigger denial of service via segmentation faults. The implementation(https://github.com/tensorflow/tensorflow/blob/a74768f8e4efbda4def9f16ee7e13cf3922ac5f7/tensorflow/core/kernels/ctc_decoder_ops.cc#L68-L79) fails to detect cases when the input tensor is empty and proceeds to read data from a null buffer. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29581",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29582",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.Dequantize`, an attacker can trigger a read from outside of bounds of heap allocated data. The implementation(https://github.com/tensorflow/tensorflow/blob/26003593aa94b1742f34dc22ce88a1e17776a67d/tensorflow/core/kernels/dequantize_op.cc#L106-L131) accesses the `min_range` and `max_range` tensors in parallel but fails to check that they have the same shape. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29582",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29583",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.FusedBatchNorm` is vulnerable to a heap buffer overflow. If the tensors are empty, the same implementation can trigger undefined behavior by dereferencing null pointers. The implementation(https://github.com/tensorflow/tensorflow/blob/57d86e0db5d1365f19adcce848dfc1bf89fdd4c7/tensorflow/core/kernels/fused_batch_norm_op.cc) fails to validate that `scale`, `offset`, `mean` and `variance` (the last two only when required) all have the same number of elements as the number of channels of `x`. This results in heap out of bounds reads when the buffers backing these tensors are indexed past their boundary. If the tensors are empty, the validation mentioned in the above paragraph would also trigger and prevent the undefined behavior. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29583",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29584",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in caused by an integer overflow in constructing a new tensor shape. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/0908c2f2397c099338b901b067f6495a5b96760b/tensorflow/core/kernels/sparse_split_op.cc#L66-L70) builds a dense shape without checking that the dimensions would not result in overflow. The `TensorShape` constructor(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L183-L188) uses a `CHECK` operation which triggers when `InitDims`(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L212-L296) returns a non-OK status. This is a legacy implementation of the constructor and operations should use `BuildTensorShapeBase` or `AddDimWithStatus` to prevent `CHECK`-failures in the presence of overflows. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29584",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29585",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The TFLite computation for size of output after padding, `ComputeOutSize`(https://github.com/tensorflow/tensorflow/blob/0c9692ae7b1671c983569e5d3de5565843d500cf/tensorflow/lite/kernels/padding.h#L43-L55), does not check that the `stride` argument is not 0 before doing the division. Users can craft special models such that `ComputeOutSize` is called with `stride` set to 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29585",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29586",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Optimized pooling implementations in TFLite fail to check that the stride arguments are not 0 before calling `ComputePaddingHeightWidth`(https://github.com/tensorflow/tensorflow/blob/3f24ccd932546416ec906a02ddd183b48a1d2c83/tensorflow/lite/kernels/pooling.cc#L90). Since users can craft special models which will have `params->stride_{height,width}` be zero, this will result in a division by zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29586",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29587",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The `Prepare` step of the `SpaceToDepth` TFLite operator does not check for 0 before division(https://github.com/tensorflow/tensorflow/blob/5f7975d09eac0f10ed8a17dbb6f5964977725adc/tensorflow/lite/kernels/space_to_depth.cc#L63-L67). An attacker can craft a model such that `params->block_size` would be zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29587",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29588",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The optimized implementation of the `TransposeConv` TFLite operator is [vulnerable to a division by zero error](https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/internal/optimized/optimized_ops.h#L5221-L5222). An attacker can craft a model such that `stride_{h,w}` values are 0. Code calling this function must validate these arguments. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29588",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29589",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The reference implementation of the `GatherNd` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/internal/reference/reference_ops.h#L966). An attacker can craft a model such that `params` input would be an empty tensor. In turn, `params_shape.Dims(.)` would be zero, in at least one dimension. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29589",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29590",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementations of the `Minimum` and `Maximum` TFLite operators can be used to read data outside of bounds of heap allocated objects, if any of the two input tensor arguments are empty. This is because the broadcasting implementation(https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/internal/reference/maximum_minimum.h#L52-L56) indexes in both tensors with the same index but does not validate that the index is within bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29590",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29591",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. TFlite graphs must not have loops between nodes. However, this condition was not checked and an attacker could craft models that would result in infinite loop during evaluation. In certain cases, the infinite loop would be replaced by stack overflow due to too many recursive calls. For example, the `While` implementation(https://github.com/tensorflow/tensorflow/blob/106d8f4fb89335a2c52d7c895b7a7485465ca8d9/tensorflow/lite/kernels/while.cc) could be tricked into a scneario where both the body and the loop subgraphs are the same. Evaluating one of the subgraphs means calling the `Eval` function for the other and this quickly exhaust all stack space. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range. Please consult our security guide(https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.",
      "cve": "CVE-2021-29591",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29592",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The fix for CVE-2020-15209(https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-15209) missed the case when the target shape of `Reshape` operator is given by the elements of a 1-D tensor. As such, the fix for the vulnerability(https://github.com/tensorflow/tensorflow/blob/9c1dc920d8ffb4893d6c9d27d1f039607b326743/tensorflow/lite/core/subgraph.cc#L1062-L1074) allowed passing a null-buffer-backed tensor with a 1D shape. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29592",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29593",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `BatchToSpaceNd` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/b5ed552fe55895aee8bd8b191f744a069957d18d/tensorflow/lite/kernels/batch_to_space_nd.cc#L81-L82). An attacker can craft a model such that one dimension of the `block` input is 0. Hence, the corresponding value in `block_shape` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29593",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29594",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. TFLite's convolution code(https://github.com/tensorflow/tensorflow/blob/09c73bca7d648e961dd05898292d91a8322a9d45/tensorflow/lite/kernels/conv.cc) has multiple division where the divisor is controlled by the user and not checked to be non-zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29594",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29595",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `DepthToSpace` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/depth_to_space.cc#L63-L69). An attacker can craft a model such that `params->block_size` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29595",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29596",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `EmbeddingLookup` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/e4b29809543b250bc9b19678ec4776299dd569ba/tensorflow/lite/kernels/embedding_lookup.cc#L73-L74). An attacker can craft a model such that the first dimension of the `value` input is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29596",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29597",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `SpaceToBatchNd` TFLite operator is [vulnerable to a division by zero error](https://github.com/tensorflow/tensorflow/blob/412c7d9bb8f8a762c5b266c9e73bfa165f29aac8/tensorflow/lite/kernels/space_to_batch_nd.cc#L82-L83). An attacker can craft a model such that one dimension of the `block` input is 0. Hence, the corresponding value in `block_shape` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29597",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29598",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `SVDF` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/7f283ff806b2031f407db64c4d3edcda8fb9f9f5/tensorflow/lite/kernels/svdf.cc#L99-L102). An attacker can craft a model such that `params->rank` would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29598",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29599",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `Split` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/e2752089ef7ce9bcf3db0ec618ebd23ea119d0c7/tensorflow/lite/kernels/split.cc#L63-L65). An attacker can craft a model such that `num_splits` would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29599",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29600",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `OneHot` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/f61c57bd425878be108ec787f4d96390579fb83e/tensorflow/lite/kernels/one_hot.cc#L68-L72). An attacker can craft a model such that at least one of the dimensions of `indices` would be 0. In turn, the `prefix_dim_size` value would become 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29600",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29601",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The TFLite implementation of concatenation is vulnerable to an integer overflow issue(https://github.com/tensorflow/tensorflow/blob/7b7352a724b690b11bfaae2cd54bc3907daf6285/tensorflow/lite/kernels/concatenation.cc#L70-L76). An attacker can craft a model such that the dimensions of one of the concatenation input overflow the values of `int`. TFLite uses `int` to represent tensor dimensions, whereas TF uses `int64`. Hence, valid TF models can trigger an integer overflow when converted to TFLite format. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29601",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29602",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `DepthwiseConv` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/1a8e885b864c818198a5b2c0cbbeca5a1e833bc8/tensorflow/lite/kernels/depthwise_conv.cc#L287-L288). An attacker can craft a model such that `input`'s fourth dimension would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29602",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29603",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. A specially crafted TFLite model could trigger an OOB write on heap in the TFLite implementation of `ArgMin`/`ArgMax`(https://github.com/tensorflow/tensorflow/blob/102b211d892f3abc14f845a72047809b39cc65ab/tensorflow/lite/kernels/arg_min_max.cc#L52-L59). If `axis_value` is not a value between 0 and `NumDimensions(input)`, then the condition in the `if` is never true, so code writes past the last valid element of `output_dims->data`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29603",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29604",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The TFLite implementation of hashtable lookup is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/1a8e885b864c818198a5b2c0cbbeca5a1e833bc8/tensorflow/lite/kernels/hashtable_lookup.cc#L114-L115) An attacker can craft a model such that `values`'s first dimension would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29604",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29605",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The TFLite code for allocating `TFLiteIntArray`s is vulnerable to an integer overflow issue(https://github.com/tensorflow/tensorflow/blob/4ceffae632721e52bf3501b736e4fe9d1221cdfa/tensorflow/lite/c/common.c#L24-L27). An attacker can craft a model such that the `size` multiplier is so large that the return value overflows the `int` datatype and becomes negative. In turn, this results in invalid value being given to `malloc`(https://github.com/tensorflow/tensorflow/blob/4ceffae632721e52bf3501b736e4fe9d1221cdfa/tensorflow/lite/c/common.c#L47-L52). In this case, `ret->size` would dereference an invalid pointer. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29605",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29606",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. A specially crafted TFLite model could trigger an OOB read on heap in the TFLite implementation of `Split_V`(https://github.com/tensorflow/tensorflow/blob/c59c37e7b2d563967da813fa50fe20b21f4da683/tensorflow/lite/kernels/split_v.cc#L99). If `axis_value` is not a value between 0 and `NumDimensions(input)`, then the `SizeOfDimension` function(https://github.com/tensorflow/tensorflow/blob/102b211d892f3abc14f845a72047809b39cc65ab/tensorflow/lite/kernels/kernel_util.h#L148-L150) will access data outside the bounds of the tensor shape array. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29606",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29607",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `SparseAdd` results in allowing attackers to exploit undefined behavior (dereferencing null pointers) as well as write outside of bounds of heap allocated data. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/sparse_sparse_binary_op_shared.cc) has a large set of validation for the two sparse tensor inputs (6 tensors in total), but does not validate that the tensors are not empty or that the second dimension of `*_indices` matches the size of corresponding `*_shape`. This allows attackers to send tensor triples that represent invalid sparse tensors to abuse code assumptions that are not protected by validation. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29607",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29608",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.RaggedTensorToTensor`, an attacker can exploit an undefined behavior if input arguments are empty. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L356-L360) only checks that one of the tensors is not empty, but does not check for the other ones. There are multiple `DCHECK` validations to prevent heap OOB, but these are no-op in release builds, hence they don't prevent anything. The fix will be included in TensorFlow 2.5.0. We will also cherrypick these commits on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29608",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29609",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `SparseAdd` results in allowing attackers to exploit undefined behavior (dereferencing null pointers) as well as write outside of bounds of heap allocated data. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/sparse_add_op.cc) has a large set of validation for the two sparse tensor inputs (6 tensors in total), but does not validate that the tensors are not empty or that the second dimension of `*_indices` matches the size of corresponding `*_shape`. This allows attackers to send tensor triples that represent invalid sparse tensors to abuse code assumptions that are not protected by validation. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29609",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29610",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The validation in `tf.raw_ops.QuantizeAndDequantizeV2` allows invalid values for `axis` argument:. The validation(https://github.com/tensorflow/tensorflow/blob/eccb7ec454e6617738554a255d77f08e60ee0808/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L74-L77) uses `||` to mix two different conditions. If `axis_ < -1` the condition in `OP_REQUIRES` will still be true, but this value of `axis_` results in heap underflow. This allows attackers to read/write to other data on the heap. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29610",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29611",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `SparseReshape` results in a denial of service based on a `CHECK`-failure. The implementation(https://github.com/tensorflow/tensorflow/blob/e87b51ce05c3eb172065a6ea5f48415854223285/tensorflow/core/kernels/sparse_reshape_op.cc#L40) has no validation that the input arguments specify a valid sparse tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3, as these are the only affected versions.",
      "cve": "CVE-2021-29611",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29612",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a heap buffer overflow in Eigen implementation of `tf.raw_ops.BandedTriangularSolve`. The implementation(https://github.com/tensorflow/tensorflow/blob/eccb7ec454e6617738554a255d77f08e60ee0808/tensorflow/core/kernels/linalg/banded_triangular_solve_op.cc#L269-L278) calls `ValidateInputTensors` for input validation but fails to validate that the two tensors are not empty. Furthermore, since `OP_REQUIRES` macro only stops execution of current function after setting `ctx->status()` to a non-OK value, callers of helper functions that use `OP_REQUIRES` must check value of `ctx->status()` before continuing. This doesn't happen in this op's implementation(https://github.com/tensorflow/tensorflow/blob/eccb7ec454e6617738554a255d77f08e60ee0808/tensorflow/core/kernels/linalg/banded_triangular_solve_op.cc#L219), hence the validation that is present is also not effective. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29612",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29613",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `tf.raw_ops.CTCLoss` allows an attacker to trigger an OOB read from heap. The fix will be included in TensorFlow 2.5.0. We will also cherrypick these commits on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29613",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29614",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.io.decode_raw` produces incorrect results and crashes the Python interpreter when combining `fixed_length` and wider datatypes. The implementation of the padded version(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc) is buggy due to a confusion about pointer arithmetic rules. First, the code computes(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L61) the width of each output element by dividing the `fixed_length` value to the size of the type argument. The `fixed_length` argument is also used to determine the size needed for the output tensor(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L63-L79). This is followed by reencoding code(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L85-L94). The erroneous code is the last line above: it is moving the `out_data` pointer by `fixed_length * sizeof(T)` bytes whereas it only copied at most `fixed_length` bytes from the input. This results in parts of the input not being decoded into the output. Furthermore, because the pointer advance is far wider than desired, this quickly leads to writing to outside the bounds of the backing data. This OOB write leads to interpreter crash in the reproducer mentioned here, but more severe attacks can be mounted too, given that this gadget allows writing to periodically placed locations in memory. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29614",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29615",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `ParseAttrValue`(https://github.com/tensorflow/tensorflow/blob/c22d88d6ff33031aa113e48aa3fc9aa74ed79595/tensorflow/core/framework/attr_value_util.cc#L397-L453) can be tricked into stack overflow due to recursion by giving in a specially crafted input. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29615",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29616",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of TrySimplify(https://github.com/tensorflow/tensorflow/blob/c22d88d6ff33031aa113e48aa3fc9aa74ed79595/tensorflow/core/grappler/optimizers/arithmetic_optimizer.cc#L390-L401) has undefined behavior due to dereferencing a null pointer in corner cases that result in optimizing a node with no inputs. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29616",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29617",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via `CHECK`-fail in `tf.strings.substr` with invalid arguments. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29617",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29618",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Passing a complex argument to `tf.transpose` at the same time as passing `conjugate=True` argument results in a crash. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29618",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-29619",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Passing invalid arguments (e.g., discovered via fuzzing) to `tf.raw_ops.SparseCountSparseOutput` results in segfault. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29619",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-35958",
      "advisory": "** DISPUTED ** TensorFlow through 2.5.0 allows attackers to overwrite arbitrary files via a crafted archive when tf.keras.utils.get_file is used with extract=True. NOTE: the vendor's position is that tf.keras.utils.get_file is not intended for untrusted archives.",
      "cve": "CVE-2021-35958",
      "specs": [
        "<=2.5.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37635",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of sparse reduction operations in TensorFlow can trigger accesses outside of bounds of heap allocated data. The [implementation](https://github.com/tensorflow/tensorflow/blob/a1bc56203f21a5a4995311825ffaba7a670d7747/tensorflow/core/kernels/sparse_reduce_op.cc#L217-L228) fails to validate that each reduction group does not overflow and that each corresponding index does not point to outside the bounds of the input tensor. We have patched the issue in GitHub commit 87158f43f05f2720a374f3e6d22a7aaa3a33f750. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37635",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37636",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.SparseDenseCwiseDiv` is vulnerable to a division by 0 error. The [implementation](https://github.com/tensorflow/tensorflow/blob/a1bc56203f21a5a4995311825ffaba7a670d7747/tensorflow/core/kernels/sparse_dense_binary_op_shared.cc#L56) uses a common class for all binary operations but fails to treat the division by 0 case separately. We have patched the issue in GitHub commit d9204be9f49520cdaaeb2541d1dc5187b23f31d9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37636",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37637",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. It is possible to trigger a null pointer dereference in TensorFlow by passing an invalid input to `tf.raw_ops.CompressElement`. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/data/compression_utils.cc#L34) was accessing the size of a buffer obtained from the return of a separate function call before validating that said buffer is valid. We have patched the issue in GitHub commit 5dc7f6981fdaf74c8c5be41f393df705841fb7c5. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37637",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37638",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Sending invalid argument for `row_partition_types` of `tf.raw_ops.RaggedTensorToTensor` API results in a null pointer dereference and undefined behavior. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L328) accesses the first element of a user supplied list of values without validating that the provided list is not empty. We have patched the issue in GitHub commit 301ae88b331d37a2a16159b65b255f4f9eb39314. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37638",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37639",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. When restoring tensors via raw APIs, if the tensor name is not provided, TensorFlow can be tricked into dereferencing a null pointer. Alternatively, attackers can read memory outside the bounds of heap allocated data by providing some tensor names but not enough for a successful restoration. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/kernels/save_restore_tensor.cc#L158-L159) retrieves the tensor list corresponding to the `tensor_name` user controlled input and immediately retrieves the tensor at the restoration index (controlled via `preferred_shard` argument). This occurs without validating that the provided list has enough values. If the list is empty this results in dereferencing a null pointer (undefined behavior). If, however, the list has some elements, if the restoration index is outside the bounds this results in heap OOB read. We have patched the issue in GitHub commit 9e82dce6e6bd1f36a57e08fa85af213e2b2f2622. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37639",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37640",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.SparseReshape` can be made to trigger an integral division by 0 exception. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/reshape_util.cc#L176-L181) calls the reshaping functor whenever there is at least an index in the input but does not check that shape of the input or the target shape have both a non-zero number of elements. The [reshape functor](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/reshape_util.cc#L40-L78) blindly divides by the dimensions of the target shape. Hence, if this is not checked, code will result in a division by 0. We have patched the issue in GitHub commit 4923de56ec94fff7770df259ab7f2288a74feb41. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1 as this is the other affected version.",
      "cve": "CVE-2021-37640",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37641",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions if the arguments to `tf.raw_ops.RaggedGather` don't determine a valid ragged tensor code can trigger a read from outside of bounds of heap allocated buffers. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/ragged_gather_op.cc#L70) directly reads the first dimension of a tensor shape before checking that said tensor has rank of at least 1 (i.e., it is not a scalar). Furthermore, the implementation does not check that the list given by `params_nested_splits` is not an empty list of tensors. We have patched the issue in GitHub commit a2b743f6017d7b97af1fe49087ae15f0ac634373. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37641",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37642",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.ResourceScatterDiv` is vulnerable to a division by 0 error. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/resource_variable_ops.cc#L865) uses a common class for all binary operations but fails to treat the division by 0 case separately. We have patched the issue in GitHub commit 4aacb30888638da75023e6601149415b39763d76. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37642",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37643",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. If a user does not provide a valid padding value to `tf.raw_ops.MatrixDiagPartOp`, then the code triggers a null pointer dereference (if input is empty) or produces invalid behavior, ignoring all values after the first. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/linalg/matrix_diag_op.cc#L89) reads the first value from a tensor buffer without first checking that the tensor has values to read from. We have patched the issue in GitHub commit 482da92095c4d48f8784b1f00dda4f81c28d2988. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37643",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37644",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions providing a negative element to `num_elements` list argument of `tf.raw_ops.TensorListReserve` causes the runtime to abort the process due to reallocating a `std::vector` to have a negative number of elements. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/list_kernels.cc#L312) calls `std::vector.resize()` with the new size controlled by input given by the user, without checking that this input is valid. We have patched the issue in GitHub commit 8a6e874437670045e6c7dc6154c7412b4a2135e2. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37644",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37645",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.QuantizeAndDequantizeV4Grad` is vulnerable to an integer overflow issue caused by converting a signed integer value to an unsigned one and then allocating memory based on this value. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L126) uses the `axis` value as the size argument to `absl::InlinedVector` constructor. But, the constructor uses an unsigned type for the argument, so the implicit conversion transforms the negative value to a large integer. We have patched the issue in GitHub commit 96f364a1ca3009f98980021c4b32be5fdcca33a1. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, and TensorFlow 2.4.3, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37645",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37646",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.StringNGrams` is vulnerable to an integer overflow issue caused by converting a signed integer value to an unsigned one and then allocating memory based on this value. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/string_ngrams_op.cc#L184) calls `reserve` on a `tstring` with a value that sometimes can be negative if user supplies negative `ngram_widths`. The `reserve` method calls `TF_TString_Reserve` which has an `unsigned long` argument for the size of the buffer. Hence, the implicit conversion transforms the negative value to a large integer. We have patched the issue in GitHub commit c283e542a3f422420cfdb332414543b62fc4e4a5. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37646",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37647",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. When a user does not supply arguments that determine a valid sparse tensor, `tf.raw_ops.SparseTensorSliceDataset` implementation can be made to dereference a null pointer. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc#L240-L251) has some argument validation but fails to consider the case when either `indices` or `values` are provided for an empty sparse tensor when the other is not. If `indices` is empty, then [code that performs validation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc#L260-L261) (i.e., checking that the indices are monotonically increasing) results in a null pointer dereference. If `indices` as provided by the user is empty, then `indices` in the C++ code above is backed by an empty `std::vector`, hence calling `indices->dim_size(0)` results in null pointer dereferencing (same as calling `std::vector::at()` on an empty vector). We have patched the issue in GitHub commit 02cc160e29d20631de3859c6653184e3f876b9d7. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37647",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37648",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the code for `tf.raw_ops.SaveV2` does not properly validate the inputs and an attacker can trigger a null pointer dereference. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/save_restore_v2_ops.cc) uses `ValidateInputs` to check that the input arguments are valid. This validation would have caught the illegal state represented by the reproducer above. However, the validation uses `OP_REQUIRES` which translates to setting the `Status` object of the current `OpKernelContext` to an error status, followed by an empty `return` statement which just terminates the execution of the function it is present in. However, this does not mean that the kernel execution is finalized: instead, execution continues from the next line in `Compute` that follows the call to `ValidateInputs`. This is equivalent to lacking the validation. We have patched the issue in GitHub commit 9728c60e136912a12d99ca56e106b7cce7af5986. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37648",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37649",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The code for `tf.raw_ops.UncompressElement` can be made to trigger a null pointer dereference. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/data/experimental/compression_ops.cc#L50-L53) obtains a pointer to a `CompressedElement` from a `Variant` tensor and then proceeds to dereference it for decompressing. There is no check that the `Variant` tensor contained a `CompressedElement`, so the pointer is actually `nullptr`. We have patched the issue in GitHub commit 7bdf50bb4f5c54a4997c379092888546c97c3ebd. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37649",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37650",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.ExperimentalDatasetToTFRecord` and `tf.raw_ops.DatasetToTFRecord` can trigger heap buffer overflow and segmentation fault. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/data/experimental/to_tf_record_op.cc#L93-L102) assumes that all records in the dataset are of string type. However, there is no check for that, and the example given above uses numeric types. We have patched the issue in GitHub commit e0b6e58c328059829c3eb968136f17aa72b6c876. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37650",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37651",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.FractionalAvgPoolGrad` can be tricked into accessing data outside of bounds of heap allocated buffers. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/fractional_avg_pool_op.cc#L205) does not validate that the input tensor is non-empty. Thus, code constructs an empty `EigenDoubleMatrixMap` and then accesses this buffer with indices that are outside of the empty area. We have patched the issue in GitHub commit 0f931751fb20f565c4e94aa6df58d54a003cdb30. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37651",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37652",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.BoostedTreesCreateEnsemble` can result in a use after free error if an attacker supplies specially crafted arguments. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/boosted_trees/resource_ops.cc#L55) uses a reference counted resource and decrements the refcount if the initialization fails, as it should. However, when the code was written, the resource was represented as a naked pointer but later refactoring has changed it to be a smart pointer. Thus, when the pointer leaves the scope, a subsequent `free`-ing of the resource occurs, but this fails to take into account that the refcount has already reached 0, thus the resource has been already freed. During this double-free process, members of the resource object are accessed for cleanup but they are invalid as the entire resource has been freed. We have patched the issue in GitHub commit 5ecec9c6fbdbc6be03295685190a45e7eee726ab. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37652",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37653",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a crash via a floating point exception in `tf.raw_ops.ResourceGather`. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/resource_variable_ops.cc#L725-L731) computes the value of a value, `batch_size`, and then divides by it without checking that this value is not 0. We have patched the issue in GitHub commit ac117ee8a8ea57b73d34665cdf00ef3303bc0b11. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37653",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37654",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a crash via a `CHECK`-fail in debug builds of TensorFlow using `tf.raw_ops.ResourceGather` or a read from outside the bounds of heap allocated data in the same API in a release build. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/resource_variable_ops.cc#L660-L668) does not check that the `batch_dims` value that the user supplies is less than the rank of the input tensor. Since the implementation uses several for loops over the dimensions of `tensor`, this results in reading data from outside the bounds of heap allocated buffer backing the tensor. We have patched the issue in GitHub commit bc9c546ce7015c57c2f15c168b3d9201de679a1d. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37654",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37655",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a read from outside of bounds of heap allocated data by sending invalid arguments to `tf.raw_ops.ResourceScatterUpdate`. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/resource_variable_ops.cc#L919-L923) has an incomplete validation of the relationship between the shapes of `indices` and `updates`: instead of checking that the shape of `indices` is a prefix of the shape of `updates` (so that broadcasting can happen), code only checks that the number of elements in these two tensors are in a divisibility relationship. We have patched the issue in GitHub commit 01cff3f986259d661103412a20745928c727326f. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37655",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37656",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.RaggedTensorToSparse`. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/ragged_tensor_to_sparse_kernel.cc#L30) has an incomplete validation of the splits values: it does not check that they are in increasing order. We have patched the issue in GitHub commit 1071f554dbd09f7e101324d366eec5f4fe5a3ece. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37656",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37657",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in all operations of type `tf.raw_ops.MatrixDiagV*`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/linalg/matrix_diag_op.cc) has incomplete validation that the value of `k` is a valid tensor. We have check that this value is either a scalar or a vector, but there is no check for the number of elements. If this is an empty tensor, then code that accesses the first element of the tensor is wrong. We have patched the issue in GitHub commit f2a673bd34f0d64b8e40a551ac78989d16daad09. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37657",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37658",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in all operations of type `tf.raw_ops.MatrixSetDiagV*`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/linalg/matrix_diag_op.cc) has incomplete validation that the value of `k` is a valid tensor. We have check that this value is either a scalar or a vector, but there is no check for the number of elements. If this is an empty tensor, then code that accesses the first element of the tensor is wrong. We have patched the issue in GitHub commit ff8894044dfae5568ecbf2ed514c1a37dc394f1b. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37658",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37659",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in all binary cwise operations that don't require broadcasting (e.g., gradients of binary cwise operations). The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/cwise_ops_common.h#L264) assumes that the two inputs have exactly the same number of elements but does not check that. Hence, when the eigen functor executes it triggers heap OOB reads and undefined behavior due to binding to nullptr. We have patched the issue in GitHub commit 93f428fd1768df147171ed674fee1fc5ab8309ec. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37659",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37660",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause a floating point exception by calling inplace operations with crafted arguments that would result in a division by 0. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/inplace_ops.cc#L283) has a logic error: it should skip processing if `x` and `v` are empty but the code uses `||` instead of `&&`. We have patched the issue in GitHub commit e86605c0a336c088b638da02135ea6f9f6753618. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37660",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37661",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause a denial of service in `boosted_trees_create_quantile_stream_resource` by using negative arguments. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/quantile_ops.cc#L96) does not validate that `num_streams` only contains non-negative numbers. In turn, [this results in using this value to allocate memory](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/quantiles/quantile_stream_resource.h#L31-L40). However, `reserve` receives an unsigned integer so there is an implicit conversion from a negative value to a large positive unsigned. This results in a crash from the standard library. We have patched the issue in GitHub commit 8a84f7a2b5a2b27ecf88d25bad9ac777cd2f7992. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37661",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37662",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can generate undefined behavior via a reference binding to nullptr in `BoostedTreesCalculateBestGainsPerFeature` and similar attack can occur in `BoostedTreesCalculateBestFeatureSplitV2`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/stats_ops.cc) does not validate the input values. We have patched the issue in GitHub commit 9c87c32c710d0b5b53dc6fd3bfde4046e1f7a5ad and in commit 429f009d2b2c09028647dd4bb7b3f6f414bbaad7. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37662",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37663",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions due to incomplete validation in `tf.raw_ops.QuantizeV2`, an attacker can trigger undefined behavior via binding a reference to a null pointer or can access data outside the bounds of heap allocated arrays. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/quantize_op.cc#L59) has some validation but does not check that `min_range` and `max_range` both have the same non-zero number of elements. If `axis` is provided (i.e., not `-1`), then validation should check that it is a value in range for the rank of `input` tensor and then the lengths of `min_range` and `max_range` inputs match the `axis` dimension of the `input` tensor. We have patched the issue in GitHub commit 6da6620efad397c85493b8f8667b821403516708. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37663",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37664",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can read from outside of bounds of heap allocated data by sending specially crafted illegal arguments to `BoostedTreesSparseCalculateBestFeatureSplit`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/stats_ops.cc) needs to validate that each value in `stats_summary_indices` is in range. We have patched the issue in GitHub commit e84c975313e8e8e38bb2ea118196369c45c51378. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37664",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37665",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions due to incomplete validation in MKL implementation of requantization, an attacker can trigger undefined behavior via binding a reference to a null pointer or can access data outside the bounds of heap allocated arrays. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/mkl/mkl_requantization_range_per_channel_op.cc) does not validate the dimensions of the `input` tensor. A similar issue occurs in `MklRequantizePerChannelOp`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/mkl/mkl_requantize_per_channel_op.cc) does not perform full validation for all the input arguments. We have patched the issue in GitHub commit 9e62869465573cb2d9b5053f1fa02a81fce21d69 and in the Github commit 203214568f5bc237603dbab6e1fd389f1572f5c9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37665",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37666",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.RaggedTensorToVariant`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/ragged_tensor_to_variant_op.cc#L129) has an incomplete validation of the splits values, missing the case when the argument would be empty. We have patched the issue in GitHub commit be7a4de6adfbd303ce08be4332554dff70362612. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37666",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37667",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.UnicodeEncode`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/unicode_ops.cc#L533-L539) reads the first dimension of the `input_splits` tensor before validating that this tensor is not empty. We have patched the issue in GitHub commit 2e0ee46f1a47675152d3d865797a18358881d7a6. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37667",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37668",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause denial of service in applications serving models using `tf.raw_ops.UnravelIndex` by triggering a division by 0. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/unravel_index_op.cc#L36) does not check that the tensor subsumed by `dims` is not empty. Hence, if one element of `dims` is 0, the implementation does a division by 0. We have patched the issue in GitHub commit a776040a5e7ebf76eeb7eb923bf1ae417dd4d233. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37668",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37669",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause denial of service in applications serving models using `tf.raw_ops.NonMaxSuppressionV5` by triggering a division by 0. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/image/non_max_suppression_op.cc#L170-L271) uses a user controlled argument to resize a `std::vector`. However, as `std::vector::resize` takes the size argument as a `size_t` and `output_size` is an `int`, there is an implicit conversion to unsigned. If the attacker supplies a negative value, this conversion results in a crash. A similar issue occurs in `CombinedNonMaxSuppression`. We have patched the issue in GitHub commit 3a7362750d5c372420aa8f0caf7bf5b5c3d0f52d and commit [b5cdbf12ffcaaffecf98f22a6be5a64bb96e4f58. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37669",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37670",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can read from outside of bounds of heap allocated data by sending specially crafted illegal arguments to `tf.raw_ops.UpperBound`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/searchsorted_op.cc#L85-L104) does not validate the rank of `sorted_input` argument. A similar issue occurs in `tf.raw_ops.LowerBound`. We have patched the issue in GitHub commit 42459e4273c2e47a3232cc16c4f4fff3b3a35c38. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37670",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37671",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.Map*` and `tf.raw_ops.OrderedMap*` operations. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/map_stage_op.cc#L222-L248) has a check in place to ensure that `indices` is in ascending order, but does not check that `indices` is not empty. We have patched the issue in GitHub commit 532f5c5a547126c634fefd43bbad1dc6417678ac. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37671",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37672",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can read from outside of bounds of heap allocated data by sending specially crafted illegal arguments to `tf.raw_ops.SdcaOptimizerV2`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/sdca_internal.cc#L320-L353) does not check that the length of `example_labels` is the same as the number of examples. We have patched the issue in GitHub commit a4e138660270e7599793fa438cd7b2fc2ce215a6. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37672",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37673",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.MapStage`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/map_stage_op.cc#L513) does not check that the `key` input is a valid non-empty tensor. We have patched the issue in GitHub commit d7de67733925de196ec8863a33445b73f9562d1d. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37673",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37674",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a denial of service via a segmentation fault in `tf.raw_ops.MaxPoolGrad` caused by missing validation. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/maxpooling_op.cc) misses some validation for the `orig_input` and `orig_output` tensors. The fixes for CVE-2021-29579 were incomplete. We have patched the issue in GitHub commit 136b51f10903e044308cf77117c0ed9871350475. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37674",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37675",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions most implementations of convolution operators in TensorFlow are affected by a division by 0 vulnerability where an attacker can trigger a denial of service via a crash. The shape inference [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/framework/common_shape_fns.cc#L577) is missing several validations before doing divisions and modulo operations. We have patched the issue in GitHub commit 8a793b5d7f59e37ac7f3cd0954a750a2fe76bad4. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37675",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37676",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.SparseFillEmptyRows`. The shape inference [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/ops/sparse_ops.cc#L608-L634) does not validate that the input arguments are not empty tensors. We have patched the issue in GitHub commit 578e634b4f1c1c684d4b4294f9e5281b2133b3ed. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37676",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37677",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the shape inference code for `tf.raw_ops.Dequantize` has a vulnerability that could trigger a denial of service via a segfault if an attacker provides invalid arguments. The shape inference [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/ops/array_ops.cc#L2999-L3014) uses `axis` to select between two different values for `minmax_rank` which is then used to retrieve tensor dimensions. However, code assumes that `axis` can be either `-1` or a value greater than `-1`, with no validation for the other values. We have patched the issue in GitHub commit da857cfa0fde8f79ad0afdbc94e88b5d4bbec764. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37677",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37678",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions TensorFlow and Keras can be tricked to perform arbitrary code execution when deserializing a Keras model from YAML format. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/python/keras/saving/model_config.py#L66-L104) uses `yaml.unsafe_load` which can perform arbitrary code execution on the input. Given that YAML format support requires a significant amount of work, we have removed it for now. We have patched the issue in GitHub commit 23d6383eb6c14084a8fc3bdf164043b974818012. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37678",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37679",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions it is possible to nest a `tf.map_fn` within another `tf.map_fn` call. However, if the input tensor is a `RaggedTensor` and there is no function signature provided, code assumes the output is a fully specified tensor and fills output buffer with uninitialized contents from the heap. The `t` and `z` outputs should be identical, however this is not the case. The last row of `t` contains data from the heap which can be used to leak other memory information. The bug lies in the conversion from a `Variant` tensor to a `RaggedTensor`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/ragged_tensor_from_variant_op.cc#L177-L190) does not check that all inner shapes match and this results in the additional dimensions. The same implementation can result in data loss, if input tensor is tweaked. We have patched the issue in GitHub commit 4e2565483d0ffcadc719bd44893fb7f609bb5f12. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37679",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37680",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of fully connected layers in TFLite is [vulnerable to a division by zero error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/fully_connected.cc#L226). We have patched the issue in GitHub commit 718721986aa137691ee23f03638867151f74935f. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37680",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37681",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of SVDF in TFLite is [vulnerable to a null pointer error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/svdf.cc#L300-L313). The [`GetVariableInput` function](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/kernel_util.cc#L115-L119) can return a null pointer but `GetTensorData` assumes that the argument is always a valid tensor. Furthermore, because `GetVariableInput` calls [`GetMutableInput`](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/kernel_util.cc#L82-L90) which might return `nullptr`, the `tensor->is_variable` expression can also trigger a null pointer exception. We have patched the issue in GitHub commit 5b048e87e4e55990dae6b547add4dae59f4e1c76. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37681",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37682",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions all TFLite operations that use quantization can be made to use unitialized values. [For example](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/depthwise_conv.cc#L198-L200). The issue stems from the fact that `quantization.params` is only valid if `quantization.type` is different that `kTfLiteNoQuantization`. However, these checks are missing in large parts of the code. We have patched the issue in GitHub commits 537bc7c723439b9194a358f64d871dd326c18887, 4a91f2069f7145aab6ba2d8cfe41be8a110c18a5 and 8933b8a21280696ab119b63263babdb54c298538. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37682",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37683",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of division in TFLite is [vulnerable to a division by 0 error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/div.cc). There is no check that the divisor tensor does not contain zero elements. We have patched the issue in GitHub commit 1e206baedf8bef0334cca3eb92bab134ef525a28. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37683",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37684",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementations of pooling in TFLite are vulnerable to division by 0 errors as there are no checks for divisors not being 0. We have patched the issue in GitHub commit [dfa22b348b70bb89d6d6ec0ff53973bacb4f4695](https://github.com/tensorflow/tensorflow/commit/dfa22b348b70bb89d6d6ec0ff53973bacb4f4695). The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37684",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37685",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions TFLite's [`expand_dims.cc`](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/expand_dims.cc#L36-L50) contains a vulnerability which allows reading one element outside of bounds of heap allocated data. If `axis` is a large negative value (e.g., `-100000`), then after the first `if` it would still be negative. The check following the `if` statement will pass and the `for` loop would read one element before the start of `input_dims.data` (when `i = 0`). We have patched the issue in GitHub commit d94ffe08a65400f898241c0374e9edc6fa8ed257. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37685",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37686",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the strided slice implementation in TFLite has a logic bug which can allow an attacker to trigger an infinite loop. This arises from newly introduced support for [ellipsis in axis definition](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/strided_slice.cc#L103-L122). An attacker can craft a model such that `ellipsis_end_idx` is smaller than `i` (e.g., always negative). In this case, the inner loop does not increase `i` and the `continue` statement causes execution to skip over the preincrement at the end of the outer loop. We have patched the issue in GitHub commit dfa22b348b70bb89d6d6ec0ff53973bacb4f4695. TensorFlow 2.6.0 is the only affected version.",
      "cve": "CVE-2021-37686",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37687",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions TFLite's [`GatherNd` implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/gather_nd.cc#L124) does not support negative indices but there are no checks for this situation. Hence, an attacker can read arbitrary data from the heap by carefully crafting a model with negative values in `indices`. Similar issue exists in [`Gather` implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/gather.cc). We have patched the issue in GitHub commits bb6a0383ed553c286f87ca88c207f6774d5c4a8f and eb921122119a6b6e470ee98b89e65d721663179d. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37687",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37688",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can craft a TFLite model that would trigger a null pointer dereference, which would result in a crash and denial of service. The [implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/internal/optimized/optimized_ops.h#L268-L285) unconditionally dereferences a pointer. We have patched the issue in GitHub commit 15691e456c7dc9bd6be203b09765b063bf4a380c. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37688",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37689",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can craft a TFLite model that would trigger a null pointer dereference, which would result in a crash and denial of service. This is caused by the MLIR optimization of `L2NormalizeReduceAxis` operator. The [implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/compiler/mlir/lite/transforms/optimize.cc#L67-L70) unconditionally dereferences a pointer to an iterator to a vector without checking that the vector has elements. We have patched the issue in GitHub commit d6b57f461b39fd1aa8c1b870f1b974aac3554955. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37689",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37690",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions when running shape functions, some functions (such as `MutableHashTableShape`) produce extra output information in the form of a `ShapeAndType` struct. The shapes embedded in this struct are owned by an inference context that is cleaned up almost immediately; if the upstream code attempts to access this shape information, it can trigger a segfault. `ShapeRefiner` is mitigating this for normal output shapes by cloning them (and thus putting the newly created shape under ownership of an inference context that will not die), but we were not doing the same for shapes and types. This commit fixes that by doing similar logic on output shapes and types. We have patched the issue in GitHub commit ee119d4a498979525046fba1c3dd3f13a039fbb1. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37690",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37691",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can craft a TFLite model that would trigger a division by zero error in LSH [implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/lsh_projection.cc#L118). We have patched the issue in GitHub commit 0575b640091680cfb70f4dd93e70658de43b94f9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick thiscommit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37691",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-37692",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions under certain conditions, Go code can trigger a segfault in string deallocation. For string tensors, `C.TF_TString_Dealloc` is called during garbage collection within a finalizer function. However, tensor structure isn't checked until encoding to avoid a performance penalty. The current method for dealloc assumes that encoding succeeded, but segfaults when a string tensor is garbage collected whose encoding failed (e.g., due to mismatched dimensions). To fix this, the call to set the finalizer function is deferred until `NewTensor` returns and, if encoding failed for a string tensor, deallocs are determined based on bytes written. We have patched the issue in GitHub commit 8721ba96e5760c229217b594f6d2ba332beedf22. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, which is the other affected version.",
      "cve": "CVE-2021-37692",
      "specs": [
        ">=2.5.0,<2.6.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41195",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `tf.math.segment_*` operations results in a `CHECK`-fail related abort (and denial of service) if a segment id in `segment_ids` is large. This is similar to CVE-2021-29584 (and similar other reported vulnerabilities in TensorFlow, localized to specific APIs): the implementation (both on CPU and GPU) computes the output shape using `AddDim`. However, if the number of elements in the tensor overflows an `int64_t` value, `AddDim` results in a `CHECK` failure which provokes a `std::abort`. Instead, code should use `AddDimWithStatus`. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41195",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41196",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the Keras pooling layers can trigger a segfault if the size of the pool is 0 or if a dimension is negative. This is due to the TensorFlow's implementation of pooling operations where the values in the sliding window are not checked to be strictly positive. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41196",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41197",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions TensorFlow allows tensor to have a large number of dimensions and each dimension can be as large as desired. However, the total number of elements in a tensor must fit within an `int64_t`. If an overflow occurs, `MultiplyWithoutOverflow` would return a negative result. In the majority of TensorFlow codebase this then results in a `CHECK`-failure. Newer constructs exist which return a `Status` instead of crashing the binary. This is similar to CVE-2021-29584. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41197",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41198",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions if `tf.tile` is called with a large input argument then the TensorFlow process will crash due to a `CHECK`-failure caused by an overflow. The number of elements in the output tensor is too much for the `int64_t` type and the overflow is detected via a `CHECK` statement. This aborts the process. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41198",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41199",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions if `tf.image.resize` is called with a large input argument then the TensorFlow process will crash due to a `CHECK`-failure caused by an overflow. The number of elements in the output tensor is too much for the `int64_t` type and the overflow is detected via a `CHECK` statement. This aborts the process. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41199",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41200",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions if `tf.summary.create_file_writer` is called with non-scalar arguments code crashes due to a `CHECK`-fail. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41200",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41201",
      "advisory": "TensorFlow is an open source platform for machine learning. In affeced versions during execution, `EinsumHelper::ParseEquation()` is supposed to set the flags in `input_has_ellipsis` vector and `*output_has_ellipsis` boolean to indicate whether there is ellipsis in the corresponding inputs and output. However, the code only changes these flags to `true` and never assigns `false`. This results in unitialized variable access if callers assume that `EinsumHelper::ParseEquation()` always sets these flags. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41201",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41202",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions while calculating the size of the output within the `tf.range` kernel, there is a conditional statement of type `int64 = condition ? int64 : double`. Due to C++ implicit conversion rules, both branches of the condition will be cast to `double` and the result would be truncated before the assignment. This result in overflows. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41202",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41203",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions an attacker can trigger undefined behavior, integer overflows, segfaults and `CHECK`-fail crashes if they can change saved checkpoints from outside of TensorFlow. This is because the checkpoints loading infrastructure is missing validation for invalid file formats. The fixes will be included in TensorFlow 2.7.0. We will also cherrypick these commits on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41203",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41204",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions during TensorFlow's Grappler optimizer phase, constant folding might attempt to deep copy a resource tensor. This results in a segfault, as these tensors are supposed to not change. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41204",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41205",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference functions for the `QuantizeAndDequantizeV*` operations can trigger a read outside of bounds of heap allocated array. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41205",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41206",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions several TensorFlow operations are missing validation for the shapes of the tensor arguments involved in the call. Depending on the API, this can result in undefined behavior and segfault or `CHECK`-fail related crashes but in some scenarios writes and reads from heap populated arrays are also possible. We have discovered these issues internally via tooling while working on improving/testing GPU op determinism. As such, we don't have reproducers and there will be multiple fixes for these issues. These fixes will be included in TensorFlow 2.7.0. We will also cherrypick these commits on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41206",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41207",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `ParallelConcat` misses some input validation and can produce a division by 0. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41207",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41208",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the code for boosted trees in TensorFlow is still missing validation. As a result, attackers can trigger denial of service (via dereferencing `nullptr`s or via `CHECK`-failures) as well as abuse undefined behavior (binding references to `nullptr`s). An attacker can also read and write from heap buffers, depending on the API that gets used and the arguments that are passed to the call. Given that the boosted trees implementation in TensorFlow is unmaintained, it is recommend to no longer use these APIs. We will deprecate TensorFlow's boosted trees APIs in subsequent releases. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41208",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41209",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementations for convolution operators trigger a division by 0 if passed empty filter tensor arguments. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41209",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41210",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference functions for `SparseCountSparseOutput` can trigger a read outside of bounds of heap allocated array. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41210",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41211",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `QuantizeV2` can trigger a read outside of bounds of heap allocated array. This occurs whenever `axis` is a negative value less than `-1`. In this case, we are accessing data before the start of a heap buffer. The code allows `axis` to be an optional argument (`s` would contain an `error::NOT_FOUND` error code). Otherwise, it assumes that `axis` is a valid index into the dimensions of the `input` tensor. If `axis` is less than `-1` then this results in a heap OOB read. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, as this version is the only one that is also affected.",
      "cve": "CVE-2021-41211",
      "specs": [
        "==2.6.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41212",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `tf.ragged.cross` can trigger a read outside of bounds of heap allocated array. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41212",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41213",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the code behind `tf.function` API can be made to deadlock when two `tf.function` decorated Python functions are mutually recursive. This occurs due to using a non-reentrant `Lock` Python object. Loading any model which contains mutually recursive functions is vulnerable. An attacker can cause denial of service by causing users to load such models and calling a recursive `tf.function`, although this is not a frequent scenario. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41213",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41214",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `tf.ragged.cross` has an undefined behavior due to binding a reference to `nullptr`. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41214",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41215",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `DeserializeSparse` can trigger a null pointer dereference. This is because the shape inference function assumes that the `serialize_sparse` tensor is a tensor with positive rank (and having `3` as the last dimension). The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41215",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41216",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference function for `Transpose` is vulnerable to a heap buffer overflow. This occurs whenever `perm` contains negative elements. The shape inference function does not validate that the indices in `perm` are all valid. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41216",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41217",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the process of building the control flow graph for a TensorFlow model is vulnerable to a null pointer exception when nodes that should be paired are not. This occurs because the code assumes that the first node in the pairing (e.g., an `Enter` node) always exists when encountering the second node (e.g., an `Exit` node). When this is not the case, `parent` is `nullptr` so dereferencing it causes a crash. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41217",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41218",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `AllToAll` can be made to execute a division by 0. This occurs whenever the `split_count` argument is 0. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41218",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41219",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the code for sparse matrix multiplication is vulnerable to undefined behavior via binding a reference to `nullptr`. This occurs whenever the dimensions of `a` or `b` are 0 or less. In the case on one of these is 0, an empty output tensor should be allocated (to conserve the invariant that output tensors are always allocated when the operation is successful) but nothing should be written to it (that is, we should return early from the kernel implementation). Otherwise, attempts to write to this empty tensor would result in heap OOB access. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41219",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41220",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the async implementation of `CollectiveReduceV2` suffers from a memory leak and a use after free. This occurs due to the asynchronous computation and the fact that objects that have been `std::move()`d from are still accessed. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, as this version is the only one that is also affected.",
      "cve": "CVE-2021-41220",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41221",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for the `Cudnn*` operations in TensorFlow can be tricked into accessing invalid memory, via a heap buffer overflow. This occurs because the ranks of the `input`, `input_h` and `input_c` parameters are not validated, but code assumes they have certain values. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41221",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41222",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `SplitV` can trigger a segfault is an attacker supplies negative arguments. This occurs whenever `size_splits` contains more than one value and at least one value is negative. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41222",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41223",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `FusedBatchNorm` kernels is vulnerable to a heap OOB access. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41223",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41224",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `SparseFillEmptyRows` can be made to trigger a heap OOB access. This occurs whenever the size of `indices` does not match the size of `values`. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41224",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41225",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions TensorFlow's Grappler optimizer has a use of unitialized variable. If the `train_nodes` vector (obtained from the saved model that gets optimized) does not contain a `Dequeue` node, then `dequeue_node` is left unitialized. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41225",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41226",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `SparseBinCount` is vulnerable to a heap OOB access. This is because of missing validation between the elements of the `values` argument and the shape of the sparse output. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41226",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41227",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the `ImmutableConst` operation in TensorFlow can be tricked into reading arbitrary memory contents. This is because the `tstring` TensorFlow string class has a special case for memory mapped strings but the operation itself does not offer any support for this datatype. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41227",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-cpu:CVE-2021-41228",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions TensorFlow's `saved_model_cli` tool is vulnerable to a code injection as it calls `eval` on user supplied strings. This can be used by attackers to run arbitrary code on the plaform where the CLI tool runs. However, given that the tool is always run manually, the impact of this is not severe. We have patched this by adding a `safe` flag which defaults to `True` and an explicit warning for users. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41228",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    }
  ],
  "tensorflow-gpu": [
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2018-10055",
      "advisory": "Invalid memory access and/or a heap buffer overflow in the TensorFlow XLA compiler in Google TensorFlow before 1.7.1 could cause a crash or read from other parts of process memory via a crafted configuration file.",
      "cve": "CVE-2018-10055",
      "specs": [
        "<1.7.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2018-21233",
      "advisory": "TensorFlow before 1.7.0 has an integer overflow that causes an out-of-bounds read, possibly causing disclosure of the contents of process memory. This occurs in the DecodeBmp feature of the BMP decoder in core/kernels/decode_bmp_op.cc.",
      "cve": "CVE-2018-21233",
      "specs": [
        "<1.7.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2018-7575",
      "advisory": "Google TensorFlow 1.7.x and earlier is affected by a Buffer Overflow vulnerability. The type of exploitation is context-dependent.",
      "cve": "CVE-2018-7575",
      "specs": [
        "<=1.7.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2018-7576",
      "advisory": "Google TensorFlow 1.6.x and earlier is affected by: Null Pointer Dereference. The type of exploitation is: context-dependent.",
      "cve": "CVE-2018-7576",
      "specs": [
        "<=1.6.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2018-7577",
      "advisory": "Memcpy parameter overlap in Google Snappy library 1.1.4, as used in Google TensorFlow before 1.7.1, could result in a crash or read from other parts of process memory.",
      "cve": "CVE-2018-7577",
      "specs": [
        "<1.7.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2018-8825",
      "advisory": "Google TensorFlow 1.7 and below is affected by: Buffer Overflow. The impact is: execute arbitrary code (local).",
      "cve": "CVE-2018-8825",
      "specs": [
        "<=1.7.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2019-16778",
      "advisory": "In TensorFlow before 1.15, a heap buffer overflow in UnsortedSegmentSum can be produced when the Index template argument is int32. In this case data_size and num_segments fields are truncated from int64 to int32 and can produce negative numbers, resulting in accessing out of bounds heap memory. This is unlikely to be exploitable and was detected and fixed internally in TensorFlow 1.15 and 2.0.",
      "cve": "CVE-2019-16778",
      "specs": [
        ">=1.0.0,<1.15.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2019-9635",
      "advisory": "NULL pointer dereference in Google TensorFlow before 1.12.2 could cause a denial of service via an invalid GIF file.",
      "cve": "CVE-2019-9635",
      "specs": [
        "<1.12.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15190",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `tf.raw_ops.Switch` operation takes as input a tensor and a boolean and outputs two tensors. Depending on the boolean value, one of the tensors is exactly the input tensor whereas the other one should be an empty tensor. However, the eager runtime traverses all tensors in the output. Since only one of the tensors is defined, the other one is `nullptr`, hence we are binding a reference to `nullptr`. This is undefined behavior and reported as an error if compiling with `-fsanitize=null`. In this case, this results in a segmentation fault The issue is patched in commit da8558533d925694483d2c136a9220d6d49d843c, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15190",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15191",
      "advisory": "In Tensorflow before versions 2.2.1 and 2.3.1, if a user passes an invalid argument to `dlpack.to_dlpack` the expected validations will cause variables to bind to `nullptr` while setting a `status` variable to the error condition. However, this `status` argument is not properly checked. Hence, code following these methods will bind references to null pointers. This is undefined behavior and reported as an error if compiling with `-fsanitize=null`. The issue is patched in commit 22e07fb204386768e5bcbea563641ea11f96ceb8 and is released in TensorFlow versions 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15191",
      "specs": [
        "==2.2.0",
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15192",
      "advisory": "In Tensorflow before versions 2.2.1 and 2.3.1, if a user passes a list of strings to `dlpack.to_dlpack` there is a memory leak following an expected validation failure. The issue occurs because the `status` argument during validation failures is not properly checked. Since each of the above methods can return an error status, the `status` value must be checked before continuing. The issue is patched in commit 22e07fb204386768e5bcbea563641ea11f96ceb8 and is released in TensorFlow versions 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15192",
      "specs": [
        "==2.2.0",
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15193",
      "advisory": "In Tensorflow before versions 2.2.1 and 2.3.1, the implementation of `dlpack.to_dlpack` can be made to use uninitialized memory resulting in further memory corruption. This is because the pybind11 glue code assumes that the argument is a tensor. However, there is nothing stopping users from passing in a Python object instead of a tensor. The uninitialized memory address is due to a `reinterpret_cast` Since the `PyObject` is a Python object, not a TensorFlow Tensor, the cast to `EagerTensor` fails. The issue is patched in commit 22e07fb204386768e5bcbea563641ea11f96ceb8 and is released in TensorFlow versions 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15193",
      "specs": [
        "==2.2.0",
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15194",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `SparseFillEmptyRowsGrad` implementation has incomplete validation of the shapes of its arguments. Although `reverse_index_map_t` and `grad_values_t` are accessed in a similar pattern, only `reverse_index_map_t` is validated to be of proper shape. Hence, malicious users can pass a bad `grad_values_t` to trigger an assertion failure in `vec`, causing denial of service in serving installations. The issue is patched in commit 390611e0d45c5793c7066110af37c8514e6a6c54, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.\"",
      "cve": "CVE-2020-15194",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15195",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the implementation of `SparseFillEmptyRowsGrad` uses a double indexing pattern. It is possible for `reverse_index_map(i)` to be an index outside of bounds of `grad_values`, thus resulting in a heap buffer overflow. The issue is patched in commit 390611e0d45c5793c7066110af37c8514e6a6c54, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15195",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15196",
      "advisory": "In Tensorflow version 2.3.0, the `SparseCountSparseOutput` and `RaggedCountSparseOutput` implementations don't validate that the `weights` tensor has the same shape as the data. The check exists for `DenseCountSparseOutput`, where both tensors are fully specified. In the sparse and ragged count weights are still accessed in parallel with the data. But, since there is no validation, a user passing fewer weights than the values for the tensors can generate a read from outside the bounds of the heap buffer allocated for the weights. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15196",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15197",
      "advisory": "In Tensorflow before version 2.3.1, the `SparseCountSparseOutput` implementation does not validate that the input arguments form a valid sparse tensor. In particular, there is no validation that the `indices` tensor has rank 2. This tensor must be a matrix because code assumes its elements are accessed as elements of a matrix. However, malicious users can pass in tensors of different rank, resulting in a `CHECK` assertion failure and a crash. This can be used to cause denial of service in serving installations, if users are allowed to control the components of the input sparse tensor. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15197",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15198",
      "advisory": "In Tensorflow before version 2.3.1, the `SparseCountSparseOutput` implementation does not validate that the input arguments form a valid sparse tensor. In particular, there is no validation that the `indices` tensor has the same shape as the `values` one. The values in these tensors are always accessed in parallel. Thus, a shape mismatch can result in accesses outside the bounds of heap allocated buffers. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15198",
      "specs": [
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15199",
      "advisory": "In Tensorflow before version 2.3.1, the `RaggedCountSparseOutput` does not validate that the input arguments form a valid ragged tensor. In particular, there is no validation that the `splits` tensor has the minimum required number of elements. Code uses this quantity to initialize a different data structure. Since `BatchedMap` is equivalent to a vector, it needs to have at least one element to not be `nullptr`. If user passes a `splits` tensor that is empty or has exactly one element, we get a `SIGABRT` signal raised by the operating system. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15199",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15200",
      "advisory": "In Tensorflow before version 2.3.1, the `RaggedCountSparseOutput` implementation does not validate that the input arguments form a valid ragged tensor. In particular, there is no validation that the values in the `splits` tensor generate a valid partitioning of the `values` tensor. Thus, the code sets up conditions to cause a heap buffer overflow. A `BatchedMap` is equivalent to a vector where each element is a hashmap. However, if the first element of `splits_values` is not 0, `batch_idx` will never be 1, hence there will be no hashmap at index 0 in `per_batch_counts`. Trying to access that in the user code results in a segmentation fault. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15200",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15201",
      "advisory": "In Tensorflow before version 2.3.1, the `RaggedCountSparseOutput` implementation does not validate that the input arguments form a valid ragged tensor. In particular, there is no validation that the values in the `splits` tensor generate a valid partitioning of the `values` tensor. Hence, the code is prone to heap buffer overflow. If `split_values` does not end with a value at least `num_values` then the `while` loop condition will trigger a read outside of the bounds of `split_values` once `batch_idx` grows too large. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15201",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15202",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `Shard` API in TensorFlow expects the last argument to be a function taking two `int64` (i.e., `long long`) arguments. However, there are several places in TensorFlow where a lambda taking `int` or `int32` arguments is being used. In these cases, if the amount of work to be parallelized is large enough, integer truncation occurs. Depending on how the two arguments of the lambda are used, this can result in segfaults, read/write outside of heap allocated arrays, stack overflows, or data corruption. The issue is patched in commits 27b417360cbd671ef55915e4bb6bb06af8b8a832 and ca8c013b5e97b1373b3bb1c97ea655e69f31a575, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15202",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15203",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, by controlling the `fill` argument of tf.strings.as_string, a malicious attacker is able to trigger a format string vulnerability due to the way the internal format use in a `printf` call is constructed. This may result in segmentation fault. The issue is patched in commit 33be22c65d86256e6826666662e40dbdfe70ee83, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15203",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15204",
      "advisory": "In eager mode, TensorFlow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1 does not set the session state. Hence, calling `tf.raw_ops.GetSessionHandle` or `tf.raw_ops.GetSessionHandleV2` results in a null pointer dereference In linked snippet, in eager mode, `ctx->session_state()` returns `nullptr`. Since code immediately dereferences this, we get a segmentation fault. The issue is patched in commit 9a133d73ae4b4664d22bd1aa6d654fec13c52ee1, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15204",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15205",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `data_splits` argument of `tf.raw_ops.StringNGrams` lacks validation. This allows a user to pass values that can cause heap overflow errors and even leak contents of memory In the linked code snippet, all the binary strings after `ee ff` are contents from the memory stack. Since these can contain return addresses, this data leak can be used to defeat ASLR. The issue is patched in commit 0462de5b544ed4731aa2fb23946ac22c01856b80, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15205",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15206",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, changing the TensorFlow's `SavedModel` protocol buffer and altering the name of required keys results in segfaults and data corruption while loading the model. This can cause a denial of service in products using `tensorflow-serving` or other inference-as-a-service installments. Fixed were added in commits f760f88b4267d981e13f4b302c437ae800445968 and fcfef195637c6e365577829c4d67681695956e7d (both going into TensorFlow 2.2.0 and 2.3.0 but not yet backported to earlier versions). However, this was not enough, as #41097 reports a different failure mode. The issue is patched in commit adf095206f25471e864a8e63a0f1caef53a0e3a6, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15206",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15207",
      "advisory": "In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, to mimic Python's indexing with negative values, TFLite uses `ResolveAxis` to convert negative values to positive indices. However, the only check that the converted index is now valid is only present in debug builds. If the `DCHECK` does not trigger, then code execution moves ahead with a negative index. This, in turn, results in accessing data out of bounds which results in segfaults and/or data corruption. The issue is patched in commit 2d88f470dea2671b430884260f3626b1fe99830a, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15207",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15208",
      "advisory": "In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, when determining the common dimension size of two tensors, TFLite uses a `DCHECK` which is no-op outside of debug compilation modes. Since the function always returns the dimension of the first tensor, malicious attackers can craft cases where this is larger than that of the second tensor. In turn, this would result in reads/writes outside of bounds since the interpreter will wrongly assume that there is enough data in both tensors. The issue is patched in commit 8ee24e7949a203d234489f9da2c5bf45a7d5157d, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15208",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15209",
      "advisory": "In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, a crafted TFLite model can force a node to have as input a tensor backed by a `nullptr` buffer. This can be achieved by changing a buffer index in the flatbuffer serialization to convert a read-only tensor to a read-write one. The runtime assumes that these buffers are written to before a possible read, hence they are initialized with `nullptr`. However, by changing the buffer index for a tensor and implicitly converting that tensor to be a read-write one, as there is nothing in the model that writes to it, we get a null pointer dereference. The issue is patched in commit 0b5662bc, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15209",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15210",
      "advisory": "In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, if a TFLite saved model uses the same tensor as both input and output of an operator, then, depending on the operator, we can observe a segmentation fault or just memory corruption. We have patched the issue in d58c96946b and will release patch releases for all versions between 1.15 and 2.3. We recommend users to upgrade to TensorFlow 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15210",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15211",
      "advisory": "In TensorFlow Lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, saved models in the flatbuffer format use a double indexing scheme: a model has a set of subgraphs, each subgraph has a set of operators and each operator has a set of input/output tensors. The flatbuffer format uses indices for the tensors, indexing into an array of tensors that is owned by the subgraph. This results in a pattern of double array indexing when trying to get the data of each tensor. However, some operators can have some tensors be optional. To handle this scenario, the flatbuffer model uses a negative `-1` value as index for these tensors. This results in special casing during validation at model loading time. Unfortunately, this means that the `-1` index is a valid tensor index for any operator, including those that don't expect optional inputs and including for output tensors. Thus, this allows writing and reading from outside the bounds of heap allocated arrays, although only at a specific offset from the start of these arrays. This results in both read and write gadgets, albeit very limited in scope. The issue is patched in several commits (46d5b0852, 00302787b7, e11f5558, cd31fd0ce, 1970c21, and fff2c83), and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to the model loading code to ensure that only operators which accept optional inputs use the `-1` special value and only for the tensors that they expect to be optional. Since this allow-list type approach is erro-prone, we advise upgrading to the patched code.",
      "cve": "CVE-2020-15211",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15212",
      "advisory": "In TensorFlow Lite before versions 2.2.1 and 2.3.1, models using segment sum can trigger writes outside of bounds of heap allocated buffers by inserting negative elements in the segment ids tensor. Users having access to `segment_ids_data` can alter `output_index` and then write to outside of `output_data` buffer. This might result in a segmentation fault but it can also be used to further corrupt the memory and can be chained with other vulnerabilities to create more advanced exploits. The issue is patched in commit 204945b19e44b57906c9344c0d00120eeeae178a and is released in TensorFlow versions 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to the model loading code to ensure that the segment ids are all positive, although this only handles the case when the segment ids are stored statically in the model. A similar validation could be done if the segment ids are generated at runtime between inference steps. If the segment ids are generated as outputs of a tensor during inference steps, then there are no possible workaround and users are advised to upgrade to patched code.",
      "cve": "CVE-2020-15212",
      "specs": [
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15213",
      "advisory": "In TensorFlow Lite before versions 2.2.1 and 2.3.1, models using segment sum can trigger a denial of service by causing an out of memory allocation in the implementation of segment sum. Since code uses the last element of the tensor holding them to determine the dimensionality of output tensor, attackers can use a very large value to trigger a large allocation. The issue is patched in commit 204945b19e44b57906c9344c0d00120eeeae178a and is released in TensorFlow versions 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to limit the maximum value in the segment ids tensor. This only handles the case when the segment ids are stored statically in the model, but a similar validation could be done if the segment ids are generated at runtime, between inference steps. However, if the segment ids are generated as outputs of a tensor during inference steps, then there are no possible workaround and users are advised to upgrade to patched code.",
      "cve": "CVE-2020-15213",
      "specs": [
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15214",
      "advisory": "In TensorFlow Lite before versions 2.2.1 and 2.3.1, models using segment sum can trigger a write out bounds / segmentation fault if the segment ids are not sorted. Code assumes that the segment ids are in increasing order, using the last element of the tensor holding them to determine the dimensionality of output tensor. This results in allocating insufficient memory for the output tensor and in a write outside the bounds of the output array. This usually results in a segmentation fault, but depending on runtime conditions it can provide for a write gadget to be used in future memory corruption-based exploits. The issue is patched in commit 204945b19e44b57906c9344c0d00120eeeae178a and is released in TensorFlow versions 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to the model loading code to ensure that the segment ids are sorted, although this only handles the case when the segment ids are stored statically in the model. A similar validation could be done if the segment ids are generated at runtime between inference steps. If the segment ids are generated as outputs of a tensor during inference steps, then there are no possible workaround and users are advised to upgrade to patched code.",
      "cve": "CVE-2020-15214",
      "specs": [
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15265",
      "advisory": "In Tensorflow before version 2.4.0, an attacker can pass an invalid `axis` value to `tf.quantization.quantize_and_dequantize`. This results in accessing a dimension outside the rank of the input tensor in the C++ kernel implementation. However, dim_size only does a DCHECK to validate the argument and then uses it to access the corresponding element of an array. Since in normal builds, `DCHECK`-like macros are no-ops, this results in segfault and access out of bounds of the array. The issue is patched in eccb7ec454e6617738554a255d77f08e60ee0808 and TensorFlow 2.4.0 will be released containing the patch. TensorFlow nightly packages after this commit will also have the issue resolved.",
      "cve": "CVE-2020-15265",
      "specs": [
        "<2.4.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-15266",
      "advisory": "In Tensorflow before version 2.4.0, when the `boxes` argument of `tf.image.crop_and_resize` has a very large value, the CPU kernel implementation receives it as a C++ `nan` floating point value. Attempting to operate on this is undefined behavior which later produces a segmentation fault. The issue is patched in eccb7ec454e6617738554a255d77f08e60ee0808 and TensorFlow 2.4.0 will be released containing the patch. TensorFlow nightly packages after this commit will also have the issue resolved.",
      "cve": "CVE-2020-15266",
      "specs": [
        "<2.4.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-26266",
      "advisory": "In affected versions of TensorFlow under certain cases a saved model can trigger use of uninitialized values during code execution. This is caused by having tensor buffers be filled with the default value of the type but forgetting to default initialize the quantized floating point types in Eigen. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26266",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-26267",
      "advisory": "In affected versions of TensorFlow the tf.raw_ops.DataFormatVecPermute API does not validate the src_format and dst_format attributes. The code assumes that these two arguments define a permutation of NHWC. This can result in uninitialized memory accesses, read outside of bounds and even crashes. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26267",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-26268",
      "advisory": "In affected versions of TensorFlow the tf.raw_ops.ImmutableConst operation returns a constant tensor created from a memory mapped file which is assumed immutable. However, if the type of the tensor is not an integral type, the operation crashes the Python interpreter as it tries to write to the memory area. If the file is too small, TensorFlow properly returns an error as the memory area has fewer bytes than what is needed for the tensor it creates. However, as soon as there are enough bytes, the above snippet causes a segmentation fault. This is because the allocator used to return the buffer data is not marked as returning an opaque handle since the needed virtual method is not overridden. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26268",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-26269",
      "advisory": "In TensorFlow release candidate versions 2.4.0rc*, the general implementation for matching filesystem paths to globbing pattern is vulnerable to an access out of bounds of the array holding the directories. There are multiple invariants and preconditions that are assumed by the parallel implementation of GetMatchingPaths but are not verified by the PRs introducing it (#40861 and #44310). Thus, we are completely rewriting the implementation to fully specify and validate these. This is patched in version 2.4.0. This issue only impacts master branch and the release candidates for TF version 2.4. The final release of the 2.4 release will be patched.",
      "cve": "CVE-2020-26269",
      "specs": [
        "==2.4.0-rc0",
        "==2.4.0-rc1",
        "==2.4.0-rc2",
        "==2.4.0-rc3",
        "==2.4.0-rc4"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-26270",
      "advisory": "In affected versions of TensorFlow running an LSTM/GRU model where the LSTM/GRU layer receives an input with zero-length results in a CHECK failure when using the CUDA backend. This can result in a query-of-death vulnerability, via denial of service, if users can control the input to the layer. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26270",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-26271",
      "advisory": "In affected versions of TensorFlow under certain cases, loading a saved model can result in accessing uninitialized memory while building the computation graph. The MakeEdge function creates an edge between one output tensor of the src node (given by output_index) and the input slot of the dst node (given by input_index). This is only possible if the types of the tensors on both sides coincide, so the function begins by obtaining the corresponding DataType values and comparing these for equality. However, there is no check that the indices point to inside of the arrays they index into. Thus, this can result in accessing data out of bounds of the corresponding heap allocated arrays. In most scenarios, this can manifest as unitialized data access, but if the index points far away from the boundaries of the arrays this can be used to leak addresses from the library. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26271",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2020-5215",
      "advisory": "In TensorFlow before 1.15.2 and 2.0.1, converting a string (from Python) to a tf.float16 value results in a segmentation fault in eager mode as the format checks for this use case are only in the graph mode. This issue can lead to denial of service in inference/training where a malicious attacker can send a data point which contains a string instead of a tf.float16 value. Similar effects can be obtained by manipulating saved models and checkpoints whereby replacing a scalar tf.float16 value with a scalar string will trigger this issue due to automatic conversions. This can be easily reproduced by tf.constant(\"hello\", tf.float16), if eager execution is enabled. This issue is patched in TensorFlow 1.15.1 and 2.0.1 with this vulnerability patched. TensorFlow 2.1.0 was released after we fixed the issue, thus it is not affected. Users are encouraged to switch to TensorFlow 1.15.1, 2.0.1 or 2.1.0.",
      "cve": "CVE-2020-5215",
      "specs": [
        "<1.15.2",
        ">=2.0.0,<2.0.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29512",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. If the `splits` argument of `RaggedBincount` does not specify a valid `SparseTensor`(https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor), then an attacker can trigger a heap buffer overflow. This will cause a read from outside the bounds of the `splits` tensor buffer in the implementation of the `RaggedBincount` op(https://github.com/tensorflow/tensorflow/blob/8b677d79167799f71c42fd3fa074476e0295413a/tensorflow/core/kernels/bincount_op.cc#L430-L433). Before the `for` loop, `batch_idx` is set to 0. The user controls the `splits` array, making it contain only one element, 0. Thus, the code in the `while` loop would increment `batch_idx` and then try to read `splits(1)`, which is outside of bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3, as these are also affected.",
      "cve": "CVE-2021-29512",
      "specs": [
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29513",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Calling TF operations with tensors of non-numeric types when the operations expect numeric tensors result in null pointer dereferences. The conversion from Python array to C++ array(https://github.com/tensorflow/tensorflow/blob/ff70c47a396ef1e3cb73c90513da4f5cb71bebba/tensorflow/python/lib/core/ndarray_tensor.cc#L113-L169) is vulnerable to a type confusion. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29513",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29514",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. If the `splits` argument of `RaggedBincount` does not specify a valid `SparseTensor`(https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor), then an attacker can trigger a heap buffer overflow. This will cause a read from outside the bounds of the `splits` tensor buffer in the implementation of the `RaggedBincount` op(https://github.com/tensorflow/tensorflow/blob/8b677d79167799f71c42fd3fa074476e0295413a/tensorflow/core/kernels/bincount_op.cc#L430-L446). Before the `for` loop, `batch_idx` is set to 0. The attacker sets `splits(0)` to be 7, hence the `while` loop does not execute and `batch_idx` remains 0. This then results in writing to `out(-1, bin)`, which is before the heap allocated buffer for the output tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3, as these are also affected.",
      "cve": "CVE-2021-29514",
      "specs": [
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29515",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `MatrixDiag*` operations(https://github.com/tensorflow/tensorflow/blob/4c4f420e68f1cfaf8f4b6e8e3eb857e9e4c3ff33/tensorflow/core/kernels/linalg/matrix_diag_op.cc#L195-L197) does not validate that the tensor arguments are non-empty. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29515",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29516",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Calling `tf.raw_ops.RaggedTensorToVariant` with arguments specifying an invalid ragged tensor results in a null pointer dereference. The implementation of `RaggedTensorToVariant` operations(https://github.com/tensorflow/tensorflow/blob/904b3926ed1c6c70380d5313d282d248a776baa1/tensorflow/core/kernels/ragged_tensor_to_variant_op.cc#L39-L40) does not validate that the ragged tensor argument is non-empty. Since `batched_ragged` contains no elements, `batched_ragged.splits` is a null vector, thus `batched_ragged.splits(0)` will result in dereferencing `nullptr`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29516",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29517",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. A malicious user could trigger a division by 0 in `Conv3D` implementation. The implementation(https://github.com/tensorflow/tensorflow/blob/42033603003965bffac51ae171b51801565e002d/tensorflow/core/kernels/conv_ops_3d.cc#L143-L145) does a modulo operation based on user controlled input. Thus, when `filter` has a 0 as the fifth element, this results in a division by 0. Additionally, if the shape of the two tensors is not valid, an Eigen assertion can be triggered, resulting in a program crash. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29517",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29518",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In eager mode (default in TF 2.0 and later), session operations are invalid. However, users could still call the raw ops associated with them and trigger a null pointer dereference. The implementation(https://github.com/tensorflow/tensorflow/blob/eebb96c2830d48597d055d247c0e9aebaea94cd5/tensorflow/core/kernels/session_ops.cc#L104) dereferences the session state pointer without checking if it is valid. Thus, in eager mode, `ctx->session_state()` is nullptr and the call of the member function is undefined behavior. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29518",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29519",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The API of `tf.raw_ops.SparseCross` allows combinations which would result in a `CHECK`-failure and denial of service. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/3d782b7d47b1bf2ed32bd4a246d6d6cadc4c903d/tensorflow/core/kernels/sparse_cross_op.cc#L114-L116) is tricked to consider a tensor of type `tstring` which in fact contains integral elements. Fixing the type confusion by preventing mixing `DT_STRING` and `DT_INT64` types solves this issue. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29519",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29520",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Missing validation between arguments to `tf.raw_ops.Conv3DBackprop*` operations can result in heap buffer overflows. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/4814fafb0ca6b5ab58a09411523b2193fed23fed/tensorflow/core/kernels/conv_grad_shape_utils.cc#L94-L153) assumes that the `input`, `filter_sizes` and `out_backprop` tensors have the same shape, as they are accessed in parallel. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29520",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29521",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Specifying a negative dense shape in `tf.raw_ops.SparseCountSparseOutput` results in a segmentation fault being thrown out from the standard library as `std::vector` invariants are broken. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/8f7b60ee8c0206a2c99802e3a4d1bb55d2bc0624/tensorflow/core/kernels/count_ops.cc#L199-L213) assumes the first element of the dense shape is always positive and uses it to initialize a `BatchedMap<T>` (i.e., `std::vector<absl::flat_hash_map<int64,T>>`(https://github.com/tensorflow/tensorflow/blob/8f7b60ee8c0206a2c99802e3a4d1bb55d2bc0624/tensorflow/core/kernels/count_ops.cc#L27)) data structure. If the `shape` tensor has more than one element, `num_batches` is the first value in `shape`. Ensuring that the `dense_shape` argument is a valid tensor shape (that is, all elements are non-negative) solves this issue. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3.",
      "cve": "CVE-2021-29521",
      "specs": [
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29522",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The `tf.raw_ops.Conv3DBackprop*` operations fail to validate that the input tensors are not empty. In turn, this would result in a division by 0. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a91bb59769f19146d5a0c20060244378e878f140/tensorflow/core/kernels/conv_grad_ops_3d.cc#L430-L450) does not check that the divisor used in computing the shard size is not zero. Thus, if attacker controls the input sizes, they can trigger a denial of service via a division by zero error. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29522",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29523",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.AddManySparseToTensorsMap`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/kernels/sparse_tensors_map_ops.cc#L257) takes the values specified in `sparse_shape` as dimensions for the output shape. The `TensorShape` constructor(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L183-L188) uses a `CHECK` operation which triggers when `InitDims`(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L212-L296) returns a non-OK status. This is a legacy implementation of the constructor and operations should use `BuildTensorShapeBase` or `AddDimWithStatus` to prevent `CHECK`-failures in the presence of overflows. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29523",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29524",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/496c2630e51c1a478f095b084329acedb253db6b/tensorflow/core/kernels/conv_grad_shape_utils.cc#L130) does a modulus operation where the divisor is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29524",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29525",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2DBackpropInput`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/b40060c9f697b044e3107917c797ba052f4506ab/tensorflow/core/kernels/conv_grad_input_ops.h#L625-L655) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29525",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29526",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2D`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/988087bd83f144af14087fe4fecee2d250d93737/tensorflow/core/kernels/conv_ops.cc#L261-L263) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29526",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29527",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.QuantizedConv2D`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/00e9a4d67d76703fa1aee33dac582acf317e0e81/tensorflow/core/kernels/quantized_conv_ops.cc#L257-L259) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29527",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29528",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.QuantizedMul`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/55900e961ed4a23b438392024912154a2c2f5e85/tensorflow/core/kernels/quantized_mul_op.cc#L188-L198) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29528",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29529",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a heap buffer overflow in `tf.raw_ops.QuantizedResizeBilinear` by manipulating input values so that float rounding results in off-by-one error in accessing image elements. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/44b7f486c0143f68b56c34e2d01e146ee445134a/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L62-L66) computes two integers (representing the upper and lower bounds for interpolation) by ceiling and flooring a floating point value. For some values of `in`, `interpolation->upper[i]` might be smaller than `interpolation->lower[i]`. This is an issue if `interpolation->upper[i]` is capped at `in_size-1` as it means that `interpolation->lower[i]` points outside of the image. Then, in the interpolation code(https://github.com/tensorflow/tensorflow/blob/44b7f486c0143f68b56c34e2d01e146ee445134a/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L245-L264), this would result in heap buffer overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29529",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29530",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a null pointer dereference by providing an invalid `permutation` to `tf.raw_ops.SparseMatrixSparseCholesky`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/080f1d9e257589f78b3ffb75debf584168aa6062/tensorflow/core/kernels/sparse/sparse_cholesky_op.cc#L85-L86) fails to properly validate the input arguments. Although `ValidateInputs` is called and there are checks in the body of this function, the code proceeds to the next line in `ValidateInputs` since `OP_REQUIRES`(https://github.com/tensorflow/tensorflow/blob/080f1d9e257589f78b3ffb75debf584168aa6062/tensorflow/core/framework/op_requires.h#L41-L48) is a macro that only exits the current function. Thus, the first validation condition that fails in `ValidateInputs` will cause an early return from that function. However, the caller will continue execution from the next line. The fix is to either explicitly check `context->status()` or to convert `ValidateInputs` to return a `Status`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29530",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29531",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a `CHECK` fail in PNG encoding by providing an empty input tensor as the pixel data. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/e312e0791ce486a80c9d23110841525c6f7c3289/tensorflow/core/kernels/image/encode_png_op.cc#L57-L60) only validates that the total number of pixels in the image does not overflow. Thus, an attacker can send an empty matrix for encoding. However, if the tensor is empty, then the associated buffer is `nullptr`. Hence, when calling `png::WriteImageToBuffer`(https://github.com/tensorflow/tensorflow/blob/e312e0791ce486a80c9d23110841525c6f7c3289/tensorflow/core/kernels/image/encode_png_op.cc#L79-L93), the first argument (i.e., `image.flat<T>().data()`) is `NULL`. This then triggers the `CHECK_NOTNULL` in the first line of `png::WriteImageToBuffer`(https://github.com/tensorflow/tensorflow/blob/e312e0791ce486a80c9d23110841525c6f7c3289/tensorflow/core/lib/png/png_io.cc#L345-L349). Since `image` is null, this results in `abort` being called after printing the stacktrace. Effectively, this allows an attacker to mount a denial of service attack. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29531",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29532",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can force accesses outside the bounds of heap allocated arrays by passing in invalid tensor values to `tf.raw_ops.RaggedCross`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/efea03b38fb8d3b81762237dc85e579cc5fc6e87/tensorflow/core/kernels/ragged_cross_op.cc#L456-L487) lacks validation for the user supplied arguments. Each of the above branches call a helper function after accessing array elements via a `*_list[next_*]` pattern, followed by incrementing the `next_*` index. However, as there is no validation that the `next_*` values are in the valid range for the corresponding `*_list` arrays, this results in heap OOB reads. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29532",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29533",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK` failure by passing an empty image to `tf.raw_ops.DrawBoundingBoxes`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/ea34a18dc3f5c8d80a40ccca1404f343b5d55f91/tensorflow/core/kernels/image/draw_bounding_box_op.cc#L148-L165) uses `CHECK_*` assertions instead of `OP_REQUIRES` to validate user controlled inputs. Whereas `OP_REQUIRES` allows returning an error condition back to the user, the `CHECK_*` macros result in a crash if the condition is false, similar to `assert`. In this case, `height` is 0 from the `images` input. This results in `max_box_row_clamp` being negative and the assertion being falsified, followed by aborting program execution. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29533",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29534",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.SparseConcat`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/b432a38fe0e1b4b904a6c222cbce794c39703e87/tensorflow/core/kernels/sparse_concat_op.cc#L76) takes the values specified in `shapes[0]` as dimensions for the output shape. The `TensorShape` constructor(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L183-L188) uses a `CHECK` operation which triggers when `InitDims`(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L212-L296) returns a non-OK status. This is a legacy implementation of the constructor and operations should use `BuildTensorShapeBase` or `AddDimWithStatus` to prevent `CHECK`-failures in the presence of overflows. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29534",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29535",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedMul` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/87cf4d3ea9949051e50ca3f071fc909538a51cd0/tensorflow/core/kernels/quantized_mul_op.cc#L287-L290) assumes that the 4 arguments are always valid scalars and tries to access the numeric value directly. However, if any of these tensors is empty, then `.flat<T>()` is an empty buffer and accessing the element at position 0 results in overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29535",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29536",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedReshape` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a324ac84e573fba362a5e53d4e74d5de6729933e/tensorflow/core/kernels/quantized_reshape_op.cc#L38-L55) assumes that the 2 arguments are always valid scalars and tries to access the numeric value directly. However, if any of these tensors is empty, then `.flat<T>()` is an empty buffer and accessing the element at position 0 results in overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29536",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29537",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedResizeBilinear` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/50711818d2e61ccce012591eeb4fdf93a8496726/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L705-L706) assumes that the 2 arguments are always valid scalars and tries to access the numeric value directly. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29537",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29538",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a division by zero to occur in `Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1b0296c3b8dd9bd948f924aa8cd62f87dbb7c3da/tensorflow/core/kernels/conv_grad_filter_ops.cc#L513-L522) computes a divisor based on user provided data (i.e., the shape of the tensors given as arguments). If all shapes are empty then `work_unit_size` is 0. Since there is no check for this case before division, this results in a runtime exception, with potential to be abused for a denial of service. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29538",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29539",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Calling `tf.raw_ops.ImmutableConst`(https://www.tensorflow.org/api_docs/python/tf/raw_ops/ImmutableConst) with a `dtype` of `tf.resource` or `tf.variant` results in a segfault in the implementation as code assumes that the tensor contents are pure scalars. We have patched the issue in 4f663d4b8f0bec1b48da6fa091a7d29609980fa4 and will release TensorFlow 2.5.0 containing the patch. TensorFlow nightly packages after this commit will also have the issue resolved. If using `tf.raw_ops.ImmutableConst` in code, you can prevent the segfault by inserting a filter for the `dtype` argument.",
      "cve": "CVE-2021-29539",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29540",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow to occur in `Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1b0296c3b8dd9bd948f924aa8cd62f87dbb7c3da/tensorflow/core/kernels/conv_grad_filter_ops.cc#L495-L497) computes the size of the filter tensor but does not validate that it matches the number of elements in `filter_sizes`. Later, when reading/writing to this buffer, code uses the value computed here, instead of the number of elements in the tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29540",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29541",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a dereference of a null pointer in `tf.raw_ops.StringNGrams`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1cdd4da14282210cc759e468d9781741ac7d01bf/tensorflow/core/kernels/string_ngrams_op.cc#L67-L74) does not fully validate the `data_splits` argument. This would result in `ngrams_data`(https://github.com/tensorflow/tensorflow/blob/1cdd4da14282210cc759e468d9781741ac7d01bf/tensorflow/core/kernels/string_ngrams_op.cc#L106-L110) to be a null pointer when the output would be computed to have 0 or negative size. Later writes to the output tensor would then cause a null pointer dereference. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29541",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29542",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow by passing crafted inputs to `tf.raw_ops.StringNGrams`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1cdd4da14282210cc759e468d9781741ac7d01bf/tensorflow/core/kernels/string_ngrams_op.cc#L171-L185) fails to consider corner cases where input would be split in such a way that the generated tokens should only contain padding elements. If input is such that `num_tokens` is 0, then, for `data_start_index=0` (when left padding is present), the marked line would result in reading `data[-1]`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29542",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29543",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.CTCGreedyDecoder`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1615440b17b364b875eb06f43d087381f1460a65/tensorflow/core/kernels/ctc_decoder_ops.cc#L37-L50) has a `CHECK_LT` inserted to validate some invariants. When this condition is false, the program aborts, instead of returning a valid error to the user. This abnormal termination can be weaponized in denial of service attacks. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29543",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29544",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.QuantizeAndDequantizeV4Grad`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/95078c145b5a7a43ee046144005f733092756ab5/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L162-L163) does not validate the rank of the `input_*` tensors. In turn, this results in the tensors being passes as they are to `QuantizeAndDequantizePerChannelGradientImpl`(https://github.com/tensorflow/tensorflow/blob/95078c145b5a7a43ee046144005f733092756ab5/tensorflow/core/kernels/quantize_and_dequantize_op.h#L295-L306). However, the `vec<T>` method, requires the rank to 1 and triggers a `CHECK` failure otherwise. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 as this is the only other affected version.",
      "cve": "CVE-2021-29544",
      "specs": [
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29545",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in converting sparse tensors to CSR Sparse matrices. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/800346f2c03a27e182dd4fba48295f65e7790739/tensorflow/core/kernels/sparse/kernels.cc#L66) does a double redirection to access an element of an array allocated on the heap. If the value at `indices(i, 0)` is such that `indices(i, 0) + 1` is outside the bounds of `csr_row_ptr`, this results in writing outside of bounds of heap allocated data. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29545",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29546",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger an integer division by zero undefined behavior in `tf.raw_ops.QuantizedBiasAdd`. This is because the implementation of the Eigen kernel(https://github.com/tensorflow/tensorflow/blob/61bca8bd5ba8a68b2d97435ddfafcdf2b85672cd/tensorflow/core/kernels/quantization_utils.h#L812-L849) does a division by the number of elements of the smaller input (based on shape) without checking that this is not zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29546",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29547",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a segfault and denial of service via accessing data outside of bounds in `tf.raw_ops.QuantizedBatchNormWithGlobalNormalization`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/55a97caa9e99c7f37a0bbbeb414dc55553d3ae7f/tensorflow/core/kernels/quantized_batch_norm_op.cc#L176-L189) assumes the inputs are not empty. If any of these inputs is empty, `.flat<T>()` is an empty buffer, so accessing the element at index 0 is accessing data outside of bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29547",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29548",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a runtime division by zero error and denial of service in `tf.raw_ops.QuantizedBatchNormWithGlobalNormalization`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/55a97caa9e99c7f37a0bbbeb414dc55553d3ae7f/tensorflow/core/kernels/quantized_batch_norm_op.cc) does not validate all constraints specified in the op's contract(https://www.tensorflow.org/api_docs/python/tf/raw_ops/QuantizedBatchNormWithGlobalNormalization). The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29548",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29549",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a runtime division by zero error and denial of service in `tf.raw_ops.QuantizedBatchNormWithGlobalNormalization`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/6f26b3f3418201479c264f2a02000880d8df151c/tensorflow/core/kernels/quantized_add_op.cc#L289-L295) computes a modulo operation without validating that the divisor is not zero. Since `vector_num_elements` is determined based on input shapes(https://github.com/tensorflow/tensorflow/blob/6f26b3f3418201479c264f2a02000880d8df151c/tensorflow/core/kernels/quantized_add_op.cc#L522-L544), a user can trigger scenarios where this quantity is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29549",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29550",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a runtime division by zero error and denial of service in `tf.raw_ops.FractionalAvgPool`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/acc8ee69f5f46f92a3f1f11230f49c6ac266f10c/tensorflow/core/kernels/fractional_avg_pool_op.cc#L85-L89) computes a divisor quantity by dividing two user controlled values. The user controls the values of `input_size[i]` and `pooling_ratio_[i]` (via the `value.shape()` and `pooling_ratio` arguments). If the value in `input_size[i]` is smaller than the `pooling_ratio_[i]`, then the floor operation results in `output_size[i]` being 0. The `DCHECK_GT` line is a no-op outside of debug mode, so in released versions of TF this does not trigger. Later, these computed values are used as arguments(https://github.com/tensorflow/tensorflow/blob/acc8ee69f5f46f92a3f1f11230f49c6ac266f10c/tensorflow/core/kernels/fractional_avg_pool_op.cc#L96-L99) to `GeneratePoolingSequence`(https://github.com/tensorflow/tensorflow/blob/acc8ee69f5f46f92a3f1f11230f49c6ac266f10c/tensorflow/core/kernels/fractional_pool_common.cc#L100-L108). There, the first computation is a division in a modulo operation. Since `output_length` can be 0, this results in runtime crashing. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29550",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29551",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `MatrixTriangularSolve`(https://github.com/tensorflow/tensorflow/blob/8cae746d8449c7dda5298327353d68613f16e798/tensorflow/core/kernels/linalg/matrix_triangular_solve_op_impl.h#L160-L240) fails to terminate kernel execution if one validation condition fails. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29551",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29552",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by controlling the values of `num_segments` tensor argument for `UnsortedSegmentJoin`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a2a607db15c7cd01d754d37e5448d72a13491bdb/tensorflow/core/kernels/unsorted_segment_join_op.cc#L92-L93) assumes that the `num_segments` tensor is a valid scalar. Since the tensor is empty the `CHECK` involved in `.scalar<T>()()` that checks that the number of elements is exactly 1 will be invalidated and this would result in process termination. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29552",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29553",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can read data outside of bounds of heap allocated buffer in `tf.raw_ops.QuantizeAndDequantizeV3`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/11ff7f80667e6490d7b5174aa6bf5e01886e770f/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L237) does not validate the value of user supplied `axis` attribute before using it to index in the array backing the `input` argument. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29553",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29554",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.DenseCountSparseOutput`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/efff014f3b2d8ef6141da30c806faf141297eca1/tensorflow/core/kernels/count_ops.cc#L123-L127) computes a divisor value from user data but does not check that the result is 0 before doing the division. Since `data` is given by the `values` argument, `num_batch_elements` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, and TensorFlow 2.3.3, as these are also affected.",
      "cve": "CVE-2021-29554",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29555",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.FusedBatchNorm`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/828f346274841fa7505f7020e88ca36c22e557ab/tensorflow/core/kernels/fused_batch_norm_op.cc#L295-L297) performs a division based on the last dimension of the `x` tensor. Since this is controlled by the user, an attacker can trigger a denial of service. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29555",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29556",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.Reverse`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/36229ea9e9451dac14a8b1f4711c435a1d84a594/tensorflow/core/kernels/reverse_op.cc#L75-L76) performs a division based on the first dimension of the tensor argument. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29556",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29557",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.SparseMatMul`. The division by 0 occurs deep in Eigen code because the `b` tensor is empty. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29557",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29558",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `tf.raw_ops.SparseSplit`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/699bff5d961f0abfde8fa3f876e6d241681fbef8/tensorflow/core/util/sparse/sparse_tensor.h#L528-L530) accesses an array element based on a user controlled offset. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29558",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29559",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can access data outside of bounds of heap allocated array in `tf.raw_ops.UnicodeEncode`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/472c1f12ad9063405737679d4f6bd43094e1d36d/tensorflow/core/kernels/unicode_ops.cc) assumes that the `input_value`/`input_splits` pair specify a valid sparse tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29559",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29560",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `tf.raw_ops.RaggedTensorToTensor`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/d94227d43aa125ad8b54115c03cece54f6a1977b/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L219-L222) uses the same index to access two arrays in parallel. Since the user controls the shape of the input arguments, an attacker could trigger a heap OOB access when `parent_output_index` is shorter than `row_split`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29560",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29561",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by exploiting a `CHECK`-failure coming from `tf.raw_ops.LoadAndRemapMatrix`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/d94227d43aa125ad8b54115c03cece54f6a1977b/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L219-L222) assumes that the `ckpt_path` is always a valid scalar. However, an attacker can send any other tensor as the first argument of `LoadAndRemapMatrix`. This would cause the rank `CHECK` in `scalar<T>()()` to trigger and terminate the process. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29561",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29562",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by exploiting a `CHECK`-failure coming from the implementation of `tf.raw_ops.IRFFT`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29562",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29563",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by exploiting a `CHECK`-failure coming from the implementation of `tf.raw_ops.RFFT`. Eigen code operating on an empty matrix can trigger on an assertion and will cause program termination. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29563",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29564",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a null pointer dereference in the implementation of `tf.raw_ops.EditDistance`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/79865b542f9ffdc9caeb255631f7c56f1d4b6517/tensorflow/core/kernels/edit_distance_op.cc#L103-L159) has incomplete validation of the input parameters. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29564",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29565",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a null pointer dereference in the implementation of `tf.raw_ops.SparseFillEmptyRows`. This is because of missing validation(https://github.com/tensorflow/tensorflow/blob/fdc82089d206e281c628a93771336bf87863d5e8/tensorflow/core/kernels/sparse_fill_empty_rows_op.cc#L230-L231) that was covered under a `TODO`. If the `dense_shape` tensor is empty, then `dense_shape_t.vec<>()` would cause a null pointer dereference in the implementation of the op. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29565",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29566",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can write outside the bounds of heap allocated arrays by passing invalid arguments to `tf.raw_ops.Dilation2DBackpropInput`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/afd954e65f15aea4d438d0a219136fc4a63a573d/tensorflow/core/kernels/dilation_ops.cc#L321-L322) does not validate before writing to the output array. The values for `h_out` and `w_out` are guaranteed to be in range for `out_backprop` (as they are loop indices bounded by the size of the array). However, there are no similar guarantees relating `h_in_max`/`w_in_max` and `in_backprop`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29566",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29567",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.SparseDenseCwiseMul`, an attacker can trigger denial of service via `CHECK`-fails or accesses to outside the bounds of heap allocated data. Since the implementation(https://github.com/tensorflow/tensorflow/blob/38178a2f7a681a7835bb0912702a134bfe3b4d84/tensorflow/core/kernels/sparse_dense_binary_op_shared.cc#L68-L80) only validates the rank of the input arguments but no constraints between dimensions(https://www.tensorflow.org/api_docs/python/tf/raw_ops/SparseDenseCwiseMul), an attacker can abuse them to trigger internal `CHECK` assertions (and cause program termination, denial of service) or to write to memory outside of bounds of heap allocated tensor buffers. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29567",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29568",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger undefined behavior by binding to null pointer in `tf.raw_ops.ParameterizedTruncatedNormal`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/3f6fe4dfef6f57e768260b48166c27d148f3015f/tensorflow/core/kernels/parameterized_truncated_normal_op.cc#L630) does not validate input arguments before accessing the first element of `shape`. If `shape` argument is empty, then `shape_tensor.flat<T>()` is an empty array. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29568",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29569",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` can cause reads outside of bounds of heap allocated data if attacker supplies specially crafted inputs. The implementation(https://github.com/tensorflow/tensorflow/blob/ac328eaa3870491ababc147822cd04e91a790643/tensorflow/core/kernels/requantization_range_op.cc#L49-L50) assumes that the `input_min` and `input_max` tensors have at least one element, as it accesses the first element in two arrays. If the tensors are empty, `.flat<T>()` is an empty object, backed by an empty array. Hence, accesing even the 0th element is a read outside the bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29569",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29570",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` can cause reads outside of bounds of heap allocated data if attacker supplies specially crafted inputs. The implementation(https://github.com/tensorflow/tensorflow/blob/ef0c008ee84bad91ec6725ddc42091e19a30cf0e/tensorflow/core/kernels/maxpooling_op.cc#L1016-L1017) uses the same value to index in two different arrays but there is no guarantee that the sizes are identical. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29570",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29571",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` can cause reads outside of bounds of heap allocated data if attacker supplies specially crafted inputs. The implementation(https://github.com/tensorflow/tensorflow/blob/31bd5026304677faa8a0b77602c6154171b9aec1/tensorflow/core/kernels/image/draw_bounding_box_op.cc#L116-L130) assumes that the last element of `boxes` input is 4, as required by [the op](https://www.tensorflow.org/api_docs/python/tf/raw_ops/DrawBoundingBoxesV2). Since this is not checked attackers passing values less than 4 can write outside of bounds of heap allocated objects and cause memory corruption. If the last dimension in `boxes` is less than 4, accesses similar to `tboxes(b, bb, 3)` will access data outside of bounds. Further during code execution there are also writes to these indices. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29571",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29572",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.SdcaOptimizer` triggers undefined behavior due to dereferencing a null pointer. The implementation(https://github.com/tensorflow/tensorflow/blob/60a45c8b6192a4699f2e2709a2645a751d435cc3/tensorflow/core/kernels/sdca_internal.cc) does not validate that the user supplied arguments satisfy all constraints expected by the op(https://www.tensorflow.org/api_docs/python/tf/raw_ops/SdcaOptimizer). The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29572",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29573",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` is vulnerable to a division by 0. The implementation(https://github.com/tensorflow/tensorflow/blob/279bab6efa22752a2827621b7edb56a730233bd8/tensorflow/core/kernels/maxpooling_op.cc#L1033-L1034) fails to validate that the batch dimension of the tensor is non-zero, before dividing by this quantity. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29573",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29574",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPool3DGradGrad` exhibits undefined behavior by dereferencing null pointers backing attacker-supplied empty tensors. The implementation(https://github.com/tensorflow/tensorflow/blob/72fe792967e7fd25234342068806707bbc116618/tensorflow/core/kernels/pooling_ops_3d.cc#L679-L703) fails to validate that the 3 tensor inputs are not empty. If any of them is empty, then accessing the elements in the tensor results in dereferencing a null pointer. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29574",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29575",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.ReverseSequence` allows for stack overflow and/or `CHECK`-fail based denial of service. The implementation(https://github.com/tensorflow/tensorflow/blob/5b3b071975e01f0d250c928b2a8f901cd53b90a7/tensorflow/core/kernels/reverse_sequence_op.cc#L114-L118) fails to validate that `seq_dim` and `batch_dim` arguments are valid. Negative values for `seq_dim` can result in stack overflow or `CHECK`-failure, depending on the version of Eigen code used to implement the operation. Similar behavior can be exhibited by invalid values of `batch_dim`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29575",
      "specs": [
        "<=2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29576",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPool3DGradGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/596c05a159b6fbb9e39ca10b3f7753b7244fa1e9/tensorflow/core/kernels/pooling_ops_3d.cc#L694-L696) does not check that the initialization of `Pool3dParameters` completes successfully. Since the constructor(https://github.com/tensorflow/tensorflow/blob/596c05a159b6fbb9e39ca10b3f7753b7244fa1e9/tensorflow/core/kernels/pooling_ops_3d.cc#L48-L88) uses `OP_REQUIRES` to validate conditions, the first assertion that fails interrupts the initialization of `params`, making it contain invalid data. In turn, this might cause a heap buffer overflow, depending on default initialized values. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29576",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29577",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.AvgPool3DGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/d80ffba9702dc19d1fac74fc4b766b3fa1ee976b/tensorflow/core/kernels/pooling_ops_3d.cc#L376-L450) assumes that the `orig_input_shape` and `grad` tensors have similar first and last dimensions but does not check that this assumption is validated. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29577",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29578",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.FractionalAvgPoolGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/dcba796a28364d6d7f003f6fe733d82726dda713/tensorflow/core/kernels/fractional_avg_pool_op.cc#L216) fails to validate that the pooling sequence arguments have enough elements as required by the `out_backprop` tensor shape. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29578",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29579",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/ab1e644b48c82cb71493f4362b4dd38f4577a1cf/tensorflow/core/kernels/maxpooling_op.cc#L194-L203) fails to validate that indices used to access elements of input/output arrays are valid. Whereas accesses to `input_backprop_flat` are guarded by `FastBoundsCheck`, the indexing in `out_backprop_flat` can result in OOB access. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29579",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29580",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.FractionalMaxPoolGrad` triggers an undefined behavior if one of the input tensors is empty. The code is also vulnerable to a denial of service attack as a `CHECK` condition becomes false and aborts the process. The implementation(https://github.com/tensorflow/tensorflow/blob/169054888d50ce488dfde9ca55d91d6325efbd5b/tensorflow/core/kernels/fractional_max_pool_op.cc#L215) fails to validate that input and output tensors are not empty and are of the same rank. Each of these unchecked assumptions is responsible for the above issues. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29580",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29581",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.CTCBeamSearchDecoder`, an attacker can trigger denial of service via segmentation faults. The implementation(https://github.com/tensorflow/tensorflow/blob/a74768f8e4efbda4def9f16ee7e13cf3922ac5f7/tensorflow/core/kernels/ctc_decoder_ops.cc#L68-L79) fails to detect cases when the input tensor is empty and proceeds to read data from a null buffer. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29581",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29582",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.Dequantize`, an attacker can trigger a read from outside of bounds of heap allocated data. The implementation(https://github.com/tensorflow/tensorflow/blob/26003593aa94b1742f34dc22ce88a1e17776a67d/tensorflow/core/kernels/dequantize_op.cc#L106-L131) accesses the `min_range` and `max_range` tensors in parallel but fails to check that they have the same shape. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29582",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29583",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.FusedBatchNorm` is vulnerable to a heap buffer overflow. If the tensors are empty, the same implementation can trigger undefined behavior by dereferencing null pointers. The implementation(https://github.com/tensorflow/tensorflow/blob/57d86e0db5d1365f19adcce848dfc1bf89fdd4c7/tensorflow/core/kernels/fused_batch_norm_op.cc) fails to validate that `scale`, `offset`, `mean` and `variance` (the last two only when required) all have the same number of elements as the number of channels of `x`. This results in heap out of bounds reads when the buffers backing these tensors are indexed past their boundary. If the tensors are empty, the validation mentioned in the above paragraph would also trigger and prevent the undefined behavior. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29583",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29584",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in caused by an integer overflow in constructing a new tensor shape. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/0908c2f2397c099338b901b067f6495a5b96760b/tensorflow/core/kernels/sparse_split_op.cc#L66-L70) builds a dense shape without checking that the dimensions would not result in overflow. The `TensorShape` constructor(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L183-L188) uses a `CHECK` operation which triggers when `InitDims`(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L212-L296) returns a non-OK status. This is a legacy implementation of the constructor and operations should use `BuildTensorShapeBase` or `AddDimWithStatus` to prevent `CHECK`-failures in the presence of overflows. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29584",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29585",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The TFLite computation for size of output after padding, `ComputeOutSize`(https://github.com/tensorflow/tensorflow/blob/0c9692ae7b1671c983569e5d3de5565843d500cf/tensorflow/lite/kernels/padding.h#L43-L55), does not check that the `stride` argument is not 0 before doing the division. Users can craft special models such that `ComputeOutSize` is called with `stride` set to 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29585",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29586",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Optimized pooling implementations in TFLite fail to check that the stride arguments are not 0 before calling `ComputePaddingHeightWidth`(https://github.com/tensorflow/tensorflow/blob/3f24ccd932546416ec906a02ddd183b48a1d2c83/tensorflow/lite/kernels/pooling.cc#L90). Since users can craft special models which will have `params->stride_{height,width}` be zero, this will result in a division by zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29586",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29587",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The `Prepare` step of the `SpaceToDepth` TFLite operator does not check for 0 before division(https://github.com/tensorflow/tensorflow/blob/5f7975d09eac0f10ed8a17dbb6f5964977725adc/tensorflow/lite/kernels/space_to_depth.cc#L63-L67). An attacker can craft a model such that `params->block_size` would be zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29587",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29588",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The optimized implementation of the `TransposeConv` TFLite operator is [vulnerable to a division by zero error](https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/internal/optimized/optimized_ops.h#L5221-L5222). An attacker can craft a model such that `stride_{h,w}` values are 0. Code calling this function must validate these arguments. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29588",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29589",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The reference implementation of the `GatherNd` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/internal/reference/reference_ops.h#L966). An attacker can craft a model such that `params` input would be an empty tensor. In turn, `params_shape.Dims(.)` would be zero, in at least one dimension. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29589",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29590",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementations of the `Minimum` and `Maximum` TFLite operators can be used to read data outside of bounds of heap allocated objects, if any of the two input tensor arguments are empty. This is because the broadcasting implementation(https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/internal/reference/maximum_minimum.h#L52-L56) indexes in both tensors with the same index but does not validate that the index is within bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29590",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29591",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. TFlite graphs must not have loops between nodes. However, this condition was not checked and an attacker could craft models that would result in infinite loop during evaluation. In certain cases, the infinite loop would be replaced by stack overflow due to too many recursive calls. For example, the `While` implementation(https://github.com/tensorflow/tensorflow/blob/106d8f4fb89335a2c52d7c895b7a7485465ca8d9/tensorflow/lite/kernels/while.cc) could be tricked into a scneario where both the body and the loop subgraphs are the same. Evaluating one of the subgraphs means calling the `Eval` function for the other and this quickly exhaust all stack space. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range. Please consult our security guide(https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.",
      "cve": "CVE-2021-29591",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29592",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The fix for CVE-2020-15209(https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-15209) missed the case when the target shape of `Reshape` operator is given by the elements of a 1-D tensor. As such, the fix for the vulnerability(https://github.com/tensorflow/tensorflow/blob/9c1dc920d8ffb4893d6c9d27d1f039607b326743/tensorflow/lite/core/subgraph.cc#L1062-L1074) allowed passing a null-buffer-backed tensor with a 1D shape. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29592",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29593",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `BatchToSpaceNd` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/b5ed552fe55895aee8bd8b191f744a069957d18d/tensorflow/lite/kernels/batch_to_space_nd.cc#L81-L82). An attacker can craft a model such that one dimension of the `block` input is 0. Hence, the corresponding value in `block_shape` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29593",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29594",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. TFLite's convolution code(https://github.com/tensorflow/tensorflow/blob/09c73bca7d648e961dd05898292d91a8322a9d45/tensorflow/lite/kernels/conv.cc) has multiple division where the divisor is controlled by the user and not checked to be non-zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29594",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29595",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `DepthToSpace` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/depth_to_space.cc#L63-L69). An attacker can craft a model such that `params->block_size` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29595",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29596",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `EmbeddingLookup` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/e4b29809543b250bc9b19678ec4776299dd569ba/tensorflow/lite/kernels/embedding_lookup.cc#L73-L74). An attacker can craft a model such that the first dimension of the `value` input is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29596",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29597",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `SpaceToBatchNd` TFLite operator is [vulnerable to a division by zero error](https://github.com/tensorflow/tensorflow/blob/412c7d9bb8f8a762c5b266c9e73bfa165f29aac8/tensorflow/lite/kernels/space_to_batch_nd.cc#L82-L83). An attacker can craft a model such that one dimension of the `block` input is 0. Hence, the corresponding value in `block_shape` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29597",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29598",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `SVDF` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/7f283ff806b2031f407db64c4d3edcda8fb9f9f5/tensorflow/lite/kernels/svdf.cc#L99-L102). An attacker can craft a model such that `params->rank` would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29598",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29599",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `Split` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/e2752089ef7ce9bcf3db0ec618ebd23ea119d0c7/tensorflow/lite/kernels/split.cc#L63-L65). An attacker can craft a model such that `num_splits` would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29599",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29600",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `OneHot` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/f61c57bd425878be108ec787f4d96390579fb83e/tensorflow/lite/kernels/one_hot.cc#L68-L72). An attacker can craft a model such that at least one of the dimensions of `indices` would be 0. In turn, the `prefix_dim_size` value would become 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29600",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29601",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The TFLite implementation of concatenation is vulnerable to an integer overflow issue(https://github.com/tensorflow/tensorflow/blob/7b7352a724b690b11bfaae2cd54bc3907daf6285/tensorflow/lite/kernels/concatenation.cc#L70-L76). An attacker can craft a model such that the dimensions of one of the concatenation input overflow the values of `int`. TFLite uses `int` to represent tensor dimensions, whereas TF uses `int64`. Hence, valid TF models can trigger an integer overflow when converted to TFLite format. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29601",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29602",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `DepthwiseConv` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/1a8e885b864c818198a5b2c0cbbeca5a1e833bc8/tensorflow/lite/kernels/depthwise_conv.cc#L287-L288). An attacker can craft a model such that `input`'s fourth dimension would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29602",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29603",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. A specially crafted TFLite model could trigger an OOB write on heap in the TFLite implementation of `ArgMin`/`ArgMax`(https://github.com/tensorflow/tensorflow/blob/102b211d892f3abc14f845a72047809b39cc65ab/tensorflow/lite/kernels/arg_min_max.cc#L52-L59). If `axis_value` is not a value between 0 and `NumDimensions(input)`, then the condition in the `if` is never true, so code writes past the last valid element of `output_dims->data`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29603",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29604",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The TFLite implementation of hashtable lookup is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/1a8e885b864c818198a5b2c0cbbeca5a1e833bc8/tensorflow/lite/kernels/hashtable_lookup.cc#L114-L115) An attacker can craft a model such that `values`'s first dimension would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29604",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29605",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The TFLite code for allocating `TFLiteIntArray`s is vulnerable to an integer overflow issue(https://github.com/tensorflow/tensorflow/blob/4ceffae632721e52bf3501b736e4fe9d1221cdfa/tensorflow/lite/c/common.c#L24-L27). An attacker can craft a model such that the `size` multiplier is so large that the return value overflows the `int` datatype and becomes negative. In turn, this results in invalid value being given to `malloc`(https://github.com/tensorflow/tensorflow/blob/4ceffae632721e52bf3501b736e4fe9d1221cdfa/tensorflow/lite/c/common.c#L47-L52). In this case, `ret->size` would dereference an invalid pointer. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29605",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29606",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. A specially crafted TFLite model could trigger an OOB read on heap in the TFLite implementation of `Split_V`(https://github.com/tensorflow/tensorflow/blob/c59c37e7b2d563967da813fa50fe20b21f4da683/tensorflow/lite/kernels/split_v.cc#L99). If `axis_value` is not a value between 0 and `NumDimensions(input)`, then the `SizeOfDimension` function(https://github.com/tensorflow/tensorflow/blob/102b211d892f3abc14f845a72047809b39cc65ab/tensorflow/lite/kernels/kernel_util.h#L148-L150) will access data outside the bounds of the tensor shape array. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29606",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29607",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `SparseAdd` results in allowing attackers to exploit undefined behavior (dereferencing null pointers) as well as write outside of bounds of heap allocated data. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/sparse_sparse_binary_op_shared.cc) has a large set of validation for the two sparse tensor inputs (6 tensors in total), but does not validate that the tensors are not empty or that the second dimension of `*_indices` matches the size of corresponding `*_shape`. This allows attackers to send tensor triples that represent invalid sparse tensors to abuse code assumptions that are not protected by validation. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29607",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29608",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.RaggedTensorToTensor`, an attacker can exploit an undefined behavior if input arguments are empty. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L356-L360) only checks that one of the tensors is not empty, but does not check for the other ones. There are multiple `DCHECK` validations to prevent heap OOB, but these are no-op in release builds, hence they don't prevent anything. The fix will be included in TensorFlow 2.5.0. We will also cherrypick these commits on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29608",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29609",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `SparseAdd` results in allowing attackers to exploit undefined behavior (dereferencing null pointers) as well as write outside of bounds of heap allocated data. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/sparse_add_op.cc) has a large set of validation for the two sparse tensor inputs (6 tensors in total), but does not validate that the tensors are not empty or that the second dimension of `*_indices` matches the size of corresponding `*_shape`. This allows attackers to send tensor triples that represent invalid sparse tensors to abuse code assumptions that are not protected by validation. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29609",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29610",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The validation in `tf.raw_ops.QuantizeAndDequantizeV2` allows invalid values for `axis` argument:. The validation(https://github.com/tensorflow/tensorflow/blob/eccb7ec454e6617738554a255d77f08e60ee0808/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L74-L77) uses `||` to mix two different conditions. If `axis_ < -1` the condition in `OP_REQUIRES` will still be true, but this value of `axis_` results in heap underflow. This allows attackers to read/write to other data on the heap. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29610",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29611",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `SparseReshape` results in a denial of service based on a `CHECK`-failure. The implementation(https://github.com/tensorflow/tensorflow/blob/e87b51ce05c3eb172065a6ea5f48415854223285/tensorflow/core/kernels/sparse_reshape_op.cc#L40) has no validation that the input arguments specify a valid sparse tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3, as these are the only affected versions.",
      "cve": "CVE-2021-29611",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29612",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a heap buffer overflow in Eigen implementation of `tf.raw_ops.BandedTriangularSolve`. The implementation(https://github.com/tensorflow/tensorflow/blob/eccb7ec454e6617738554a255d77f08e60ee0808/tensorflow/core/kernels/linalg/banded_triangular_solve_op.cc#L269-L278) calls `ValidateInputTensors` for input validation but fails to validate that the two tensors are not empty. Furthermore, since `OP_REQUIRES` macro only stops execution of current function after setting `ctx->status()` to a non-OK value, callers of helper functions that use `OP_REQUIRES` must check value of `ctx->status()` before continuing. This doesn't happen in this op's implementation(https://github.com/tensorflow/tensorflow/blob/eccb7ec454e6617738554a255d77f08e60ee0808/tensorflow/core/kernels/linalg/banded_triangular_solve_op.cc#L219), hence the validation that is present is also not effective. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29612",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29613",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `tf.raw_ops.CTCLoss` allows an attacker to trigger an OOB read from heap. The fix will be included in TensorFlow 2.5.0. We will also cherrypick these commits on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29613",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29614",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.io.decode_raw` produces incorrect results and crashes the Python interpreter when combining `fixed_length` and wider datatypes. The implementation of the padded version(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc) is buggy due to a confusion about pointer arithmetic rules. First, the code computes(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L61) the width of each output element by dividing the `fixed_length` value to the size of the type argument. The `fixed_length` argument is also used to determine the size needed for the output tensor(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L63-L79). This is followed by reencoding code(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L85-L94). The erroneous code is the last line above: it is moving the `out_data` pointer by `fixed_length * sizeof(T)` bytes whereas it only copied at most `fixed_length` bytes from the input. This results in parts of the input not being decoded into the output. Furthermore, because the pointer advance is far wider than desired, this quickly leads to writing to outside the bounds of the backing data. This OOB write leads to interpreter crash in the reproducer mentioned here, but more severe attacks can be mounted too, given that this gadget allows writing to periodically placed locations in memory. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29614",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29615",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `ParseAttrValue`(https://github.com/tensorflow/tensorflow/blob/c22d88d6ff33031aa113e48aa3fc9aa74ed79595/tensorflow/core/framework/attr_value_util.cc#L397-L453) can be tricked into stack overflow due to recursion by giving in a specially crafted input. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29615",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29616",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of TrySimplify(https://github.com/tensorflow/tensorflow/blob/c22d88d6ff33031aa113e48aa3fc9aa74ed79595/tensorflow/core/grappler/optimizers/arithmetic_optimizer.cc#L390-L401) has undefined behavior due to dereferencing a null pointer in corner cases that result in optimizing a node with no inputs. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29616",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29617",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via `CHECK`-fail in `tf.strings.substr` with invalid arguments. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29617",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29618",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Passing a complex argument to `tf.transpose` at the same time as passing `conjugate=True` argument results in a crash. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29618",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-29619",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Passing invalid arguments (e.g., discovered via fuzzing) to `tf.raw_ops.SparseCountSparseOutput` results in segfault. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29619",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-35958",
      "advisory": "** DISPUTED ** TensorFlow through 2.5.0 allows attackers to overwrite arbitrary files via a crafted archive when tf.keras.utils.get_file is used with extract=True. NOTE: the vendor's position is that tf.keras.utils.get_file is not intended for untrusted archives.",
      "cve": "CVE-2021-35958",
      "specs": [
        "<=2.5.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37635",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of sparse reduction operations in TensorFlow can trigger accesses outside of bounds of heap allocated data. The [implementation](https://github.com/tensorflow/tensorflow/blob/a1bc56203f21a5a4995311825ffaba7a670d7747/tensorflow/core/kernels/sparse_reduce_op.cc#L217-L228) fails to validate that each reduction group does not overflow and that each corresponding index does not point to outside the bounds of the input tensor. We have patched the issue in GitHub commit 87158f43f05f2720a374f3e6d22a7aaa3a33f750. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37635",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37636",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.SparseDenseCwiseDiv` is vulnerable to a division by 0 error. The [implementation](https://github.com/tensorflow/tensorflow/blob/a1bc56203f21a5a4995311825ffaba7a670d7747/tensorflow/core/kernels/sparse_dense_binary_op_shared.cc#L56) uses a common class for all binary operations but fails to treat the division by 0 case separately. We have patched the issue in GitHub commit d9204be9f49520cdaaeb2541d1dc5187b23f31d9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37636",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37637",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. It is possible to trigger a null pointer dereference in TensorFlow by passing an invalid input to `tf.raw_ops.CompressElement`. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/data/compression_utils.cc#L34) was accessing the size of a buffer obtained from the return of a separate function call before validating that said buffer is valid. We have patched the issue in GitHub commit 5dc7f6981fdaf74c8c5be41f393df705841fb7c5. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37637",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37638",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Sending invalid argument for `row_partition_types` of `tf.raw_ops.RaggedTensorToTensor` API results in a null pointer dereference and undefined behavior. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L328) accesses the first element of a user supplied list of values without validating that the provided list is not empty. We have patched the issue in GitHub commit 301ae88b331d37a2a16159b65b255f4f9eb39314. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37638",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37639",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. When restoring tensors via raw APIs, if the tensor name is not provided, TensorFlow can be tricked into dereferencing a null pointer. Alternatively, attackers can read memory outside the bounds of heap allocated data by providing some tensor names but not enough for a successful restoration. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/kernels/save_restore_tensor.cc#L158-L159) retrieves the tensor list corresponding to the `tensor_name` user controlled input and immediately retrieves the tensor at the restoration index (controlled via `preferred_shard` argument). This occurs without validating that the provided list has enough values. If the list is empty this results in dereferencing a null pointer (undefined behavior). If, however, the list has some elements, if the restoration index is outside the bounds this results in heap OOB read. We have patched the issue in GitHub commit 9e82dce6e6bd1f36a57e08fa85af213e2b2f2622. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37639",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37640",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.SparseReshape` can be made to trigger an integral division by 0 exception. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/reshape_util.cc#L176-L181) calls the reshaping functor whenever there is at least an index in the input but does not check that shape of the input or the target shape have both a non-zero number of elements. The [reshape functor](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/reshape_util.cc#L40-L78) blindly divides by the dimensions of the target shape. Hence, if this is not checked, code will result in a division by 0. We have patched the issue in GitHub commit 4923de56ec94fff7770df259ab7f2288a74feb41. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1 as this is the other affected version.",
      "cve": "CVE-2021-37640",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37641",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions if the arguments to `tf.raw_ops.RaggedGather` don't determine a valid ragged tensor code can trigger a read from outside of bounds of heap allocated buffers. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/ragged_gather_op.cc#L70) directly reads the first dimension of a tensor shape before checking that said tensor has rank of at least 1 (i.e., it is not a scalar). Furthermore, the implementation does not check that the list given by `params_nested_splits` is not an empty list of tensors. We have patched the issue in GitHub commit a2b743f6017d7b97af1fe49087ae15f0ac634373. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37641",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37642",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.ResourceScatterDiv` is vulnerable to a division by 0 error. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/resource_variable_ops.cc#L865) uses a common class for all binary operations but fails to treat the division by 0 case separately. We have patched the issue in GitHub commit 4aacb30888638da75023e6601149415b39763d76. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37642",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37643",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. If a user does not provide a valid padding value to `tf.raw_ops.MatrixDiagPartOp`, then the code triggers a null pointer dereference (if input is empty) or produces invalid behavior, ignoring all values after the first. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/linalg/matrix_diag_op.cc#L89) reads the first value from a tensor buffer without first checking that the tensor has values to read from. We have patched the issue in GitHub commit 482da92095c4d48f8784b1f00dda4f81c28d2988. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37643",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37644",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions providing a negative element to `num_elements` list argument of `tf.raw_ops.TensorListReserve` causes the runtime to abort the process due to reallocating a `std::vector` to have a negative number of elements. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/list_kernels.cc#L312) calls `std::vector.resize()` with the new size controlled by input given by the user, without checking that this input is valid. We have patched the issue in GitHub commit 8a6e874437670045e6c7dc6154c7412b4a2135e2. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37644",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37645",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.QuantizeAndDequantizeV4Grad` is vulnerable to an integer overflow issue caused by converting a signed integer value to an unsigned one and then allocating memory based on this value. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L126) uses the `axis` value as the size argument to `absl::InlinedVector` constructor. But, the constructor uses an unsigned type for the argument, so the implicit conversion transforms the negative value to a large integer. We have patched the issue in GitHub commit 96f364a1ca3009f98980021c4b32be5fdcca33a1. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, and TensorFlow 2.4.3, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37645",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37646",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.StringNGrams` is vulnerable to an integer overflow issue caused by converting a signed integer value to an unsigned one and then allocating memory based on this value. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/string_ngrams_op.cc#L184) calls `reserve` on a `tstring` with a value that sometimes can be negative if user supplies negative `ngram_widths`. The `reserve` method calls `TF_TString_Reserve` which has an `unsigned long` argument for the size of the buffer. Hence, the implicit conversion transforms the negative value to a large integer. We have patched the issue in GitHub commit c283e542a3f422420cfdb332414543b62fc4e4a5. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37646",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37647",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. When a user does not supply arguments that determine a valid sparse tensor, `tf.raw_ops.SparseTensorSliceDataset` implementation can be made to dereference a null pointer. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc#L240-L251) has some argument validation but fails to consider the case when either `indices` or `values` are provided for an empty sparse tensor when the other is not. If `indices` is empty, then [code that performs validation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc#L260-L261) (i.e., checking that the indices are monotonically increasing) results in a null pointer dereference. If `indices` as provided by the user is empty, then `indices` in the C++ code above is backed by an empty `std::vector`, hence calling `indices->dim_size(0)` results in null pointer dereferencing (same as calling `std::vector::at()` on an empty vector). We have patched the issue in GitHub commit 02cc160e29d20631de3859c6653184e3f876b9d7. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37647",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37648",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the code for `tf.raw_ops.SaveV2` does not properly validate the inputs and an attacker can trigger a null pointer dereference. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/save_restore_v2_ops.cc) uses `ValidateInputs` to check that the input arguments are valid. This validation would have caught the illegal state represented by the reproducer above. However, the validation uses `OP_REQUIRES` which translates to setting the `Status` object of the current `OpKernelContext` to an error status, followed by an empty `return` statement which just terminates the execution of the function it is present in. However, this does not mean that the kernel execution is finalized: instead, execution continues from the next line in `Compute` that follows the call to `ValidateInputs`. This is equivalent to lacking the validation. We have patched the issue in GitHub commit 9728c60e136912a12d99ca56e106b7cce7af5986. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37648",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37649",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The code for `tf.raw_ops.UncompressElement` can be made to trigger a null pointer dereference. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/data/experimental/compression_ops.cc#L50-L53) obtains a pointer to a `CompressedElement` from a `Variant` tensor and then proceeds to dereference it for decompressing. There is no check that the `Variant` tensor contained a `CompressedElement`, so the pointer is actually `nullptr`. We have patched the issue in GitHub commit 7bdf50bb4f5c54a4997c379092888546c97c3ebd. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37649",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37650",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.ExperimentalDatasetToTFRecord` and `tf.raw_ops.DatasetToTFRecord` can trigger heap buffer overflow and segmentation fault. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/data/experimental/to_tf_record_op.cc#L93-L102) assumes that all records in the dataset are of string type. However, there is no check for that, and the example given above uses numeric types. We have patched the issue in GitHub commit e0b6e58c328059829c3eb968136f17aa72b6c876. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37650",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37651",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.FractionalAvgPoolGrad` can be tricked into accessing data outside of bounds of heap allocated buffers. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/fractional_avg_pool_op.cc#L205) does not validate that the input tensor is non-empty. Thus, code constructs an empty `EigenDoubleMatrixMap` and then accesses this buffer with indices that are outside of the empty area. We have patched the issue in GitHub commit 0f931751fb20f565c4e94aa6df58d54a003cdb30. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37651",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37652",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.BoostedTreesCreateEnsemble` can result in a use after free error if an attacker supplies specially crafted arguments. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/boosted_trees/resource_ops.cc#L55) uses a reference counted resource and decrements the refcount if the initialization fails, as it should. However, when the code was written, the resource was represented as a naked pointer but later refactoring has changed it to be a smart pointer. Thus, when the pointer leaves the scope, a subsequent `free`-ing of the resource occurs, but this fails to take into account that the refcount has already reached 0, thus the resource has been already freed. During this double-free process, members of the resource object are accessed for cleanup but they are invalid as the entire resource has been freed. We have patched the issue in GitHub commit 5ecec9c6fbdbc6be03295685190a45e7eee726ab. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37652",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37653",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a crash via a floating point exception in `tf.raw_ops.ResourceGather`. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/resource_variable_ops.cc#L725-L731) computes the value of a value, `batch_size`, and then divides by it without checking that this value is not 0. We have patched the issue in GitHub commit ac117ee8a8ea57b73d34665cdf00ef3303bc0b11. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37653",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37654",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a crash via a `CHECK`-fail in debug builds of TensorFlow using `tf.raw_ops.ResourceGather` or a read from outside the bounds of heap allocated data in the same API in a release build. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/resource_variable_ops.cc#L660-L668) does not check that the `batch_dims` value that the user supplies is less than the rank of the input tensor. Since the implementation uses several for loops over the dimensions of `tensor`, this results in reading data from outside the bounds of heap allocated buffer backing the tensor. We have patched the issue in GitHub commit bc9c546ce7015c57c2f15c168b3d9201de679a1d. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37654",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37655",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a read from outside of bounds of heap allocated data by sending invalid arguments to `tf.raw_ops.ResourceScatterUpdate`. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/resource_variable_ops.cc#L919-L923) has an incomplete validation of the relationship between the shapes of `indices` and `updates`: instead of checking that the shape of `indices` is a prefix of the shape of `updates` (so that broadcasting can happen), code only checks that the number of elements in these two tensors are in a divisibility relationship. We have patched the issue in GitHub commit 01cff3f986259d661103412a20745928c727326f. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37655",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37656",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.RaggedTensorToSparse`. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/ragged_tensor_to_sparse_kernel.cc#L30) has an incomplete validation of the splits values: it does not check that they are in increasing order. We have patched the issue in GitHub commit 1071f554dbd09f7e101324d366eec5f4fe5a3ece. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37656",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37657",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in all operations of type `tf.raw_ops.MatrixDiagV*`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/linalg/matrix_diag_op.cc) has incomplete validation that the value of `k` is a valid tensor. We have check that this value is either a scalar or a vector, but there is no check for the number of elements. If this is an empty tensor, then code that accesses the first element of the tensor is wrong. We have patched the issue in GitHub commit f2a673bd34f0d64b8e40a551ac78989d16daad09. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37657",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37658",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in all operations of type `tf.raw_ops.MatrixSetDiagV*`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/linalg/matrix_diag_op.cc) has incomplete validation that the value of `k` is a valid tensor. We have check that this value is either a scalar or a vector, but there is no check for the number of elements. If this is an empty tensor, then code that accesses the first element of the tensor is wrong. We have patched the issue in GitHub commit ff8894044dfae5568ecbf2ed514c1a37dc394f1b. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37658",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37659",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in all binary cwise operations that don't require broadcasting (e.g., gradients of binary cwise operations). The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/cwise_ops_common.h#L264) assumes that the two inputs have exactly the same number of elements but does not check that. Hence, when the eigen functor executes it triggers heap OOB reads and undefined behavior due to binding to nullptr. We have patched the issue in GitHub commit 93f428fd1768df147171ed674fee1fc5ab8309ec. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37659",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37660",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause a floating point exception by calling inplace operations with crafted arguments that would result in a division by 0. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/inplace_ops.cc#L283) has a logic error: it should skip processing if `x` and `v` are empty but the code uses `||` instead of `&&`. We have patched the issue in GitHub commit e86605c0a336c088b638da02135ea6f9f6753618. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37660",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37661",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause a denial of service in `boosted_trees_create_quantile_stream_resource` by using negative arguments. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/quantile_ops.cc#L96) does not validate that `num_streams` only contains non-negative numbers. In turn, [this results in using this value to allocate memory](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/quantiles/quantile_stream_resource.h#L31-L40). However, `reserve` receives an unsigned integer so there is an implicit conversion from a negative value to a large positive unsigned. This results in a crash from the standard library. We have patched the issue in GitHub commit 8a84f7a2b5a2b27ecf88d25bad9ac777cd2f7992. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37661",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37662",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can generate undefined behavior via a reference binding to nullptr in `BoostedTreesCalculateBestGainsPerFeature` and similar attack can occur in `BoostedTreesCalculateBestFeatureSplitV2`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/stats_ops.cc) does not validate the input values. We have patched the issue in GitHub commit 9c87c32c710d0b5b53dc6fd3bfde4046e1f7a5ad and in commit 429f009d2b2c09028647dd4bb7b3f6f414bbaad7. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37662",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37663",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions due to incomplete validation in `tf.raw_ops.QuantizeV2`, an attacker can trigger undefined behavior via binding a reference to a null pointer or can access data outside the bounds of heap allocated arrays. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/quantize_op.cc#L59) has some validation but does not check that `min_range` and `max_range` both have the same non-zero number of elements. If `axis` is provided (i.e., not `-1`), then validation should check that it is a value in range for the rank of `input` tensor and then the lengths of `min_range` and `max_range` inputs match the `axis` dimension of the `input` tensor. We have patched the issue in GitHub commit 6da6620efad397c85493b8f8667b821403516708. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37663",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37664",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can read from outside of bounds of heap allocated data by sending specially crafted illegal arguments to `BoostedTreesSparseCalculateBestFeatureSplit`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/stats_ops.cc) needs to validate that each value in `stats_summary_indices` is in range. We have patched the issue in GitHub commit e84c975313e8e8e38bb2ea118196369c45c51378. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37664",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37665",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions due to incomplete validation in MKL implementation of requantization, an attacker can trigger undefined behavior via binding a reference to a null pointer or can access data outside the bounds of heap allocated arrays. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/mkl/mkl_requantization_range_per_channel_op.cc) does not validate the dimensions of the `input` tensor. A similar issue occurs in `MklRequantizePerChannelOp`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/mkl/mkl_requantize_per_channel_op.cc) does not perform full validation for all the input arguments. We have patched the issue in GitHub commit 9e62869465573cb2d9b5053f1fa02a81fce21d69 and in the Github commit 203214568f5bc237603dbab6e1fd389f1572f5c9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37665",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37666",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.RaggedTensorToVariant`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/ragged_tensor_to_variant_op.cc#L129) has an incomplete validation of the splits values, missing the case when the argument would be empty. We have patched the issue in GitHub commit be7a4de6adfbd303ce08be4332554dff70362612. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37666",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37667",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.UnicodeEncode`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/unicode_ops.cc#L533-L539) reads the first dimension of the `input_splits` tensor before validating that this tensor is not empty. We have patched the issue in GitHub commit 2e0ee46f1a47675152d3d865797a18358881d7a6. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37667",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37668",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause denial of service in applications serving models using `tf.raw_ops.UnravelIndex` by triggering a division by 0. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/unravel_index_op.cc#L36) does not check that the tensor subsumed by `dims` is not empty. Hence, if one element of `dims` is 0, the implementation does a division by 0. We have patched the issue in GitHub commit a776040a5e7ebf76eeb7eb923bf1ae417dd4d233. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37668",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37669",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause denial of service in applications serving models using `tf.raw_ops.NonMaxSuppressionV5` by triggering a division by 0. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/image/non_max_suppression_op.cc#L170-L271) uses a user controlled argument to resize a `std::vector`. However, as `std::vector::resize` takes the size argument as a `size_t` and `output_size` is an `int`, there is an implicit conversion to unsigned. If the attacker supplies a negative value, this conversion results in a crash. A similar issue occurs in `CombinedNonMaxSuppression`. We have patched the issue in GitHub commit 3a7362750d5c372420aa8f0caf7bf5b5c3d0f52d and commit [b5cdbf12ffcaaffecf98f22a6be5a64bb96e4f58. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37669",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37670",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can read from outside of bounds of heap allocated data by sending specially crafted illegal arguments to `tf.raw_ops.UpperBound`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/searchsorted_op.cc#L85-L104) does not validate the rank of `sorted_input` argument. A similar issue occurs in `tf.raw_ops.LowerBound`. We have patched the issue in GitHub commit 42459e4273c2e47a3232cc16c4f4fff3b3a35c38. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37670",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37671",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.Map*` and `tf.raw_ops.OrderedMap*` operations. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/map_stage_op.cc#L222-L248) has a check in place to ensure that `indices` is in ascending order, but does not check that `indices` is not empty. We have patched the issue in GitHub commit 532f5c5a547126c634fefd43bbad1dc6417678ac. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37671",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37672",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can read from outside of bounds of heap allocated data by sending specially crafted illegal arguments to `tf.raw_ops.SdcaOptimizerV2`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/sdca_internal.cc#L320-L353) does not check that the length of `example_labels` is the same as the number of examples. We have patched the issue in GitHub commit a4e138660270e7599793fa438cd7b2fc2ce215a6. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37672",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37673",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.MapStage`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/map_stage_op.cc#L513) does not check that the `key` input is a valid non-empty tensor. We have patched the issue in GitHub commit d7de67733925de196ec8863a33445b73f9562d1d. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37673",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37674",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a denial of service via a segmentation fault in `tf.raw_ops.MaxPoolGrad` caused by missing validation. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/maxpooling_op.cc) misses some validation for the `orig_input` and `orig_output` tensors. The fixes for CVE-2021-29579 were incomplete. We have patched the issue in GitHub commit 136b51f10903e044308cf77117c0ed9871350475. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37674",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37675",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions most implementations of convolution operators in TensorFlow are affected by a division by 0 vulnerability where an attacker can trigger a denial of service via a crash. The shape inference [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/framework/common_shape_fns.cc#L577) is missing several validations before doing divisions and modulo operations. We have patched the issue in GitHub commit 8a793b5d7f59e37ac7f3cd0954a750a2fe76bad4. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37675",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37676",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.SparseFillEmptyRows`. The shape inference [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/ops/sparse_ops.cc#L608-L634) does not validate that the input arguments are not empty tensors. We have patched the issue in GitHub commit 578e634b4f1c1c684d4b4294f9e5281b2133b3ed. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37676",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37677",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the shape inference code for `tf.raw_ops.Dequantize` has a vulnerability that could trigger a denial of service via a segfault if an attacker provides invalid arguments. The shape inference [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/ops/array_ops.cc#L2999-L3014) uses `axis` to select between two different values for `minmax_rank` which is then used to retrieve tensor dimensions. However, code assumes that `axis` can be either `-1` or a value greater than `-1`, with no validation for the other values. We have patched the issue in GitHub commit da857cfa0fde8f79ad0afdbc94e88b5d4bbec764. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37677",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37678",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions TensorFlow and Keras can be tricked to perform arbitrary code execution when deserializing a Keras model from YAML format. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/python/keras/saving/model_config.py#L66-L104) uses `yaml.unsafe_load` which can perform arbitrary code execution on the input. Given that YAML format support requires a significant amount of work, we have removed it for now. We have patched the issue in GitHub commit 23d6383eb6c14084a8fc3bdf164043b974818012. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37678",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37679",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions it is possible to nest a `tf.map_fn` within another `tf.map_fn` call. However, if the input tensor is a `RaggedTensor` and there is no function signature provided, code assumes the output is a fully specified tensor and fills output buffer with uninitialized contents from the heap. The `t` and `z` outputs should be identical, however this is not the case. The last row of `t` contains data from the heap which can be used to leak other memory information. The bug lies in the conversion from a `Variant` tensor to a `RaggedTensor`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/ragged_tensor_from_variant_op.cc#L177-L190) does not check that all inner shapes match and this results in the additional dimensions. The same implementation can result in data loss, if input tensor is tweaked. We have patched the issue in GitHub commit 4e2565483d0ffcadc719bd44893fb7f609bb5f12. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37679",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37680",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of fully connected layers in TFLite is [vulnerable to a division by zero error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/fully_connected.cc#L226). We have patched the issue in GitHub commit 718721986aa137691ee23f03638867151f74935f. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37680",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37681",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of SVDF in TFLite is [vulnerable to a null pointer error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/svdf.cc#L300-L313). The [`GetVariableInput` function](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/kernel_util.cc#L115-L119) can return a null pointer but `GetTensorData` assumes that the argument is always a valid tensor. Furthermore, because `GetVariableInput` calls [`GetMutableInput`](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/kernel_util.cc#L82-L90) which might return `nullptr`, the `tensor->is_variable` expression can also trigger a null pointer exception. We have patched the issue in GitHub commit 5b048e87e4e55990dae6b547add4dae59f4e1c76. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37681",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37682",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions all TFLite operations that use quantization can be made to use unitialized values. [For example](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/depthwise_conv.cc#L198-L200). The issue stems from the fact that `quantization.params` is only valid if `quantization.type` is different that `kTfLiteNoQuantization`. However, these checks are missing in large parts of the code. We have patched the issue in GitHub commits 537bc7c723439b9194a358f64d871dd326c18887, 4a91f2069f7145aab6ba2d8cfe41be8a110c18a5 and 8933b8a21280696ab119b63263babdb54c298538. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37682",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37683",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of division in TFLite is [vulnerable to a division by 0 error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/div.cc). There is no check that the divisor tensor does not contain zero elements. We have patched the issue in GitHub commit 1e206baedf8bef0334cca3eb92bab134ef525a28. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37683",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37684",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementations of pooling in TFLite are vulnerable to division by 0 errors as there are no checks for divisors not being 0. We have patched the issue in GitHub commit [dfa22b348b70bb89d6d6ec0ff53973bacb4f4695](https://github.com/tensorflow/tensorflow/commit/dfa22b348b70bb89d6d6ec0ff53973bacb4f4695). The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37684",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37685",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions TFLite's [`expand_dims.cc`](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/expand_dims.cc#L36-L50) contains a vulnerability which allows reading one element outside of bounds of heap allocated data. If `axis` is a large negative value (e.g., `-100000`), then after the first `if` it would still be negative. The check following the `if` statement will pass and the `for` loop would read one element before the start of `input_dims.data` (when `i = 0`). We have patched the issue in GitHub commit d94ffe08a65400f898241c0374e9edc6fa8ed257. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37685",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37686",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the strided slice implementation in TFLite has a logic bug which can allow an attacker to trigger an infinite loop. This arises from newly introduced support for [ellipsis in axis definition](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/strided_slice.cc#L103-L122). An attacker can craft a model such that `ellipsis_end_idx` is smaller than `i` (e.g., always negative). In this case, the inner loop does not increase `i` and the `continue` statement causes execution to skip over the preincrement at the end of the outer loop. We have patched the issue in GitHub commit dfa22b348b70bb89d6d6ec0ff53973bacb4f4695. TensorFlow 2.6.0 is the only affected version.",
      "cve": "CVE-2021-37686",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37687",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions TFLite's [`GatherNd` implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/gather_nd.cc#L124) does not support negative indices but there are no checks for this situation. Hence, an attacker can read arbitrary data from the heap by carefully crafting a model with negative values in `indices`. Similar issue exists in [`Gather` implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/gather.cc). We have patched the issue in GitHub commits bb6a0383ed553c286f87ca88c207f6774d5c4a8f and eb921122119a6b6e470ee98b89e65d721663179d. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37687",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37688",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can craft a TFLite model that would trigger a null pointer dereference, which would result in a crash and denial of service. The [implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/internal/optimized/optimized_ops.h#L268-L285) unconditionally dereferences a pointer. We have patched the issue in GitHub commit 15691e456c7dc9bd6be203b09765b063bf4a380c. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37688",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37689",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can craft a TFLite model that would trigger a null pointer dereference, which would result in a crash and denial of service. This is caused by the MLIR optimization of `L2NormalizeReduceAxis` operator. The [implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/compiler/mlir/lite/transforms/optimize.cc#L67-L70) unconditionally dereferences a pointer to an iterator to a vector without checking that the vector has elements. We have patched the issue in GitHub commit d6b57f461b39fd1aa8c1b870f1b974aac3554955. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37689",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37690",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions when running shape functions, some functions (such as `MutableHashTableShape`) produce extra output information in the form of a `ShapeAndType` struct. The shapes embedded in this struct are owned by an inference context that is cleaned up almost immediately; if the upstream code attempts to access this shape information, it can trigger a segfault. `ShapeRefiner` is mitigating this for normal output shapes by cloning them (and thus putting the newly created shape under ownership of an inference context that will not die), but we were not doing the same for shapes and types. This commit fixes that by doing similar logic on output shapes and types. We have patched the issue in GitHub commit ee119d4a498979525046fba1c3dd3f13a039fbb1. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37690",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37691",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can craft a TFLite model that would trigger a division by zero error in LSH [implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/lsh_projection.cc#L118). We have patched the issue in GitHub commit 0575b640091680cfb70f4dd93e70658de43b94f9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick thiscommit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37691",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-37692",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions under certain conditions, Go code can trigger a segfault in string deallocation. For string tensors, `C.TF_TString_Dealloc` is called during garbage collection within a finalizer function. However, tensor structure isn't checked until encoding to avoid a performance penalty. The current method for dealloc assumes that encoding succeeded, but segfaults when a string tensor is garbage collected whose encoding failed (e.g., due to mismatched dimensions). To fix this, the call to set the finalizer function is deferred until `NewTensor` returns and, if encoding failed for a string tensor, deallocs are determined based on bytes written. We have patched the issue in GitHub commit 8721ba96e5760c229217b594f6d2ba332beedf22. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, which is the other affected version.",
      "cve": "CVE-2021-37692",
      "specs": [
        ">=2.5.0,<2.6.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41195",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `tf.math.segment_*` operations results in a `CHECK`-fail related abort (and denial of service) if a segment id in `segment_ids` is large. This is similar to CVE-2021-29584 (and similar other reported vulnerabilities in TensorFlow, localized to specific APIs): the implementation (both on CPU and GPU) computes the output shape using `AddDim`. However, if the number of elements in the tensor overflows an `int64_t` value, `AddDim` results in a `CHECK` failure which provokes a `std::abort`. Instead, code should use `AddDimWithStatus`. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41195",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41196",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the Keras pooling layers can trigger a segfault if the size of the pool is 0 or if a dimension is negative. This is due to the TensorFlow's implementation of pooling operations where the values in the sliding window are not checked to be strictly positive. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41196",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41197",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions TensorFlow allows tensor to have a large number of dimensions and each dimension can be as large as desired. However, the total number of elements in a tensor must fit within an `int64_t`. If an overflow occurs, `MultiplyWithoutOverflow` would return a negative result. In the majority of TensorFlow codebase this then results in a `CHECK`-failure. Newer constructs exist which return a `Status` instead of crashing the binary. This is similar to CVE-2021-29584. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41197",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41198",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions if `tf.tile` is called with a large input argument then the TensorFlow process will crash due to a `CHECK`-failure caused by an overflow. The number of elements in the output tensor is too much for the `int64_t` type and the overflow is detected via a `CHECK` statement. This aborts the process. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41198",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41199",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions if `tf.image.resize` is called with a large input argument then the TensorFlow process will crash due to a `CHECK`-failure caused by an overflow. The number of elements in the output tensor is too much for the `int64_t` type and the overflow is detected via a `CHECK` statement. This aborts the process. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41199",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41200",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions if `tf.summary.create_file_writer` is called with non-scalar arguments code crashes due to a `CHECK`-fail. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41200",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41201",
      "advisory": "TensorFlow is an open source platform for machine learning. In affeced versions during execution, `EinsumHelper::ParseEquation()` is supposed to set the flags in `input_has_ellipsis` vector and `*output_has_ellipsis` boolean to indicate whether there is ellipsis in the corresponding inputs and output. However, the code only changes these flags to `true` and never assigns `false`. This results in unitialized variable access if callers assume that `EinsumHelper::ParseEquation()` always sets these flags. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41201",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41202",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions while calculating the size of the output within the `tf.range` kernel, there is a conditional statement of type `int64 = condition ? int64 : double`. Due to C++ implicit conversion rules, both branches of the condition will be cast to `double` and the result would be truncated before the assignment. This result in overflows. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41202",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41203",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions an attacker can trigger undefined behavior, integer overflows, segfaults and `CHECK`-fail crashes if they can change saved checkpoints from outside of TensorFlow. This is because the checkpoints loading infrastructure is missing validation for invalid file formats. The fixes will be included in TensorFlow 2.7.0. We will also cherrypick these commits on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41203",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41204",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions during TensorFlow's Grappler optimizer phase, constant folding might attempt to deep copy a resource tensor. This results in a segfault, as these tensors are supposed to not change. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41204",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41205",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference functions for the `QuantizeAndDequantizeV*` operations can trigger a read outside of bounds of heap allocated array. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41205",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41206",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions several TensorFlow operations are missing validation for the shapes of the tensor arguments involved in the call. Depending on the API, this can result in undefined behavior and segfault or `CHECK`-fail related crashes but in some scenarios writes and reads from heap populated arrays are also possible. We have discovered these issues internally via tooling while working on improving/testing GPU op determinism. As such, we don't have reproducers and there will be multiple fixes for these issues. These fixes will be included in TensorFlow 2.7.0. We will also cherrypick these commits on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41206",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41207",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `ParallelConcat` misses some input validation and can produce a division by 0. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41207",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41208",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the code for boosted trees in TensorFlow is still missing validation. As a result, attackers can trigger denial of service (via dereferencing `nullptr`s or via `CHECK`-failures) as well as abuse undefined behavior (binding references to `nullptr`s). An attacker can also read and write from heap buffers, depending on the API that gets used and the arguments that are passed to the call. Given that the boosted trees implementation in TensorFlow is unmaintained, it is recommend to no longer use these APIs. We will deprecate TensorFlow's boosted trees APIs in subsequent releases. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41208",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41209",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementations for convolution operators trigger a division by 0 if passed empty filter tensor arguments. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41209",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41210",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference functions for `SparseCountSparseOutput` can trigger a read outside of bounds of heap allocated array. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41210",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41211",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `QuantizeV2` can trigger a read outside of bounds of heap allocated array. This occurs whenever `axis` is a negative value less than `-1`. In this case, we are accessing data before the start of a heap buffer. The code allows `axis` to be an optional argument (`s` would contain an `error::NOT_FOUND` error code). Otherwise, it assumes that `axis` is a valid index into the dimensions of the `input` tensor. If `axis` is less than `-1` then this results in a heap OOB read. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, as this version is the only one that is also affected.",
      "cve": "CVE-2021-41211",
      "specs": [
        "==2.6.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41212",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `tf.ragged.cross` can trigger a read outside of bounds of heap allocated array. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41212",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41213",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the code behind `tf.function` API can be made to deadlock when two `tf.function` decorated Python functions are mutually recursive. This occurs due to using a non-reentrant `Lock` Python object. Loading any model which contains mutually recursive functions is vulnerable. An attacker can cause denial of service by causing users to load such models and calling a recursive `tf.function`, although this is not a frequent scenario. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41213",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41214",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `tf.ragged.cross` has an undefined behavior due to binding a reference to `nullptr`. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41214",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41215",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `DeserializeSparse` can trigger a null pointer dereference. This is because the shape inference function assumes that the `serialize_sparse` tensor is a tensor with positive rank (and having `3` as the last dimension). The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41215",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41216",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference function for `Transpose` is vulnerable to a heap buffer overflow. This occurs whenever `perm` contains negative elements. The shape inference function does not validate that the indices in `perm` are all valid. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41216",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41217",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the process of building the control flow graph for a TensorFlow model is vulnerable to a null pointer exception when nodes that should be paired are not. This occurs because the code assumes that the first node in the pairing (e.g., an `Enter` node) always exists when encountering the second node (e.g., an `Exit` node). When this is not the case, `parent` is `nullptr` so dereferencing it causes a crash. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41217",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41218",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `AllToAll` can be made to execute a division by 0. This occurs whenever the `split_count` argument is 0. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41218",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41219",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the code for sparse matrix multiplication is vulnerable to undefined behavior via binding a reference to `nullptr`. This occurs whenever the dimensions of `a` or `b` are 0 or less. In the case on one of these is 0, an empty output tensor should be allocated (to conserve the invariant that output tensors are always allocated when the operation is successful) but nothing should be written to it (that is, we should return early from the kernel implementation). Otherwise, attempts to write to this empty tensor would result in heap OOB access. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41219",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41220",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the async implementation of `CollectiveReduceV2` suffers from a memory leak and a use after free. This occurs due to the asynchronous computation and the fact that objects that have been `std::move()`d from are still accessed. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, as this version is the only one that is also affected.",
      "cve": "CVE-2021-41220",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41221",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for the `Cudnn*` operations in TensorFlow can be tricked into accessing invalid memory, via a heap buffer overflow. This occurs because the ranks of the `input`, `input_h` and `input_c` parameters are not validated, but code assumes they have certain values. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41221",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41222",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `SplitV` can trigger a segfault is an attacker supplies negative arguments. This occurs whenever `size_splits` contains more than one value and at least one value is negative. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41222",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41223",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `FusedBatchNorm` kernels is vulnerable to a heap OOB access. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41223",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41224",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `SparseFillEmptyRows` can be made to trigger a heap OOB access. This occurs whenever the size of `indices` does not match the size of `values`. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41224",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41225",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions TensorFlow's Grappler optimizer has a use of unitialized variable. If the `train_nodes` vector (obtained from the saved model that gets optimized) does not contain a `Dequeue` node, then `dequeue_node` is left unitialized. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41225",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41226",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `SparseBinCount` is vulnerable to a heap OOB access. This is because of missing validation between the elements of the `values` argument and the shape of the sparse output. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41226",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41227",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the `ImmutableConst` operation in TensorFlow can be tricked into reading arbitrary memory contents. This is because the `tstring` TensorFlow string class has a special case for memory mapped strings but the operation itself does not offer any support for this datatype. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41227",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-gpu:CVE-2021-41228",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions TensorFlow's `saved_model_cli` tool is vulnerable to a code injection as it calls `eval` on user supplied strings. This can be used by attackers to run arbitrary code on the plaform where the CLI tool runs. However, given that the tool is always run manually, the impact of this is not severe. We have patched this by adding a `safe` flag which defaults to `True` and an explicit warning for users. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41228",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    }
  ],
  "tensorflow-lite": [
    {
      "id": "pyup.io-tensorflow-lite:CVE-2018-10055",
      "advisory": "Invalid memory access and/or a heap buffer overflow in the TensorFlow XLA compiler in Google TensorFlow before 1.7.1 could cause a crash or read from other parts of process memory via a crafted configuration file.",
      "cve": "CVE-2018-10055",
      "specs": [
        "<1.7.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2018-21233",
      "advisory": "TensorFlow before 1.7.0 has an integer overflow that causes an out-of-bounds read, possibly causing disclosure of the contents of process memory. This occurs in the DecodeBmp feature of the BMP decoder in core/kernels/decode_bmp_op.cc.",
      "cve": "CVE-2018-21233",
      "specs": [
        "<1.7.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2018-7575",
      "advisory": "Google TensorFlow 1.7.x and earlier is affected by a Buffer Overflow vulnerability. The type of exploitation is context-dependent.",
      "cve": "CVE-2018-7575",
      "specs": [
        "<=1.7.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2018-7576",
      "advisory": "Google TensorFlow 1.6.x and earlier is affected by: Null Pointer Dereference. The type of exploitation is: context-dependent.",
      "cve": "CVE-2018-7576",
      "specs": [
        "<=1.6.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2018-7577",
      "advisory": "Memcpy parameter overlap in Google Snappy library 1.1.4, as used in Google TensorFlow before 1.7.1, could result in a crash or read from other parts of process memory.",
      "cve": "CVE-2018-7577",
      "specs": [
        "<1.7.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2018-8825",
      "advisory": "Google TensorFlow 1.7 and below is affected by: Buffer Overflow. The impact is: execute arbitrary code (local).",
      "cve": "CVE-2018-8825",
      "specs": [
        "<=1.7.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2019-16778",
      "advisory": "In TensorFlow before 1.15, a heap buffer overflow in UnsortedSegmentSum can be produced when the Index template argument is int32. In this case data_size and num_segments fields are truncated from int64 to int32 and can produce negative numbers, resulting in accessing out of bounds heap memory. This is unlikely to be exploitable and was detected and fixed internally in TensorFlow 1.15 and 2.0.",
      "cve": "CVE-2019-16778",
      "specs": [
        ">=1.0.0,<1.15.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2019-9635",
      "advisory": "NULL pointer dereference in Google TensorFlow before 1.12.2 could cause a denial of service via an invalid GIF file.",
      "cve": "CVE-2019-9635",
      "specs": [
        "<1.12.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15190",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `tf.raw_ops.Switch` operation takes as input a tensor and a boolean and outputs two tensors. Depending on the boolean value, one of the tensors is exactly the input tensor whereas the other one should be an empty tensor. However, the eager runtime traverses all tensors in the output. Since only one of the tensors is defined, the other one is `nullptr`, hence we are binding a reference to `nullptr`. This is undefined behavior and reported as an error if compiling with `-fsanitize=null`. In this case, this results in a segmentation fault The issue is patched in commit da8558533d925694483d2c136a9220d6d49d843c, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15190",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15191",
      "advisory": "In Tensorflow before versions 2.2.1 and 2.3.1, if a user passes an invalid argument to `dlpack.to_dlpack` the expected validations will cause variables to bind to `nullptr` while setting a `status` variable to the error condition. However, this `status` argument is not properly checked. Hence, code following these methods will bind references to null pointers. This is undefined behavior and reported as an error if compiling with `-fsanitize=null`. The issue is patched in commit 22e07fb204386768e5bcbea563641ea11f96ceb8 and is released in TensorFlow versions 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15191",
      "specs": [
        "==2.2.0",
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15192",
      "advisory": "In Tensorflow before versions 2.2.1 and 2.3.1, if a user passes a list of strings to `dlpack.to_dlpack` there is a memory leak following an expected validation failure. The issue occurs because the `status` argument during validation failures is not properly checked. Since each of the above methods can return an error status, the `status` value must be checked before continuing. The issue is patched in commit 22e07fb204386768e5bcbea563641ea11f96ceb8 and is released in TensorFlow versions 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15192",
      "specs": [
        "==2.2.0",
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15193",
      "advisory": "In Tensorflow before versions 2.2.1 and 2.3.1, the implementation of `dlpack.to_dlpack` can be made to use uninitialized memory resulting in further memory corruption. This is because the pybind11 glue code assumes that the argument is a tensor. However, there is nothing stopping users from passing in a Python object instead of a tensor. The uninitialized memory address is due to a `reinterpret_cast` Since the `PyObject` is a Python object, not a TensorFlow Tensor, the cast to `EagerTensor` fails. The issue is patched in commit 22e07fb204386768e5bcbea563641ea11f96ceb8 and is released in TensorFlow versions 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15193",
      "specs": [
        "==2.2.0",
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15194",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `SparseFillEmptyRowsGrad` implementation has incomplete validation of the shapes of its arguments. Although `reverse_index_map_t` and `grad_values_t` are accessed in a similar pattern, only `reverse_index_map_t` is validated to be of proper shape. Hence, malicious users can pass a bad `grad_values_t` to trigger an assertion failure in `vec`, causing denial of service in serving installations. The issue is patched in commit 390611e0d45c5793c7066110af37c8514e6a6c54, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.\"",
      "cve": "CVE-2020-15194",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15195",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the implementation of `SparseFillEmptyRowsGrad` uses a double indexing pattern. It is possible for `reverse_index_map(i)` to be an index outside of bounds of `grad_values`, thus resulting in a heap buffer overflow. The issue is patched in commit 390611e0d45c5793c7066110af37c8514e6a6c54, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15195",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15196",
      "advisory": "In Tensorflow version 2.3.0, the `SparseCountSparseOutput` and `RaggedCountSparseOutput` implementations don't validate that the `weights` tensor has the same shape as the data. The check exists for `DenseCountSparseOutput`, where both tensors are fully specified. In the sparse and ragged count weights are still accessed in parallel with the data. But, since there is no validation, a user passing fewer weights than the values for the tensors can generate a read from outside the bounds of the heap buffer allocated for the weights. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15196",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15197",
      "advisory": "In Tensorflow before version 2.3.1, the `SparseCountSparseOutput` implementation does not validate that the input arguments form a valid sparse tensor. In particular, there is no validation that the `indices` tensor has rank 2. This tensor must be a matrix because code assumes its elements are accessed as elements of a matrix. However, malicious users can pass in tensors of different rank, resulting in a `CHECK` assertion failure and a crash. This can be used to cause denial of service in serving installations, if users are allowed to control the components of the input sparse tensor. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15197",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15198",
      "advisory": "In Tensorflow before version 2.3.1, the `SparseCountSparseOutput` implementation does not validate that the input arguments form a valid sparse tensor. In particular, there is no validation that the `indices` tensor has the same shape as the `values` one. The values in these tensors are always accessed in parallel. Thus, a shape mismatch can result in accesses outside the bounds of heap allocated buffers. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15198",
      "specs": [
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15199",
      "advisory": "In Tensorflow before version 2.3.1, the `RaggedCountSparseOutput` does not validate that the input arguments form a valid ragged tensor. In particular, there is no validation that the `splits` tensor has the minimum required number of elements. Code uses this quantity to initialize a different data structure. Since `BatchedMap` is equivalent to a vector, it needs to have at least one element to not be `nullptr`. If user passes a `splits` tensor that is empty or has exactly one element, we get a `SIGABRT` signal raised by the operating system. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15199",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15200",
      "advisory": "In Tensorflow before version 2.3.1, the `RaggedCountSparseOutput` implementation does not validate that the input arguments form a valid ragged tensor. In particular, there is no validation that the values in the `splits` tensor generate a valid partitioning of the `values` tensor. Thus, the code sets up conditions to cause a heap buffer overflow. A `BatchedMap` is equivalent to a vector where each element is a hashmap. However, if the first element of `splits_values` is not 0, `batch_idx` will never be 1, hence there will be no hashmap at index 0 in `per_batch_counts`. Trying to access that in the user code results in a segmentation fault. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15200",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15201",
      "advisory": "In Tensorflow before version 2.3.1, the `RaggedCountSparseOutput` implementation does not validate that the input arguments form a valid ragged tensor. In particular, there is no validation that the values in the `splits` tensor generate a valid partitioning of the `values` tensor. Hence, the code is prone to heap buffer overflow. If `split_values` does not end with a value at least `num_values` then the `while` loop condition will trigger a read outside of the bounds of `split_values` once `batch_idx` grows too large. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
      "cve": "CVE-2020-15201",
      "specs": [
        "==2.3.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15202",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `Shard` API in TensorFlow expects the last argument to be a function taking two `int64` (i.e., `long long`) arguments. However, there are several places in TensorFlow where a lambda taking `int` or `int32` arguments is being used. In these cases, if the amount of work to be parallelized is large enough, integer truncation occurs. Depending on how the two arguments of the lambda are used, this can result in segfaults, read/write outside of heap allocated arrays, stack overflows, or data corruption. The issue is patched in commits 27b417360cbd671ef55915e4bb6bb06af8b8a832 and ca8c013b5e97b1373b3bb1c97ea655e69f31a575, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15202",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15203",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, by controlling the `fill` argument of tf.strings.as_string, a malicious attacker is able to trigger a format string vulnerability due to the way the internal format use in a `printf` call is constructed. This may result in segmentation fault. The issue is patched in commit 33be22c65d86256e6826666662e40dbdfe70ee83, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15203",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15204",
      "advisory": "In eager mode, TensorFlow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1 does not set the session state. Hence, calling `tf.raw_ops.GetSessionHandle` or `tf.raw_ops.GetSessionHandleV2` results in a null pointer dereference In linked snippet, in eager mode, `ctx->session_state()` returns `nullptr`. Since code immediately dereferences this, we get a segmentation fault. The issue is patched in commit 9a133d73ae4b4664d22bd1aa6d654fec13c52ee1, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15204",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15205",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `data_splits` argument of `tf.raw_ops.StringNGrams` lacks validation. This allows a user to pass values that can cause heap overflow errors and even leak contents of memory In the linked code snippet, all the binary strings after `ee ff` are contents from the memory stack. Since these can contain return addresses, this data leak can be used to defeat ASLR. The issue is patched in commit 0462de5b544ed4731aa2fb23946ac22c01856b80, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15205",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15206",
      "advisory": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, changing the TensorFlow's `SavedModel` protocol buffer and altering the name of required keys results in segfaults and data corruption while loading the model. This can cause a denial of service in products using `tensorflow-serving` or other inference-as-a-service installments. Fixed were added in commits f760f88b4267d981e13f4b302c437ae800445968 and fcfef195637c6e365577829c4d67681695956e7d (both going into TensorFlow 2.2.0 and 2.3.0 but not yet backported to earlier versions). However, this was not enough, as #41097 reports a different failure mode. The issue is patched in commit adf095206f25471e864a8e63a0f1caef53a0e3a6, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15206",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15207",
      "advisory": "In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, to mimic Python's indexing with negative values, TFLite uses `ResolveAxis` to convert negative values to positive indices. However, the only check that the converted index is now valid is only present in debug builds. If the `DCHECK` does not trigger, then code execution moves ahead with a negative index. This, in turn, results in accessing data out of bounds which results in segfaults and/or data corruption. The issue is patched in commit 2d88f470dea2671b430884260f3626b1fe99830a, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15207",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15208",
      "advisory": "In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, when determining the common dimension size of two tensors, TFLite uses a `DCHECK` which is no-op outside of debug compilation modes. Since the function always returns the dimension of the first tensor, malicious attackers can craft cases where this is larger than that of the second tensor. In turn, this would result in reads/writes outside of bounds since the interpreter will wrongly assume that there is enough data in both tensors. The issue is patched in commit 8ee24e7949a203d234489f9da2c5bf45a7d5157d, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15208",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15209",
      "advisory": "In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, a crafted TFLite model can force a node to have as input a tensor backed by a `nullptr` buffer. This can be achieved by changing a buffer index in the flatbuffer serialization to convert a read-only tensor to a read-write one. The runtime assumes that these buffers are written to before a possible read, hence they are initialized with `nullptr`. However, by changing the buffer index for a tensor and implicitly converting that tensor to be a read-write one, as there is nothing in the model that writes to it, we get a null pointer dereference. The issue is patched in commit 0b5662bc, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15209",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15210",
      "advisory": "In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, if a TFLite saved model uses the same tensor as both input and output of an operator, then, depending on the operator, we can observe a segmentation fault or just memory corruption. We have patched the issue in d58c96946b and will release patch releases for all versions between 1.15 and 2.3. We recommend users to upgrade to TensorFlow 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
      "cve": "CVE-2020-15210",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15211",
      "advisory": "In TensorFlow Lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, saved models in the flatbuffer format use a double indexing scheme: a model has a set of subgraphs, each subgraph has a set of operators and each operator has a set of input/output tensors. The flatbuffer format uses indices for the tensors, indexing into an array of tensors that is owned by the subgraph. This results in a pattern of double array indexing when trying to get the data of each tensor. However, some operators can have some tensors be optional. To handle this scenario, the flatbuffer model uses a negative `-1` value as index for these tensors. This results in special casing during validation at model loading time. Unfortunately, this means that the `-1` index is a valid tensor index for any operator, including those that don't expect optional inputs and including for output tensors. Thus, this allows writing and reading from outside the bounds of heap allocated arrays, although only at a specific offset from the start of these arrays. This results in both read and write gadgets, albeit very limited in scope. The issue is patched in several commits (46d5b0852, 00302787b7, e11f5558, cd31fd0ce, 1970c21, and fff2c83), and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to the model loading code to ensure that only operators which accept optional inputs use the `-1` special value and only for the tensors that they expect to be optional. Since this allow-list type approach is erro-prone, we advise upgrading to the patched code.",
      "cve": "CVE-2020-15211",
      "specs": [
        "<1.15.4",
        ">=2.0.0,<2.0.3",
        ">=2.1.0,<2.1.2",
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15212",
      "advisory": "In TensorFlow Lite before versions 2.2.1 and 2.3.1, models using segment sum can trigger writes outside of bounds of heap allocated buffers by inserting negative elements in the segment ids tensor. Users having access to `segment_ids_data` can alter `output_index` and then write to outside of `output_data` buffer. This might result in a segmentation fault but it can also be used to further corrupt the memory and can be chained with other vulnerabilities to create more advanced exploits. The issue is patched in commit 204945b19e44b57906c9344c0d00120eeeae178a and is released in TensorFlow versions 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to the model loading code to ensure that the segment ids are all positive, although this only handles the case when the segment ids are stored statically in the model. A similar validation could be done if the segment ids are generated at runtime between inference steps. If the segment ids are generated as outputs of a tensor during inference steps, then there are no possible workaround and users are advised to upgrade to patched code.",
      "cve": "CVE-2020-15212",
      "specs": [
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15213",
      "advisory": "In TensorFlow Lite before versions 2.2.1 and 2.3.1, models using segment sum can trigger a denial of service by causing an out of memory allocation in the implementation of segment sum. Since code uses the last element of the tensor holding them to determine the dimensionality of output tensor, attackers can use a very large value to trigger a large allocation. The issue is patched in commit 204945b19e44b57906c9344c0d00120eeeae178a and is released in TensorFlow versions 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to limit the maximum value in the segment ids tensor. This only handles the case when the segment ids are stored statically in the model, but a similar validation could be done if the segment ids are generated at runtime, between inference steps. However, if the segment ids are generated as outputs of a tensor during inference steps, then there are no possible workaround and users are advised to upgrade to patched code.",
      "cve": "CVE-2020-15213",
      "specs": [
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15214",
      "advisory": "In TensorFlow Lite before versions 2.2.1 and 2.3.1, models using segment sum can trigger a write out bounds / segmentation fault if the segment ids are not sorted. Code assumes that the segment ids are in increasing order, using the last element of the tensor holding them to determine the dimensionality of output tensor. This results in allocating insufficient memory for the output tensor and in a write outside the bounds of the output array. This usually results in a segmentation fault, but depending on runtime conditions it can provide for a write gadget to be used in future memory corruption-based exploits. The issue is patched in commit 204945b19e44b57906c9344c0d00120eeeae178a and is released in TensorFlow versions 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to the model loading code to ensure that the segment ids are sorted, although this only handles the case when the segment ids are stored statically in the model. A similar validation could be done if the segment ids are generated at runtime between inference steps. If the segment ids are generated as outputs of a tensor during inference steps, then there are no possible workaround and users are advised to upgrade to patched code.",
      "cve": "CVE-2020-15214",
      "specs": [
        ">=2.2.0,<2.2.1",
        ">=2.3.0,<2.3.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15265",
      "advisory": "In Tensorflow before version 2.4.0, an attacker can pass an invalid `axis` value to `tf.quantization.quantize_and_dequantize`. This results in accessing a dimension outside the rank of the input tensor in the C++ kernel implementation. However, dim_size only does a DCHECK to validate the argument and then uses it to access the corresponding element of an array. Since in normal builds, `DCHECK`-like macros are no-ops, this results in segfault and access out of bounds of the array. The issue is patched in eccb7ec454e6617738554a255d77f08e60ee0808 and TensorFlow 2.4.0 will be released containing the patch. TensorFlow nightly packages after this commit will also have the issue resolved.",
      "cve": "CVE-2020-15265",
      "specs": [
        "<2.4.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-15266",
      "advisory": "In Tensorflow before version 2.4.0, when the `boxes` argument of `tf.image.crop_and_resize` has a very large value, the CPU kernel implementation receives it as a C++ `nan` floating point value. Attempting to operate on this is undefined behavior which later produces a segmentation fault. The issue is patched in eccb7ec454e6617738554a255d77f08e60ee0808 and TensorFlow 2.4.0 will be released containing the patch. TensorFlow nightly packages after this commit will also have the issue resolved.",
      "cve": "CVE-2020-15266",
      "specs": [
        "<2.4.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-26266",
      "advisory": "In affected versions of TensorFlow under certain cases a saved model can trigger use of uninitialized values during code execution. This is caused by having tensor buffers be filled with the default value of the type but forgetting to default initialize the quantized floating point types in Eigen. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26266",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-26267",
      "advisory": "In affected versions of TensorFlow the tf.raw_ops.DataFormatVecPermute API does not validate the src_format and dst_format attributes. The code assumes that these two arguments define a permutation of NHWC. This can result in uninitialized memory accesses, read outside of bounds and even crashes. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26267",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-26268",
      "advisory": "In affected versions of TensorFlow the tf.raw_ops.ImmutableConst operation returns a constant tensor created from a memory mapped file which is assumed immutable. However, if the type of the tensor is not an integral type, the operation crashes the Python interpreter as it tries to write to the memory area. If the file is too small, TensorFlow properly returns an error as the memory area has fewer bytes than what is needed for the tensor it creates. However, as soon as there are enough bytes, the above snippet causes a segmentation fault. This is because the allocator used to return the buffer data is not marked as returning an opaque handle since the needed virtual method is not overridden. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26268",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-26269",
      "advisory": "In TensorFlow release candidate versions 2.4.0rc*, the general implementation for matching filesystem paths to globbing pattern is vulnerable to an access out of bounds of the array holding the directories. There are multiple invariants and preconditions that are assumed by the parallel implementation of GetMatchingPaths but are not verified by the PRs introducing it (#40861 and #44310). Thus, we are completely rewriting the implementation to fully specify and validate these. This is patched in version 2.4.0. This issue only impacts master branch and the release candidates for TF version 2.4. The final release of the 2.4 release will be patched.",
      "cve": "CVE-2020-26269",
      "specs": [
        "==2.4.0-rc0",
        "==2.4.0-rc1",
        "==2.4.0-rc2",
        "==2.4.0-rc3",
        "==2.4.0-rc4"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-26270",
      "advisory": "In affected versions of TensorFlow running an LSTM/GRU model where the LSTM/GRU layer receives an input with zero-length results in a CHECK failure when using the CUDA backend. This can result in a query-of-death vulnerability, via denial of service, if users can control the input to the layer. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26270",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-26271",
      "advisory": "In affected versions of TensorFlow under certain cases, loading a saved model can result in accessing uninitialized memory while building the computation graph. The MakeEdge function creates an edge between one output tensor of the src node (given by output_index) and the input slot of the dst node (given by input_index). This is only possible if the types of the tensors on both sides coincide, so the function begins by obtaining the corresponding DataType values and comparing these for equality. However, there is no check that the indices point to inside of the arrays they index into. Thus, this can result in accessing data out of bounds of the corresponding heap allocated arrays. In most scenarios, this can manifest as unitialized data access, but if the index points far away from the boundaries of the arrays this can be used to leak addresses from the library. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.",
      "cve": "CVE-2020-26271",
      "specs": [
        "<1.15.5",
        ">=2.0.0,<2.0.4",
        ">=2.1.0,<2.1.3",
        ">=2.2.0,<2.2.2",
        ">=2.3.0,<2.3.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2020-5215",
      "advisory": "In TensorFlow before 1.15.2 and 2.0.1, converting a string (from Python) to a tf.float16 value results in a segmentation fault in eager mode as the format checks for this use case are only in the graph mode. This issue can lead to denial of service in inference/training where a malicious attacker can send a data point which contains a string instead of a tf.float16 value. Similar effects can be obtained by manipulating saved models and checkpoints whereby replacing a scalar tf.float16 value with a scalar string will trigger this issue due to automatic conversions. This can be easily reproduced by tf.constant(\"hello\", tf.float16), if eager execution is enabled. This issue is patched in TensorFlow 1.15.1 and 2.0.1 with this vulnerability patched. TensorFlow 2.1.0 was released after we fixed the issue, thus it is not affected. Users are encouraged to switch to TensorFlow 1.15.1, 2.0.1 or 2.1.0.",
      "cve": "CVE-2020-5215",
      "specs": [
        "<1.15.2",
        ">=2.0.0,<2.0.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29512",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. If the `splits` argument of `RaggedBincount` does not specify a valid `SparseTensor`(https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor), then an attacker can trigger a heap buffer overflow. This will cause a read from outside the bounds of the `splits` tensor buffer in the implementation of the `RaggedBincount` op(https://github.com/tensorflow/tensorflow/blob/8b677d79167799f71c42fd3fa074476e0295413a/tensorflow/core/kernels/bincount_op.cc#L430-L433). Before the `for` loop, `batch_idx` is set to 0. The user controls the `splits` array, making it contain only one element, 0. Thus, the code in the `while` loop would increment `batch_idx` and then try to read `splits(1)`, which is outside of bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3, as these are also affected.",
      "cve": "CVE-2021-29512",
      "specs": [
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29513",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Calling TF operations with tensors of non-numeric types when the operations expect numeric tensors result in null pointer dereferences. The conversion from Python array to C++ array(https://github.com/tensorflow/tensorflow/blob/ff70c47a396ef1e3cb73c90513da4f5cb71bebba/tensorflow/python/lib/core/ndarray_tensor.cc#L113-L169) is vulnerable to a type confusion. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29513",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29514",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. If the `splits` argument of `RaggedBincount` does not specify a valid `SparseTensor`(https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor), then an attacker can trigger a heap buffer overflow. This will cause a read from outside the bounds of the `splits` tensor buffer in the implementation of the `RaggedBincount` op(https://github.com/tensorflow/tensorflow/blob/8b677d79167799f71c42fd3fa074476e0295413a/tensorflow/core/kernels/bincount_op.cc#L430-L446). Before the `for` loop, `batch_idx` is set to 0. The attacker sets `splits(0)` to be 7, hence the `while` loop does not execute and `batch_idx` remains 0. This then results in writing to `out(-1, bin)`, which is before the heap allocated buffer for the output tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3, as these are also affected.",
      "cve": "CVE-2021-29514",
      "specs": [
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29515",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `MatrixDiag*` operations(https://github.com/tensorflow/tensorflow/blob/4c4f420e68f1cfaf8f4b6e8e3eb857e9e4c3ff33/tensorflow/core/kernels/linalg/matrix_diag_op.cc#L195-L197) does not validate that the tensor arguments are non-empty. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29515",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29516",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Calling `tf.raw_ops.RaggedTensorToVariant` with arguments specifying an invalid ragged tensor results in a null pointer dereference. The implementation of `RaggedTensorToVariant` operations(https://github.com/tensorflow/tensorflow/blob/904b3926ed1c6c70380d5313d282d248a776baa1/tensorflow/core/kernels/ragged_tensor_to_variant_op.cc#L39-L40) does not validate that the ragged tensor argument is non-empty. Since `batched_ragged` contains no elements, `batched_ragged.splits` is a null vector, thus `batched_ragged.splits(0)` will result in dereferencing `nullptr`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29516",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29517",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. A malicious user could trigger a division by 0 in `Conv3D` implementation. The implementation(https://github.com/tensorflow/tensorflow/blob/42033603003965bffac51ae171b51801565e002d/tensorflow/core/kernels/conv_ops_3d.cc#L143-L145) does a modulo operation based on user controlled input. Thus, when `filter` has a 0 as the fifth element, this results in a division by 0. Additionally, if the shape of the two tensors is not valid, an Eigen assertion can be triggered, resulting in a program crash. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29517",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29518",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In eager mode (default in TF 2.0 and later), session operations are invalid. However, users could still call the raw ops associated with them and trigger a null pointer dereference. The implementation(https://github.com/tensorflow/tensorflow/blob/eebb96c2830d48597d055d247c0e9aebaea94cd5/tensorflow/core/kernels/session_ops.cc#L104) dereferences the session state pointer without checking if it is valid. Thus, in eager mode, `ctx->session_state()` is nullptr and the call of the member function is undefined behavior. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29518",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29519",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The API of `tf.raw_ops.SparseCross` allows combinations which would result in a `CHECK`-failure and denial of service. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/3d782b7d47b1bf2ed32bd4a246d6d6cadc4c903d/tensorflow/core/kernels/sparse_cross_op.cc#L114-L116) is tricked to consider a tensor of type `tstring` which in fact contains integral elements. Fixing the type confusion by preventing mixing `DT_STRING` and `DT_INT64` types solves this issue. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29519",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29520",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Missing validation between arguments to `tf.raw_ops.Conv3DBackprop*` operations can result in heap buffer overflows. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/4814fafb0ca6b5ab58a09411523b2193fed23fed/tensorflow/core/kernels/conv_grad_shape_utils.cc#L94-L153) assumes that the `input`, `filter_sizes` and `out_backprop` tensors have the same shape, as they are accessed in parallel. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29520",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29521",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Specifying a negative dense shape in `tf.raw_ops.SparseCountSparseOutput` results in a segmentation fault being thrown out from the standard library as `std::vector` invariants are broken. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/8f7b60ee8c0206a2c99802e3a4d1bb55d2bc0624/tensorflow/core/kernels/count_ops.cc#L199-L213) assumes the first element of the dense shape is always positive and uses it to initialize a `BatchedMap<T>` (i.e., `std::vector<absl::flat_hash_map<int64,T>>`(https://github.com/tensorflow/tensorflow/blob/8f7b60ee8c0206a2c99802e3a4d1bb55d2bc0624/tensorflow/core/kernels/count_ops.cc#L27)) data structure. If the `shape` tensor has more than one element, `num_batches` is the first value in `shape`. Ensuring that the `dense_shape` argument is a valid tensor shape (that is, all elements are non-negative) solves this issue. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3.",
      "cve": "CVE-2021-29521",
      "specs": [
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29522",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The `tf.raw_ops.Conv3DBackprop*` operations fail to validate that the input tensors are not empty. In turn, this would result in a division by 0. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a91bb59769f19146d5a0c20060244378e878f140/tensorflow/core/kernels/conv_grad_ops_3d.cc#L430-L450) does not check that the divisor used in computing the shard size is not zero. Thus, if attacker controls the input sizes, they can trigger a denial of service via a division by zero error. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29522",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29523",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.AddManySparseToTensorsMap`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/kernels/sparse_tensors_map_ops.cc#L257) takes the values specified in `sparse_shape` as dimensions for the output shape. The `TensorShape` constructor(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L183-L188) uses a `CHECK` operation which triggers when `InitDims`(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L212-L296) returns a non-OK status. This is a legacy implementation of the constructor and operations should use `BuildTensorShapeBase` or `AddDimWithStatus` to prevent `CHECK`-failures in the presence of overflows. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29523",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29524",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/496c2630e51c1a478f095b084329acedb253db6b/tensorflow/core/kernels/conv_grad_shape_utils.cc#L130) does a modulus operation where the divisor is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29524",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29525",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2DBackpropInput`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/b40060c9f697b044e3107917c797ba052f4506ab/tensorflow/core/kernels/conv_grad_input_ops.h#L625-L655) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29525",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29526",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2D`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/988087bd83f144af14087fe4fecee2d250d93737/tensorflow/core/kernels/conv_ops.cc#L261-L263) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29526",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29527",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.QuantizedConv2D`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/00e9a4d67d76703fa1aee33dac582acf317e0e81/tensorflow/core/kernels/quantized_conv_ops.cc#L257-L259) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29527",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29528",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.QuantizedMul`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/55900e961ed4a23b438392024912154a2c2f5e85/tensorflow/core/kernels/quantized_mul_op.cc#L188-L198) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29528",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29529",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a heap buffer overflow in `tf.raw_ops.QuantizedResizeBilinear` by manipulating input values so that float rounding results in off-by-one error in accessing image elements. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/44b7f486c0143f68b56c34e2d01e146ee445134a/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L62-L66) computes two integers (representing the upper and lower bounds for interpolation) by ceiling and flooring a floating point value. For some values of `in`, `interpolation->upper[i]` might be smaller than `interpolation->lower[i]`. This is an issue if `interpolation->upper[i]` is capped at `in_size-1` as it means that `interpolation->lower[i]` points outside of the image. Then, in the interpolation code(https://github.com/tensorflow/tensorflow/blob/44b7f486c0143f68b56c34e2d01e146ee445134a/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L245-L264), this would result in heap buffer overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29529",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29530",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a null pointer dereference by providing an invalid `permutation` to `tf.raw_ops.SparseMatrixSparseCholesky`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/080f1d9e257589f78b3ffb75debf584168aa6062/tensorflow/core/kernels/sparse/sparse_cholesky_op.cc#L85-L86) fails to properly validate the input arguments. Although `ValidateInputs` is called and there are checks in the body of this function, the code proceeds to the next line in `ValidateInputs` since `OP_REQUIRES`(https://github.com/tensorflow/tensorflow/blob/080f1d9e257589f78b3ffb75debf584168aa6062/tensorflow/core/framework/op_requires.h#L41-L48) is a macro that only exits the current function. Thus, the first validation condition that fails in `ValidateInputs` will cause an early return from that function. However, the caller will continue execution from the next line. The fix is to either explicitly check `context->status()` or to convert `ValidateInputs` to return a `Status`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29530",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29531",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a `CHECK` fail in PNG encoding by providing an empty input tensor as the pixel data. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/e312e0791ce486a80c9d23110841525c6f7c3289/tensorflow/core/kernels/image/encode_png_op.cc#L57-L60) only validates that the total number of pixels in the image does not overflow. Thus, an attacker can send an empty matrix for encoding. However, if the tensor is empty, then the associated buffer is `nullptr`. Hence, when calling `png::WriteImageToBuffer`(https://github.com/tensorflow/tensorflow/blob/e312e0791ce486a80c9d23110841525c6f7c3289/tensorflow/core/kernels/image/encode_png_op.cc#L79-L93), the first argument (i.e., `image.flat<T>().data()`) is `NULL`. This then triggers the `CHECK_NOTNULL` in the first line of `png::WriteImageToBuffer`(https://github.com/tensorflow/tensorflow/blob/e312e0791ce486a80c9d23110841525c6f7c3289/tensorflow/core/lib/png/png_io.cc#L345-L349). Since `image` is null, this results in `abort` being called after printing the stacktrace. Effectively, this allows an attacker to mount a denial of service attack. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29531",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29532",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can force accesses outside the bounds of heap allocated arrays by passing in invalid tensor values to `tf.raw_ops.RaggedCross`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/efea03b38fb8d3b81762237dc85e579cc5fc6e87/tensorflow/core/kernels/ragged_cross_op.cc#L456-L487) lacks validation for the user supplied arguments. Each of the above branches call a helper function after accessing array elements via a `*_list[next_*]` pattern, followed by incrementing the `next_*` index. However, as there is no validation that the `next_*` values are in the valid range for the corresponding `*_list` arrays, this results in heap OOB reads. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29532",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29533",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK` failure by passing an empty image to `tf.raw_ops.DrawBoundingBoxes`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/ea34a18dc3f5c8d80a40ccca1404f343b5d55f91/tensorflow/core/kernels/image/draw_bounding_box_op.cc#L148-L165) uses `CHECK_*` assertions instead of `OP_REQUIRES` to validate user controlled inputs. Whereas `OP_REQUIRES` allows returning an error condition back to the user, the `CHECK_*` macros result in a crash if the condition is false, similar to `assert`. In this case, `height` is 0 from the `images` input. This results in `max_box_row_clamp` being negative and the assertion being falsified, followed by aborting program execution. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29533",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29534",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.SparseConcat`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/b432a38fe0e1b4b904a6c222cbce794c39703e87/tensorflow/core/kernels/sparse_concat_op.cc#L76) takes the values specified in `shapes[0]` as dimensions for the output shape. The `TensorShape` constructor(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L183-L188) uses a `CHECK` operation which triggers when `InitDims`(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L212-L296) returns a non-OK status. This is a legacy implementation of the constructor and operations should use `BuildTensorShapeBase` or `AddDimWithStatus` to prevent `CHECK`-failures in the presence of overflows. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29534",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29535",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedMul` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/87cf4d3ea9949051e50ca3f071fc909538a51cd0/tensorflow/core/kernels/quantized_mul_op.cc#L287-L290) assumes that the 4 arguments are always valid scalars and tries to access the numeric value directly. However, if any of these tensors is empty, then `.flat<T>()` is an empty buffer and accessing the element at position 0 results in overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29535",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29536",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedReshape` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a324ac84e573fba362a5e53d4e74d5de6729933e/tensorflow/core/kernels/quantized_reshape_op.cc#L38-L55) assumes that the 2 arguments are always valid scalars and tries to access the numeric value directly. However, if any of these tensors is empty, then `.flat<T>()` is an empty buffer and accessing the element at position 0 results in overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29536",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29537",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedResizeBilinear` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/50711818d2e61ccce012591eeb4fdf93a8496726/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L705-L706) assumes that the 2 arguments are always valid scalars and tries to access the numeric value directly. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29537",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29538",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a division by zero to occur in `Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1b0296c3b8dd9bd948f924aa8cd62f87dbb7c3da/tensorflow/core/kernels/conv_grad_filter_ops.cc#L513-L522) computes a divisor based on user provided data (i.e., the shape of the tensors given as arguments). If all shapes are empty then `work_unit_size` is 0. Since there is no check for this case before division, this results in a runtime exception, with potential to be abused for a denial of service. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29538",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29539",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Calling `tf.raw_ops.ImmutableConst`(https://www.tensorflow.org/api_docs/python/tf/raw_ops/ImmutableConst) with a `dtype` of `tf.resource` or `tf.variant` results in a segfault in the implementation as code assumes that the tensor contents are pure scalars. We have patched the issue in 4f663d4b8f0bec1b48da6fa091a7d29609980fa4 and will release TensorFlow 2.5.0 containing the patch. TensorFlow nightly packages after this commit will also have the issue resolved. If using `tf.raw_ops.ImmutableConst` in code, you can prevent the segfault by inserting a filter for the `dtype` argument.",
      "cve": "CVE-2021-29539",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29540",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow to occur in `Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1b0296c3b8dd9bd948f924aa8cd62f87dbb7c3da/tensorflow/core/kernels/conv_grad_filter_ops.cc#L495-L497) computes the size of the filter tensor but does not validate that it matches the number of elements in `filter_sizes`. Later, when reading/writing to this buffer, code uses the value computed here, instead of the number of elements in the tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29540",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29541",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a dereference of a null pointer in `tf.raw_ops.StringNGrams`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1cdd4da14282210cc759e468d9781741ac7d01bf/tensorflow/core/kernels/string_ngrams_op.cc#L67-L74) does not fully validate the `data_splits` argument. This would result in `ngrams_data`(https://github.com/tensorflow/tensorflow/blob/1cdd4da14282210cc759e468d9781741ac7d01bf/tensorflow/core/kernels/string_ngrams_op.cc#L106-L110) to be a null pointer when the output would be computed to have 0 or negative size. Later writes to the output tensor would then cause a null pointer dereference. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29541",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29542",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow by passing crafted inputs to `tf.raw_ops.StringNGrams`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1cdd4da14282210cc759e468d9781741ac7d01bf/tensorflow/core/kernels/string_ngrams_op.cc#L171-L185) fails to consider corner cases where input would be split in such a way that the generated tokens should only contain padding elements. If input is such that `num_tokens` is 0, then, for `data_start_index=0` (when left padding is present), the marked line would result in reading `data[-1]`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29542",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29543",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.CTCGreedyDecoder`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1615440b17b364b875eb06f43d087381f1460a65/tensorflow/core/kernels/ctc_decoder_ops.cc#L37-L50) has a `CHECK_LT` inserted to validate some invariants. When this condition is false, the program aborts, instead of returning a valid error to the user. This abnormal termination can be weaponized in denial of service attacks. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29543",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29544",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.QuantizeAndDequantizeV4Grad`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/95078c145b5a7a43ee046144005f733092756ab5/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L162-L163) does not validate the rank of the `input_*` tensors. In turn, this results in the tensors being passes as they are to `QuantizeAndDequantizePerChannelGradientImpl`(https://github.com/tensorflow/tensorflow/blob/95078c145b5a7a43ee046144005f733092756ab5/tensorflow/core/kernels/quantize_and_dequantize_op.h#L295-L306). However, the `vec<T>` method, requires the rank to 1 and triggers a `CHECK` failure otherwise. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 as this is the only other affected version.",
      "cve": "CVE-2021-29544",
      "specs": [
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29545",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in converting sparse tensors to CSR Sparse matrices. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/800346f2c03a27e182dd4fba48295f65e7790739/tensorflow/core/kernels/sparse/kernels.cc#L66) does a double redirection to access an element of an array allocated on the heap. If the value at `indices(i, 0)` is such that `indices(i, 0) + 1` is outside the bounds of `csr_row_ptr`, this results in writing outside of bounds of heap allocated data. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29545",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29546",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger an integer division by zero undefined behavior in `tf.raw_ops.QuantizedBiasAdd`. This is because the implementation of the Eigen kernel(https://github.com/tensorflow/tensorflow/blob/61bca8bd5ba8a68b2d97435ddfafcdf2b85672cd/tensorflow/core/kernels/quantization_utils.h#L812-L849) does a division by the number of elements of the smaller input (based on shape) without checking that this is not zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29546",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29547",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a segfault and denial of service via accessing data outside of bounds in `tf.raw_ops.QuantizedBatchNormWithGlobalNormalization`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/55a97caa9e99c7f37a0bbbeb414dc55553d3ae7f/tensorflow/core/kernels/quantized_batch_norm_op.cc#L176-L189) assumes the inputs are not empty. If any of these inputs is empty, `.flat<T>()` is an empty buffer, so accessing the element at index 0 is accessing data outside of bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29547",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29548",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a runtime division by zero error and denial of service in `tf.raw_ops.QuantizedBatchNormWithGlobalNormalization`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/55a97caa9e99c7f37a0bbbeb414dc55553d3ae7f/tensorflow/core/kernels/quantized_batch_norm_op.cc) does not validate all constraints specified in the op's contract(https://www.tensorflow.org/api_docs/python/tf/raw_ops/QuantizedBatchNormWithGlobalNormalization). The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29548",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29549",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a runtime division by zero error and denial of service in `tf.raw_ops.QuantizedBatchNormWithGlobalNormalization`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/6f26b3f3418201479c264f2a02000880d8df151c/tensorflow/core/kernels/quantized_add_op.cc#L289-L295) computes a modulo operation without validating that the divisor is not zero. Since `vector_num_elements` is determined based on input shapes(https://github.com/tensorflow/tensorflow/blob/6f26b3f3418201479c264f2a02000880d8df151c/tensorflow/core/kernels/quantized_add_op.cc#L522-L544), a user can trigger scenarios where this quantity is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29549",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29550",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a runtime division by zero error and denial of service in `tf.raw_ops.FractionalAvgPool`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/acc8ee69f5f46f92a3f1f11230f49c6ac266f10c/tensorflow/core/kernels/fractional_avg_pool_op.cc#L85-L89) computes a divisor quantity by dividing two user controlled values. The user controls the values of `input_size[i]` and `pooling_ratio_[i]` (via the `value.shape()` and `pooling_ratio` arguments). If the value in `input_size[i]` is smaller than the `pooling_ratio_[i]`, then the floor operation results in `output_size[i]` being 0. The `DCHECK_GT` line is a no-op outside of debug mode, so in released versions of TF this does not trigger. Later, these computed values are used as arguments(https://github.com/tensorflow/tensorflow/blob/acc8ee69f5f46f92a3f1f11230f49c6ac266f10c/tensorflow/core/kernels/fractional_avg_pool_op.cc#L96-L99) to `GeneratePoolingSequence`(https://github.com/tensorflow/tensorflow/blob/acc8ee69f5f46f92a3f1f11230f49c6ac266f10c/tensorflow/core/kernels/fractional_pool_common.cc#L100-L108). There, the first computation is a division in a modulo operation. Since `output_length` can be 0, this results in runtime crashing. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29550",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29551",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `MatrixTriangularSolve`(https://github.com/tensorflow/tensorflow/blob/8cae746d8449c7dda5298327353d68613f16e798/tensorflow/core/kernels/linalg/matrix_triangular_solve_op_impl.h#L160-L240) fails to terminate kernel execution if one validation condition fails. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29551",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29552",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by controlling the values of `num_segments` tensor argument for `UnsortedSegmentJoin`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a2a607db15c7cd01d754d37e5448d72a13491bdb/tensorflow/core/kernels/unsorted_segment_join_op.cc#L92-L93) assumes that the `num_segments` tensor is a valid scalar. Since the tensor is empty the `CHECK` involved in `.scalar<T>()()` that checks that the number of elements is exactly 1 will be invalidated and this would result in process termination. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29552",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29553",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can read data outside of bounds of heap allocated buffer in `tf.raw_ops.QuantizeAndDequantizeV3`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/11ff7f80667e6490d7b5174aa6bf5e01886e770f/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L237) does not validate the value of user supplied `axis` attribute before using it to index in the array backing the `input` argument. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29553",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29554",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.DenseCountSparseOutput`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/efff014f3b2d8ef6141da30c806faf141297eca1/tensorflow/core/kernels/count_ops.cc#L123-L127) computes a divisor value from user data but does not check that the result is 0 before doing the division. Since `data` is given by the `values` argument, `num_batch_elements` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, and TensorFlow 2.3.3, as these are also affected.",
      "cve": "CVE-2021-29554",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29555",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.FusedBatchNorm`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/828f346274841fa7505f7020e88ca36c22e557ab/tensorflow/core/kernels/fused_batch_norm_op.cc#L295-L297) performs a division based on the last dimension of the `x` tensor. Since this is controlled by the user, an attacker can trigger a denial of service. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29555",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29556",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.Reverse`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/36229ea9e9451dac14a8b1f4711c435a1d84a594/tensorflow/core/kernels/reverse_op.cc#L75-L76) performs a division based on the first dimension of the tensor argument. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29556",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29557",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.SparseMatMul`. The division by 0 occurs deep in Eigen code because the `b` tensor is empty. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29557",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29558",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `tf.raw_ops.SparseSplit`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/699bff5d961f0abfde8fa3f876e6d241681fbef8/tensorflow/core/util/sparse/sparse_tensor.h#L528-L530) accesses an array element based on a user controlled offset. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29558",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29559",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can access data outside of bounds of heap allocated array in `tf.raw_ops.UnicodeEncode`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/472c1f12ad9063405737679d4f6bd43094e1d36d/tensorflow/core/kernels/unicode_ops.cc) assumes that the `input_value`/`input_splits` pair specify a valid sparse tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29559",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29560",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `tf.raw_ops.RaggedTensorToTensor`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/d94227d43aa125ad8b54115c03cece54f6a1977b/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L219-L222) uses the same index to access two arrays in parallel. Since the user controls the shape of the input arguments, an attacker could trigger a heap OOB access when `parent_output_index` is shorter than `row_split`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29560",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29561",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by exploiting a `CHECK`-failure coming from `tf.raw_ops.LoadAndRemapMatrix`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/d94227d43aa125ad8b54115c03cece54f6a1977b/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L219-L222) assumes that the `ckpt_path` is always a valid scalar. However, an attacker can send any other tensor as the first argument of `LoadAndRemapMatrix`. This would cause the rank `CHECK` in `scalar<T>()()` to trigger and terminate the process. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29561",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29562",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by exploiting a `CHECK`-failure coming from the implementation of `tf.raw_ops.IRFFT`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29562",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29563",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by exploiting a `CHECK`-failure coming from the implementation of `tf.raw_ops.RFFT`. Eigen code operating on an empty matrix can trigger on an assertion and will cause program termination. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29563",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29564",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a null pointer dereference in the implementation of `tf.raw_ops.EditDistance`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/79865b542f9ffdc9caeb255631f7c56f1d4b6517/tensorflow/core/kernels/edit_distance_op.cc#L103-L159) has incomplete validation of the input parameters. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29564",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29565",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a null pointer dereference in the implementation of `tf.raw_ops.SparseFillEmptyRows`. This is because of missing validation(https://github.com/tensorflow/tensorflow/blob/fdc82089d206e281c628a93771336bf87863d5e8/tensorflow/core/kernels/sparse_fill_empty_rows_op.cc#L230-L231) that was covered under a `TODO`. If the `dense_shape` tensor is empty, then `dense_shape_t.vec<>()` would cause a null pointer dereference in the implementation of the op. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29565",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29566",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can write outside the bounds of heap allocated arrays by passing invalid arguments to `tf.raw_ops.Dilation2DBackpropInput`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/afd954e65f15aea4d438d0a219136fc4a63a573d/tensorflow/core/kernels/dilation_ops.cc#L321-L322) does not validate before writing to the output array. The values for `h_out` and `w_out` are guaranteed to be in range for `out_backprop` (as they are loop indices bounded by the size of the array). However, there are no similar guarantees relating `h_in_max`/`w_in_max` and `in_backprop`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29566",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29567",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.SparseDenseCwiseMul`, an attacker can trigger denial of service via `CHECK`-fails or accesses to outside the bounds of heap allocated data. Since the implementation(https://github.com/tensorflow/tensorflow/blob/38178a2f7a681a7835bb0912702a134bfe3b4d84/tensorflow/core/kernels/sparse_dense_binary_op_shared.cc#L68-L80) only validates the rank of the input arguments but no constraints between dimensions(https://www.tensorflow.org/api_docs/python/tf/raw_ops/SparseDenseCwiseMul), an attacker can abuse them to trigger internal `CHECK` assertions (and cause program termination, denial of service) or to write to memory outside of bounds of heap allocated tensor buffers. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29567",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29568",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger undefined behavior by binding to null pointer in `tf.raw_ops.ParameterizedTruncatedNormal`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/3f6fe4dfef6f57e768260b48166c27d148f3015f/tensorflow/core/kernels/parameterized_truncated_normal_op.cc#L630) does not validate input arguments before accessing the first element of `shape`. If `shape` argument is empty, then `shape_tensor.flat<T>()` is an empty array. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29568",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29569",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` can cause reads outside of bounds of heap allocated data if attacker supplies specially crafted inputs. The implementation(https://github.com/tensorflow/tensorflow/blob/ac328eaa3870491ababc147822cd04e91a790643/tensorflow/core/kernels/requantization_range_op.cc#L49-L50) assumes that the `input_min` and `input_max` tensors have at least one element, as it accesses the first element in two arrays. If the tensors are empty, `.flat<T>()` is an empty object, backed by an empty array. Hence, accesing even the 0th element is a read outside the bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29569",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29570",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` can cause reads outside of bounds of heap allocated data if attacker supplies specially crafted inputs. The implementation(https://github.com/tensorflow/tensorflow/blob/ef0c008ee84bad91ec6725ddc42091e19a30cf0e/tensorflow/core/kernels/maxpooling_op.cc#L1016-L1017) uses the same value to index in two different arrays but there is no guarantee that the sizes are identical. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29570",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29571",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` can cause reads outside of bounds of heap allocated data if attacker supplies specially crafted inputs. The implementation(https://github.com/tensorflow/tensorflow/blob/31bd5026304677faa8a0b77602c6154171b9aec1/tensorflow/core/kernels/image/draw_bounding_box_op.cc#L116-L130) assumes that the last element of `boxes` input is 4, as required by [the op](https://www.tensorflow.org/api_docs/python/tf/raw_ops/DrawBoundingBoxesV2). Since this is not checked attackers passing values less than 4 can write outside of bounds of heap allocated objects and cause memory corruption. If the last dimension in `boxes` is less than 4, accesses similar to `tboxes(b, bb, 3)` will access data outside of bounds. Further during code execution there are also writes to these indices. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29571",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29572",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.SdcaOptimizer` triggers undefined behavior due to dereferencing a null pointer. The implementation(https://github.com/tensorflow/tensorflow/blob/60a45c8b6192a4699f2e2709a2645a751d435cc3/tensorflow/core/kernels/sdca_internal.cc) does not validate that the user supplied arguments satisfy all constraints expected by the op(https://www.tensorflow.org/api_docs/python/tf/raw_ops/SdcaOptimizer). The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29572",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29573",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` is vulnerable to a division by 0. The implementation(https://github.com/tensorflow/tensorflow/blob/279bab6efa22752a2827621b7edb56a730233bd8/tensorflow/core/kernels/maxpooling_op.cc#L1033-L1034) fails to validate that the batch dimension of the tensor is non-zero, before dividing by this quantity. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29573",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29574",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPool3DGradGrad` exhibits undefined behavior by dereferencing null pointers backing attacker-supplied empty tensors. The implementation(https://github.com/tensorflow/tensorflow/blob/72fe792967e7fd25234342068806707bbc116618/tensorflow/core/kernels/pooling_ops_3d.cc#L679-L703) fails to validate that the 3 tensor inputs are not empty. If any of them is empty, then accessing the elements in the tensor results in dereferencing a null pointer. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29574",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29575",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.ReverseSequence` allows for stack overflow and/or `CHECK`-fail based denial of service. The implementation(https://github.com/tensorflow/tensorflow/blob/5b3b071975e01f0d250c928b2a8f901cd53b90a7/tensorflow/core/kernels/reverse_sequence_op.cc#L114-L118) fails to validate that `seq_dim` and `batch_dim` arguments are valid. Negative values for `seq_dim` can result in stack overflow or `CHECK`-failure, depending on the version of Eigen code used to implement the operation. Similar behavior can be exhibited by invalid values of `batch_dim`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29575",
      "specs": [
        "<=2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29576",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPool3DGradGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/596c05a159b6fbb9e39ca10b3f7753b7244fa1e9/tensorflow/core/kernels/pooling_ops_3d.cc#L694-L696) does not check that the initialization of `Pool3dParameters` completes successfully. Since the constructor(https://github.com/tensorflow/tensorflow/blob/596c05a159b6fbb9e39ca10b3f7753b7244fa1e9/tensorflow/core/kernels/pooling_ops_3d.cc#L48-L88) uses `OP_REQUIRES` to validate conditions, the first assertion that fails interrupts the initialization of `params`, making it contain invalid data. In turn, this might cause a heap buffer overflow, depending on default initialized values. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29576",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29577",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.AvgPool3DGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/d80ffba9702dc19d1fac74fc4b766b3fa1ee976b/tensorflow/core/kernels/pooling_ops_3d.cc#L376-L450) assumes that the `orig_input_shape` and `grad` tensors have similar first and last dimensions but does not check that this assumption is validated. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29577",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29578",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.FractionalAvgPoolGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/dcba796a28364d6d7f003f6fe733d82726dda713/tensorflow/core/kernels/fractional_avg_pool_op.cc#L216) fails to validate that the pooling sequence arguments have enough elements as required by the `out_backprop` tensor shape. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29578",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29579",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/ab1e644b48c82cb71493f4362b4dd38f4577a1cf/tensorflow/core/kernels/maxpooling_op.cc#L194-L203) fails to validate that indices used to access elements of input/output arrays are valid. Whereas accesses to `input_backprop_flat` are guarded by `FastBoundsCheck`, the indexing in `out_backprop_flat` can result in OOB access. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29579",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29580",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.FractionalMaxPoolGrad` triggers an undefined behavior if one of the input tensors is empty. The code is also vulnerable to a denial of service attack as a `CHECK` condition becomes false and aborts the process. The implementation(https://github.com/tensorflow/tensorflow/blob/169054888d50ce488dfde9ca55d91d6325efbd5b/tensorflow/core/kernels/fractional_max_pool_op.cc#L215) fails to validate that input and output tensors are not empty and are of the same rank. Each of these unchecked assumptions is responsible for the above issues. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29580",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29581",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.CTCBeamSearchDecoder`, an attacker can trigger denial of service via segmentation faults. The implementation(https://github.com/tensorflow/tensorflow/blob/a74768f8e4efbda4def9f16ee7e13cf3922ac5f7/tensorflow/core/kernels/ctc_decoder_ops.cc#L68-L79) fails to detect cases when the input tensor is empty and proceeds to read data from a null buffer. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29581",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29582",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.Dequantize`, an attacker can trigger a read from outside of bounds of heap allocated data. The implementation(https://github.com/tensorflow/tensorflow/blob/26003593aa94b1742f34dc22ce88a1e17776a67d/tensorflow/core/kernels/dequantize_op.cc#L106-L131) accesses the `min_range` and `max_range` tensors in parallel but fails to check that they have the same shape. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29582",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29583",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.FusedBatchNorm` is vulnerable to a heap buffer overflow. If the tensors are empty, the same implementation can trigger undefined behavior by dereferencing null pointers. The implementation(https://github.com/tensorflow/tensorflow/blob/57d86e0db5d1365f19adcce848dfc1bf89fdd4c7/tensorflow/core/kernels/fused_batch_norm_op.cc) fails to validate that `scale`, `offset`, `mean` and `variance` (the last two only when required) all have the same number of elements as the number of channels of `x`. This results in heap out of bounds reads when the buffers backing these tensors are indexed past their boundary. If the tensors are empty, the validation mentioned in the above paragraph would also trigger and prevent the undefined behavior. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29583",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29584",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in caused by an integer overflow in constructing a new tensor shape. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/0908c2f2397c099338b901b067f6495a5b96760b/tensorflow/core/kernels/sparse_split_op.cc#L66-L70) builds a dense shape without checking that the dimensions would not result in overflow. The `TensorShape` constructor(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L183-L188) uses a `CHECK` operation which triggers when `InitDims`(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L212-L296) returns a non-OK status. This is a legacy implementation of the constructor and operations should use `BuildTensorShapeBase` or `AddDimWithStatus` to prevent `CHECK`-failures in the presence of overflows. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29584",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29585",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The TFLite computation for size of output after padding, `ComputeOutSize`(https://github.com/tensorflow/tensorflow/blob/0c9692ae7b1671c983569e5d3de5565843d500cf/tensorflow/lite/kernels/padding.h#L43-L55), does not check that the `stride` argument is not 0 before doing the division. Users can craft special models such that `ComputeOutSize` is called with `stride` set to 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29585",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29586",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Optimized pooling implementations in TFLite fail to check that the stride arguments are not 0 before calling `ComputePaddingHeightWidth`(https://github.com/tensorflow/tensorflow/blob/3f24ccd932546416ec906a02ddd183b48a1d2c83/tensorflow/lite/kernels/pooling.cc#L90). Since users can craft special models which will have `params->stride_{height,width}` be zero, this will result in a division by zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29586",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29587",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The `Prepare` step of the `SpaceToDepth` TFLite operator does not check for 0 before division(https://github.com/tensorflow/tensorflow/blob/5f7975d09eac0f10ed8a17dbb6f5964977725adc/tensorflow/lite/kernels/space_to_depth.cc#L63-L67). An attacker can craft a model such that `params->block_size` would be zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29587",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29588",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The optimized implementation of the `TransposeConv` TFLite operator is [vulnerable to a division by zero error](https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/internal/optimized/optimized_ops.h#L5221-L5222). An attacker can craft a model such that `stride_{h,w}` values are 0. Code calling this function must validate these arguments. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29588",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29589",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The reference implementation of the `GatherNd` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/internal/reference/reference_ops.h#L966). An attacker can craft a model such that `params` input would be an empty tensor. In turn, `params_shape.Dims(.)` would be zero, in at least one dimension. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29589",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29590",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementations of the `Minimum` and `Maximum` TFLite operators can be used to read data outside of bounds of heap allocated objects, if any of the two input tensor arguments are empty. This is because the broadcasting implementation(https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/internal/reference/maximum_minimum.h#L52-L56) indexes in both tensors with the same index but does not validate that the index is within bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29590",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29591",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. TFlite graphs must not have loops between nodes. However, this condition was not checked and an attacker could craft models that would result in infinite loop during evaluation. In certain cases, the infinite loop would be replaced by stack overflow due to too many recursive calls. For example, the `While` implementation(https://github.com/tensorflow/tensorflow/blob/106d8f4fb89335a2c52d7c895b7a7485465ca8d9/tensorflow/lite/kernels/while.cc) could be tricked into a scneario where both the body and the loop subgraphs are the same. Evaluating one of the subgraphs means calling the `Eval` function for the other and this quickly exhaust all stack space. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range. Please consult our security guide(https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.",
      "cve": "CVE-2021-29591",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29592",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The fix for CVE-2020-15209(https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-15209) missed the case when the target shape of `Reshape` operator is given by the elements of a 1-D tensor. As such, the fix for the vulnerability(https://github.com/tensorflow/tensorflow/blob/9c1dc920d8ffb4893d6c9d27d1f039607b326743/tensorflow/lite/core/subgraph.cc#L1062-L1074) allowed passing a null-buffer-backed tensor with a 1D shape. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29592",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29593",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `BatchToSpaceNd` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/b5ed552fe55895aee8bd8b191f744a069957d18d/tensorflow/lite/kernels/batch_to_space_nd.cc#L81-L82). An attacker can craft a model such that one dimension of the `block` input is 0. Hence, the corresponding value in `block_shape` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29593",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29594",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. TFLite's convolution code(https://github.com/tensorflow/tensorflow/blob/09c73bca7d648e961dd05898292d91a8322a9d45/tensorflow/lite/kernels/conv.cc) has multiple division where the divisor is controlled by the user and not checked to be non-zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29594",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29595",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `DepthToSpace` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/depth_to_space.cc#L63-L69). An attacker can craft a model such that `params->block_size` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29595",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29596",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `EmbeddingLookup` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/e4b29809543b250bc9b19678ec4776299dd569ba/tensorflow/lite/kernels/embedding_lookup.cc#L73-L74). An attacker can craft a model such that the first dimension of the `value` input is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29596",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29597",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `SpaceToBatchNd` TFLite operator is [vulnerable to a division by zero error](https://github.com/tensorflow/tensorflow/blob/412c7d9bb8f8a762c5b266c9e73bfa165f29aac8/tensorflow/lite/kernels/space_to_batch_nd.cc#L82-L83). An attacker can craft a model such that one dimension of the `block` input is 0. Hence, the corresponding value in `block_shape` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29597",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29598",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `SVDF` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/7f283ff806b2031f407db64c4d3edcda8fb9f9f5/tensorflow/lite/kernels/svdf.cc#L99-L102). An attacker can craft a model such that `params->rank` would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29598",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29599",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `Split` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/e2752089ef7ce9bcf3db0ec618ebd23ea119d0c7/tensorflow/lite/kernels/split.cc#L63-L65). An attacker can craft a model such that `num_splits` would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29599",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29600",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `OneHot` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/f61c57bd425878be108ec787f4d96390579fb83e/tensorflow/lite/kernels/one_hot.cc#L68-L72). An attacker can craft a model such that at least one of the dimensions of `indices` would be 0. In turn, the `prefix_dim_size` value would become 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29600",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29601",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The TFLite implementation of concatenation is vulnerable to an integer overflow issue(https://github.com/tensorflow/tensorflow/blob/7b7352a724b690b11bfaae2cd54bc3907daf6285/tensorflow/lite/kernels/concatenation.cc#L70-L76). An attacker can craft a model such that the dimensions of one of the concatenation input overflow the values of `int`. TFLite uses `int` to represent tensor dimensions, whereas TF uses `int64`. Hence, valid TF models can trigger an integer overflow when converted to TFLite format. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29601",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29602",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `DepthwiseConv` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/1a8e885b864c818198a5b2c0cbbeca5a1e833bc8/tensorflow/lite/kernels/depthwise_conv.cc#L287-L288). An attacker can craft a model such that `input`'s fourth dimension would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29602",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29603",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. A specially crafted TFLite model could trigger an OOB write on heap in the TFLite implementation of `ArgMin`/`ArgMax`(https://github.com/tensorflow/tensorflow/blob/102b211d892f3abc14f845a72047809b39cc65ab/tensorflow/lite/kernels/arg_min_max.cc#L52-L59). If `axis_value` is not a value between 0 and `NumDimensions(input)`, then the condition in the `if` is never true, so code writes past the last valid element of `output_dims->data`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29603",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29604",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The TFLite implementation of hashtable lookup is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/1a8e885b864c818198a5b2c0cbbeca5a1e833bc8/tensorflow/lite/kernels/hashtable_lookup.cc#L114-L115) An attacker can craft a model such that `values`'s first dimension would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29604",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29605",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The TFLite code for allocating `TFLiteIntArray`s is vulnerable to an integer overflow issue(https://github.com/tensorflow/tensorflow/blob/4ceffae632721e52bf3501b736e4fe9d1221cdfa/tensorflow/lite/c/common.c#L24-L27). An attacker can craft a model such that the `size` multiplier is so large that the return value overflows the `int` datatype and becomes negative. In turn, this results in invalid value being given to `malloc`(https://github.com/tensorflow/tensorflow/blob/4ceffae632721e52bf3501b736e4fe9d1221cdfa/tensorflow/lite/c/common.c#L47-L52). In this case, `ret->size` would dereference an invalid pointer. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29605",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29606",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. A specially crafted TFLite model could trigger an OOB read on heap in the TFLite implementation of `Split_V`(https://github.com/tensorflow/tensorflow/blob/c59c37e7b2d563967da813fa50fe20b21f4da683/tensorflow/lite/kernels/split_v.cc#L99). If `axis_value` is not a value between 0 and `NumDimensions(input)`, then the `SizeOfDimension` function(https://github.com/tensorflow/tensorflow/blob/102b211d892f3abc14f845a72047809b39cc65ab/tensorflow/lite/kernels/kernel_util.h#L148-L150) will access data outside the bounds of the tensor shape array. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29606",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29607",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `SparseAdd` results in allowing attackers to exploit undefined behavior (dereferencing null pointers) as well as write outside of bounds of heap allocated data. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/sparse_sparse_binary_op_shared.cc) has a large set of validation for the two sparse tensor inputs (6 tensors in total), but does not validate that the tensors are not empty or that the second dimension of `*_indices` matches the size of corresponding `*_shape`. This allows attackers to send tensor triples that represent invalid sparse tensors to abuse code assumptions that are not protected by validation. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29607",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29608",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.RaggedTensorToTensor`, an attacker can exploit an undefined behavior if input arguments are empty. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L356-L360) only checks that one of the tensors is not empty, but does not check for the other ones. There are multiple `DCHECK` validations to prevent heap OOB, but these are no-op in release builds, hence they don't prevent anything. The fix will be included in TensorFlow 2.5.0. We will also cherrypick these commits on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29608",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29609",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `SparseAdd` results in allowing attackers to exploit undefined behavior (dereferencing null pointers) as well as write outside of bounds of heap allocated data. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/sparse_add_op.cc) has a large set of validation for the two sparse tensor inputs (6 tensors in total), but does not validate that the tensors are not empty or that the second dimension of `*_indices` matches the size of corresponding `*_shape`. This allows attackers to send tensor triples that represent invalid sparse tensors to abuse code assumptions that are not protected by validation. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29609",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29610",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The validation in `tf.raw_ops.QuantizeAndDequantizeV2` allows invalid values for `axis` argument:. The validation(https://github.com/tensorflow/tensorflow/blob/eccb7ec454e6617738554a255d77f08e60ee0808/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L74-L77) uses `||` to mix two different conditions. If `axis_ < -1` the condition in `OP_REQUIRES` will still be true, but this value of `axis_` results in heap underflow. This allows attackers to read/write to other data on the heap. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29610",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29611",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `SparseReshape` results in a denial of service based on a `CHECK`-failure. The implementation(https://github.com/tensorflow/tensorflow/blob/e87b51ce05c3eb172065a6ea5f48415854223285/tensorflow/core/kernels/sparse_reshape_op.cc#L40) has no validation that the input arguments specify a valid sparse tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3, as these are the only affected versions.",
      "cve": "CVE-2021-29611",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29612",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a heap buffer overflow in Eigen implementation of `tf.raw_ops.BandedTriangularSolve`. The implementation(https://github.com/tensorflow/tensorflow/blob/eccb7ec454e6617738554a255d77f08e60ee0808/tensorflow/core/kernels/linalg/banded_triangular_solve_op.cc#L269-L278) calls `ValidateInputTensors` for input validation but fails to validate that the two tensors are not empty. Furthermore, since `OP_REQUIRES` macro only stops execution of current function after setting `ctx->status()` to a non-OK value, callers of helper functions that use `OP_REQUIRES` must check value of `ctx->status()` before continuing. This doesn't happen in this op's implementation(https://github.com/tensorflow/tensorflow/blob/eccb7ec454e6617738554a255d77f08e60ee0808/tensorflow/core/kernels/linalg/banded_triangular_solve_op.cc#L219), hence the validation that is present is also not effective. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29612",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29613",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `tf.raw_ops.CTCLoss` allows an attacker to trigger an OOB read from heap. The fix will be included in TensorFlow 2.5.0. We will also cherrypick these commits on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29613",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29614",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.io.decode_raw` produces incorrect results and crashes the Python interpreter when combining `fixed_length` and wider datatypes. The implementation of the padded version(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc) is buggy due to a confusion about pointer arithmetic rules. First, the code computes(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L61) the width of each output element by dividing the `fixed_length` value to the size of the type argument. The `fixed_length` argument is also used to determine the size needed for the output tensor(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L63-L79). This is followed by reencoding code(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L85-L94). The erroneous code is the last line above: it is moving the `out_data` pointer by `fixed_length * sizeof(T)` bytes whereas it only copied at most `fixed_length` bytes from the input. This results in parts of the input not being decoded into the output. Furthermore, because the pointer advance is far wider than desired, this quickly leads to writing to outside the bounds of the backing data. This OOB write leads to interpreter crash in the reproducer mentioned here, but more severe attacks can be mounted too, given that this gadget allows writing to periodically placed locations in memory. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29614",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29615",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `ParseAttrValue`(https://github.com/tensorflow/tensorflow/blob/c22d88d6ff33031aa113e48aa3fc9aa74ed79595/tensorflow/core/framework/attr_value_util.cc#L397-L453) can be tricked into stack overflow due to recursion by giving in a specially crafted input. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29615",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29616",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of TrySimplify(https://github.com/tensorflow/tensorflow/blob/c22d88d6ff33031aa113e48aa3fc9aa74ed79595/tensorflow/core/grappler/optimizers/arithmetic_optimizer.cc#L390-L401) has undefined behavior due to dereferencing a null pointer in corner cases that result in optimizing a node with no inputs. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29616",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29617",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via `CHECK`-fail in `tf.strings.substr` with invalid arguments. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29617",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29618",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Passing a complex argument to `tf.transpose` at the same time as passing `conjugate=True` argument results in a crash. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29618",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-29619",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Passing invalid arguments (e.g., discovered via fuzzing) to `tf.raw_ops.SparseCountSparseOutput` results in segfault. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-29619",
      "specs": [
        "<2.1.4",
        ">=2.2.0,<2.2.3",
        ">=2.3.0,<2.3.3",
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-35958",
      "advisory": "** DISPUTED ** TensorFlow through 2.5.0 allows attackers to overwrite arbitrary files via a crafted archive when tf.keras.utils.get_file is used with extract=True. NOTE: the vendor's position is that tf.keras.utils.get_file is not intended for untrusted archives.",
      "cve": "CVE-2021-35958",
      "specs": [
        "<=2.5.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37635",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of sparse reduction operations in TensorFlow can trigger accesses outside of bounds of heap allocated data. The [implementation](https://github.com/tensorflow/tensorflow/blob/a1bc56203f21a5a4995311825ffaba7a670d7747/tensorflow/core/kernels/sparse_reduce_op.cc#L217-L228) fails to validate that each reduction group does not overflow and that each corresponding index does not point to outside the bounds of the input tensor. We have patched the issue in GitHub commit 87158f43f05f2720a374f3e6d22a7aaa3a33f750. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37635",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37636",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.SparseDenseCwiseDiv` is vulnerable to a division by 0 error. The [implementation](https://github.com/tensorflow/tensorflow/blob/a1bc56203f21a5a4995311825ffaba7a670d7747/tensorflow/core/kernels/sparse_dense_binary_op_shared.cc#L56) uses a common class for all binary operations but fails to treat the division by 0 case separately. We have patched the issue in GitHub commit d9204be9f49520cdaaeb2541d1dc5187b23f31d9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37636",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37637",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. It is possible to trigger a null pointer dereference in TensorFlow by passing an invalid input to `tf.raw_ops.CompressElement`. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/data/compression_utils.cc#L34) was accessing the size of a buffer obtained from the return of a separate function call before validating that said buffer is valid. We have patched the issue in GitHub commit 5dc7f6981fdaf74c8c5be41f393df705841fb7c5. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37637",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37638",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. Sending invalid argument for `row_partition_types` of `tf.raw_ops.RaggedTensorToTensor` API results in a null pointer dereference and undefined behavior. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L328) accesses the first element of a user supplied list of values without validating that the provided list is not empty. We have patched the issue in GitHub commit 301ae88b331d37a2a16159b65b255f4f9eb39314. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37638",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37639",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. When restoring tensors via raw APIs, if the tensor name is not provided, TensorFlow can be tricked into dereferencing a null pointer. Alternatively, attackers can read memory outside the bounds of heap allocated data by providing some tensor names but not enough for a successful restoration. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/kernels/save_restore_tensor.cc#L158-L159) retrieves the tensor list corresponding to the `tensor_name` user controlled input and immediately retrieves the tensor at the restoration index (controlled via `preferred_shard` argument). This occurs without validating that the provided list has enough values. If the list is empty this results in dereferencing a null pointer (undefined behavior). If, however, the list has some elements, if the restoration index is outside the bounds this results in heap OOB read. We have patched the issue in GitHub commit 9e82dce6e6bd1f36a57e08fa85af213e2b2f2622. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37639",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37640",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.SparseReshape` can be made to trigger an integral division by 0 exception. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/reshape_util.cc#L176-L181) calls the reshaping functor whenever there is at least an index in the input but does not check that shape of the input or the target shape have both a non-zero number of elements. The [reshape functor](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/reshape_util.cc#L40-L78) blindly divides by the dimensions of the target shape. Hence, if this is not checked, code will result in a division by 0. We have patched the issue in GitHub commit 4923de56ec94fff7770df259ab7f2288a74feb41. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1 as this is the other affected version.",
      "cve": "CVE-2021-37640",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37641",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions if the arguments to `tf.raw_ops.RaggedGather` don't determine a valid ragged tensor code can trigger a read from outside of bounds of heap allocated buffers. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/ragged_gather_op.cc#L70) directly reads the first dimension of a tensor shape before checking that said tensor has rank of at least 1 (i.e., it is not a scalar). Furthermore, the implementation does not check that the list given by `params_nested_splits` is not an empty list of tensors. We have patched the issue in GitHub commit a2b743f6017d7b97af1fe49087ae15f0ac634373. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37641",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37642",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.ResourceScatterDiv` is vulnerable to a division by 0 error. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/resource_variable_ops.cc#L865) uses a common class for all binary operations but fails to treat the division by 0 case separately. We have patched the issue in GitHub commit 4aacb30888638da75023e6601149415b39763d76. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37642",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37643",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. If a user does not provide a valid padding value to `tf.raw_ops.MatrixDiagPartOp`, then the code triggers a null pointer dereference (if input is empty) or produces invalid behavior, ignoring all values after the first. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/linalg/matrix_diag_op.cc#L89) reads the first value from a tensor buffer without first checking that the tensor has values to read from. We have patched the issue in GitHub commit 482da92095c4d48f8784b1f00dda4f81c28d2988. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37643",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37644",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions providing a negative element to `num_elements` list argument of `tf.raw_ops.TensorListReserve` causes the runtime to abort the process due to reallocating a `std::vector` to have a negative number of elements. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/list_kernels.cc#L312) calls `std::vector.resize()` with the new size controlled by input given by the user, without checking that this input is valid. We have patched the issue in GitHub commit 8a6e874437670045e6c7dc6154c7412b4a2135e2. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37644",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37645",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.QuantizeAndDequantizeV4Grad` is vulnerable to an integer overflow issue caused by converting a signed integer value to an unsigned one and then allocating memory based on this value. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L126) uses the `axis` value as the size argument to `absl::InlinedVector` constructor. But, the constructor uses an unsigned type for the argument, so the implicit conversion transforms the negative value to a large integer. We have patched the issue in GitHub commit 96f364a1ca3009f98980021c4b32be5fdcca33a1. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, and TensorFlow 2.4.3, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37645",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37646",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.StringNGrams` is vulnerable to an integer overflow issue caused by converting a signed integer value to an unsigned one and then allocating memory based on this value. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/string_ngrams_op.cc#L184) calls `reserve` on a `tstring` with a value that sometimes can be negative if user supplies negative `ngram_widths`. The `reserve` method calls `TF_TString_Reserve` which has an `unsigned long` argument for the size of the buffer. Hence, the implicit conversion transforms the negative value to a large integer. We have patched the issue in GitHub commit c283e542a3f422420cfdb332414543b62fc4e4a5. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37646",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37647",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. When a user does not supply arguments that determine a valid sparse tensor, `tf.raw_ops.SparseTensorSliceDataset` implementation can be made to dereference a null pointer. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc#L240-L251) has some argument validation but fails to consider the case when either `indices` or `values` are provided for an empty sparse tensor when the other is not. If `indices` is empty, then [code that performs validation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/data/sparse_tensor_slice_dataset_op.cc#L260-L261) (i.e., checking that the indices are monotonically increasing) results in a null pointer dereference. If `indices` as provided by the user is empty, then `indices` in the C++ code above is backed by an empty `std::vector`, hence calling `indices->dim_size(0)` results in null pointer dereferencing (same as calling `std::vector::at()` on an empty vector). We have patched the issue in GitHub commit 02cc160e29d20631de3859c6653184e3f876b9d7. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37647",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37648",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the code for `tf.raw_ops.SaveV2` does not properly validate the inputs and an attacker can trigger a null pointer dereference. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/save_restore_v2_ops.cc) uses `ValidateInputs` to check that the input arguments are valid. This validation would have caught the illegal state represented by the reproducer above. However, the validation uses `OP_REQUIRES` which translates to setting the `Status` object of the current `OpKernelContext` to an error status, followed by an empty `return` statement which just terminates the execution of the function it is present in. However, this does not mean that the kernel execution is finalized: instead, execution continues from the next line in `Compute` that follows the call to `ValidateInputs`. This is equivalent to lacking the validation. We have patched the issue in GitHub commit 9728c60e136912a12d99ca56e106b7cce7af5986. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37648",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37649",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. The code for `tf.raw_ops.UncompressElement` can be made to trigger a null pointer dereference. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/data/experimental/compression_ops.cc#L50-L53) obtains a pointer to a `CompressedElement` from a `Variant` tensor and then proceeds to dereference it for decompressing. There is no check that the `Variant` tensor contained a `CompressedElement`, so the pointer is actually `nullptr`. We have patched the issue in GitHub commit 7bdf50bb4f5c54a4997c379092888546c97c3ebd. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37649",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37650",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.ExperimentalDatasetToTFRecord` and `tf.raw_ops.DatasetToTFRecord` can trigger heap buffer overflow and segmentation fault. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/data/experimental/to_tf_record_op.cc#L93-L102) assumes that all records in the dataset are of string type. However, there is no check for that, and the example given above uses numeric types. We have patched the issue in GitHub commit e0b6e58c328059829c3eb968136f17aa72b6c876. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37650",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37651",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.FractionalAvgPoolGrad` can be tricked into accessing data outside of bounds of heap allocated buffers. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/fractional_avg_pool_op.cc#L205) does not validate that the input tensor is non-empty. Thus, code constructs an empty `EigenDoubleMatrixMap` and then accesses this buffer with indices that are outside of the empty area. We have patched the issue in GitHub commit 0f931751fb20f565c4e94aa6df58d54a003cdb30. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37651",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37652",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.BoostedTreesCreateEnsemble` can result in a use after free error if an attacker supplies specially crafted arguments. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/boosted_trees/resource_ops.cc#L55) uses a reference counted resource and decrements the refcount if the initialization fails, as it should. However, when the code was written, the resource was represented as a naked pointer but later refactoring has changed it to be a smart pointer. Thus, when the pointer leaves the scope, a subsequent `free`-ing of the resource occurs, but this fails to take into account that the refcount has already reached 0, thus the resource has been already freed. During this double-free process, members of the resource object are accessed for cleanup but they are invalid as the entire resource has been freed. We have patched the issue in GitHub commit 5ecec9c6fbdbc6be03295685190a45e7eee726ab. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37652",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37653",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a crash via a floating point exception in `tf.raw_ops.ResourceGather`. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/resource_variable_ops.cc#L725-L731) computes the value of a value, `batch_size`, and then divides by it without checking that this value is not 0. We have patched the issue in GitHub commit ac117ee8a8ea57b73d34665cdf00ef3303bc0b11. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37653",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37654",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a crash via a `CHECK`-fail in debug builds of TensorFlow using `tf.raw_ops.ResourceGather` or a read from outside the bounds of heap allocated data in the same API in a release build. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/resource_variable_ops.cc#L660-L668) does not check that the `batch_dims` value that the user supplies is less than the rank of the input tensor. Since the implementation uses several for loops over the dimensions of `tensor`, this results in reading data from outside the bounds of heap allocated buffer backing the tensor. We have patched the issue in GitHub commit bc9c546ce7015c57c2f15c168b3d9201de679a1d. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37654",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37655",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a read from outside of bounds of heap allocated data by sending invalid arguments to `tf.raw_ops.ResourceScatterUpdate`. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/resource_variable_ops.cc#L919-L923) has an incomplete validation of the relationship between the shapes of `indices` and `updates`: instead of checking that the shape of `indices` is a prefix of the shape of `updates` (so that broadcasting can happen), code only checks that the number of elements in these two tensors are in a divisibility relationship. We have patched the issue in GitHub commit 01cff3f986259d661103412a20745928c727326f. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37655",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37656",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.RaggedTensorToSparse`. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/ragged_tensor_to_sparse_kernel.cc#L30) has an incomplete validation of the splits values: it does not check that they are in increasing order. We have patched the issue in GitHub commit 1071f554dbd09f7e101324d366eec5f4fe5a3ece. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37656",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37657",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in all operations of type `tf.raw_ops.MatrixDiagV*`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/linalg/matrix_diag_op.cc) has incomplete validation that the value of `k` is a valid tensor. We have check that this value is either a scalar or a vector, but there is no check for the number of elements. If this is an empty tensor, then code that accesses the first element of the tensor is wrong. We have patched the issue in GitHub commit f2a673bd34f0d64b8e40a551ac78989d16daad09. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37657",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37658",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in all operations of type `tf.raw_ops.MatrixSetDiagV*`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/linalg/matrix_diag_op.cc) has incomplete validation that the value of `k` is a valid tensor. We have check that this value is either a scalar or a vector, but there is no check for the number of elements. If this is an empty tensor, then code that accesses the first element of the tensor is wrong. We have patched the issue in GitHub commit ff8894044dfae5568ecbf2ed514c1a37dc394f1b. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37658",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37659",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in all binary cwise operations that don't require broadcasting (e.g., gradients of binary cwise operations). The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/cwise_ops_common.h#L264) assumes that the two inputs have exactly the same number of elements but does not check that. Hence, when the eigen functor executes it triggers heap OOB reads and undefined behavior due to binding to nullptr. We have patched the issue in GitHub commit 93f428fd1768df147171ed674fee1fc5ab8309ec. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37659",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37660",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause a floating point exception by calling inplace operations with crafted arguments that would result in a division by 0. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/inplace_ops.cc#L283) has a logic error: it should skip processing if `x` and `v` are empty but the code uses `||` instead of `&&`. We have patched the issue in GitHub commit e86605c0a336c088b638da02135ea6f9f6753618. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37660",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37661",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause a denial of service in `boosted_trees_create_quantile_stream_resource` by using negative arguments. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/quantile_ops.cc#L96) does not validate that `num_streams` only contains non-negative numbers. In turn, [this results in using this value to allocate memory](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/quantiles/quantile_stream_resource.h#L31-L40). However, `reserve` receives an unsigned integer so there is an implicit conversion from a negative value to a large positive unsigned. This results in a crash from the standard library. We have patched the issue in GitHub commit 8a84f7a2b5a2b27ecf88d25bad9ac777cd2f7992. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37661",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37662",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can generate undefined behavior via a reference binding to nullptr in `BoostedTreesCalculateBestGainsPerFeature` and similar attack can occur in `BoostedTreesCalculateBestFeatureSplitV2`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/stats_ops.cc) does not validate the input values. We have patched the issue in GitHub commit 9c87c32c710d0b5b53dc6fd3bfde4046e1f7a5ad and in commit 429f009d2b2c09028647dd4bb7b3f6f414bbaad7. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37662",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37663",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions due to incomplete validation in `tf.raw_ops.QuantizeV2`, an attacker can trigger undefined behavior via binding a reference to a null pointer or can access data outside the bounds of heap allocated arrays. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/quantize_op.cc#L59) has some validation but does not check that `min_range` and `max_range` both have the same non-zero number of elements. If `axis` is provided (i.e., not `-1`), then validation should check that it is a value in range for the rank of `input` tensor and then the lengths of `min_range` and `max_range` inputs match the `axis` dimension of the `input` tensor. We have patched the issue in GitHub commit 6da6620efad397c85493b8f8667b821403516708. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37663",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37664",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can read from outside of bounds of heap allocated data by sending specially crafted illegal arguments to `BoostedTreesSparseCalculateBestFeatureSplit`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/stats_ops.cc) needs to validate that each value in `stats_summary_indices` is in range. We have patched the issue in GitHub commit e84c975313e8e8e38bb2ea118196369c45c51378. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37664",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37665",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions due to incomplete validation in MKL implementation of requantization, an attacker can trigger undefined behavior via binding a reference to a null pointer or can access data outside the bounds of heap allocated arrays. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/mkl/mkl_requantization_range_per_channel_op.cc) does not validate the dimensions of the `input` tensor. A similar issue occurs in `MklRequantizePerChannelOp`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/mkl/mkl_requantize_per_channel_op.cc) does not perform full validation for all the input arguments. We have patched the issue in GitHub commit 9e62869465573cb2d9b5053f1fa02a81fce21d69 and in the Github commit 203214568f5bc237603dbab6e1fd389f1572f5c9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37665",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37666",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.RaggedTensorToVariant`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/ragged_tensor_to_variant_op.cc#L129) has an incomplete validation of the splits values, missing the case when the argument would be empty. We have patched the issue in GitHub commit be7a4de6adfbd303ce08be4332554dff70362612. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37666",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37667",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.UnicodeEncode`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/unicode_ops.cc#L533-L539) reads the first dimension of the `input_splits` tensor before validating that this tensor is not empty. We have patched the issue in GitHub commit 2e0ee46f1a47675152d3d865797a18358881d7a6. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37667",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37668",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause denial of service in applications serving models using `tf.raw_ops.UnravelIndex` by triggering a division by 0. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/unravel_index_op.cc#L36) does not check that the tensor subsumed by `dims` is not empty. Hence, if one element of `dims` is 0, the implementation does a division by 0. We have patched the issue in GitHub commit a776040a5e7ebf76eeb7eb923bf1ae417dd4d233. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37668",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37669",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause denial of service in applications serving models using `tf.raw_ops.NonMaxSuppressionV5` by triggering a division by 0. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/image/non_max_suppression_op.cc#L170-L271) uses a user controlled argument to resize a `std::vector`. However, as `std::vector::resize` takes the size argument as a `size_t` and `output_size` is an `int`, there is an implicit conversion to unsigned. If the attacker supplies a negative value, this conversion results in a crash. A similar issue occurs in `CombinedNonMaxSuppression`. We have patched the issue in GitHub commit 3a7362750d5c372420aa8f0caf7bf5b5c3d0f52d and commit [b5cdbf12ffcaaffecf98f22a6be5a64bb96e4f58. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37669",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37670",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can read from outside of bounds of heap allocated data by sending specially crafted illegal arguments to `tf.raw_ops.UpperBound`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/searchsorted_op.cc#L85-L104) does not validate the rank of `sorted_input` argument. A similar issue occurs in `tf.raw_ops.LowerBound`. We have patched the issue in GitHub commit 42459e4273c2e47a3232cc16c4f4fff3b3a35c38. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37670",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37671",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.Map*` and `tf.raw_ops.OrderedMap*` operations. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/map_stage_op.cc#L222-L248) has a check in place to ensure that `indices` is in ascending order, but does not check that `indices` is not empty. We have patched the issue in GitHub commit 532f5c5a547126c634fefd43bbad1dc6417678ac. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37671",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37672",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can read from outside of bounds of heap allocated data by sending specially crafted illegal arguments to `tf.raw_ops.SdcaOptimizerV2`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/sdca_internal.cc#L320-L353) does not check that the length of `example_labels` is the same as the number of examples. We have patched the issue in GitHub commit a4e138660270e7599793fa438cd7b2fc2ce215a6. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37672",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37673",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.MapStage`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/map_stage_op.cc#L513) does not check that the `key` input is a valid non-empty tensor. We have patched the issue in GitHub commit d7de67733925de196ec8863a33445b73f9562d1d. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37673",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37674",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a denial of service via a segmentation fault in `tf.raw_ops.MaxPoolGrad` caused by missing validation. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/maxpooling_op.cc) misses some validation for the `orig_input` and `orig_output` tensors. The fixes for CVE-2021-29579 were incomplete. We have patched the issue in GitHub commit 136b51f10903e044308cf77117c0ed9871350475. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37674",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37675",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions most implementations of convolution operators in TensorFlow are affected by a division by 0 vulnerability where an attacker can trigger a denial of service via a crash. The shape inference [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/framework/common_shape_fns.cc#L577) is missing several validations before doing divisions and modulo operations. We have patched the issue in GitHub commit 8a793b5d7f59e37ac7f3cd0954a750a2fe76bad4. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37675",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37676",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.SparseFillEmptyRows`. The shape inference [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/ops/sparse_ops.cc#L608-L634) does not validate that the input arguments are not empty tensors. We have patched the issue in GitHub commit 578e634b4f1c1c684d4b4294f9e5281b2133b3ed. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37676",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37677",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the shape inference code for `tf.raw_ops.Dequantize` has a vulnerability that could trigger a denial of service via a segfault if an attacker provides invalid arguments. The shape inference [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/ops/array_ops.cc#L2999-L3014) uses `axis` to select between two different values for `minmax_rank` which is then used to retrieve tensor dimensions. However, code assumes that `axis` can be either `-1` or a value greater than `-1`, with no validation for the other values. We have patched the issue in GitHub commit da857cfa0fde8f79ad0afdbc94e88b5d4bbec764. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37677",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37678",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions TensorFlow and Keras can be tricked to perform arbitrary code execution when deserializing a Keras model from YAML format. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/python/keras/saving/model_config.py#L66-L104) uses `yaml.unsafe_load` which can perform arbitrary code execution on the input. Given that YAML format support requires a significant amount of work, we have removed it for now. We have patched the issue in GitHub commit 23d6383eb6c14084a8fc3bdf164043b974818012. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37678",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37679",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions it is possible to nest a `tf.map_fn` within another `tf.map_fn` call. However, if the input tensor is a `RaggedTensor` and there is no function signature provided, code assumes the output is a fully specified tensor and fills output buffer with uninitialized contents from the heap. The `t` and `z` outputs should be identical, however this is not the case. The last row of `t` contains data from the heap which can be used to leak other memory information. The bug lies in the conversion from a `Variant` tensor to a `RaggedTensor`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/ragged_tensor_from_variant_op.cc#L177-L190) does not check that all inner shapes match and this results in the additional dimensions. The same implementation can result in data loss, if input tensor is tweaked. We have patched the issue in GitHub commit 4e2565483d0ffcadc719bd44893fb7f609bb5f12. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37679",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37680",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of fully connected layers in TFLite is [vulnerable to a division by zero error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/fully_connected.cc#L226). We have patched the issue in GitHub commit 718721986aa137691ee23f03638867151f74935f. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37680",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37681",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of SVDF in TFLite is [vulnerable to a null pointer error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/svdf.cc#L300-L313). The [`GetVariableInput` function](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/kernel_util.cc#L115-L119) can return a null pointer but `GetTensorData` assumes that the argument is always a valid tensor. Furthermore, because `GetVariableInput` calls [`GetMutableInput`](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/kernel_util.cc#L82-L90) which might return `nullptr`, the `tensor->is_variable` expression can also trigger a null pointer exception. We have patched the issue in GitHub commit 5b048e87e4e55990dae6b547add4dae59f4e1c76. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37681",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37682",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions all TFLite operations that use quantization can be made to use unitialized values. [For example](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/depthwise_conv.cc#L198-L200). The issue stems from the fact that `quantization.params` is only valid if `quantization.type` is different that `kTfLiteNoQuantization`. However, these checks are missing in large parts of the code. We have patched the issue in GitHub commits 537bc7c723439b9194a358f64d871dd326c18887, 4a91f2069f7145aab6ba2d8cfe41be8a110c18a5 and 8933b8a21280696ab119b63263babdb54c298538. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37682",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37683",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of division in TFLite is [vulnerable to a division by 0 error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/div.cc). There is no check that the divisor tensor does not contain zero elements. We have patched the issue in GitHub commit 1e206baedf8bef0334cca3eb92bab134ef525a28. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37683",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37684",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementations of pooling in TFLite are vulnerable to division by 0 errors as there are no checks for divisors not being 0. We have patched the issue in GitHub commit [dfa22b348b70bb89d6d6ec0ff53973bacb4f4695](https://github.com/tensorflow/tensorflow/commit/dfa22b348b70bb89d6d6ec0ff53973bacb4f4695). The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37684",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37685",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions TFLite's [`expand_dims.cc`](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/expand_dims.cc#L36-L50) contains a vulnerability which allows reading one element outside of bounds of heap allocated data. If `axis` is a large negative value (e.g., `-100000`), then after the first `if` it would still be negative. The check following the `if` statement will pass and the `for` loop would read one element before the start of `input_dims.data` (when `i = 0`). We have patched the issue in GitHub commit d94ffe08a65400f898241c0374e9edc6fa8ed257. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37685",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37686",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the strided slice implementation in TFLite has a logic bug which can allow an attacker to trigger an infinite loop. This arises from newly introduced support for [ellipsis in axis definition](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/strided_slice.cc#L103-L122). An attacker can craft a model such that `ellipsis_end_idx` is smaller than `i` (e.g., always negative). In this case, the inner loop does not increase `i` and the `continue` statement causes execution to skip over the preincrement at the end of the outer loop. We have patched the issue in GitHub commit dfa22b348b70bb89d6d6ec0ff53973bacb4f4695. TensorFlow 2.6.0 is the only affected version.",
      "cve": "CVE-2021-37686",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37687",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions TFLite's [`GatherNd` implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/gather_nd.cc#L124) does not support negative indices but there are no checks for this situation. Hence, an attacker can read arbitrary data from the heap by carefully crafting a model with negative values in `indices`. Similar issue exists in [`Gather` implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/gather.cc). We have patched the issue in GitHub commits bb6a0383ed553c286f87ca88c207f6774d5c4a8f and eb921122119a6b6e470ee98b89e65d721663179d. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37687",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37688",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can craft a TFLite model that would trigger a null pointer dereference, which would result in a crash and denial of service. The [implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/internal/optimized/optimized_ops.h#L268-L285) unconditionally dereferences a pointer. We have patched the issue in GitHub commit 15691e456c7dc9bd6be203b09765b063bf4a380c. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37688",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37689",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can craft a TFLite model that would trigger a null pointer dereference, which would result in a crash and denial of service. This is caused by the MLIR optimization of `L2NormalizeReduceAxis` operator. The [implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/compiler/mlir/lite/transforms/optimize.cc#L67-L70) unconditionally dereferences a pointer to an iterator to a vector without checking that the vector has elements. We have patched the issue in GitHub commit d6b57f461b39fd1aa8c1b870f1b974aac3554955. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37689",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37690",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions when running shape functions, some functions (such as `MutableHashTableShape`) produce extra output information in the form of a `ShapeAndType` struct. The shapes embedded in this struct are owned by an inference context that is cleaned up almost immediately; if the upstream code attempts to access this shape information, it can trigger a segfault. `ShapeRefiner` is mitigating this for normal output shapes by cloning them (and thus putting the newly created shape under ownership of an inference context that will not die), but we were not doing the same for shapes and types. This commit fixes that by doing similar logic on output shapes and types. We have patched the issue in GitHub commit ee119d4a498979525046fba1c3dd3f13a039fbb1. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37690",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37691",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can craft a TFLite model that would trigger a division by zero error in LSH [implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/lsh_projection.cc#L118). We have patched the issue in GitHub commit 0575b640091680cfb70f4dd93e70658de43b94f9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick thiscommit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-37691",
      "specs": [
        "==2.5.0",
        "==2.6.0-rc0",
        "==2.6.0-rc1",
        "==2.6.0-rc2",
        ">=2.3.0,<2.3.4",
        ">=2.4.0,<2.4.3"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-37692",
      "advisory": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions under certain conditions, Go code can trigger a segfault in string deallocation. For string tensors, `C.TF_TString_Dealloc` is called during garbage collection within a finalizer function. However, tensor structure isn't checked until encoding to avoid a performance penalty. The current method for dealloc assumes that encoding succeeded, but segfaults when a string tensor is garbage collected whose encoding failed (e.g., due to mismatched dimensions). To fix this, the call to set the finalizer function is deferred until `NewTensor` returns and, if encoding failed for a string tensor, deallocs are determined based on bytes written. We have patched the issue in GitHub commit 8721ba96e5760c229217b594f6d2ba332beedf22. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, which is the other affected version.",
      "cve": "CVE-2021-37692",
      "specs": [
        ">=2.5.0,<2.6.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41195",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `tf.math.segment_*` operations results in a `CHECK`-fail related abort (and denial of service) if a segment id in `segment_ids` is large. This is similar to CVE-2021-29584 (and similar other reported vulnerabilities in TensorFlow, localized to specific APIs): the implementation (both on CPU and GPU) computes the output shape using `AddDim`. However, if the number of elements in the tensor overflows an `int64_t` value, `AddDim` results in a `CHECK` failure which provokes a `std::abort`. Instead, code should use `AddDimWithStatus`. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41195",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41196",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the Keras pooling layers can trigger a segfault if the size of the pool is 0 or if a dimension is negative. This is due to the TensorFlow's implementation of pooling operations where the values in the sliding window are not checked to be strictly positive. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41196",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41197",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions TensorFlow allows tensor to have a large number of dimensions and each dimension can be as large as desired. However, the total number of elements in a tensor must fit within an `int64_t`. If an overflow occurs, `MultiplyWithoutOverflow` would return a negative result. In the majority of TensorFlow codebase this then results in a `CHECK`-failure. Newer constructs exist which return a `Status` instead of crashing the binary. This is similar to CVE-2021-29584. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41197",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41198",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions if `tf.tile` is called with a large input argument then the TensorFlow process will crash due to a `CHECK`-failure caused by an overflow. The number of elements in the output tensor is too much for the `int64_t` type and the overflow is detected via a `CHECK` statement. This aborts the process. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41198",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41199",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions if `tf.image.resize` is called with a large input argument then the TensorFlow process will crash due to a `CHECK`-failure caused by an overflow. The number of elements in the output tensor is too much for the `int64_t` type and the overflow is detected via a `CHECK` statement. This aborts the process. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41199",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41200",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions if `tf.summary.create_file_writer` is called with non-scalar arguments code crashes due to a `CHECK`-fail. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41200",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41201",
      "advisory": "TensorFlow is an open source platform for machine learning. In affeced versions during execution, `EinsumHelper::ParseEquation()` is supposed to set the flags in `input_has_ellipsis` vector and `*output_has_ellipsis` boolean to indicate whether there is ellipsis in the corresponding inputs and output. However, the code only changes these flags to `true` and never assigns `false`. This results in unitialized variable access if callers assume that `EinsumHelper::ParseEquation()` always sets these flags. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41201",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41202",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions while calculating the size of the output within the `tf.range` kernel, there is a conditional statement of type `int64 = condition ? int64 : double`. Due to C++ implicit conversion rules, both branches of the condition will be cast to `double` and the result would be truncated before the assignment. This result in overflows. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41202",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41203",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions an attacker can trigger undefined behavior, integer overflows, segfaults and `CHECK`-fail crashes if they can change saved checkpoints from outside of TensorFlow. This is because the checkpoints loading infrastructure is missing validation for invalid file formats. The fixes will be included in TensorFlow 2.7.0. We will also cherrypick these commits on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41203",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41204",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions during TensorFlow's Grappler optimizer phase, constant folding might attempt to deep copy a resource tensor. This results in a segfault, as these tensors are supposed to not change. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41204",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41205",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference functions for the `QuantizeAndDequantizeV*` operations can trigger a read outside of bounds of heap allocated array. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41205",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41206",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions several TensorFlow operations are missing validation for the shapes of the tensor arguments involved in the call. Depending on the API, this can result in undefined behavior and segfault or `CHECK`-fail related crashes but in some scenarios writes and reads from heap populated arrays are also possible. We have discovered these issues internally via tooling while working on improving/testing GPU op determinism. As such, we don't have reproducers and there will be multiple fixes for these issues. These fixes will be included in TensorFlow 2.7.0. We will also cherrypick these commits on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41206",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41207",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `ParallelConcat` misses some input validation and can produce a division by 0. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41207",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41208",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the code for boosted trees in TensorFlow is still missing validation. As a result, attackers can trigger denial of service (via dereferencing `nullptr`s or via `CHECK`-failures) as well as abuse undefined behavior (binding references to `nullptr`s). An attacker can also read and write from heap buffers, depending on the API that gets used and the arguments that are passed to the call. Given that the boosted trees implementation in TensorFlow is unmaintained, it is recommend to no longer use these APIs. We will deprecate TensorFlow's boosted trees APIs in subsequent releases. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41208",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41209",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementations for convolution operators trigger a division by 0 if passed empty filter tensor arguments. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41209",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41210",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference functions for `SparseCountSparseOutput` can trigger a read outside of bounds of heap allocated array. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41210",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41211",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `QuantizeV2` can trigger a read outside of bounds of heap allocated array. This occurs whenever `axis` is a negative value less than `-1`. In this case, we are accessing data before the start of a heap buffer. The code allows `axis` to be an optional argument (`s` would contain an `error::NOT_FOUND` error code). Otherwise, it assumes that `axis` is a valid index into the dimensions of the `input` tensor. If `axis` is less than `-1` then this results in a heap OOB read. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, as this version is the only one that is also affected.",
      "cve": "CVE-2021-41211",
      "specs": [
        "==2.6.0"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41212",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `tf.ragged.cross` can trigger a read outside of bounds of heap allocated array. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41212",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41213",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the code behind `tf.function` API can be made to deadlock when two `tf.function` decorated Python functions are mutually recursive. This occurs due to using a non-reentrant `Lock` Python object. Loading any model which contains mutually recursive functions is vulnerable. An attacker can cause denial of service by causing users to load such models and calling a recursive `tf.function`, although this is not a frequent scenario. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41213",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41214",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `tf.ragged.cross` has an undefined behavior due to binding a reference to `nullptr`. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41214",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41215",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `DeserializeSparse` can trigger a null pointer dereference. This is because the shape inference function assumes that the `serialize_sparse` tensor is a tensor with positive rank (and having `3` as the last dimension). The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41215",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41216",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference function for `Transpose` is vulnerable to a heap buffer overflow. This occurs whenever `perm` contains negative elements. The shape inference function does not validate that the indices in `perm` are all valid. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41216",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41217",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the process of building the control flow graph for a TensorFlow model is vulnerable to a null pointer exception when nodes that should be paired are not. This occurs because the code assumes that the first node in the pairing (e.g., an `Enter` node) always exists when encountering the second node (e.g., an `Exit` node). When this is not the case, `parent` is `nullptr` so dereferencing it causes a crash. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41217",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41218",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `AllToAll` can be made to execute a division by 0. This occurs whenever the `split_count` argument is 0. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41218",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41219",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the code for sparse matrix multiplication is vulnerable to undefined behavior via binding a reference to `nullptr`. This occurs whenever the dimensions of `a` or `b` are 0 or less. In the case on one of these is 0, an empty output tensor should be allocated (to conserve the invariant that output tensors are always allocated when the operation is successful) but nothing should be written to it (that is, we should return early from the kernel implementation). Otherwise, attempts to write to this empty tensor would result in heap OOB access. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41219",
      "specs": [
        "<2.4.4",
        "==2.6.0",
        ">=2.5.0,<2.5.2"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41220",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the async implementation of `CollectiveReduceV2` suffers from a memory leak and a use after free. This occurs due to the asynchronous computation and the fact that objects that have been `std::move()`d from are still accessed. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, as this version is the only one that is also affected.",
      "cve": "CVE-2021-41220",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41221",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for the `Cudnn*` operations in TensorFlow can be tricked into accessing invalid memory, via a heap buffer overflow. This occurs because the ranks of the `input`, `input_h` and `input_c` parameters are not validated, but code assumes they have certain values. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41221",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41222",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `SplitV` can trigger a segfault is an attacker supplies negative arguments. This occurs whenever `size_splits` contains more than one value and at least one value is negative. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41222",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41223",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `FusedBatchNorm` kernels is vulnerable to a heap OOB access. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41223",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41224",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `SparseFillEmptyRows` can be made to trigger a heap OOB access. This occurs whenever the size of `indices` does not match the size of `values`. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41224",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41225",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions TensorFlow's Grappler optimizer has a use of unitialized variable. If the `train_nodes` vector (obtained from the saved model that gets optimized) does not contain a `Dequeue` node, then `dequeue_node` is left unitialized. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41225",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41226",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `SparseBinCount` is vulnerable to a heap OOB access. This is because of missing validation between the elements of the `values` argument and the shape of the sparse output. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41226",
      "specs": [
        "<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41227",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions the `ImmutableConst` operation in TensorFlow can be tricked into reading arbitrary memory contents. This is because the `tstring` TensorFlow string class has a special case for memory mapped strings but the operation itself does not offer any support for this datatype. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41227",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    },
    {
      "id": "pyup.io-tensorflow-lite:CVE-2021-41228",
      "advisory": "TensorFlow is an open source platform for machine learning. In affected versions TensorFlow's `saved_model_cli` tool is vulnerable to a code injection as it calls `eval` on user supplied strings. This can be used by attackers to run arbitrary code on the plaform where the CLI tool runs. However, given that the tool is always run manually, the impact of this is not severe. We have patched this by adding a `safe` flag which defaults to `True` and an explicit warning for users. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
      "cve": "CVE-2021-41228",
      "specs": [
        "==2.7.0-rc0",
        "==2.7.0-rc1",
        ">=2.4.0,<2.4.4",
        ">=2.5.0,<2.5.2",
        ">=2.6.0,<2.6.1"
      ]
    }
  ],
  "thefuck": [
    {
      "id": "pyup.io-thefuck:CVE-2021-34363",
      "advisory": "The thefuck (aka The Fuck) package before 3.31 for Python allows Path Traversal that leads to arbitrary file deletion via the \"undo archive operation\" feature.",
      "cve": "CVE-2021-34363",
      "specs": [
        "<3.31"
      ]
    }
  ],
  "thrift": [
    {
      "id": "pyup.io-thrift:CVE-2015-3254",
      "advisory": "The client libraries in Apache Thrift before 0.9.3 might allow remote authenticated users to cause a denial of service (infinite recursion) via vectors involving the skip function.",
      "cve": "CVE-2015-3254",
      "specs": [
        "<=0.9.2"
      ]
    },
    {
      "id": "pyup.io-thrift:CVE-2016-5397",
      "advisory": "The Apache Thrift Go client library exposed the potential during code generation for command injection due to using an external formatting tool. Affected Apache Thrift 0.9.3 and older, Fixed in Apache Thrift 0.10.0.",
      "cve": "CVE-2016-5397",
      "specs": [
        "<=0.9.3"
      ]
    },
    {
      "id": "pyup.io-thrift:CVE-2018-11798",
      "advisory": "The Apache Thrift Node.js static web server in versions 0.9.2 through 0.11.0 have been determined to contain a security vulnerability in which a remote user has the ability to access files outside the set webservers docroot path.",
      "cve": "CVE-2018-11798",
      "specs": [
        ">=0.9.2,<=0.11.0"
      ]
    },
    {
      "id": "pyup.io-thrift:CVE-2018-1320",
      "advisory": "Apache Thrift Java client library versions 0.5.0 through 0.11.0 can bypass SASL negotiation isComplete validation in the org.apache.thrift.transport.TSaslTransport class. An assert used to determine if the SASL handshake had successfully completed could be disabled in production settings making the validation incomplete.",
      "cve": "CVE-2018-1320",
      "specs": [
        ">=0.5.0,<=0.11.0"
      ]
    },
    {
      "id": "pyup.io-thrift:CVE-2019-0205",
      "advisory": "In Apache Thrift all versions up to and including 0.12.0, a server or client may run into an endless loop when feed with specific input data. Because the issue had already been partially fixed in version 0.11.0, depending on the installed version it affects only certain language bindings.",
      "cve": "CVE-2019-0205",
      "specs": [
        "<=0.12.0"
      ]
    },
    {
      "id": "pyup.io-thrift:CVE-2019-0210",
      "advisory": "In Apache Thrift 0.9.3 to 0.12.0, a server implemented in Go using TJSONProtocol or TSimpleJSONProtocol may panic when feed with invalid input data.",
      "cve": "CVE-2019-0210",
      "specs": [
        ">=0.9.3,<=0.12.0"
      ]
    },
    {
      "id": "pyup.io-thrift:CVE-2020-13949",
      "advisory": "In Apache Thrift 0.9.3 to 0.13.0, malicious RPC clients could send short messages which would result in a large memory allocation, potentially leading to denial of service.",
      "cve": "CVE-2020-13949",
      "specs": [
        ">=0.9.3,<=0.13.0"
      ]
    }
  ],
  "tlslite": [
    {
      "id": "pyup.io-tlslite:CVE-2015-3220",
      "advisory": "The tlslite library before 0.4.9 for Python allows remote attackers to trigger a denial of service (runtime exception and process crash).",
      "cve": "CVE-2015-3220",
      "specs": [
        "<=0.4.9"
      ]
    }
  ],
  "tlslite-ng": [
    {
      "id": "pyup.io-tlslite-ng:CVE-2018-1000159",
      "advisory": "tlslite-ng version 0.7.3 and earlier, since commit d7b288316bca7bcdd082e6ccff5491e241305233 contains a CWE-354: Improper Validation of Integrity Check Value vulnerability in TLS implementation, tlslite/utils/constanttime.py: ct_check_cbc_mac_and_pad(); line \"end_pos = data_len - 1 - mac.digest_size\" that can result in an attacker manipulating the TLS ciphertext which will not be detected by receiving tlslite-ng. This attack appears to be exploitable via man in the middle on a network connection. This vulnerability appears to have been fixed after commit 3674815d1b0f7484454995e2737a352e0a6a93d8.",
      "cve": "CVE-2018-1000159",
      "specs": [
        "<=0.7.3"
      ]
    },
    {
      "id": "pyup.io-tlslite-ng:CVE-2020-26263",
      "advisory": "tlslite-ng is an open source python library that implements SSL and TLS cryptographic protocols. In tlslite-ng before versions 0.7.6 and 0.8.0-alpha39, the code that performs decryption and padding check in RSA PKCS#1 v1.5 decryption is data dependant. In particular, the code has multiple ways in which it leaks information about the decrypted ciphertext. It aborts as soon as the plaintext doesn't start with 0x00, 0x02. All TLS servers that enable RSA key exchange as well as applications that use the RSA decryption API directly are vulnerable. This is patched in versions 0.7.6 and 0.8.0-alpha39. Note: the patches depend on Python processing the individual bytes in side-channel free manner, this is known to not the case (see reference). As such, users that require side-channel resistance are recommended to use different TLS implementations, as stated in the security policy of tlslite-ng.",
      "cve": "CVE-2020-26263",
      "specs": [
        "<0.7.6",
        "==0.8.0-alpha1",
        "==0.8.0-alpha10",
        "==0.8.0-alpha11",
        "==0.8.0-alpha12",
        "==0.8.0-alpha13",
        "==0.8.0-alpha14",
        "==0.8.0-alpha15",
        "==0.8.0-alpha16",
        "==0.8.0-alpha17",
        "==0.8.0-alpha18",
        "==0.8.0-alpha19",
        "==0.8.0-alpha2",
        "==0.8.0-alpha20",
        "==0.8.0-alpha21",
        "==0.8.0-alpha22",
        "==0.8.0-alpha23",
        "==0.8.0-alpha24",
        "==0.8.0-alpha25",
        "==0.8.0-alpha26",
        "==0.8.0-alpha27",
        "==0.8.0-alpha28",
        "==0.8.0-alpha29",
        "==0.8.0-alpha3",
        "==0.8.0-alpha30",
        "==0.8.0-alpha31",
        "==0.8.0-alpha32",
        "==0.8.0-alpha33",
        "==0.8.0-alpha34",
        "==0.8.0-alpha35",
        "==0.8.0-alpha36",
        "==0.8.0-alpha37",
        "==0.8.0-alpha38",
        "==0.8.0-alpha4",
        "==0.8.0-alpha5",
        "==0.8.0-alpha6",
        "==0.8.0-alpha7",
        "==0.8.0-alpha8",
        "==0.8.0-alpha9"
      ]
    }
  ],
  "tornado": [
    {
      "id": "pyup.io-tornado:CVE-2012-2374",
      "advisory": "CRLF injection vulnerability in the tornado.web.RequestHandler.set_header function in Tornado before 2.2.1 allows remote attackers to inject arbitrary HTTP headers and conduct HTTP response splitting attacks via crafted input.",
      "cve": "CVE-2012-2374",
      "specs": [
        "<=2.2",
        "==1.0",
        "==1.0.1",
        "==1.1",
        "==1.1.1",
        "==1.2",
        "==1.2.1",
        "==2.0",
        "==2.1",
        "==2.1.1"
      ]
    },
    {
      "id": "pyup.io-tornado:CVE-2014-9720",
      "advisory": "Tornado before 3.2.2 sends arbitrary responses that contain a fixed CSRF token and may be sent with HTTP compression, which makes it easier for remote attackers to conduct a BREACH attack and determine this token via a series of crafted requests.",
      "cve": "CVE-2014-9720",
      "specs": [
        "<3.2.2"
      ]
    }
  ],
  "tortoise-orm": [
    {
      "id": "pyup.io-tortoise-orm:CVE-2020-11010",
      "advisory": "In Tortoise ORM before versions 0.15.23 and 0.16.6, various forms of SQL injection have been found for MySQL and when filtering or doing mass-updates on char/text fields. SQLite & PostgreSQL are only affected when filtering with contains, starts_with, or ends_with filters (and their case-insensitive counterparts).",
      "cve": "CVE-2020-11010",
      "specs": [
        "<0.15.23",
        ">=0.16.0,<0.16.6"
      ]
    }
  ],
  "tqdm": [
    {
      "id": "pyup.io-tqdm:CVE-2016-10075",
      "advisory": "The tqdm._version module in tqdm versions 4.4.1 and 4.10 allows local users to execute arbitrary code via a crafted repo with a malicious git log in the current working directory.",
      "cve": "CVE-2016-10075",
      "specs": [
        "==4.10",
        "==4.4.1"
      ]
    }
  ],
  "tripleo-heat-templates": [
    {
      "id": "pyup.io-tripleo-heat-templates:CVE-2018-10898",
      "advisory": "A vulnerability was found in openstack-tripleo-heat-templates before version 8.0.2-40. When deployed using Director using default configuration, Opendaylight in RHOSP13 is configured with easily guessable default credentials.",
      "cve": "CVE-2018-10898",
      "specs": [
        "<8.0.2-40"
      ]
    }
  ],
  "tryton": [
    {
      "id": "pyup.io-tryton:CVE-2013-4510",
      "advisory": "Directory traversal vulnerability in the client in Tryton 3.0.0, as distributed before 20131104 and earlier, allows remote servers to write arbitrary files via path separators in the extension of a report.",
      "cve": "CVE-2013-4510",
      "specs": [
        "==3.0.0"
      ]
    },
    {
      "id": "pyup.io-tryton:CVE-2014-6633",
      "advisory": "The safe_eval function in trytond in Tryton before 2.4.15, 2.6.x before 2.6.14, 2.8.x before 2.8.11, 3.0.x before 3.0.7, and 3.2.x before 3.2.3 allows remote authenticated users to execute arbitrary commands via shell metacharacters in (1) the collection.domain in the webdav module or (2) the formula field in the price_list module.",
      "cve": "CVE-2014-6633",
      "specs": [
        ">=2.4.0,<2.4.15",
        ">=2.6.0,<2.6.14",
        ">=2.8.0,<2.8.11",
        ">=3.0.0,<3.0.7",
        ">=3.2.0,<3.2.3"
      ]
    },
    {
      "id": "pyup.io-tryton:CVE-2016-1241",
      "advisory": "Tryton 3.x before 3.2.17, 3.4.x before 3.4.14, 3.6.x before 3.6.12, 3.8.x before 3.8.8, and 4.x before 4.0.4 allow remote authenticated users to discover user password hashes via unspecified vectors.",
      "cve": "CVE-2016-1241",
      "specs": [
        "<=3.2.16",
        "==3.2.0",
        "==3.4.0",
        "==3.4.1",
        "==3.4.10",
        "==3.4.11",
        "==3.4.12",
        "==3.4.13",
        "==3.4.2",
        "==3.4.3",
        "==3.4.4",
        "==3.4.5",
        "==3.4.6",
        "==3.4.7",
        "==3.4.8",
        "==3.4.9",
        "==3.6.0",
        "==3.6.1",
        "==3.6.10",
        "==3.6.11",
        "==3.6.2",
        "==3.6.3",
        "==3.6.4",
        "==3.6.5",
        "==3.6.6",
        "==3.6.7",
        "==3.6.8",
        "==3.6.9",
        "==3.8.0",
        "==3.8.1",
        "==3.8.2",
        "==3.8.3",
        "==3.8.4",
        "==3.8.5",
        "==3.8.6",
        "==3.8.7",
        "==4.0.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3"
      ]
    },
    {
      "id": "pyup.io-tryton:CVE-2016-1242",
      "advisory": "file_open in Tryton before 3.2.17, 3.4.x before 3.4.14, 3.6.x before 3.6.12, 3.8.x before 3.8.8, and 4.x before 4.0.4 allows remote authenticated users with certain permissions to read arbitrary files via the name parameter or unspecified other vectors.",
      "cve": "CVE-2016-1242",
      "specs": [
        "<=3.2.16",
        "==3.2.0",
        "==3.4.0",
        "==3.4.1",
        "==3.4.10",
        "==3.4.11",
        "==3.4.12",
        "==3.4.13",
        "==3.4.2",
        "==3.4.3",
        "==3.4.4",
        "==3.4.5",
        "==3.4.6",
        "==3.4.7",
        "==3.4.8",
        "==3.4.9",
        "==3.6.0",
        "==3.6.1",
        "==3.6.10",
        "==3.6.11",
        "==3.6.2",
        "==3.6.3",
        "==3.6.4",
        "==3.6.5",
        "==3.6.6",
        "==3.6.7",
        "==3.6.8",
        "==3.6.9",
        "==3.8.0",
        "==3.8.1",
        "==3.8.2",
        "==3.8.3",
        "==3.8.4",
        "==3.8.5",
        "==3.8.6",
        "==3.8.7",
        "==4.0.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3"
      ]
    },
    {
      "id": "pyup.io-tryton:CVE-2017-0360",
      "advisory": "file_open in Tryton 3.x and 4.x through 4.2.2 allows remote authenticated users with certain permissions to read arbitrary files via a \"same root name but with a suffix\" attack. NOTE: This vulnerability exists because of an incomplete fix for CVE-2016-1242.",
      "cve": "CVE-2017-0360",
      "specs": [
        "==3.0.0",
        "==3.0.1",
        "==3.0.10",
        "==3.0.11",
        "==3.0.12",
        "==3.0.13",
        "==3.0.14",
        "==3.0.15",
        "==3.0.16",
        "==3.0.17",
        "==3.0.2",
        "==3.0.3",
        "==3.0.4",
        "==3.0.5",
        "==3.0.6",
        "==3.0.7",
        "==3.0.8",
        "==3.0.9",
        "==3.2.0",
        "==3.2.1",
        "==3.2.10",
        "==3.2.11",
        "==3.2.12",
        "==3.2.13",
        "==3.2.14",
        "==3.2.15",
        "==3.2.16",
        "==3.2.17",
        "==3.2.2",
        "==3.2.3",
        "==3.2.4",
        "==3.2.5",
        "==3.2.6",
        "==3.2.7",
        "==3.2.8",
        "==3.2.9",
        "==3.4.0",
        "==3.4.1",
        "==3.4.10",
        "==3.4.11",
        "==3.4.12",
        "==3.4.13",
        "==3.4.14",
        "==3.4.15",
        "==3.4.16",
        "==3.4.17",
        "==3.4.2",
        "==3.4.3",
        "==3.4.4",
        "==3.4.5",
        "==3.4.6",
        "==3.4.7",
        "==3.4.8",
        "==3.4.9",
        "==3.6.0",
        "==3.6.1",
        "==3.6.10",
        "==3.6.11",
        "==3.6.12",
        "==3.6.13",
        "==3.6.14",
        "==3.6.15",
        "==3.6.16",
        "==3.6.2",
        "==3.6.3",
        "==3.6.4",
        "==3.6.5",
        "==3.6.6",
        "==3.6.7",
        "==3.6.8",
        "==3.6.9",
        "==3.8.0",
        "==3.8.1",
        "==3.8.10",
        "==3.8.11",
        "==3.8.12",
        "==3.8.13",
        "==3.8.14",
        "==3.8.2",
        "==3.8.3",
        "==3.8.4",
        "==3.8.5",
        "==3.8.6",
        "==3.8.7",
        "==3.8.8",
        "==3.8.9",
        "==4.0.0",
        "==4.0.1",
        "==4.0.2",
        "==4.0.3",
        "==4.0.4",
        "==4.0.5",
        "==4.0.6",
        "==4.0.7",
        "==4.0.8",
        "==4.0.9",
        "==4.2.0",
        "==4.2.1",
        "==4.2.2"
      ]
    },
    {
      "id": "pyup.io-tryton:CVE-2018-19443",
      "advisory": "The client in Tryton 5.x before 5.0.1 tries to make a connection to the bus in cleartext instead of encrypted under certain circumstances in bus.py and jsonrpc.py. This connection attempt fails, but it contains in the header the current session of the user. This session could then be stolen by a man-in-the-middle.",
      "cve": "CVE-2018-19443",
      "specs": [
        "==5.0.0"
      ]
    }
  ],
  "trytond": [
    {
      "id": "pyup.io-trytond:CVE-2012-0215",
      "advisory": "model/modelstorage.py in the Tryton application framework (trytond) before 2.4.0 for Python does not properly restrict access to the Many2Many field in the relation model, which allows remote authenticated users to modify the privileges of arbitrary users via a (1) create, (2) write, (3) delete, or (4) copy rpc call.",
      "cve": "CVE-2012-0215",
      "specs": [
        "<=2.2.3",
        "==1.4.13",
        "==1.6.8",
        "==1.8.7",
        "==2.0.5"
      ]
    },
    {
      "id": "pyup.io-trytond:CVE-2012-2238",
      "advisory": "trytond 2.4: ModelView.button fails to validate authorization",
      "cve": "CVE-2012-2238",
      "specs": [
        ">=2.4.0,<2.4.2"
      ]
    },
    {
      "id": "pyup.io-trytond:CVE-2015-0861",
      "advisory": "model/modelstorage.py in trytond 3.2.x before 3.2.10, 3.4.x before 3.4.8, 3.6.x before 3.6.5, and 3.8.x before 3.8.1 allows remote authenticated users to bypass intended access restrictions and write to arbitrary fields via a sequence of records.",
      "cve": "CVE-2015-0861",
      "specs": [
        ">=3.2.0,<3.2.10",
        ">=3.4.0,<3.4.8",
        ">=3.6.0,<3.6.5",
        ">=3.8.0,<3.8.1"
      ]
    },
    {
      "id": "pyup.io-trytond:CVE-2019-10868",
      "advisory": "In trytond/model/modelstorage.py in Tryton 4.2 before 4.2.21, 4.4 before 4.4.19, 4.6 before 4.6.14, 4.8 before 4.8.10, and 5.0 before 5.0.6, an authenticated user can order records based on a field for which he has no access right. This may allow the user to guess values.",
      "cve": "CVE-2019-10868",
      "specs": [
        ">=4.2.0,<4.2.21",
        ">=4.4.0,<4.4.19",
        ">=4.6.0,<4.6.14",
        ">=4.8.0,<4.8.10",
        ">=5.0.0,<5.0.6"
      ]
    }
  ],
  "tuf": [
    {
      "id": "pyup.io-tuf:CVE-2020-15163",
      "advisory": "Python TUF (The Update Framework) reference implementation before version 0.12 it will incorrectly trust a previously downloaded root metadata file which failed verification at download time. This allows an attacker who is able to serve multiple new versions of root metadata (i.e. by a person-in-the-middle attack) culminating in a version which has not been correctly signed to control the trust chain for future updates. This is fixed in version 0.12 and newer.",
      "cve": "CVE-2020-15163",
      "specs": [
        "<0.12.0"
      ]
    },
    {
      "id": "pyup.io-tuf:CVE-2020-6173",
      "advisory": "TUF (aka The Update Framework) 0.7.2 through 0.12.1 allows Uncontrolled Resource Consumption.",
      "cve": "CVE-2020-6173",
      "specs": [
        ">=0.7.2,<=0.12.1"
      ]
    },
    {
      "id": "pyup.io-tuf:CVE-2020-6174",
      "advisory": "TUF (aka The Update Framework) through 0.12.1 has Improper Verification of a Cryptographic Signature.",
      "cve": "CVE-2020-6174",
      "specs": [
        "<=0.12.1"
      ]
    },
    {
      "id": "pyup.io-tuf:CVE-2021-41131",
      "advisory": "python-tuf is a Python reference implementation of The Update Framework (TUF). In both clients (`tuf/client` and `tuf/ngclient`), there is a path traversal vulnerability that in the worst case can overwrite files ending in `.json` anywhere on the client system on a call to `get_one_valid_targetinfo()`. It occurs because the rolename is used to form the filename, and may contain path traversal characters (ie `../../name.json`). The impact is mitigated by a few facts: It only affects implementations that allow arbitrary rolename selection for delegated targets metadata, The attack requires the ability to A) insert new metadata for the path-traversing role and B) get the role delegated by an existing targets metadata, The written file content is heavily restricted since it needs to be a valid, signed targets file. The file extension is always .json. A fix is available in version 0.19 or newer. There are no workarounds that do not require code changes. Clients can restrict the allowed character set for rolenames, or they can store metadata in files named in a way that is not vulnerable: neither of these approaches is possible without modifying python-tuf.",
      "cve": "CVE-2021-41131",
      "specs": [
        "<=0.18.1"
      ]
    }
  ],
  "twisted": [
    {
      "id": "pyup.io-twisted:CVE-2014-7143",
      "advisory": "Python Twisted 14.0 trustRoot is not respected in HTTP client",
      "cve": "CVE-2014-7143",
      "specs": [
        "==14.0.0"
      ]
    },
    {
      "id": "pyup.io-twisted:CVE-2016-1000111",
      "advisory": "Twisted before 16.3.1 does not attempt to address RFC 3875 section 4.1.18 namespace conflicts and therefore does not protect CGI applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect a CGI application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "cve": "CVE-2016-1000111",
      "specs": [
        "<16.3.1"
      ]
    },
    {
      "id": "pyup.io-twisted:CVE-2019-12387",
      "advisory": "In Twisted before 19.2.1, twisted.web did not validate or sanitize URIs or HTTP methods, allowing an attacker to inject invalid characters such as CRLF.",
      "cve": "CVE-2019-12387",
      "specs": [
        "<19.2.1"
      ]
    },
    {
      "id": "pyup.io-twisted:CVE-2019-12855",
      "advisory": "In words.protocols.jabber.xmlstream in Twisted through 19.2.1, XMPP support did not verify certificates when used with TLS, allowing an attacker to MITM connections.",
      "cve": "CVE-2019-12855",
      "specs": [
        "<=19.2.1"
      ]
    },
    {
      "id": "pyup.io-twisted:CVE-2020-10108",
      "advisory": "In Twisted Web through 19.10.0, there was an HTTP request splitting vulnerability. When presented with two content-length headers, it ignored the first header. When the second content-length value was set to zero, the request body was interpreted as a pipelined request.",
      "cve": "CVE-2020-10108",
      "specs": [
        "<=19.10.0"
      ]
    },
    {
      "id": "pyup.io-twisted:CVE-2020-10109",
      "advisory": "In Twisted Web through 19.10.0, there was an HTTP request splitting vulnerability. When presented with a content-length and a chunked encoding header, the content-length took precedence and the remainder of the request body was interpreted as a pipelined request.",
      "cve": "CVE-2020-10109",
      "specs": [
        "<=19.10.0"
      ]
    }
  ],
  "typed-ast": [
    {
      "id": "pyup.io-typed-ast:CVE-2019-19274",
      "advisory": "typed_ast 1.3.0 and 1.3.1 has a handle_keywordonly_args out-of-bounds read. An attacker with the ability to cause a Python interpreter to parse Python source (but not necessarily execute it) may be able to crash the interpreter process. This could be a concern, for example, in a web-based service that parses (but does not execute) Python code. (This issue also affected certain Python 3.8.0-alpha prereleases.)",
      "cve": "CVE-2019-19274",
      "specs": [
        "==1.3.0",
        "==1.3.1"
      ]
    },
    {
      "id": "pyup.io-typed-ast:CVE-2019-19275",
      "advisory": "typed_ast 1.3.0 and 1.3.1 has an ast_for_arguments out-of-bounds read. An attacker with the ability to cause a Python interpreter to parse Python source (but not necessarily execute it) may be able to crash the interpreter process. This could be a concern, for example, in a web-based service that parses (but does not execute) Python code. (This issue also affected certain Python 3.8.0-alpha prereleases.)",
      "cve": "CVE-2019-19275",
      "specs": [
        "==1.3.0",
        "==1.3.1"
      ]
    }
  ],
  "unoconv": [
    {
      "id": "pyup.io-unoconv:CVE-2019-17400",
      "advisory": "The unoconv package before 0.9 mishandles untrusted pathnames, leading to SSRF and local file inclusion.",
      "cve": "CVE-2019-17400",
      "specs": [
        "<0.9"
      ]
    }
  ],
  "urllib3": [
    {
      "id": "pyup.io-urllib3:CVE-2016-9015",
      "advisory": "Versions 1.17 and 1.18 of the Python urllib3 library suffer from a vulnerability that can cause them, in certain configurations, to not correctly validate TLS certificates. This places users of the library with those configurations at risk of man-in-the-middle and information leakage attacks. This vulnerability affects users using versions 1.17 and 1.18 of the urllib3 library, who are using the optional PyOpenSSL support for TLS instead of the regular standard library TLS backend, and who are using OpenSSL 1.1.0 via PyOpenSSL. This is an extremely uncommon configuration, so the security impact of this vulnerability is low.",
      "cve": "CVE-2016-9015",
      "specs": [
        "==1.17",
        "==1.18"
      ]
    },
    {
      "id": "pyup.io-urllib3:CVE-2018-20060",
      "advisory": "urllib3 before version 1.23 does not remove the Authorization HTTP header when following a cross-origin redirect (i.e., a redirect that differs in host, port, or scheme). This can allow for credentials in the Authorization header to be exposed to unintended hosts or transmitted in cleartext.",
      "cve": "CVE-2018-20060",
      "specs": [
        "<1.23"
      ]
    },
    {
      "id": "pyup.io-urllib3:CVE-2019-11236",
      "advisory": "In the urllib3 library through 1.24.1 for Python, CRLF injection is possible if the attacker controls the request parameter.",
      "cve": "CVE-2019-11236",
      "specs": [
        "<=1.24.2"
      ]
    },
    {
      "id": "pyup.io-urllib3:CVE-2019-11324",
      "advisory": "The urllib3 library before 1.24.2 for Python mishandles certain cases where the desired set of CA certificates is different from the OS store of CA certificates, which results in SSL connections succeeding in situations where a verification failure is the correct outcome. This is related to use of the ssl_context, ca_certs, or ca_certs_dir argument.",
      "cve": "CVE-2019-11324",
      "specs": [
        "<1.24.2"
      ]
    },
    {
      "id": "pyup.io-urllib3:CVE-2020-26137",
      "advisory": "urllib3 before 1.25.9 allows CRLF injection if the attacker controls the HTTP request method, as demonstrated by inserting CR and LF control characters in the first argument of putrequest(). NOTE: this is similar to CVE-2020-26116.",
      "cve": "CVE-2020-26137",
      "specs": [
        "<1.25.9"
      ]
    },
    {
      "id": "pyup.io-urllib3:CVE-2020-7212",
      "advisory": "The _encode_invalid_chars function in util/url.py in the urllib3 library 1.25.2 through 1.25.7 for Python allows a denial of service (CPU consumption) because of an inefficient algorithm. The percent_encodings array contains all matches of percent encodings. It is not deduplicated. For a URL of length N, the size of percent_encodings may be up to O(N). The next step (normalize existing percent-encoded bytes) also takes up to O(N) for each step, so the total time is O(N^2). If percent_encodings were deduplicated, the time to compute _encode_invalid_chars would be O(kN), where k is at most 484 ((10+6*2)^2).",
      "cve": "CVE-2020-7212",
      "specs": [
        ">=1.25.2,<=1.25.7"
      ]
    },
    {
      "id": "pyup.io-urllib3:CVE-2021-28363",
      "advisory": "The urllib3 library 1.26.x before 1.26.4 for Python omits SSL certificate validation in some cases involving HTTPS to HTTPS proxies. The initial connection to the HTTPS proxy (if an SSLContext isn't given via proxy_config) doesn't verify the hostname of the certificate. This means certificates for different servers that still validate properly with the default urllib3 SSLContext will be silently accepted.",
      "cve": "CVE-2021-28363",
      "specs": [
        ">=1.26.0,<1.26.4"
      ]
    },
    {
      "id": "pyup.io-urllib3:CVE-2021-33503",
      "advisory": "An issue was discovered in urllib3 before 1.26.5. When provided with a URL containing many @ characters in the authority component, the authority regular expression exhibits catastrophic backtracking, causing a denial of service if a URL were passed as a parameter or redirected to via an HTTP redirect.",
      "cve": "CVE-2021-33503",
      "specs": [
        "<1.26.5"
      ]
    }
  ],
  "validators": [
    {
      "id": "pyup.io-validators:CVE-2019-19588",
      "advisory": "The validators package 0.12.2 through 0.12.5 for Python enters an infinite loop when validators.domain is called with a crafted domain string. This is fixed in 0.12.6.",
      "cve": "CVE-2019-19588",
      "specs": [
        ">=0.12.2,<=0.12.5"
      ]
    }
  ],
  "virtualenv": [
    {
      "id": "pyup.io-virtualenv:CVE-2011-4617",
      "advisory": "virtualenv.py in virtualenv before 1.5 allows local users to overwrite arbitrary files via a symlink attack on a certain file in /tmp/.",
      "cve": "CVE-2011-4617",
      "specs": [
        "<=1.4.9",
        "==0.8",
        "==0.8.1",
        "==0.8.2",
        "==0.8.3",
        "==0.8.4",
        "==0.9",
        "==0.9.1",
        "==0.9.2",
        "==1.0",
        "==1.1",
        "==1.1.1",
        "==1.2",
        "==1.3",
        "==1.3.1",
        "==1.3.2",
        "==1.3.3",
        "==1.3.4",
        "==1.4",
        "==1.4.1",
        "==1.4.2",
        "==1.4.3",
        "==1.4.4",
        "==1.4.5",
        "==1.4.6",
        "==1.4.7",
        "==1.4.8"
      ]
    }
  ],
  "vyper": [
    {
      "id": "pyup.io-vyper:CVE-2021-41121",
      "advisory": "Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.",
      "cve": "CVE-2021-41121",
      "specs": [
        "<0.3.0"
      ]
    },
    {
      "id": "pyup.io-vyper:CVE-2021-41122",
      "advisory": "Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.",
      "cve": "CVE-2021-41122",
      "specs": [
        "<0.3.0"
      ]
    }
  ],
  "wagtail": [
    {
      "id": "pyup.io-wagtail:CVE-2020-11001",
      "advisory": "In Wagtail before versions 2.8.1 and 2.7.2, a cross-site scripting (XSS) vulnerability exists on the page revision comparison view within the Wagtail admin interface. A user with a limited-permission editor account for the Wagtail admin could potentially craft a page revision history that, when viewed by a user with higher privileges, could perform actions with that user's credentials. The vulnerability is not exploitable by an ordinary site visitor without access to the Wagtail admin. Patched versions have been released as Wagtail 2.7.2 (for the LTS 2.7 branch) and Wagtail 2.8.1 (for the current 2.8 branch).",
      "cve": "CVE-2020-11001",
      "specs": [
        "==2.8",
        ">=1.9,<=2.7.1"
      ]
    },
    {
      "id": "pyup.io-wagtail:CVE-2020-11037",
      "advisory": "In Wagtail before versions 2.7.2 and 2.8.2, a potential timing attack exists on pages or documents that have been protected with a shared password through Wagtail's \"Privacy\" controls. This password check is performed through a character-by-character string comparison, and so an attacker who is able to measure the time taken by this check to a high degree of accuracy could potentially use timing differences to gain knowledge of the password. This is understood to be feasible on a local network, but not on the public internet. Privacy settings that restrict access to pages/documents on a per-user or per-group basis (as opposed to a shared password) are unaffected by this vulnerability. This has been patched in 2.7.3, 2.8.2, 2.9.",
      "cve": "CVE-2020-11037",
      "specs": [
        ">=2.7,<2.7.3",
        ">=2.8,<2.8.2"
      ]
    },
    {
      "id": "pyup.io-wagtail:CVE-2020-15118",
      "advisory": "In Wagtail before versions 2.7.4 and 2.9.3, when a form page type is made available to Wagtail editors through the `wagtail.contrib.forms` app, and the page template is built using Django's standard form rendering helpers such as form.as_p, any HTML tags used within a form field's help text will be rendered unescaped in the page. Allowing HTML within help text is an intentional design decision by Django; however, as a matter of policy Wagtail does not allow editors to insert arbitrary HTML by default, as this could potentially be used to carry out cross-site scripting attacks, including privilege escalation. This functionality should therefore not have been made available to editor-level users. The vulnerability is not exploitable by an ordinary site visitor without access to the Wagtail admin. Patched versions have been released as Wagtail 2.7.4 (for the LTS 2.7 branch) and Wagtail 2.9.3 (for the current 2.9 branch). In these versions, help text will be escaped to prevent the inclusion of HTML tags. Site owners who wish to re-enable the use of HTML within help text (and are willing to accept the risk of this being exploited by editors) may set WAGTAILFORMS_HELP_TEXT_ALLOW_HTML = True in their configuration settings. Site owners who are unable to upgrade to the new versions can secure their form page templates by rendering forms field-by-field as per Django's documentation, but omitting the |safe filter when outputting the help text.",
      "cve": "CVE-2020-15118",
      "specs": [
        ">=2.7,<2.7.4",
        ">=2.9,<2.9.3"
      ]
    },
    {
      "id": "pyup.io-wagtail:CVE-2021-29434",
      "advisory": "Wagtail is a Django content management system. In affected versions of Wagtail, when saving the contents of a rich text field in the admin interface, Wagtail does not apply server-side checks to ensure that link URLs use a valid protocol. A malicious user with access to the admin interface could thus craft a POST request to publish content with `javascript:` URLs containing arbitrary code. The vulnerability is not exploitable by an ordinary site visitor without access to the Wagtail admin. See referenced GitHub advisory for additional details, including a workaround. Patched versions have been released as Wagtail 2.11.7 (for the LTS 2.11 branch) and Wagtail 2.12.4 (for the current 2.12 branch).",
      "cve": "CVE-2021-29434",
      "specs": [
        "<2.11.6",
        ">=2.11.0,<2.11.7",
        ">=2.12.0,<2.12.4"
      ]
    },
    {
      "id": "pyup.io-wagtail:CVE-2021-32681",
      "advisory": "Wagtail is an open source content management system built on Django. A cross-site scripting vulnerability exists in versions 2.13-2.13.1, versions 2.12-2.12.4, and versions prior to 2.11.8. When the `{% include_block %}` template tag is used to output the value of a plain-text StreamField block (`CharBlock`, `TextBlock` or a similar user-defined block derived from `FieldBlock`), and that block does not specify a template for rendering, the tag output is not properly escaped as HTML. This could allow users to insert arbitrary HTML or scripting. This vulnerability is only exploitable by users with the ability to author StreamField content (i.e. users with 'editor' access to the Wagtail admin). Patched versions have been released as Wagtail 2.11.8 (for the LTS 2.11 branch), Wagtail 2.12.5, and Wagtail 2.13.2 (for the current 2.13 branch). As a workaround, site implementors who are unable to upgrade to a current supported version should audit their use of `{% include_block %}` to ensure it is not used to output `CharBlock` / `TextBlock` values with no associated template. Note that this only applies where `{% include_block %}` is used directly on that block (uses of `include_block` on a block _containing_ a CharBlock / TextBlock, such as a StructBlock, are unaffected). In these cases, the tag can be replaced with Django's `{{ ... }}` syntax - e.g. `{% include_block my_title_block %}` becomes `{{ my_title_block }}`.",
      "cve": "CVE-2021-32681",
      "specs": [
        "<2.11.8",
        ">=2.12,<=2.12.4",
        ">=2.13,<=2.13.1"
      ]
    }
  ],
  "wagtail-2fa": [
    {
      "id": "pyup.io-wagtail-2fa:CVE-2019-16766",
      "advisory": "When using wagtail-2fa before 1.3.0, if someone gains access to someone's Wagtail login credentials, they can log into the CMS and bypass the 2FA check by changing the URL. They can then add a new device and gain full access to the CMS. This problem has been patched in version 1.3.0.",
      "cve": "CVE-2019-16766",
      "specs": [
        "<1.3.0"
      ]
    },
    {
      "id": "pyup.io-wagtail-2fa:CVE-2020-5240",
      "advisory": "In wagtail-2fa before 1.4.1, any user with access to the CMS can view and delete other users 2FA devices by going to the correct path. The user does not require special permissions in order to do so. By deleting the other users device they can disable the target users 2FA devices and potentially compromise the account if they figure out their password. The problem has been patched in version 1.4.1.",
      "cve": "CVE-2020-5240",
      "specs": [
        "<1.4.1"
      ]
    }
  ],
  "waitress": [
    {
      "id": "pyup.io-waitress:CVE-2019-16785",
      "advisory": "Waitress through version 1.3.1 implemented a \"MAY\" part of the RFC7230 which states: \"Although the line terminator for the start-line and header fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.\" Unfortunately if a front-end server does not parse header fields with an LF the same way as it does those with a CRLF it can lead to the front-end and the back-end server parsing the same HTTP message in two different ways. This can lead to a potential for HTTP request smuggling/splitting whereby Waitress may see two requests while the front-end server only sees a single HTTP message. This issue is fixed in Waitress 1.4.0.",
      "cve": "CVE-2019-16785",
      "specs": [
        "<=1.3.1"
      ]
    },
    {
      "id": "pyup.io-waitress:CVE-2019-16786",
      "advisory": "Waitress through version 1.3.1 would parse the Transfer-Encoding header and only look for a single string value, if that value was not chunked it would fall through and use the Content-Length header instead. According to the HTTP standard Transfer-Encoding should be a comma separated list, with the inner-most encoding first, followed by any further transfer codings, ending with chunked. Requests sent with: \"Transfer-Encoding: gzip, chunked\" would incorrectly get ignored, and the request would use a Content-Length header instead to determine the body size of the HTTP message. This could allow for Waitress to treat a single request as multiple requests in the case of HTTP pipelining. This issue is fixed in Waitress 1.4.0.",
      "cve": "CVE-2019-16786",
      "specs": [
        "<1.3.1"
      ]
    },
    {
      "id": "pyup.io-waitress:CVE-2019-16789",
      "advisory": "In Waitress through version 1.4.0, if a proxy server is used in front of waitress, an invalid request may be sent by an attacker that bypasses the front-end and is parsed differently by waitress leading to a potential for HTTP request smuggling. Specially crafted requests containing special whitespace characters in the Transfer-Encoding header would get parsed by Waitress as being a chunked request, but a front-end server would use the Content-Length instead as the Transfer-Encoding header is considered invalid due to containing invalid characters. If a front-end server does HTTP pipelining to a backend Waitress server this could lead to HTTP request splitting which may lead to potential cache poisoning or unexpected information disclosure. This issue is fixed in Waitress 1.4.1 through more strict HTTP field validation.",
      "cve": "CVE-2019-16789",
      "specs": [
        "<=1.4.0"
      ]
    },
    {
      "id": "pyup.io-waitress:CVE-2019-16792",
      "advisory": "Waitress through version 1.3.1 allows request smuggling by sending the Content-Length header twice. Waitress would header fold a double Content-Length header and due to being unable to cast the now comma separated value to an integer would set the Content-Length to 0 internally. If two Content-Length headers are sent in a single request, Waitress would treat the request as having no body, thereby treating the body of the request as a new request in HTTP pipelining. This issue is fixed in Waitress 1.4.0.",
      "cve": "CVE-2019-16792",
      "specs": [
        "<=1.3.1"
      ]
    },
    {
      "id": "pyup.io-waitress:CVE-2020-5236",
      "advisory": "Waitress version 1.4.2 allows a DOS attack When waitress receives a header that contains invalid characters. When a header like \"Bad-header: xxxxxxxxxxxxxxx\\x10\" is received, it will cause the regular expression engine to catastrophically backtrack causing the process to use 100% CPU time and blocking any other interactions. This allows an attacker to send a single request with an invalid header and take the service offline. This issue was introduced in version 1.4.2 when the regular expression was updated to attempt to match the behaviour required by errata associated with RFC7230. The regular expression that is used to validate incoming headers has been updated in version 1.4.3, it is recommended that people upgrade to the new version of Waitress as soon as possible.",
      "cve": "CVE-2020-5236",
      "specs": [
        "==1.4.2"
      ]
    }
  ],
  "webargs": [
    {
      "id": "pyup.io-webargs:CVE-2019-9710",
      "advisory": "An issue was discovered in webargs before 5.1.3, as used with marshmallow and other products. JSON parsing uses a short-lived cache to store the parsed JSON body. This cache is not thread-safe, meaning that incorrect JSON payloads could have been parsed for concurrent requests.",
      "cve": "CVE-2019-9710",
      "specs": [
        "<5.1.3"
      ]
    },
    {
      "id": "pyup.io-webargs:CVE-2020-7965",
      "advisory": "flaskparser.py in Webargs 5.x through 5.5.2 doesn't check that the Content-Type header is application/json when receiving JSON input. If the request body is valid JSON, it will accept it even if the content type is application/x-www-form-urlencoded. This allows for JSON POST requests to be made across domains, leading to CSRF.",
      "cve": "CVE-2020-7965",
      "specs": [
        ">=5.0.0,<=5.5.2"
      ]
    }
  ],
  "websockets": [
    {
      "id": "pyup.io-websockets:CVE-2018-1000518",
      "advisory": "aaugustin websockets version 4 contains a CWE-409: Improper Handling of Highly Compressed Data (Data Amplification) vulnerability in Servers and clients, unless configured with compression=None that can result in Denial of Service by memory exhaustion. This attack appear to be exploitable via Sending a specially crafted frame on an established connection. This vulnerability appears to have been fixed in 5.",
      "cve": "CVE-2018-1000518",
      "specs": [
        "==4.0"
      ]
    },
    {
      "id": "pyup.io-websockets:CVE-2021-33880",
      "advisory": "The aaugustin websockets library before 9.1 for Python has an Observable Timing Discrepancy on servers when HTTP Basic Authentication is enabled with basic_auth_protocol_factory(credentials=...). An attacker may be able to guess a password via a timing attack.",
      "cve": "CVE-2021-33880",
      "specs": [
        "<9.1"
      ]
    }
  ],
  "werkzeug": [
    {
      "id": "pyup.io-werkzeug:CVE-2016-10516",
      "advisory": "Cross-site scripting (XSS) vulnerability in the render_full function in debug/tbtools.py in the debugger in Pallets Werkzeug before 0.11.11 (as used in Pallets Flask and other products) allows remote attackers to inject arbitrary web script or HTML via a field that contains an exception message.",
      "cve": "CVE-2016-10516",
      "specs": [
        "<0.11.11"
      ]
    },
    {
      "id": "pyup.io-werkzeug:CVE-2019-14806",
      "advisory": "Pallets Werkzeug before 0.15.3, when used with Docker, has insufficient debugger PIN randomness because Docker containers share the same machine id.",
      "cve": "CVE-2019-14806",
      "specs": [
        "<0.15.3"
      ]
    },
    {
      "id": "pyup.io-werkzeug:CVE-2020-28724",
      "advisory": "Open redirect vulnerability in werkzeug before 0.11.6 via a double slash in the URL.",
      "cve": "CVE-2020-28724",
      "specs": [
        "<0.11.6"
      ]
    }
  ],
  "xml2dict": [
    {
      "id": "pyup.io-xml2dict:CVE-2021-25951",
      "advisory": "XXE vulnerability in 'XML2Dict' version 0.2.2 allows an attacker to cause a denial of service.",
      "cve": "CVE-2021-25951",
      "specs": [
        "==0.2.2"
      ]
    }
  ],
  "xmpp-http-upload": [
    {
      "id": "pyup.io-xmpp-http-upload:CVE-2020-15239",
      "advisory": "In xmpp-http-upload before version 0.4.0, when the GET method is attacked, attackers can read files which have a `.data` suffix and which are accompanied by a JSON file with the `.meta` suffix. This can lead to Information Disclosure and in some shared-hosting scenarios also to circumvention of authentication or other limitations on the outbound (GET) traffic. For example, in a scenario where a single server has multiple instances of the application running (with separate DATA_ROOT settings), an attacker who has knowledge about the directory structure is able to read files from any other instance to which the process has read access. If instances have individual authentication (for example, HTTP authentication via a reverse proxy, source IP based filtering) or other restrictions (such as quotas), attackers may circumvent those limits in such a scenario by using the Directory Traversal to retrieve data from the other instances. If the associated XMPP server (or anyone knowing the SECRET_KEY) is malicious, they can write files outside the DATA_ROOT. The files which are written are constrained to have the `.meta` and the `.data` suffixes; the `.meta` file will contain the JSON with the Content-Type of the original request and the `.data` file will contain the payload. The issue is patched in version 0.4.0.",
      "cve": "CVE-2020-15239",
      "specs": [
        "<0.4.0"
      ]
    }
  ],
  "yamale": [
    {
      "id": "pyup.io-yamale:CVE-2021-38305",
      "advisory": "23andMe Yamale before 3.0.8 allows remote attackers to execute arbitrary code via a crafted schema file. The schema parser uses eval as part of its processing, and tries to protect from malicious expressions by limiting the builtins that are passed to the eval. When processing the schema, each line is run through Python's eval function to make the validator available. A well-constructed string within the schema rules can execute system commands; thus, by exploiting the vulnerability, an attacker can run arbitrary code on the image that invokes Yamale.",
      "cve": "CVE-2021-38305",
      "specs": [
        "<3.0.8"
      ]
    }
  ],
  "zodb": [
    {
      "id": "pyup.io-zodb:CVE-2009-0668",
      "advisory": "Unspecified vulnerability in Zope Object Database (ZODB) before 3.8.2, when certain Zope Enterprise Objects (ZEO) database sharing is enabled, allows remote attackers to execute arbitrary Python code via vectors involving the ZEO network protocol.",
      "cve": "CVE-2009-0668",
      "specs": [
        "<=3.8.1",
        "==2.10.9",
        "==2.11.4",
        "==2.8.11",
        "==2.9.11",
        "==3.1",
        "==3.1.1",
        "==3.2",
        "==3.2.4",
        "==3.3",
        "==3.3.3",
        "==3.4",
        "==3.4.1",
        "==3.5",
        "==3.6",
        "==3.7",
        "==3.8.0"
      ]
    },
    {
      "id": "pyup.io-zodb:CVE-2009-0669",
      "advisory": "Zope Object Database (ZODB) before 3.8.2, when certain Zope Enterprise Objects (ZEO) database sharing is enabled, allows remote attackers to bypass authentication via vectors involving the ZEO network protocol.",
      "cve": "CVE-2009-0669",
      "specs": [
        "<=3.8.1",
        "==3.8",
        "==3.8.0"
      ]
    },
    {
      "id": "pyup.io-zodb:CVE-2009-2701",
      "advisory": "Unspecified vulnerability in the Zope Enterprise Objects (ZEO) storage-server functionality in Zope Object Database (ZODB) 3.8 before 3.8.3 and 3.9.x before 3.9.0c2, when certain ZEO database sharing and blob support are enabled, allows remote authenticated users to read or delete arbitrary files via unknown vectors.",
      "cve": "CVE-2009-2701",
      "specs": [
        "==3.8",
        "==3.8.0",
        "==3.8.1",
        "==3.8.2",
        "==3.9.0",
        "==3.9.0b1",
        "==3.9.0b2",
        "==3.9.0b3",
        "==3.9.0b4",
        "==3.9.0b5",
        "==3.9.0c1"
      ]
    },
    {
      "id": "pyup.io-zodb:CVE-2010-3495",
      "advisory": "Race condition in ZEO/StorageServer.py in Zope Object Database (ZODB) before 3.10.0 allows remote attackers to cause a denial of service (daemon outage) by establishing and then immediately closing a TCP connection, leading to the accept function having an unexpected return value of None, an unexpected value of None for the address, or an ECONNABORTED, EAGAIN, or EWOULDBLOCK error, a related issue to CVE-2010-3492.",
      "cve": "CVE-2010-3495",
      "specs": [
        "<=3.9.7",
        "==2.10.9",
        "==2.11.4",
        "==2.8.11",
        "==2.9.11",
        "==3.1",
        "==3.1.1",
        "==3.2",
        "==3.2.4",
        "==3.3",
        "==3.3.3",
        "==3.4",
        "==3.4.1",
        "==3.5",
        "==3.6",
        "==3.7",
        "==3.8",
        "==3.8.0",
        "==3.8.1",
        "==3.8.2",
        "==3.8.6",
        "==3.9.0",
        "==3.9.0b1",
        "==3.9.0b2",
        "==3.9.0b3",
        "==3.9.0b4",
        "==3.9.0b5",
        "==3.9.0c1"
      ]
    }
  ],
  "zope": [
    {
      "id": "pyup.io-zope:CVE-2000-0062",
      "advisory": "The DTML implementation in the Z Object Publishing Environment (Zope) allows remote attackers to conduct unauthorized activities.",
      "cve": "CVE-2000-0062",
      "specs": [
        "==1.10.3",
        "==2.1.1"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2000-0483",
      "advisory": "The DocumentTemplate package in Zope 2.2 and earlier allows a remote attacker to modify DTMLDocuments or DTMLMethods without authorization.",
      "cve": "CVE-2000-0483",
      "specs": [
        "==1.10.3",
        "==2.1.1",
        "==2.1.7"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2000-0725",
      "advisory": "Zope before 2.2.1 does not properly restrict access to the getRoles method, which allows users who can edit DTML to add or modify roles by modifying the roles list that is included in a request.",
      "cve": "CVE-2000-0725",
      "specs": [
        "==1.10.3",
        "==2.1.1",
        "==2.1.7",
        "==2.2_beta1"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2000-1211",
      "advisory": "Zope 2.2.0 through 2.2.4 does not properly perform security registration for legacy names of object constructors such as DTML method objects, which could allow attackers to perform unauthorized activities.",
      "cve": "CVE-2000-1211",
      "specs": [
        "==2.2.0",
        "==2.2.0a1",
        "==2.2.0b1",
        "==2.2.0b2",
        "==2.2.0b3",
        "==2.2.0b4",
        "==2.2.1",
        "==2.2.1b1",
        "==2.2.2",
        "==2.2.3",
        "==2.2.4"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2000-1212",
      "advisory": "Zope 2.2.0 through 2.2.4 does not properly protect a data updating method on Image and File objects, which allows attackers with DTML editing privileges to modify the raw data of these objects.",
      "cve": "CVE-2000-1212",
      "specs": [
        "==2.2.0",
        "==2.2.0a1",
        "==2.2.0b1",
        "==2.2.0b2",
        "==2.2.0b3",
        "==2.2.0b4",
        "==2.2.1",
        "==2.2.1b1",
        "==2.2.2",
        "==2.2.3",
        "==2.2.4"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2001-0128",
      "advisory": "Zope before 2.2.4 does not properly compute local roles, which could allow users to bypass specified access restrictions and gain privileges.",
      "cve": "CVE-2001-0128",
      "specs": [
        "<=2.2.4"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2001-0567",
      "advisory": "Digital Creations Zope 2.3.2 and earlier allows a local attacker to gain additional privileges via the changing of ZClass permission mappings for objects and methods in the ZClass.",
      "cve": "CVE-2001-0567",
      "specs": [
        "==7.1",
        "==7.2"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2001-0568",
      "advisory": "Digital Creations Zope 2.3.1 b1 and earlier allows a local attacker (Zope user) with through-the-web scripting capabilities to alter ZClasses class attributes.",
      "cve": "CVE-2001-0568",
      "specs": [
        "<=2.3.1_b1"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2001-0569",
      "advisory": "Digital Creations Zope 2.3.1 b1 and earlier contains a problem in the method return values related to the classes (1) ObjectManager, (2) PropertyManager, and (3) PropertySheet.",
      "cve": "CVE-2001-0569",
      "specs": [
        "<=2.3.1_b1"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2001-1227",
      "advisory": "Zope before 2.2.4 allows partially trusted users to bypass security controls for certain methods by accessing the methods through the fmt attribute of dtml-var tags.",
      "cve": "CVE-2001-1227",
      "specs": [
        "==2.2.0",
        "==2.2.1",
        "==2.2.2",
        "==2.2.3",
        "==2.2.4",
        "==2.2.5"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2001-1278",
      "advisory": "Zope before 2.2.4 allows partially trusted users to bypass security controls for certain methods by accessing the methods through the fmt attribute of dtml-var tags.",
      "cve": "CVE-2001-1278",
      "specs": [
        "==2.2.0",
        "==2.2.1",
        "==2.2.2",
        "==2.2.3",
        "==2.2.4"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2002-0170",
      "advisory": "Zope 2.2.0 through 2.5.1 does not properly verify the access for objects with proxy roles, which could allow some users to access documents in violation of the intended configuration.",
      "cve": "CVE-2002-0170",
      "specs": [
        "==2.2.0",
        "==2.2.1",
        "==2.2.2",
        "==2.2.3",
        "==2.2.4",
        "==2.2.5",
        "==2.3.0",
        "==2.3.1",
        "==2.3.2",
        "==2.3.3",
        "==2.4.0",
        "==2.4.1",
        "==2.4.2",
        "==2.4.3",
        "==2.4.4b1",
        "==2.5.0",
        "==2.5.1b1"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2002-0687",
      "advisory": "The \"through the web code\" capability for Zope 2.0 through 2.5.1 b1 allows untrusted users to shut down the Zope server via certain headers.",
      "cve": "CVE-2002-0687",
      "specs": [
        "<=2.5.1b1"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2002-0688",
      "advisory": "ZCatalog plug-in index support capability for Zope 2.4.0 through 2.5.1 allows anonymous users and untrusted code to bypass access restrictions and call arbitrary methods of catalog indexes.",
      "cve": "CVE-2002-0688",
      "specs": [
        "==2.4.0",
        "==2.5.1"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2005-3323",
      "advisory": "docutils in Zope 2.6, 2.7 before 2.7.8, and 2.8 before 2.8.2 allows remote attackers to include arbitrary files via include directives in RestructuredText functionality.",
      "cve": "CVE-2005-3323",
      "specs": [
        "==2.6",
        ">=2.7.0,<2.7.8",
        ">=2.8.0,<2.8.2"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2006-3458",
      "advisory": "Zope 2.7.0 to 2.7.8, 2.8.0 to 2.8.7, and 2.9.0 to 2.9.3 (Zope2) does not disable the \"raw\" command when providing untrusted users with restructured text (reStructuredText) functionality from docutils, which allows local users to read arbitrary files.",
      "cve": "CVE-2006-3458",
      "specs": [
        "==2.7.0",
        "==2.7.1",
        "==2.7.2",
        "==2.7.3",
        "==2.7.4",
        "==2.7.5",
        "==2.7.6",
        "==2.7.7",
        "==2.7.8",
        "==2.8.0",
        "==2.8.1",
        "==2.8.2",
        "==2.8.3",
        "==2.8.4",
        "==2.8.5",
        "==2.8.6",
        "==2.8.7",
        "==2.9.0",
        "==2.9.1",
        "==2.9.2",
        "==2.9.3"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2006-4684",
      "advisory": "The docutils module in Zope (Zope2) 2.7.0 through 2.7.9 and 2.8.0 through 2.8.8 does not properly handle web pages with reStructuredText (reST) markup, which allows remote attackers to read arbitrary files via a csv_table directive, a different vulnerability than CVE-2006-3458.",
      "cve": "CVE-2006-4684",
      "specs": [
        "==2.7.0",
        "==2.7.1",
        "==2.7.2",
        "==2.7.3",
        "==2.7.4",
        "==2.7.5",
        "==2.7.6",
        "==2.7.7",
        "==2.7.8",
        "==2.7.9",
        "==2.8.0",
        "==2.8.1",
        "==2.8.2",
        "==2.8.3",
        "==2.8.4",
        "==2.8.5",
        "==2.8.6",
        "==2.8.7",
        "==2.8.8"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2007-0240",
      "advisory": "Cross-site scripting (XSS) vulnerability in Zope 2.10.2 and earlier allows remote attackers to inject arbitrary web script or HTML via unspecified vectors in a HTTP GET request.",
      "cve": "CVE-2007-0240",
      "specs": [
        "<=2.10.2"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2008-5102",
      "advisory": "PythonScripts in Zope 2 2.11.2 and earlier, as used in Conga and other products, allows remote authenticated users to cause a denial of service (resource consumption or application halt) via certain (1) raise or (2) import statements.",
      "cve": "CVE-2008-5102",
      "specs": [
        "<=2.11.2",
        "==1.10.3",
        "==1.10.4",
        "==2.0.0",
        "==2.0.0a4",
        "==2.0.0b4",
        "==2.0.0b5",
        "==2.0.0b6",
        "==2.0.1",
        "==2.1.0",
        "==2.1.0b1",
        "==2.1.0b2",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.1.5",
        "==2.1.6",
        "==2.10.0-b1",
        "==2.10.0-b2",
        "==2.10.0-c1",
        "==2.10.0-final",
        "==2.10.2-b1",
        "==2.10.2-final",
        "==2.10.3-final",
        "==2.10.4-final",
        "==2.10.5",
        "==2.10.6",
        "==2.10.7",
        "==2.11.0",
        "==2.11.1",
        "==2.2.0",
        "==2.2.0a1",
        "==2.2.0b1",
        "==2.2.0b2",
        "==2.2.0b3",
        "==2.2.0b4",
        "==2.2.1",
        "==2.2.1b1",
        "==2.2.2",
        "==2.2.3",
        "==2.2.4",
        "==2.2.4b1",
        "==2.2.5",
        "==2.2.5b1",
        "==2.3.0",
        "==2.3.0a1",
        "==2.3.0a2",
        "==2.3.0b1",
        "==2.3.0b2",
        "==2.3.0b3",
        "==2.3.1",
        "==2.3.1b1",
        "==2.3.1b2",
        "==2.3.1b3",
        "==2.3.2",
        "==2.3.2b1",
        "==2.3.2b2",
        "==2.3.3",
        "==2.3.3b1",
        "==2.4.0",
        "==2.4.0a1",
        "==2.4.0b1",
        "==2.4.0b2",
        "==2.4.0b3",
        "==2.4.1",
        "==2.4.1b1",
        "==2.4.2",
        "==2.4.2b1",
        "==2.4.3",
        "==2.4.3-upgrade",
        "==2.4.3b1",
        "==2.4.4",
        "==2.4.4-upgrade",
        "==2.4.4b1",
        "==2.5.0",
        "==2.5.0a1",
        "==2.5.0a2",
        "==2.5.0b1",
        "==2.5.1",
        "==2.5.1-upgrade",
        "==2.5.1b1",
        "==2.5.1b2",
        "==2.6.0",
        "==2.6.0a1",
        "==2.6.0b1",
        "==2.6.0b2",
        "==2.6.1",
        "==2.6.1-upgrade",
        "==2.6.1.b1",
        "==2.6.2",
        "==2.6.2.b1",
        "==2.6.2.b2",
        "==2.6.2.b3",
        "==2.6.2.b4",
        "==2.6.2.b5",
        "==2.6.2.b6",
        "==2.6.3",
        "==2.6.4",
        "==2.6.4-rc1",
        "==2.6.4-rc2",
        "==2.7.0-a1",
        "==2.7.0-b1",
        "==2.7.0-b2",
        "==2.7.0-b3",
        "==2.7.0-b4",
        "==2.7.0-c1",
        "==2.7.0-c2",
        "==2.7.0-final",
        "==2.7.1-b1",
        "==2.7.1-b2",
        "==2.7.1-final",
        "==2.7.2-c1",
        "==2.7.2-final",
        "==2.7.3-b1",
        "==2.7.3-b2",
        "==2.7.3-final",
        "==2.7.4-b1",
        "==2.7.4-b2",
        "==2.7.4-c1",
        "==2.7.4-c2",
        "==2.7.4-final",
        "==2.7.5-b1",
        "==2.7.5-c1",
        "==2.7.5-final",
        "==2.7.6-b1",
        "==2.7.6-b2",
        "==2.7.6-final",
        "==2.7.7-b1",
        "==2.7.7-final",
        "==2.7.8",
        "==2.7.9",
        "==2.8.0-a1",
        "==2.8.0-a2",
        "==2.8.0-b1",
        "==2.8.0-b2",
        "==2.8.0-final",
        "==2.8.1-b1",
        "==2.8.1-final",
        "==2.8.10",
        "==2.8.2",
        "==2.8.3",
        "==2.8.4",
        "==2.8.5",
        "==2.8.6",
        "==2.8.7",
        "==2.8.8",
        "==2.8.9",
        "==2.8.9.1",
        "==2.9.0-b1",
        "==2.9.0-b2",
        "==2.9.0-final",
        "==2.9.1",
        "==2.9.10",
        "==2.9.2",
        "==2.9.3",
        "==2.9.4",
        "==2.9.5",
        "==2.9.6",
        "==2.9.7",
        "==2.9.8",
        "==2.9.9"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2009-5145",
      "advisory": "Cross-site scripting (XSS) vulnerability in ZMI pages that use the manage_tabs_message in Zope 2.11.4, 2.11.2, 2.10.9, 2.10.7, 2.10.6, 2.10.5, 2.10.4, 2.10.2, 2.10.1, 2.12.",
      "cve": "CVE-2009-5145",
      "specs": [
        "==2.10.1",
        "==2.10.2",
        "==2.10.4",
        "==2.10.5",
        "==2.10.6",
        "==2.10.7",
        "==2.10.9",
        "==2.11.2",
        "==2.11.4",
        "==2.12.0"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2010-1104",
      "advisory": "Cross-site scripting (XSS) vulnerability in Zope 2.8.x before 2.8.12, 2.9.x before 2.9.12, 2.10.x before 2.10.11, 2.11.x before 2.11.6, and 2.12.x before 2.12.3 allows remote attackers to inject arbitrary web script or HTML via vectors related to error messages.",
      "cve": "CVE-2010-1104",
      "specs": [
        "==2.10.0-b1",
        "==2.10.0-b2",
        "==2.10.0-c1",
        "==2.10.0-final",
        "==2.10.10",
        "==2.10.11",
        "==2.10.2",
        "==2.10.2-b1",
        "==2.10.2-final",
        "==2.10.3",
        "==2.10.3-final",
        "==2.10.4-final",
        "==2.10.5",
        "==2.10.6",
        "==2.10.7",
        "==2.10.8",
        "==2.10.9",
        "==2.11.0",
        "==2.11.0a1",
        "==2.11.0b1",
        "==2.11.0c1",
        "==2.11.1",
        "==2.11.2",
        "==2.11.3",
        "==2.11.4",
        "==2.11.5",
        "==2.12.0",
        "==2.12.1",
        "==2.12.2",
        "==2.8",
        "==2.8.0",
        "==2.8.0-a1",
        "==2.8.0-a2",
        "==2.8.0-b1",
        "==2.8.0-b2",
        "==2.8.0-final",
        "==2.8.1",
        "==2.8.1-b1",
        "==2.8.1-final",
        "==2.8.10",
        "==2.8.11",
        "==2.8.2",
        "==2.8.3",
        "==2.8.4",
        "==2.8.5",
        "==2.8.6",
        "==2.8.7",
        "==2.8.8",
        "==2.8.9",
        "==2.8.9.1",
        "==2.9.0",
        "==2.9.0-b1",
        "==2.9.0-b2",
        "==2.9.1",
        "==2.9.10",
        "==2.9.11",
        "==2.9.2",
        "==2.9.3",
        "==2.9.4",
        "==2.9.5",
        "==2.9.6",
        "==2.9.7",
        "==2.9.8",
        "==2.9.9"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2010-3198",
      "advisory": "ZServer in Zope 2.10.x before 2.10.12 and 2.11.x before 2.11.7 allows remote attackers to cause a denial of service (crash of worker threads) via vectors that trigger uncaught exceptions.",
      "cve": "CVE-2010-3198",
      "specs": [
        "==2.10.0-b1",
        "==2.10.0-b2",
        "==2.10.0-c1",
        "==2.10.0-final",
        "==2.10.10",
        "==2.10.11",
        "==2.10.2",
        "==2.10.2-b1",
        "==2.10.2-final",
        "==2.10.3",
        "==2.10.3-final",
        "==2.10.4-final",
        "==2.10.5",
        "==2.10.6",
        "==2.10.7",
        "==2.10.8",
        "==2.10.9",
        "==2.11.0",
        "==2.11.0a1",
        "==2.11.0b1",
        "==2.11.0c1",
        "==2.11.1",
        "==2.11.2",
        "==2.11.3",
        "==2.11.4",
        "==2.11.5",
        "==2.11.6"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2011-2528",
      "advisory": "Unspecified vulnerability in (1) Zope 2.12.x before 2.12.19 and 2.13.x before 2.13.8, as used in Plone 4.x and other products, and (2) PloneHotfix20110720 for Plone 3.x allows attackers to gain privileges via unspecified vectors, related to a \"highly serious vulnerability.\" NOTE: this vulnerability exists because of an incorrect fix for CVE-2011-0720.",
      "cve": "CVE-2011-2528",
      "specs": [
        "==2.12.0",
        "==2.12.0-a1",
        "==2.12.0-a2",
        "==2.12.0-a3",
        "==2.12.0-a4",
        "==2.12.0-b1",
        "==2.12.0-b2",
        "==2.12.0-b3",
        "==2.12.0-b4",
        "==2.12.1",
        "==2.12.10",
        "==2.12.11",
        "==2.12.12",
        "==2.12.13",
        "==2.12.14",
        "==2.12.15",
        "==2.12.16",
        "==2.12.17",
        "==2.12.18",
        "==2.12.2",
        "==2.12.3",
        "==2.12.4",
        "==2.12.5",
        "==2.12.6",
        "==2.12.7",
        "==2.12.8",
        "==2.12.9",
        "==2.13.0",
        "==2.13.0-a1",
        "==2.13.0-a2",
        "==2.13.0-a3",
        "==2.13.0-a4",
        "==2.13.0-b1",
        "==2.13.0-c1",
        "==2.13.1",
        "==2.13.2",
        "==2.13.3",
        "==2.13.4",
        "==2.13.5",
        "==2.13.6",
        "==2.13.7"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2011-3587",
      "advisory": "Unspecified vulnerability in Zope 2.12.x and 2.13.x, as used in Plone 4.0.x through 4.0.9, 4.1, and 4.2 through 4.2a2, allows remote attackers to execute arbitrary commands via vectors related to the p_ class in OFS/misc_.py and the use of Python modules.",
      "cve": "CVE-2011-3587",
      "specs": [
        "==2.12.0",
        "==2.12.0-a1",
        "==2.12.0-a2",
        "==2.12.0-a3",
        "==2.12.0-a4",
        "==2.12.0-b1",
        "==2.12.0-b2",
        "==2.12.0-b3",
        "==2.12.0-b4",
        "==2.12.1",
        "==2.12.10",
        "==2.12.11",
        "==2.12.12",
        "==2.12.13",
        "==2.12.14",
        "==2.12.15",
        "==2.12.16",
        "==2.12.17",
        "==2.12.18",
        "==2.12.19",
        "==2.12.2",
        "==2.12.20",
        "==2.12.3",
        "==2.12.4",
        "==2.12.5",
        "==2.12.6",
        "==2.12.7",
        "==2.12.8",
        "==2.12.9",
        "==2.13.0",
        "==2.13.0-a1",
        "==2.13.0-a2",
        "==2.13.0-a3",
        "==2.13.0-a4",
        "==2.13.0-b1",
        "==2.13.0-c1",
        "==2.13.1",
        "==2.13.10",
        "==2.13.2",
        "==2.13.3",
        "==2.13.4",
        "==2.13.5",
        "==2.13.6",
        "==2.13.7",
        "==2.13.8",
        "==2.13.9"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2011-4924",
      "advisory": "Cross-site scripting (XSS) vulnerability in Zope 2.8.x before 2.8.12, 2.9.x before 2.9.12, 2.10.x before 2.10.11, 2.11.x before 2.11.6, and 2.12.x before 2.12.3, 3.1.1 through 3.4.1. allows remote attackers to inject arbitrary web script or HTML via vectors related to the way error messages perform sanitization. NOTE: this issue exists because of an incomplete fix for CVE-2010-1104",
      "cve": "CVE-2011-4924",
      "specs": [
        ">=2.10.0,<2.10.11",
        ">=2.11.0,<2.11.6",
        ">=2.12.0,<2.12.3",
        ">=2.8.0,<2.8.12",
        ">=2.9.0,<2.9.12",
        ">=3.1.1,<=3.4.1"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2012-5486",
      "advisory": "ZPublisher.HTTPRequest._scrubHeader in Zope 2 before 2.13.19, as used in Plone before 4.3 beta 1, allows remote attackers to inject arbitrary HTTP headers via a linefeed (LF) character.",
      "cve": "CVE-2012-5486",
      "specs": [
        "==2.10.3",
        "==2.10.8",
        "==2.11.0",
        "==2.11.1",
        "==2.11.2",
        "==2.11.3",
        "==2.13.18",
        "==2.5.1",
        "==2.6.1",
        "==2.6.4",
        "==2.7.0",
        "==2.7.3",
        "==2.7.4",
        "==2.7.5",
        "==2.7.6",
        "==2.7.7",
        "==2.7.8",
        "==2.8.1",
        "==2.8.4",
        "==2.8.6",
        "==2.8.8",
        "==2.9.2",
        "==2.9.3",
        "==2.9.4",
        "==2.9.5",
        "==2.9.6",
        "==2.9.7"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2012-5489",
      "advisory": "The App.Undo.UndoSupport.get_request_var_or_attr function in Zope before 2.12.21 and 3.13.x before 2.13.11, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote authenticated users to gain access to restricted attributes via unspecified vectors.",
      "cve": "CVE-2012-5489",
      "specs": [
        "<=2.13.10",
        "==2.10.3",
        "==2.10.8",
        "==2.11.0",
        "==2.11.1",
        "==2.11.2",
        "==2.11.3",
        "==2.13.0",
        "==2.13.1",
        "==2.13.2",
        "==2.13.3",
        "==2.13.4",
        "==2.13.5",
        "==2.13.6",
        "==2.13.7",
        "==2.13.8",
        "==2.13.9",
        "==2.5.1",
        "==2.6.1",
        "==2.6.4",
        "==2.7.0",
        "==2.7.3",
        "==2.7.4",
        "==2.7.5",
        "==2.7.6",
        "==2.7.7",
        "==2.7.8",
        "==2.8.1",
        "==2.8.4",
        "==2.8.6",
        "==2.8.8",
        "==2.9.2",
        "==2.9.3",
        "==2.9.4",
        "==2.9.5",
        "==2.9.6",
        "==2.9.7"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2012-5507",
      "advisory": "AccessControl/AuthEncoding.py in Zope before 2.13.19, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote attackers to obtain passwords via vectors involving timing discrepancies in password validation.",
      "cve": "CVE-2012-5507",
      "specs": [
        "==2.10.3",
        "==2.10.8",
        "==2.11.0",
        "==2.11.1",
        "==2.11.2",
        "==2.11.3",
        "==2.13.18",
        "==2.5.1",
        "==2.6.1",
        "==2.6.4",
        "==2.7.0",
        "==2.7.3",
        "==2.7.4",
        "==2.7.5",
        "==2.7.6",
        "==2.7.7",
        "==2.7.8",
        "==2.8.1",
        "==2.8.4",
        "==2.8.6",
        "==2.8.8",
        "==2.9.2",
        "==2.9.3",
        "==2.9.4",
        "==2.9.5",
        "==2.9.6",
        "==2.9.7"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2012-6661",
      "advisory": "Zope before 2.13.19, as used in Plone before 4.2.3 and 4.3 before beta 1, does not reseed the pseudo-random number generator (PRNG), which makes it easier for remote attackers to guess the value via unspecified vectors.  NOTE: this issue was SPLIT from CVE-2012-5508 due to different vulnerability types (ADT2).",
      "cve": "CVE-2012-6661",
      "specs": [
        "<=2.13.18"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2021-32633",
      "advisory": "Zope is an open-source web application server. In Zope versions prior to 4.6 and 5.2, users can access untrusted modules indirectly through Python modules that are available for direct use. By default, only users with the Manager role can add or edit Zope Page Templates through the web, but sites that allow untrusted users to add/edit Zope Page Templates through the web are at risk from this vulnerability. The problem has been fixed in Zope 5.2 and 4.6. As a workaround, a site administrator can restrict adding/editing Zope Page Templates through the web using the standard Zope user/role permission mechanisms. Untrusted users should not be assigned the Zope Manager role and adding/editing Zope Page Templates through the web should be restricted to trusted users only.",
      "cve": "CVE-2021-32633",
      "specs": [
        "<4.6",
        ">=5.0,<5.2"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2021-32674",
      "advisory": "Zope is an open-source web application server. This advisory extends the previous advisory at https://github.com/zopefoundation/Zope/security/advisories/GHSA-5pr9-v234-jw36 with additional cases of TAL expression traversal vulnerabilities. Most Python modules are not available for using in TAL expressions that you can add through-the-web, for example in Zope Page Templates. This restriction avoids file system access, for example via the 'os' module. But some of the untrusted modules are available indirectly through Python modules that are available for direct use. By default, you need to have the Manager role to add or edit Zope Page Templates through the web. Only sites that allow untrusted users to add/edit Zope Page Templates through the web are at risk. The problem has been fixed in Zope 5.21 and 4.6.1. The workaround is the same as for https://github.com/zopefoundation/Zope/security/advisories/GHSA-5pr9-v234-jw36: A site administrator can restrict adding/editing Zope Page Templates through the web using the standard Zope user/role permission mechanisms. Untrusted users should not be assigned the Zope Manager role and adding/editing Zope Page Templates through the web should be restricted to trusted users only.",
      "cve": "CVE-2021-32674",
      "specs": [
        "<4.6.1",
        ">=5.0.0,<5.2.1"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2021-32811",
      "advisory": "Zope is an open-source web application server. Zope versions prior to versions 4.6.3 and 5.3 have a remote code execution security issue. In order to be affected, one must use Python 3 for one's Zope deployment, run Zope 4 below version 4.6.3 or Zope 5 below version 5.3, and have the optional `Products.PythonScripts` add-on package installed. By default, one must have the admin-level Zope \"Manager\" role to add or edit Script (Python) objects through the web. Only sites that allow untrusted users to add/edit these scripts through the web are at risk. Zope releases 4.6.3 and 5.3 are not vulnerable. As a workaround, a site administrator can restrict adding/editing Script (Python) objects through the web using the standard Zope user/role permission mechanisms. Untrusted users should not be assigned the Zope Manager role and adding/editing these scripts through the web should be restricted to trusted users only. This is the default configuration in Zope.",
      "cve": "CVE-2021-32811",
      "specs": [
        ">=4.0,<4.6.3",
        ">=5.0,<5.3"
      ]
    },
    {
      "id": "pyup.io-zope:CVE-2021-33507",
      "advisory": "Zope Products.CMFCore before 2.5.1 and Products.PluggableAuthService before 2.6.2, as used in Plone through 5.2.4 and other products, allow Reflected XSS.",
      "cve": "CVE-2021-33507",
      "specs": [
        "<2.5.1"
      ]
    }
  ],
  "zope2": [
    {
      "id": "pyup.io-zope2:CVE-2000-0062",
      "advisory": "The DTML implementation in the Z Object Publishing Environment (Zope) allows remote attackers to conduct unauthorized activities.",
      "cve": "CVE-2000-0062",
      "specs": [
        "==1.10.3",
        "==2.1.1"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2000-0483",
      "advisory": "The DocumentTemplate package in Zope 2.2 and earlier allows a remote attacker to modify DTMLDocuments or DTMLMethods without authorization.",
      "cve": "CVE-2000-0483",
      "specs": [
        "==1.10.3",
        "==2.1.1",
        "==2.1.7"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2000-0725",
      "advisory": "Zope before 2.2.1 does not properly restrict access to the getRoles method, which allows users who can edit DTML to add or modify roles by modifying the roles list that is included in a request.",
      "cve": "CVE-2000-0725",
      "specs": [
        "==1.10.3",
        "==2.1.1",
        "==2.1.7",
        "==2.2_beta1"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2000-1211",
      "advisory": "Zope 2.2.0 through 2.2.4 does not properly perform security registration for legacy names of object constructors such as DTML method objects, which could allow attackers to perform unauthorized activities.",
      "cve": "CVE-2000-1211",
      "specs": [
        "==2.2.0",
        "==2.2.0a1",
        "==2.2.0b1",
        "==2.2.0b2",
        "==2.2.0b3",
        "==2.2.0b4",
        "==2.2.1",
        "==2.2.1b1",
        "==2.2.2",
        "==2.2.3",
        "==2.2.4"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2000-1212",
      "advisory": "Zope 2.2.0 through 2.2.4 does not properly protect a data updating method on Image and File objects, which allows attackers with DTML editing privileges to modify the raw data of these objects.",
      "cve": "CVE-2000-1212",
      "specs": [
        "==2.2.0",
        "==2.2.0a1",
        "==2.2.0b1",
        "==2.2.0b2",
        "==2.2.0b3",
        "==2.2.0b4",
        "==2.2.1",
        "==2.2.1b1",
        "==2.2.2",
        "==2.2.3",
        "==2.2.4"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2001-0128",
      "advisory": "Zope before 2.2.4 does not properly compute local roles, which could allow users to bypass specified access restrictions and gain privileges.",
      "cve": "CVE-2001-0128",
      "specs": [
        "<=2.2.4"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2001-0567",
      "advisory": "Digital Creations Zope 2.3.2 and earlier allows a local attacker to gain additional privileges via the changing of ZClass permission mappings for objects and methods in the ZClass.",
      "cve": "CVE-2001-0567",
      "specs": [
        "==7.1",
        "==7.2"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2001-0568",
      "advisory": "Digital Creations Zope 2.3.1 b1 and earlier allows a local attacker (Zope user) with through-the-web scripting capabilities to alter ZClasses class attributes.",
      "cve": "CVE-2001-0568",
      "specs": [
        "<=2.3.1_b1"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2001-0569",
      "advisory": "Digital Creations Zope 2.3.1 b1 and earlier contains a problem in the method return values related to the classes (1) ObjectManager, (2) PropertyManager, and (3) PropertySheet.",
      "cve": "CVE-2001-0569",
      "specs": [
        "<=2.3.1_b1"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2001-1227",
      "advisory": "Zope before 2.2.4 allows partially trusted users to bypass security controls for certain methods by accessing the methods through the fmt attribute of dtml-var tags.",
      "cve": "CVE-2001-1227",
      "specs": [
        "==2.2.0",
        "==2.2.1",
        "==2.2.2",
        "==2.2.3",
        "==2.2.4",
        "==2.2.5"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2001-1278",
      "advisory": "Zope before 2.2.4 allows partially trusted users to bypass security controls for certain methods by accessing the methods through the fmt attribute of dtml-var tags.",
      "cve": "CVE-2001-1278",
      "specs": [
        "==2.2.0",
        "==2.2.1",
        "==2.2.2",
        "==2.2.3",
        "==2.2.4"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2002-0170",
      "advisory": "Zope 2.2.0 through 2.5.1 does not properly verify the access for objects with proxy roles, which could allow some users to access documents in violation of the intended configuration.",
      "cve": "CVE-2002-0170",
      "specs": [
        "==2.2.0",
        "==2.2.1",
        "==2.2.2",
        "==2.2.3",
        "==2.2.4",
        "==2.2.5",
        "==2.3.0",
        "==2.3.1",
        "==2.3.2",
        "==2.3.3",
        "==2.4.0",
        "==2.4.1",
        "==2.4.2",
        "==2.4.3",
        "==2.4.4b1",
        "==2.5.0",
        "==2.5.1b1"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2002-0687",
      "advisory": "The \"through the web code\" capability for Zope 2.0 through 2.5.1 b1 allows untrusted users to shut down the Zope server via certain headers.",
      "cve": "CVE-2002-0687",
      "specs": [
        "<=2.5.1b1"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2002-0688",
      "advisory": "ZCatalog plug-in index support capability for Zope 2.4.0 through 2.5.1 allows anonymous users and untrusted code to bypass access restrictions and call arbitrary methods of catalog indexes.",
      "cve": "CVE-2002-0688",
      "specs": [
        "==2.4.0",
        "==2.5.1"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2005-3323",
      "advisory": "docutils in Zope 2.6, 2.7 before 2.7.8, and 2.8 before 2.8.2 allows remote attackers to include arbitrary files via include directives in RestructuredText functionality.",
      "cve": "CVE-2005-3323",
      "specs": [
        "==2.6",
        ">=2.7.0,<2.7.8",
        ">=2.8.0,<2.8.2"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2006-3458",
      "advisory": "Zope 2.7.0 to 2.7.8, 2.8.0 to 2.8.7, and 2.9.0 to 2.9.3 (Zope2) does not disable the \"raw\" command when providing untrusted users with restructured text (reStructuredText) functionality from docutils, which allows local users to read arbitrary files.",
      "cve": "CVE-2006-3458",
      "specs": [
        "==2.7.0",
        "==2.7.1",
        "==2.7.2",
        "==2.7.3",
        "==2.7.4",
        "==2.7.5",
        "==2.7.6",
        "==2.7.7",
        "==2.7.8",
        "==2.8.0",
        "==2.8.1",
        "==2.8.2",
        "==2.8.3",
        "==2.8.4",
        "==2.8.5",
        "==2.8.6",
        "==2.8.7",
        "==2.9.0",
        "==2.9.1",
        "==2.9.2",
        "==2.9.3"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2006-4684",
      "advisory": "The docutils module in Zope (Zope2) 2.7.0 through 2.7.9 and 2.8.0 through 2.8.8 does not properly handle web pages with reStructuredText (reST) markup, which allows remote attackers to read arbitrary files via a csv_table directive, a different vulnerability than CVE-2006-3458.",
      "cve": "CVE-2006-4684",
      "specs": [
        "==2.7.0",
        "==2.7.1",
        "==2.7.2",
        "==2.7.3",
        "==2.7.4",
        "==2.7.5",
        "==2.7.6",
        "==2.7.7",
        "==2.7.8",
        "==2.7.9",
        "==2.8.0",
        "==2.8.1",
        "==2.8.2",
        "==2.8.3",
        "==2.8.4",
        "==2.8.5",
        "==2.8.6",
        "==2.8.7",
        "==2.8.8"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2007-0240",
      "advisory": "Cross-site scripting (XSS) vulnerability in Zope 2.10.2 and earlier allows remote attackers to inject arbitrary web script or HTML via unspecified vectors in a HTTP GET request.",
      "cve": "CVE-2007-0240",
      "specs": [
        "<=2.10.2"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2008-5102",
      "advisory": "PythonScripts in Zope 2 2.11.2 and earlier, as used in Conga and other products, allows remote authenticated users to cause a denial of service (resource consumption or application halt) via certain (1) raise or (2) import statements.",
      "cve": "CVE-2008-5102",
      "specs": [
        "<=2.11.2",
        "==1.10.3",
        "==1.10.4",
        "==2.0.0",
        "==2.0.0a4",
        "==2.0.0b4",
        "==2.0.0b5",
        "==2.0.0b6",
        "==2.0.1",
        "==2.1.0",
        "==2.1.0b1",
        "==2.1.0b2",
        "==2.1.1",
        "==2.1.2",
        "==2.1.3",
        "==2.1.4",
        "==2.1.5",
        "==2.1.6",
        "==2.10.0-b1",
        "==2.10.0-b2",
        "==2.10.0-c1",
        "==2.10.0-final",
        "==2.10.2-b1",
        "==2.10.2-final",
        "==2.10.3-final",
        "==2.10.4-final",
        "==2.10.5",
        "==2.10.6",
        "==2.10.7",
        "==2.11.0",
        "==2.11.1",
        "==2.2.0",
        "==2.2.0a1",
        "==2.2.0b1",
        "==2.2.0b2",
        "==2.2.0b3",
        "==2.2.0b4",
        "==2.2.1",
        "==2.2.1b1",
        "==2.2.2",
        "==2.2.3",
        "==2.2.4",
        "==2.2.4b1",
        "==2.2.5",
        "==2.2.5b1",
        "==2.3.0",
        "==2.3.0a1",
        "==2.3.0a2",
        "==2.3.0b1",
        "==2.3.0b2",
        "==2.3.0b3",
        "==2.3.1",
        "==2.3.1b1",
        "==2.3.1b2",
        "==2.3.1b3",
        "==2.3.2",
        "==2.3.2b1",
        "==2.3.2b2",
        "==2.3.3",
        "==2.3.3b1",
        "==2.4.0",
        "==2.4.0a1",
        "==2.4.0b1",
        "==2.4.0b2",
        "==2.4.0b3",
        "==2.4.1",
        "==2.4.1b1",
        "==2.4.2",
        "==2.4.2b1",
        "==2.4.3",
        "==2.4.3-upgrade",
        "==2.4.3b1",
        "==2.4.4",
        "==2.4.4-upgrade",
        "==2.4.4b1",
        "==2.5.0",
        "==2.5.0a1",
        "==2.5.0a2",
        "==2.5.0b1",
        "==2.5.1",
        "==2.5.1-upgrade",
        "==2.5.1b1",
        "==2.5.1b2",
        "==2.6.0",
        "==2.6.0a1",
        "==2.6.0b1",
        "==2.6.0b2",
        "==2.6.1",
        "==2.6.1-upgrade",
        "==2.6.1.b1",
        "==2.6.2",
        "==2.6.2.b1",
        "==2.6.2.b2",
        "==2.6.2.b3",
        "==2.6.2.b4",
        "==2.6.2.b5",
        "==2.6.2.b6",
        "==2.6.3",
        "==2.6.4",
        "==2.6.4-rc1",
        "==2.6.4-rc2",
        "==2.7.0-a1",
        "==2.7.0-b1",
        "==2.7.0-b2",
        "==2.7.0-b3",
        "==2.7.0-b4",
        "==2.7.0-c1",
        "==2.7.0-c2",
        "==2.7.0-final",
        "==2.7.1-b1",
        "==2.7.1-b2",
        "==2.7.1-final",
        "==2.7.2-c1",
        "==2.7.2-final",
        "==2.7.3-b1",
        "==2.7.3-b2",
        "==2.7.3-final",
        "==2.7.4-b1",
        "==2.7.4-b2",
        "==2.7.4-c1",
        "==2.7.4-c2",
        "==2.7.4-final",
        "==2.7.5-b1",
        "==2.7.5-c1",
        "==2.7.5-final",
        "==2.7.6-b1",
        "==2.7.6-b2",
        "==2.7.6-final",
        "==2.7.7-b1",
        "==2.7.7-final",
        "==2.7.8",
        "==2.7.9",
        "==2.8.0-a1",
        "==2.8.0-a2",
        "==2.8.0-b1",
        "==2.8.0-b2",
        "==2.8.0-final",
        "==2.8.1-b1",
        "==2.8.1-final",
        "==2.8.10",
        "==2.8.2",
        "==2.8.3",
        "==2.8.4",
        "==2.8.5",
        "==2.8.6",
        "==2.8.7",
        "==2.8.8",
        "==2.8.9",
        "==2.8.9.1",
        "==2.9.0-b1",
        "==2.9.0-b2",
        "==2.9.0-final",
        "==2.9.1",
        "==2.9.10",
        "==2.9.2",
        "==2.9.3",
        "==2.9.4",
        "==2.9.5",
        "==2.9.6",
        "==2.9.7",
        "==2.9.8",
        "==2.9.9"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2009-5145",
      "advisory": "Cross-site scripting (XSS) vulnerability in ZMI pages that use the manage_tabs_message in Zope 2.11.4, 2.11.2, 2.10.9, 2.10.7, 2.10.6, 2.10.5, 2.10.4, 2.10.2, 2.10.1, 2.12.",
      "cve": "CVE-2009-5145",
      "specs": [
        "==2.10.1",
        "==2.10.2",
        "==2.10.4",
        "==2.10.5",
        "==2.10.6",
        "==2.10.7",
        "==2.10.9",
        "==2.11.2",
        "==2.11.4",
        "==2.12.0"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2010-1104",
      "advisory": "Cross-site scripting (XSS) vulnerability in Zope 2.8.x before 2.8.12, 2.9.x before 2.9.12, 2.10.x before 2.10.11, 2.11.x before 2.11.6, and 2.12.x before 2.12.3 allows remote attackers to inject arbitrary web script or HTML via vectors related to error messages.",
      "cve": "CVE-2010-1104",
      "specs": [
        "==2.10.0-b1",
        "==2.10.0-b2",
        "==2.10.0-c1",
        "==2.10.0-final",
        "==2.10.10",
        "==2.10.11",
        "==2.10.2",
        "==2.10.2-b1",
        "==2.10.2-final",
        "==2.10.3",
        "==2.10.3-final",
        "==2.10.4-final",
        "==2.10.5",
        "==2.10.6",
        "==2.10.7",
        "==2.10.8",
        "==2.10.9",
        "==2.11.0",
        "==2.11.0a1",
        "==2.11.0b1",
        "==2.11.0c1",
        "==2.11.1",
        "==2.11.2",
        "==2.11.3",
        "==2.11.4",
        "==2.11.5",
        "==2.12.0",
        "==2.12.1",
        "==2.12.2",
        "==2.8",
        "==2.8.0",
        "==2.8.0-a1",
        "==2.8.0-a2",
        "==2.8.0-b1",
        "==2.8.0-b2",
        "==2.8.0-final",
        "==2.8.1",
        "==2.8.1-b1",
        "==2.8.1-final",
        "==2.8.10",
        "==2.8.11",
        "==2.8.2",
        "==2.8.3",
        "==2.8.4",
        "==2.8.5",
        "==2.8.6",
        "==2.8.7",
        "==2.8.8",
        "==2.8.9",
        "==2.8.9.1",
        "==2.9.0",
        "==2.9.0-b1",
        "==2.9.0-b2",
        "==2.9.1",
        "==2.9.10",
        "==2.9.11",
        "==2.9.2",
        "==2.9.3",
        "==2.9.4",
        "==2.9.5",
        "==2.9.6",
        "==2.9.7",
        "==2.9.8",
        "==2.9.9"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2010-3198",
      "advisory": "ZServer in Zope 2.10.x before 2.10.12 and 2.11.x before 2.11.7 allows remote attackers to cause a denial of service (crash of worker threads) via vectors that trigger uncaught exceptions.",
      "cve": "CVE-2010-3198",
      "specs": [
        "==2.10.0-b1",
        "==2.10.0-b2",
        "==2.10.0-c1",
        "==2.10.0-final",
        "==2.10.10",
        "==2.10.11",
        "==2.10.2",
        "==2.10.2-b1",
        "==2.10.2-final",
        "==2.10.3",
        "==2.10.3-final",
        "==2.10.4-final",
        "==2.10.5",
        "==2.10.6",
        "==2.10.7",
        "==2.10.8",
        "==2.10.9",
        "==2.11.0",
        "==2.11.0a1",
        "==2.11.0b1",
        "==2.11.0c1",
        "==2.11.1",
        "==2.11.2",
        "==2.11.3",
        "==2.11.4",
        "==2.11.5",
        "==2.11.6"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2011-2528",
      "advisory": "Unspecified vulnerability in (1) Zope 2.12.x before 2.12.19 and 2.13.x before 2.13.8, as used in Plone 4.x and other products, and (2) PloneHotfix20110720 for Plone 3.x allows attackers to gain privileges via unspecified vectors, related to a \"highly serious vulnerability.\" NOTE: this vulnerability exists because of an incorrect fix for CVE-2011-0720.",
      "cve": "CVE-2011-2528",
      "specs": [
        "==2.12.0",
        "==2.12.0-a1",
        "==2.12.0-a2",
        "==2.12.0-a3",
        "==2.12.0-a4",
        "==2.12.0-b1",
        "==2.12.0-b2",
        "==2.12.0-b3",
        "==2.12.0-b4",
        "==2.12.1",
        "==2.12.10",
        "==2.12.11",
        "==2.12.12",
        "==2.12.13",
        "==2.12.14",
        "==2.12.15",
        "==2.12.16",
        "==2.12.17",
        "==2.12.18",
        "==2.12.2",
        "==2.12.3",
        "==2.12.4",
        "==2.12.5",
        "==2.12.6",
        "==2.12.7",
        "==2.12.8",
        "==2.12.9",
        "==2.13.0",
        "==2.13.0-a1",
        "==2.13.0-a2",
        "==2.13.0-a3",
        "==2.13.0-a4",
        "==2.13.0-b1",
        "==2.13.0-c1",
        "==2.13.1",
        "==2.13.2",
        "==2.13.3",
        "==2.13.4",
        "==2.13.5",
        "==2.13.6",
        "==2.13.7"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2011-3587",
      "advisory": "Unspecified vulnerability in Zope 2.12.x and 2.13.x, as used in Plone 4.0.x through 4.0.9, 4.1, and 4.2 through 4.2a2, allows remote attackers to execute arbitrary commands via vectors related to the p_ class in OFS/misc_.py and the use of Python modules.",
      "cve": "CVE-2011-3587",
      "specs": [
        "==2.12.0",
        "==2.12.0-a1",
        "==2.12.0-a2",
        "==2.12.0-a3",
        "==2.12.0-a4",
        "==2.12.0-b1",
        "==2.12.0-b2",
        "==2.12.0-b3",
        "==2.12.0-b4",
        "==2.12.1",
        "==2.12.10",
        "==2.12.11",
        "==2.12.12",
        "==2.12.13",
        "==2.12.14",
        "==2.12.15",
        "==2.12.16",
        "==2.12.17",
        "==2.12.18",
        "==2.12.19",
        "==2.12.2",
        "==2.12.20",
        "==2.12.3",
        "==2.12.4",
        "==2.12.5",
        "==2.12.6",
        "==2.12.7",
        "==2.12.8",
        "==2.12.9",
        "==2.13.0",
        "==2.13.0-a1",
        "==2.13.0-a2",
        "==2.13.0-a3",
        "==2.13.0-a4",
        "==2.13.0-b1",
        "==2.13.0-c1",
        "==2.13.1",
        "==2.13.10",
        "==2.13.2",
        "==2.13.3",
        "==2.13.4",
        "==2.13.5",
        "==2.13.6",
        "==2.13.7",
        "==2.13.8",
        "==2.13.9"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2011-4924",
      "advisory": "Cross-site scripting (XSS) vulnerability in Zope 2.8.x before 2.8.12, 2.9.x before 2.9.12, 2.10.x before 2.10.11, 2.11.x before 2.11.6, and 2.12.x before 2.12.3, 3.1.1 through 3.4.1. allows remote attackers to inject arbitrary web script or HTML via vectors related to the way error messages perform sanitization. NOTE: this issue exists because of an incomplete fix for CVE-2010-1104",
      "cve": "CVE-2011-4924",
      "specs": [
        ">=2.10.0,<2.10.11",
        ">=2.11.0,<2.11.6",
        ">=2.12.0,<2.12.3",
        ">=2.8.0,<2.8.12",
        ">=2.9.0,<2.9.12",
        ">=3.1.1,<=3.4.1"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2012-5486",
      "advisory": "ZPublisher.HTTPRequest._scrubHeader in Zope 2 before 2.13.19, as used in Plone before 4.3 beta 1, allows remote attackers to inject arbitrary HTTP headers via a linefeed (LF) character.",
      "cve": "CVE-2012-5486",
      "specs": [
        "==2.10.3",
        "==2.10.8",
        "==2.11.0",
        "==2.11.1",
        "==2.11.2",
        "==2.11.3",
        "==2.13.18",
        "==2.5.1",
        "==2.6.1",
        "==2.6.4",
        "==2.7.0",
        "==2.7.3",
        "==2.7.4",
        "==2.7.5",
        "==2.7.6",
        "==2.7.7",
        "==2.7.8",
        "==2.8.1",
        "==2.8.4",
        "==2.8.6",
        "==2.8.8",
        "==2.9.2",
        "==2.9.3",
        "==2.9.4",
        "==2.9.5",
        "==2.9.6",
        "==2.9.7"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2012-5489",
      "advisory": "The App.Undo.UndoSupport.get_request_var_or_attr function in Zope before 2.12.21 and 3.13.x before 2.13.11, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote authenticated users to gain access to restricted attributes via unspecified vectors.",
      "cve": "CVE-2012-5489",
      "specs": [
        "<=2.13.10",
        "==2.10.3",
        "==2.10.8",
        "==2.11.0",
        "==2.11.1",
        "==2.11.2",
        "==2.11.3",
        "==2.13.0",
        "==2.13.1",
        "==2.13.2",
        "==2.13.3",
        "==2.13.4",
        "==2.13.5",
        "==2.13.6",
        "==2.13.7",
        "==2.13.8",
        "==2.13.9",
        "==2.5.1",
        "==2.6.1",
        "==2.6.4",
        "==2.7.0",
        "==2.7.3",
        "==2.7.4",
        "==2.7.5",
        "==2.7.6",
        "==2.7.7",
        "==2.7.8",
        "==2.8.1",
        "==2.8.4",
        "==2.8.6",
        "==2.8.8",
        "==2.9.2",
        "==2.9.3",
        "==2.9.4",
        "==2.9.5",
        "==2.9.6",
        "==2.9.7"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2012-5507",
      "advisory": "AccessControl/AuthEncoding.py in Zope before 2.13.19, as used in Plone before 4.2.3 and 4.3 before beta 1, allows remote attackers to obtain passwords via vectors involving timing discrepancies in password validation.",
      "cve": "CVE-2012-5507",
      "specs": [
        "==2.10.3",
        "==2.10.8",
        "==2.11.0",
        "==2.11.1",
        "==2.11.2",
        "==2.11.3",
        "==2.13.18",
        "==2.5.1",
        "==2.6.1",
        "==2.6.4",
        "==2.7.0",
        "==2.7.3",
        "==2.7.4",
        "==2.7.5",
        "==2.7.6",
        "==2.7.7",
        "==2.7.8",
        "==2.8.1",
        "==2.8.4",
        "==2.8.6",
        "==2.8.8",
        "==2.9.2",
        "==2.9.3",
        "==2.9.4",
        "==2.9.5",
        "==2.9.6",
        "==2.9.7"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2012-6661",
      "advisory": "Zope before 2.13.19, as used in Plone before 4.2.3 and 4.3 before beta 1, does not reseed the pseudo-random number generator (PRNG), which makes it easier for remote attackers to guess the value via unspecified vectors.  NOTE: this issue was SPLIT from CVE-2012-5508 due to different vulnerability types (ADT2).",
      "cve": "CVE-2012-6661",
      "specs": [
        "<=2.13.18"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2021-32633",
      "advisory": "Zope is an open-source web application server. In Zope versions prior to 4.6 and 5.2, users can access untrusted modules indirectly through Python modules that are available for direct use. By default, only users with the Manager role can add or edit Zope Page Templates through the web, but sites that allow untrusted users to add/edit Zope Page Templates through the web are at risk from this vulnerability. The problem has been fixed in Zope 5.2 and 4.6. As a workaround, a site administrator can restrict adding/editing Zope Page Templates through the web using the standard Zope user/role permission mechanisms. Untrusted users should not be assigned the Zope Manager role and adding/editing Zope Page Templates through the web should be restricted to trusted users only.",
      "cve": "CVE-2021-32633",
      "specs": [
        "<4.6",
        ">=5.0,<5.2"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2021-32674",
      "advisory": "Zope is an open-source web application server. This advisory extends the previous advisory at https://github.com/zopefoundation/Zope/security/advisories/GHSA-5pr9-v234-jw36 with additional cases of TAL expression traversal vulnerabilities. Most Python modules are not available for using in TAL expressions that you can add through-the-web, for example in Zope Page Templates. This restriction avoids file system access, for example via the 'os' module. But some of the untrusted modules are available indirectly through Python modules that are available for direct use. By default, you need to have the Manager role to add or edit Zope Page Templates through the web. Only sites that allow untrusted users to add/edit Zope Page Templates through the web are at risk. The problem has been fixed in Zope 5.21 and 4.6.1. The workaround is the same as for https://github.com/zopefoundation/Zope/security/advisories/GHSA-5pr9-v234-jw36: A site administrator can restrict adding/editing Zope Page Templates through the web using the standard Zope user/role permission mechanisms. Untrusted users should not be assigned the Zope Manager role and adding/editing Zope Page Templates through the web should be restricted to trusted users only.",
      "cve": "CVE-2021-32674",
      "specs": [
        "<4.6.1",
        ">=5.0.0,<5.2.1"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2021-32811",
      "advisory": "Zope is an open-source web application server. Zope versions prior to versions 4.6.3 and 5.3 have a remote code execution security issue. In order to be affected, one must use Python 3 for one's Zope deployment, run Zope 4 below version 4.6.3 or Zope 5 below version 5.3, and have the optional `Products.PythonScripts` add-on package installed. By default, one must have the admin-level Zope \"Manager\" role to add or edit Script (Python) objects through the web. Only sites that allow untrusted users to add/edit these scripts through the web are at risk. Zope releases 4.6.3 and 5.3 are not vulnerable. As a workaround, a site administrator can restrict adding/editing Script (Python) objects through the web using the standard Zope user/role permission mechanisms. Untrusted users should not be assigned the Zope Manager role and adding/editing these scripts through the web should be restricted to trusted users only. This is the default configuration in Zope.",
      "cve": "CVE-2021-32811",
      "specs": [
        ">=4.0,<4.6.3",
        ">=5.0,<5.3"
      ]
    },
    {
      "id": "pyup.io-zope2:CVE-2021-33507",
      "advisory": "Zope Products.CMFCore before 2.5.1 and Products.PluggableAuthService before 2.6.2, as used in Plone through 5.2.4 and other products, allow Reflected XSS.",
      "cve": "CVE-2021-33507",
      "specs": [
        "<2.5.1"
      ]
    }
  ],
  "zulip": [
    {
      "id": "pyup.io-zulip:CVE-2017-0881",
      "advisory": "An error in the implementation of an autosubscribe feature in the check_stream_exists route of the Zulip group chat application server before 1.4.3 allowed an authenticated user to subscribe to a private stream that should have required an invitation from an existing member to join. The issue affects all previously released versions of the Zulip server.",
      "cve": "CVE-2017-0881",
      "specs": [
        "<1.4.3"
      ]
    },
    {
      "id": "pyup.io-zulip:CVE-2017-0896",
      "advisory": "Zulip Server 1.5.1 and below suffer from an error in the implementation of the invite_by_admins_only setting in the Zulip group chat application server that allowed an authenticated user to invite other users to join a Zulip organization even if the organization was configured to prevent this.",
      "cve": "CVE-2017-0896",
      "specs": [
        "==1.3.0",
        "==1.3.1",
        "==1.3.10",
        "==1.3.11",
        "==1.3.12",
        "==1.3.13",
        "==1.3.2",
        "==1.3.3",
        "==1.3.4",
        "==1.3.6",
        "==1.3.7",
        "==1.3.8",
        "==1.3.9",
        "==1.4.0",
        "==1.4.1",
        "==1.4.2",
        "==1.4.3",
        "==1.5.0",
        "==1.5.1"
      ]
    },
    {
      "id": "pyup.io-zulip:CVE-2017-0910",
      "advisory": "In Zulip Server before 1.7.1, on a server with multiple realms, a vulnerability in the invitation system lets an authorized user of one realm on the server create a user account on any other realm.",
      "cve": "CVE-2017-0910",
      "specs": [
        "<1.7.1"
      ]
    },
    {
      "id": "pyup.io-zulip:CVE-2018-9986",
      "advisory": "In Zulip Server versions before 1.7.2, there were XSS issues with the frontend markdown processor.",
      "cve": "CVE-2018-9986",
      "specs": [
        "<1.7.2"
      ]
    },
    {
      "id": "pyup.io-zulip:CVE-2018-9987",
      "advisory": "In Zulip Server versions 1.5.x, 1.6.x, and 1.7.x before 1.7.2, there was an XSS issue with muting notifications.",
      "cve": "CVE-2018-9987",
      "specs": [
        ">=1.5.0,<1.7.2"
      ]
    },
    {
      "id": "pyup.io-zulip:CVE-2018-9990",
      "advisory": "In Zulip Server versions before 1.7.2, there was an XSS issue with stream names in topic typeahead.",
      "cve": "CVE-2018-9990",
      "specs": [
        "<1.7.2"
      ]
    },
    {
      "id": "pyup.io-zulip:CVE-2018-9999",
      "advisory": "In Zulip Server versions before 1.7.2, there was an XSS issue with user uploads and the (default) LOCAL_UPLOADS_DIR storage backend.",
      "cve": "CVE-2018-9999",
      "specs": [
        "<1.7.2"
      ]
    },
    {
      "id": "pyup.io-zulip:CVE-2019-16215",
      "advisory": "The Markdown parser in Zulip server before 2.0.5 used a regular expression vulnerable to exponential backtracking. A user who is logged into the server could send a crafted message causing the server to spend an effectively arbitrary amount of CPU time and stall the processing of future messages.",
      "cve": "CVE-2019-16215",
      "specs": [
        "<2.0.5"
      ]
    },
    {
      "id": "pyup.io-zulip:CVE-2019-16216",
      "advisory": "Zulip server before 2.0.5 incompletely validated the MIME types of uploaded files. A user who is logged into the server could upload files of certain types to mount a stored cross-site scripting attack on other logged-in users. On a Zulip server using the default local uploads backend, the attack is only effective against browsers lacking support for Content-Security-Policy such as Internet Explorer 11. On a Zulip server using the S3 uploads backend, the attack is confined to the origin of the configured S3 uploads hostname and cannot reach the Zulip server itself.",
      "cve": "CVE-2019-16216",
      "specs": [
        ">=1.8.0,<2.0.5"
      ]
    },
    {
      "id": "pyup.io-zulip:CVE-2019-18933",
      "advisory": "In Zulip Server versions from 1.7.0 to before 2.0.7, a bug in the new user signup process meant that users who registered their account using social authentication (e.g., GitHub or Google SSO) in an organization that also allows password authentication could have their personal API key stolen by an unprivileged attacker, allowing nearly full access to the user's account.",
      "cve": "CVE-2019-18933",
      "specs": [
        ">=1.7.0,<2.0.7"
      ]
    },
    {
      "id": "pyup.io-zulip:CVE-2019-19775",
      "advisory": "The image thumbnailing handler in Zulip Server versions 1.9.0 to before 2.0.8 allowed an open redirect that was visible to logged-in users.",
      "cve": "CVE-2019-19775",
      "specs": [
        ">=1.9.0,<2.0.8"
      ]
    },
    {
      "id": "pyup.io-zulip:CVE-2020-10935",
      "advisory": "Zulip Server before 2.1.3 allows XSS via a Markdown link, with resultant account takeover.",
      "cve": "CVE-2020-10935",
      "specs": [
        "<2.1.3"
      ]
    },
    {
      "id": "pyup.io-zulip:CVE-2020-12759",
      "advisory": "Zulip Server before 2.1.5 allows reflected XSS via the Dropbox webhook.",
      "cve": "CVE-2020-12759",
      "specs": [
        "<2.1.5"
      ]
    },
    {
      "id": "pyup.io-zulip:CVE-2020-14194",
      "advisory": "Zulip Server before 2.1.5 allows reverse tabnapping via a topic header link.",
      "cve": "CVE-2020-14194",
      "specs": [
        "<2.1.5"
      ]
    },
    {
      "id": "pyup.io-zulip:CVE-2020-14215",
      "advisory": "Zulip Server before 2.1.5 has Incorrect Access Control because 0198_preregistrationuser_invited_as adds the administrator role to invitations.",
      "cve": "CVE-2020-14215",
      "specs": [
        "<2.1.5"
      ]
    },
    {
      "id": "pyup.io-zulip:CVE-2020-15070",
      "advisory": "Zulip Server 2.x before 2.1.7 allows eval injection if a privileged attacker were able to write directly to the postgres database, and chose to write a crafted custom profile field value.",
      "cve": "CVE-2020-15070",
      "specs": [
        "<2.1.7"
      ]
    },
    {
      "id": "pyup.io-zulip:CVE-2020-9444",
      "advisory": "Zulip Server before 2.1.3 allows reverse tabnabbing via the Markdown functionality.",
      "cve": "CVE-2020-9444",
      "specs": [
        "<=2.1.3"
      ]
    },
    {
      "id": "pyup.io-zulip:CVE-2020-9445",
      "advisory": "Zulip Server before 2.1.3 allows XSS via the modal_link feature in the Markdown functionality.",
      "cve": "CVE-2020-9445",
      "specs": [
        "<2.1.3"
      ]
    },
    {
      "id": "pyup.io-zulip:CVE-2021-30477",
      "advisory": "An issue was discovered in Zulip Server before 3.4. A bug in the implementation of replies to messages sent by outgoing webhooks to private streams meant that an outgoing webhook bot could be used to send messages to private streams that the user was not intended to be able to send messages to.",
      "cve": "CVE-2021-30477",
      "specs": [
        "<3.4"
      ]
    },
    {
      "id": "pyup.io-zulip:CVE-2021-30478",
      "advisory": "An issue was discovered in Zulip Server before 3.4. A bug in the implementation of the can_forge_sender permission (previously is_api_super_user) resulted in users with this permission being able to send messages appearing as if sent by a system bot, including to other organizations hosted by the same Zulip installation.",
      "cve": "CVE-2021-30478",
      "specs": [
        "<3.4"
      ]
    },
    {
      "id": "pyup.io-zulip:CVE-2021-30479",
      "advisory": "An issue was discovered in Zulip Server before 3.4. A bug in the implementation of the all_public_streams API feature resulted in guest users being able to receive message traffic to public streams that should have been only accessible to members of the organization.",
      "cve": "CVE-2021-30479",
      "specs": [
        "<3.4"
      ]
    },
    {
      "id": "pyup.io-zulip:CVE-2021-30487",
      "advisory": "In the topic moving API in Zulip Server 3.x before 3.4, organization administrators were able to move messages to streams in other organizations hosted by the same Zulip installation.",
      "cve": "CVE-2021-30487",
      "specs": [
        ">=3.0,<3.4"
      ]
    }
  ]
}